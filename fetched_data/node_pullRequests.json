[
    {
        "node": {
            "number": 5020,
            "title": "Adding Core support for Promises",
            "author": {
                "login": "chrisdickinson"
            },
            "state": "CLOSED",
            "closedAt": "2017-02-28T23:08:59Z",
            "comments": {
                "totalCount": 466,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "gergelyke",
                                "__typename": "User"
                            },
                            "bodyText": "Hey,\njust out of curiosity: why the need for setPromiseImplementation? Wouldn't it be better to go with the standard ES6 promises?",
                            "createdAt": "2016-02-01T09:44:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@gergelyke This provides an escape hatch at application for folks that prefer different promise implementations, while also making sure that core doesn't suck the air out of the promise library ecosystem. Libraries can compete on features and performance without one implementation or the other winning by default. This also means that, in a vm-neutral future, developers working on applications can shield themselves from differences between VMs to some degree by using a third-party promises library.",
                            "createdAt": "2016-02-01T09:50:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "Is process.setPromiseImplementation necessary? What does it achieve that global.Promise = foo; doesn't?",
                            "createdAt": "2016-02-01T09:53:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@timoxley, @kittens: Mostly this is so we can use a \"verified good for our purposes\" promise implementation, and guard it with \"hey, don't try and set the implementation twice\" warnings. This also means that core always creates known-native promises at the outset and only casts them to user-chosen implementations. This may prove useful when combined with v8 dev tools (OTOH, it could be a case of YAGNI!)",
                            "createdAt": "2016-02-01T10:01:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@gergelyke Note that native v8 promises performance / memory consumption is far from perfect atm. See https://github.com/petkaantonov/bluebird/tree/master/benchmark for a comparison (note the difference between promises-ecmascript6-native and promises-bluebird.",
                            "createdAt": "2016-02-01T10:02:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "madbence",
                                "__typename": "User"
                            },
                            "bodyText": "@timoxley the Promise impl should be controlled by the application you write. If a library tries to mess with global.Promise (or process.setPromiseImplementation), that's just wrong.",
                            "createdAt": "2016-02-01T10:02:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@madbence That's why setPromiseImplementation warns (with a trace noting both the original setPromiseImplementation call as well as a trace to the second call) on subsequent attempts to set the promise impl \u2014 so you can track down the offending module and remove it from your application. This API is intended for top-level applications only.",
                            "createdAt": "2016-02-01T10:03:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "timoxley",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson I guess this raises the question of why add this feature specifically for Promises? should node provide pluggable implementations for other APIs as well?",
                            "createdAt": "2016-02-01T10:06:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "net.connectAsync() is fundamentally improperly named. The \"executor\" is still ran immediately, and if no hostname is given then TCP will bind to the port immediately. To get around this synchronous behavior node places the callback in a nextTick. Since I assume the callback will execute through the resolver it will be placed on the MicrotaskQueue and executed just after the nextTickQueue is completed. Causing another nextTick to be queued, and the nextTickQueue to be processed again.\nIn the end this API isn't any more async than it currently is.\nAlso I am curious how promisify is supposed to handle swallowing errors if the user's actual callback is fired on a different stack.",
                            "createdAt": "2016-02-01T10:09:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@timoxley It's possible, though we should be cautious about applying this tactic elsewhere. I'd be interested in seeing an implementation that made streams pluggable, though that might fall down since streams are not as thoroughly specified as Promises.",
                            "createdAt": "2016-02-01T10:10:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "seidtgeist",
                                "__typename": "User"
                            },
                            "bodyText": "I think React especially has shown the value of helpful runtime developer warnings. Having a function generate that warning sounds more sensible to me than a setter for example.\n@timoxley It does, yet Core Promises have been waiting for their comeback for a long time. I would really like to see a more pluggable core, but it probably needs to be discussed on a case by case basis.",
                            "createdAt": "2016-02-01T10:10:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris:\n\nnet.connectAsync() is fundamentally improperly named.\n\nThe name is up for debate. I'm using this naming scheme to match what promise users are currently expecting, but I am open to changing it. Re: the nextTick behavior, that is an excellent point, and I will look into that tomorrow evening (if no one beats me to it.)",
                            "createdAt": "2016-02-01T10:12:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "What frightens me about the process.setPromiseImplementation API is that it could prevent us from switching to a creation of Promises in C++ code. Have you thought about it ?",
                            "createdAt": "2016-02-01T10:13:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "-1 for any kind of support for non-native promises",
                            "createdAt": "2016-02-01T10:14:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "Has this PR any effect on the performance of standard, callback driven methods?\nWill this make things slower? Basically for any call to core, this adds one more function in the stack.\nThe idea of adding promises is compelling, but I fear wrapping might not be the solution.\nWould you mind running the bench pre/post and putting those in a gist?\nI think process.setPromiseImplementation()\u00a0is inviting people to \"monkey patch\" node. I think this is a complete anti-pattern, and we should restrain to do so. Maybe even delaying this PR until V8 has a good native Promise implementation.",
                            "createdAt": "2016-02-01T10:21:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@targos Yep \u2014 with this implementation, Node always creates native promises. lib/internal/promises goes as far as to ensure that it runs before any other user code can possibly run so that it can grab a reference to the \"authentic\" Promise constructor for other modules to use. The implementation only casts native promises to user-selected implementations, instead of outright constructing them \u2014 this way the C++ layer can continue to make native promises.\n@vkurchatkin I'd be interested to hear why. It seems like a fairly low cost to us to support this, while giving application authors the freedom to standardize Node on the implementation they're already using, letting the promise library ecosystem thrive and giving them more benchmarks to compete on, giving end users a way to shield against quirks across VMs, and letting users opt into faster implementations where desired. It does add complexity, and probably more worrying, adds another application level API. The complexity is mostly encompassed by \"we run our promise through a user's Promise.resolve\", though, so it doesn't seem too bad. I've tried to mitigate the application-level API problem by adding trackable warnings \u2014 does this not go far enough?",
                            "createdAt": "2016-02-01T10:22:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eljefedelrodeodeljefe",
                                "__typename": "User"
                            },
                            "bodyText": "I am hugely against promises whatsoever. However could the promisification be an explicit opt-in process.promisify(true) // conditional export in libs instead of affecting any function there is?",
                            "createdAt": "2016-02-01T10:23:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson the only reason we really consider including promises in core is that they are a part of language and a part of v8. It's not a good idea to include API that we can be sure will become obsolete and could potentially prevent all kinds of optimisations in the nearest future. If we think that v8 promises are not good enough - we shouldn't do it at all.",
                            "createdAt": "2016-02-01T10:27:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina:\n\nHas this PR any effect on the performance of standard, callback driven methods?\nWill this make things slower? Basically for any call to core, this adds one more function in the stack.\nThe idea of adding promises is compelling, but I fear wrapping might not be the solution.\nWould you mind running the bench pre/post and putting those in a gist?\n\nI'd be happy to! I'm running make bench now. My intuition is that it will make things slower, but not on a scale that will affect users applications \u2014 I'd argue that we shouldn't reject promises because they make things microseconds slower for the callback path.\n@eljefedelrodeodeljefe:\n\nI am hugely against promises whatsoever. However could the promisification be an explicit opt-in process.promisify(true) // conditional export in libs instead of affecting any function there is?\n\nIt's possible, but you end up with two distinctly different Nodes, and with two Nodes comes fragmentation in the ecosystem. In the absence of benchmarking, interoperation seems more important than taking a stand against promises on principle to me.",
                            "createdAt": "2016-02-01T10:28:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eljefedelrodeodeljefe",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson no, no. I like the idea of your PR. However just wanted to ask whether there could be a way to affect as little as possible. I was just wondering whether you could have an opt-in at runtime.",
                            "createdAt": "2016-02-01T10:31:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin:\n\n@chrisdickinson the only reason we really consider including promises in core is that they are a part of language and a part of v8. It's not a good idea to include API that we can be sure will become obsolete and could potentially prevent all kinds of optimisations in the nearest future. If we think that v8 promises are not good enough - we shouldn't do it at all.\n\nWith their inclusion in the ECMAScript spec, I don't think promises are going to be departing the language in the near-to-mid-term, for better or worse. Promises are well-specified, so implementations can compete in terms of performance and features \u2014 much like ES5+ builtins compete with libraries like underscore and lodash, or in a broader sense, like how we've been experimenting with pure JS DNS implementations and HTTP parsers. V8 may never ship with the fastest Promise implementation \u2014 it has other tradeoffs to make, like debugability and overall correctness \u2014 but we can at least give our users the ability to make those tradeoffs themselves.\n@eljefedelrodeodeljefe:\nAh! A previous implementation experimented with putting promises behind a flag. I opted out of doing so since flags tend to fragment the user base, and since with async/await impending it seemed best to enable promises use by default. How would you feel about a --disable-promises flag? Would that make transitioning to a version that supported promises easier in the future (note: not necessarily using promises yourself, but using a version that supported using them)? If it were to exist for a major version or so, then disappear, would that be ok? If folks feel strongly about this I'd be happy to add it.",
                            "createdAt": "2016-02-01T10:36:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eljefedelrodeodeljefe",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson yes, a opt-out for this would be very fine for me. I do see the necessity to address promises for the community in any form, as long as I am not forced to use them. Cool.",
                            "createdAt": "2016-02-01T10:40:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina:\n\nI think process.setPromiseImplementation()\u00a0is inviting people to \"monkey patch\" node. I think this is a complete anti-pattern, and we should restrain to do so. Maybe even delaying this PR until V8 has a good native Promise implementation.\n\nSorry, I almost missed addressing this! Monkeypatching is already going on in Node \u2014 bluebird encourages it with promisifyAll, for example; but for another example, see continuation-local-storage.\nMy suspicion, which I noted above, is that V8 promises make different tradeoffs than userland promises \u2014 and by necessity they have to err towards strict adherence to spec, which means they may never be the fastest implementation out there. This is similar to the lodash situation \u2014 lodash can be faster than ES5 primitives precisely because it's able to make tradeoffs between adherence to spec and speed, and users can opt into that behavior. In this case, we're leaving open a path for users to choose that tradeoff for their application by letting them coerce Node promises as they like.",
                            "createdAt": "2016-02-01T10:43:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson I am really afraid of monkeypatching, and one of the biggest reasons I am not sold on promises and bluebird. One thing is a module encourages monkey patching, one thing is that core encourages it. Having seen this from my Ruby days it was a really bad practice that polarized the community.\nHow about wrapping this in require('allpromises')? That can also be easily backported in userland for LTS. In this way we are not overriding any behavior/function, but still leave the support opt-in?\nBasically:\nvar promisified = require('allpromises')\npromisified.setImplementation(require('bluebird'))\nvar fs = promisified.fs\n// ...",
                            "createdAt": "2016-02-01T11:06:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Hey folks, if you are interested in this PR landing, in lieu of +1'ing this issue, consider heading over to this issue and signing up to check the output of one function or to update one method's documentation. It would help me immensely, and it does wonders for showing your interest in landing promises of some sort in core.\n(Also, don't be intimidated by the \"120+ tasks\" bit! Each task is so small \u2014 usually just \"look at the doc for this method and tell me if it's ok!\", or \"build the PR*, run the REPL, and see if this gives you the result you'd expect!\")\n(* ... and I'm working on slicing out the \"build the PR\" part ASAP!)",
                            "createdAt": "2016-02-01T11:12:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina:\n\n@chrisdickinson I am really afraid of monkeypatching, and one of the biggest reasons I am not sold on promises and bluebird. One thing is a module encourages monkey patching, one thing is that core encourages it.\n\nAre you more concerned that this PR uses a decorator to modify function signatures, or that it exposes hooks for users to coerce return values of those functions before they're exited the function? Once the user has coerced the promise we shouldn't* touch it any further, so the \"set promise implementation\" hooks simply centralizes flow control, similar to AsyncWrap, vs. changing the function itself. No methods are modified in a user-visible way \u2014 that is to say, executing the module always produces the same functions, and control can't pass to the user before all methods are decorated. Adding hooks to enable these additions at runtime (vs. through an \"opt out\" flag) would seem to me to introduce a possibility that users could see the API in two different states, though.\n* In writing this, I am recalling a place where we emphatically do touch the promise post decoration, and I will fix that post haste \ud83d\ude2c",
                            "createdAt": "2016-02-01T11:20:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, I am going to try to get some results for the benchmarks, then I'm heading to bed (before 4AM, hopefully!)\nOne thing I should note: I will moderate any comments extolling the relative virtues (or lack thereof) of promises vs. callbacks off of this PR \u2014 that discussion is not related to this issue and would best to have elsewhere.",
                            "createdAt": "2016-02-01T11:36:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nWhat is your estimate on effort of supporting pluggable promise implementation?\nAs of streams promisification, web streams have something like:\n\nstream.read().then(function processResult(data) {\n  // process data\n  // ...\n  return reader.read().then(processResult);\n});\nWhich looks slow because data events might be quite frequent and promise overhead adds up.\nBut I think aligning core/node streams with web streams would benefit both sides anyway.",
                            "createdAt": "2016-02-01T11:50:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "Promises are well-specified, so implementations can compete in terms of performance and features \u2014 much like ES5+ builtins compete with libraries like underscore and lodash\n\nlodash and underscore don't implement any spec and don't override globals, so it's not the same. Other promise implementations may have alternative efficient promisify implementation (bluebird has, I think), so this approach doesn't make much sense performance-wise (we still create native promise, after all).",
                            "createdAt": "2016-02-01T11:58:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "thefourtheye",
                                "__typename": "User"
                            },
                            "bodyText": "Should this be discussed in the CTC meeting @nodejs/CTC?",
                            "createdAt": "2016-02-01T12:12:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@thefourtheye Looks to early for that yet.",
                            "createdAt": "2016-02-01T12:17:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "thefourtheye",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I was worried that if CTC ends up deciding against this PR all the review and rework done would be of less use. It's a big fat PR :O",
                            "createdAt": "2016-02-01T12:20:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dscape",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83d\udc4e\nMaking almost every single API unstable 7 years after the release of a stable runtime.\nWhat matters for node is stability, especially APIs. This change will create thousands of bugs and productions issues with little upside.\nThe current TSC should measure the adoption of new versions of node and see the impacts of major, unsolicited changes like this.\nHaving such a dramatic change introduced needs a huge rational behind it since the risks are so high. I don't think that \"because the standard is evolving that way\" or \"because v8 supports it with some flags\" is a good enough reason to something that basically changes the idiom of the runtime. This is the sort of thing you say during coffee and not a rational for a monumentally huge breaking change.",
                            "createdAt": "2016-02-01T12:38:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "If you don't have a working program in the first place, there is nothing for a change to really break. Otherwise literally every change is a breaking change. Saying it's a breaking change to make a callback function return promise when no callback is passed is same as saying that adding a new method is breaking change because code that does process.method() expects it to throw a TypeError is now broken.",
                            "createdAt": "2016-02-01T13:11:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "remy",
                                "__typename": "User"
                            },
                            "bodyText": "So, I had a \"conversation\" on twitter about this and was asked to add the comments to this thread. I'm not entirely convinced it's worthwhile, but here goes.\nAlso up front, this isn't a comment about whether promises are good or bad. I use them, others don't - that's cool. In fact, that's kind of important. Really important.\nThis PR begs the initial question: why add to core what already can be done with existing libraries? The PR specifically mentions Bluebird, and I use then-fs for the fs promise chain.\nNode's API was always meant to be barebones and minimal to build upon.\nThere's a lot of alternative implementations people could use, events for instance could be implemented with observables, but importantly these decisions are, and should be, left to the authors.\nSure there's a tonne of choice for things like promise implementations, Bluebird, Q, Promise.js - then there's alternatives to the flow.\nThere's no shortage of options on npm. This is not a bad thing. Choice is what drives adoption, allows for flexibility and makes it easier for new developers to pick up a language.\nLeave the core light and as simple as it can be. Let the authors decide whether they want to add promises, or not. The more abstractions on top of a development process, the harder it is for new devs to pick up and learn from, regardless of whether it's opt-in or not.",
                            "createdAt": "2016-02-01T13:18:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Hi Chris,\nThanks so much for starting the discussion here. I am very glad you're doing this work. However, I have a few concerns. I am almost afraid to broach them for fear of setting back the promises-in-core cause, but I think they're pretty important.\n\n\n\nErrors thrown on the same tick are still thrown, not returned as rejected promises \u2014 in other words, programmer errors, such as invalid encodings, are still eagerly thrown.\n\nThis is not really acceptable. A huge part of promise-based programming is having one error path to handle, and not having to do try { fn()......catch(handleError) } catch (e) { handleError(e); }. This is explicitly against the promises guide which we apply uniformly across the web ecosystem, and contradicts all existing promisify implementations.\nI actually actively oppose this PR while this is in place.\n\n\n\nlib/internal/promisify\n\nit's unfortunate that this approach was chosen, instead of using V8's first-class promise support. It means promises will always be the secondary approach, instead of benefiting from creating them inside the async operations, and fulfilling them directly from the C++ implementation. One obvious minor benefit of the latter is that it does not create the resolve and reject closures. This is probably not a big deal, since long term the implementation can be swapped (as long as the first point is addressed). But I had kind of hoped that a serious attempt at putting promises in core would make them first class.\n\n\n\nThis PR allows users to swap the implementation of promises used by core.\n\nI don't think this should be possible. Alternate promise implementations for core libraries belong to userland. The entire point of putting things in core should be to use the standard built-in language features---core should pick a winner, as otherwise there's no point in core existing. If people want to manipulate global mutable application-wide state in order to change the things you talk about, they should monkey-patch Promise.prototype. If we don't think native promises are ready to be endorsed by core, then this PR should not use them. As @targos points out, it also prevents my previous point from ever being implemented using the same performant paths (unless userland promise implementations come with their own native modules implementing similar dynamically-linkable APIs!).\nI don't oppose this PR because of this; on balance, even with this ability, the PR would probably be good for the ecosystem. But I think it will set back promises-in-core for a long period of confusion, and is very unfortunate.\n\n\n\nNew APIs\n\nGiven the small number of these, and the fact that behavior is already changing, in most cases I think it would make more sense to take the breaking change for the no-callback version. The exceptions would be cases like http.getAsync where the *Async version actually loses functionality, due to the design of the current method. (I wonder if there is a better way to design those... e.g. adding a .response promise to the returned object.)\n\n\nAgain, thanks for doing this. I hope my feedback ends up being helpful.",
                            "createdAt": "2016-02-01T13:24:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mattdesl",
                                "__typename": "User"
                            },
                            "bodyText": "Wouldn't this cause thousands of modules, code samples, books, blog posts etc to become obsolete? It sounds like it could create an insane amount of fragmentation/confusion/problems.\nEDIT: After reading the breaking changes more carefully, it seems like much of the changes are backwards compatible.",
                            "createdAt": "2016-02-01T13:32:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RReverser",
                                "__typename": "User"
                            },
                            "bodyText": "Wouldn't this cause thousands of modules, code samples, books, blog posts etc to become obsolete?\n\nDidn't all the new features in ES6 make thousands of modules, code samples, books, blog posts etc. obsolete? (about IIFEs necessary in for loops for preserving iterator, about creating classes with external libs, extending prototypes, function-scoped variables, this in functions any many many others)\nShould we not add new features because they make old approaches obsolete?",
                            "createdAt": "2016-02-01T13:35:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "calvinmetcalf",
                                "__typename": "User"
                            },
                            "bodyText": "This is not really acceptable. A huge part of promise-based programming is having one error path to handle, and not having to do try { fn()......catch(handleError) } catch (e) { handleError(e); }. This is explicitly against the promises guide which we apply uniformly across the web ecosystem, and contradicts all existing promisify implementations.\n\nthis is a direct translation of how the current async api works in node where programing errors throw while operational ones don't, a tricky thing is going to be that those programing errors will sometimes get caught and end up in the promise chain (like if it is being returned in a then handler) but sometimes won't (like it's starting a chain).\nedit: through -> throw",
                            "createdAt": "2016-02-01T13:36:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MadaraUchiha",
                                "__typename": "User"
                            },
                            "bodyText": "@calvinmetcalf What's wrong with instantly returning a rejected promise?",
                            "createdAt": "2016-02-01T13:40:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "this is a direct translation of how the current async api works in node where programing errors through while operational ones don't\n\nYep. Node's current approach is antithetical to promises.",
                            "createdAt": "2016-02-01T13:48:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wraithan",
                                "__typename": "User"
                            },
                            "bodyText": "As much as I embrace Bluebird's promises, I do worry about this API. Library authors can't use this, only application developers. A library author could possibly use it with the native implementation since it is the most minimal. As long as the provided implementation conformance to native promises, it'll work. But then the application (or other libraries) would trigger the trace/warning still, and any minor inconsistencies could cause unintended side effects in your dependencies.\nMaybe a solution where a library could request core to be \"promisified with whatever\" and not trigger the trace/warning as they plan to only use the specified A+ interface? Still falls into \"well behavior may be subtly different causing bugs\" but starting the conversation about if/how library authors can use this is important.\nI very much would rather use bluebird (for that delicious extra sugar) over native, but I'm going to have to side with the folks who'd rather see this native or not at all unless this library problem can be resolved. I suspect with just a native promise layer the various non-native promise libraries could leverage it for \"promisifying core\".\nThank you so much for the work you put in on this, I know this is a very controversial thing and I appreciate you taking this on.",
                            "createdAt": "2016-02-01T14:52:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "it's unfortunate that this approach was chosen, instead of using V8's first-class promise support. It means promises will always be the secondary approach, instead of benefiting from creating them inside the async operations, and fulfilling them directly from the C++ implementation.\n\nWhen V8 makes their implementation comparably fast, we can discuss using only native promises.\nFor now, if this doesn't either use either a fast existing promise impl, or allow one to be swapped in, it is a very large and bad step backwards on the perf side, considering everything is going to be running through these. Unacceptable.\n\n\nthis is a direct translation of how the current async api works in node where programing errors throw while operational ones don't\n\nYep. Node's current approach is antithetical to promises.\n\nOops? I don't think this is going to change anytime soon.",
                            "createdAt": "2016-02-01T15:07:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matteofigus",
                                "__typename": "User"
                            },
                            "bodyText": "Fishrock123: Removed trolling.\nJokes apart, +1 on the fact that I don't see the benefit of adding this to core while you can use any promise library and achieve the same result without a new major change.",
                            "createdAt": "2016-02-01T15:40:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "Just to make sure that everybody is aware of this: you do not necessarily lose the sugar if a Promise is provided by another implementation. See for example this example using Bluebird:\nvar PromiseB = require(\"bluebird\");\n\nPromiseB.try(function() {\n        // The below originates from ES6 Promises, which do not have map/each!\n        return Promise.resolve([\"test 1\", \"test 2\"]);\n}).map(function(value) {\n        return value + \" plus addition\";\n}).each(function(value) {\n        console.log(value);\n});\nCorresponding output:\ntest 1 plus addition\ntest 2 plus addition\n\nAs long as you always return a (third-party) Promise, rather than chaining off it directly, the Promise implementation that you are using will be able to 'wrap' it, so that you can consistently work with the sugar of your implementation of choice.\nPromise.try is an easy way to accomplish this with Bluebird (as it removes the need to chain off the first asynchronous call, and otherwise functions like .then), and in implementations that do not have Promise.try, you can use Promise.resolve().then as an equivalent:\nPromise.resolve().then(function() {\n        return asyncThingThatReturnsAPromise();\n}).then(function(result) {\n        // ...\n})\nThere's a small implementation difference here, in that the Promise.try callback executes in the same tick, whereas the Promise.resolve().then callback does not, and executes it in the next tick instead. This should not matter for the majority of cases.\nEDIT: Of course, this does not solve the performance concerns. It's just about the sugar.\nEDIT2: Naturally, this only applies for Promises/A+ compliant implementations. This includes ES6 Promises, Bluebird, Q, and many others.",
                            "createdAt": "2016-02-01T16:10:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "isaacs",
                                "__typename": "User"
                            },
                            "bodyText": "This is pretty awesome.  I think the time has come to move forward on this.\nThe hook to swap out the Promise implementation feels too much like a compromise to me.  Core should use native promises.  If someone wants to swap out the implementation, they can monkey-patch global.Promise themselves.  It feels dirty to do that because it is dirty, and that's how it should feel.\nI get the desire to not suck the air out of the ecosystem by \"picking a winner\".  But V8 has already done that, and as @joepie91 pointed out, Promise implementations already interoperate very nicely.\nRegarding throwing TypeError rather than returning them in the callback, that's a bikeshed that was built a long time ago, and should not be re-legislated on account of promises.  It seems like the best goal here is to use Promises to express the same API as closely as possible to how callbacks are used now.  Immediate vs deferred errors for invalid function calls is a whole other discussion.\nIf the swappable implementation were removed, then the biggest challenge seems to be handling the naming issues.  (Eg. connectAsync as @trevnorris mentioned in #5020 (comment))  But that seems solvable.\nThanks for getting this started, @chrisdickinson!",
                            "createdAt": "2016-02-01T16:16:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Sequoia",
                                "__typename": "User"
                            },
                            "bodyText": "removed my comment to a gist as it's mostly my opinion/noise/not 100% related to technical aspects of the issue",
                            "createdAt": "2016-02-01T16:18:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "@Sequoia Promises are the standard way in JavaScript to abstract asynchronous operations. They're in the ECMAScript specification and all new WhatWG JavaScript specs use them when necessary. They aren't going anywhere.",
                            "createdAt": "2016-02-01T16:21:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Regarding throwing TypeError rather than returning them in the callback, that's a bikeshed that was built a long time ago, and should not be re-legislated on account of promises.\n\nThis isn't a bikeshed. This is fundamental to asynchronous error handling with promises.\n\nIt seems like the best goal here is to use Promises to express the same API as closely as possible to how callbacks are used now.\n\nI don't agree. Promises are being used to express an alternate error handling paradigm. If you can't buy into that, then there's no point in having promises.",
                            "createdAt": "2016-02-01T16:23:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakearchibald",
                                "__typename": "User"
                            },
                            "bodyText": "Absolutely agree with @domenic here with regard to throwing. Returning Promise.reject(err) instead of throwing, unless a callback is provided, is the right move. Devs shouldn't have to deal with two types of throwing per method.",
                            "createdAt": "2016-02-01T16:25:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "I agree with @domenic here as well. \"Unified\" error handling is a fundamental part of what Promises are and the problem that they solve, and there's no point in compromising on this.\nIf we're going to be breaking BC anyway, we might as well do it properly, and implement Promises as a first-class citizen - not just as a vaguely Promisey-looking alternative syntax for error-first callbacks.\nEDIT: To clarify, my statement is based on the assumption that promisifying the core APIs will happen. I haven't read into it enough to understand the pros and cons of doing that to begin with (and thus don't really have a particular opinion on it), but if we do it, it should be done properly.",
                            "createdAt": "2016-02-01T16:29:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "This isn't a bikeshed. This is fundamental to asynchronous error handling with promises.\n\n@domenic Why is propagating programmatic errors fundamental?  It's pretty antithetical to the node.js philosophy of throwing on programmer error and forwarding on run-time error.",
                            "createdAt": "2016-02-01T16:31:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "there's no point in having promises.\n\nI don't agree. It's annoying that there'd be a deviation -- might require you to put a try/catch if you're worried about possibly passing the wrong thing to the node function triggering such a sync error -- but having promises normalize all other parts of the async interaction cycle has huge wins in and of itself. Not worth throwing them away entirely.\nWhen async/await lands (or if people are using lib-wrapped generator+promise approaches now), the sync error that's thrown gets absorbed into the wrapping promise anyway. No, that's not the same thing as being able to locally handle it with your promise chain, but it DOES get promisified eventually (not the same as bubbling out as a sync error), so that's not as fatally flawed as it may seem.",
                            "createdAt": "2016-02-01T16:33:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis Automatic propagation of errors is one of the core tenets of how Promises were designed to work, precisely because the Node.js philosophy of \"having to do it yourself\" hasn't really worked out in practice. I can count on one hand the amount of codebases I've seen that handle errors with error-first callbacks correctly, and I do code review for a living.\nAutomatic propagation with (filtered) catching is a much safer way to do error handling, because it fails closed. If the programmer forgets to handle an error, then it won't be swallowed silently - it'll complain loudly, as it should.\nThat having been said, I'd like to see crash-the-process behaviour by default on unhandled rejections, but that is a separate issue.",
                            "createdAt": "2016-02-01T16:34:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "\"i want to use my own promises\"\n\nI've written several promise libs too, and yeah, I'd like that, but no, node core shouldn't facilitate that in any special way. That kind of monkeypatching is the sort of thing that smells OK in test frameworks where you're mocking things out, but for sure not a good pattern for core application code.\nThe good news is, you always get the choice to wrap the native promise a node function returns you into your special happy promise lib, usually with Promise.resolve(..). Is that extra work everywhere? Yeah, but it should be. It should be explicit and obvious that you're using a deviation from the spec, not implicit because it's hidden away in some monkeypatch call.\nIn fact, you should pretty much always be wrapping promises you receive from other places with Promise.resolve(..). This notion of always-wrap-a-promise has been trotted out a hundred times in other discussions around cancelable promises along the lines of \"if you don't want what we're returning, just Promise.resolve(..) it.\" Sounds like reasonable medicine to swallow here as well.",
                            "createdAt": "2016-02-01T16:34:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis see https://www.w3.org/2001/tag/doc/promises-guide#always-return-promises. A couple other reasons:\n\nIt causes inconsistency. promiseThingThatSucceds().then(promiseThingThatFails) will reject no matter what, even if promiseThingThatFails is due to one of these early-errors. Saying that promiseThingThatFails().then(promiseThingThatSucceeds) will throw instead of reject is, from this perspective, bizarre.\nPromises are good at building asynchronous flow graphs where errors can be isolated to a single output point, similar to domains' scoped unhandled exception handling. When you have isolated your graph in this way, you want to be able to handle all errors falling out of a given system (say, HTTP request) and not crash your server because someone managed to trigger a path that causes invalid arguments. That is, promises are designed to allow this kind of resilient programming, and crippling them by throwing early errors breaks those abilities.\n\nNote that in the web space, and in browser implementations, this is implemented at the lowest level binding layer, so that it's actually impossible for web APIs that return promises to throw an exception.",
                            "createdAt": "2016-02-01T16:38:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakearchibald",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis I personally find this pattern in node confusing. For a given method, Some errors crash the process, some don't.\nHaving to do this is weird:\nfunction handleError(err) {\n  // handle error\n}\n\ntry {\n  fs.whatever(foo).then(val => {\n    console.log(val);\n  }).catch(handleError);\n} catch(err) {\n  handleError(err);\n}\nvs\nfs.whatever(foo).then(val => {\n  console.log(val);\n}).catch(err => {\n  // handle error\n});\nIf you force the former, devs will have to do:\nPromise.resolve().then(() => fs.whatever(foo)).then(val => {\n  console.log(val);\n}).catch(err => {\n  // handle error\n});\n\u2026to get consistent behaviour.",
                            "createdAt": "2016-02-01T16:39:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zloirock",
                                "__typename": "User"
                            },
                            "bodyText": "What do you think about unhandled rejection hook and rejection events from legacy code?",
                            "createdAt": "2016-02-01T16:41:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Automatic propagation of errors is one of the core tenets of how Promises were designed to work, precisely because the Node.js philosophy of \"having to do it yourself\" hasn't really worked out in practice. I can count on one hand the amount of codebases I've seen that handle errors with error-first callbacks correctly, and I do code review for a living.\n\n@joepie91 I think you misunderstand what I mean by 'programmer error'.  An example is passing in a number > 65535 to a function that expects a TCP port number.  There is no scenario where that is legal so node.js will always throw a validation exception; it won't emit it as an 'error event or forward it to a callback.",
                            "createdAt": "2016-02-01T16:46:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis I understand what you mean, and I see no reason why that should be handled any different from any other error.\nYou don't know how that value ended up as an argument to the function, so it may very well end up being a runtime error as a consequence of user input - in which case you want it to be propagated through your Promises chain like any other error that results from a bug, eventually ending up in your error logging / crashing handler.\nSee also this. Basically, an error is an error, and how they are classified should depend on what the application developer decides, not what the module author decides, because errors are contextual.",
                            "createdAt": "2016-02-01T16:50:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "// before:\nfunction myhappycode() {\n   try {\n      fs.whatever(.., function(err){\n         if (err) {\n            // here is where i handle local errors!\n         }\n         // .. happy path ..\n      }); \n   }\n   catch (err) {\n      // here is where i handle abortive exceptions\n   }\n}\n// after:\nfunction myhappycode() {\n   try {\n      fs.whatever(.. ).then(function(..){\n         // .. happy path ..\n      },function(err){\n         // here is where i handle local errors!\n      });\n   }\n   catch (err) {\n      // here is where i handle abortive exceptions\n   }\n}\nWhile some people would prefer handling of the class of (as I'm calling them) \"abortive exceptions\" to be mixed in with the local errors handling, others would prefer to keep them separate, for a variety of reasons, including just plain ol' habit.\nThe try..catch approach (as shown) works for the latter folks, and the Promise.resolve().then(function(){  .. }) wrapping (as highlighted by @jakearchibald) is what the former folks can use to mix.\nThis dichotomy doesn't seem so egregious as to sink greater efforts to move node async handling forward with promises... especially since the try..catch case devolves, if desired, into just using an outer async..await function and letting the exception bubble into its promise.",
                            "createdAt": "2016-02-01T16:55:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@getify the try catch doesn't apply inside the callback, so you don't have a happy path there. You need to duplicate the try catch inside every level.",
                            "createdAt": "2016-02-01T17:19:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "the try catch doesn't apply inside the callback, so you don't have a happy path there.\n\nObviously, at any level that you want to call one of the proposed node-promised functions and mix the abortive exception handling into the locale error handling, you have to repeat the try..catch pattern. That's acknowledged additional work. I'm saying that work is worth it if you care to mix (which not everyone does).\nI called it a \"happy path\" because I was only illustrating one level.",
                            "createdAt": "2016-02-01T17:28:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "I'm saying that work is worth it if you care to mix (which not everyone does).\n\nI strongly disagree. People already mess up error-handling as is, we don't need to add yet another edge case that everybody must constantly handle in their own code, not to mention the considerable bloat that it adds for something that could easily be automated.\nThe distinction between \"local errors\" and \"abortive errors\" is not a meaningful one, anyway - how an error is to be handled depends on the type of error and the context, not at what point it is thrown. Where it is thrown is an implementation detail. I understand that we don't have a filtered .catch in ES6 Promises (and I still consider that a mistake), but that doesn't change the above.",
                            "createdAt": "2016-02-01T17:31:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "...amending a former statement of mine:\n\nthe Promise.resolve().then(function(){ .. }) wrapping is what the former folks can use to mix.\n\nActually, were I to want to mix, I would find the following (async arrow IIFE) much nicer than that Promise business:\n(async x => fs.whatever(..) })()\n.then(function(){\n   // happy path\n},function(err){\n   // mixed handling of abortive and local\n});",
                            "createdAt": "2016-02-01T17:34:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "awalgarg",
                                "__typename": "User"
                            },
                            "bodyText": "Would it be possible to use a modified version of bluebird in core trimmed to only standard API until V8 catches up with performance?\ntrimmed because using the regular version will encourage userland to use the sugar of bluebird, and would make it pretty much impossible to later switch to standard. and bluebird because performance.\nThe downside to this as I see it is that it adds the workload of keeping up with changes in upstream. pulling them and ensuring they don't expose anything out of standard.\nAFAIK, though, bluebird's build does allow us to trim down things (easily?). Maybe @petkaantonov could shower some light on this :)",
                            "createdAt": "2016-02-01T17:35:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "The distinction between \"local errors\" and \"abortive errors\" is not a meaningful one, anyway\n\nmaybe not meaningful to you, but meaningful to others. I find it quite meaningful. The rest of that paragraph was just nitpicking on what we call \"context\". I don't use silly things like the type of the error to decide how to handle it -- I use where/how it was generated to decide.",
                            "createdAt": "2016-02-01T17:37:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, I'm back awake \u2014 \ud83d\udc4b hi everyone. I am going to work on responding to everyone's concerns and moderate out any off topic conversation now. Thanks everyone for taking the time to look at this.",
                            "createdAt": "2016-02-01T17:55:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@YuriSolovyov:\n\nIt shouldn't be high.\nThis PR is a bridge, not a destination \u2013 I've left streams out of this\nproposal to reduce the scope and focus the conversation.\n\n@dscape:\nHi! I made this PR because it appears to be a recurring desire of the user\nbase. As a recent user of streams promises, I have to admit interoperating with builtin\nNode APIs is painful, and since Promises are increasingly prevalent in the ES\nspec having a solution in Node will be useful in the future.\nThis change modifies many of the single-event operations in Node, but it does\nso in a programmatic, deterministic fashion. Unless you are omitting callbacks\nto these APIs, you shouldn't notice any change. The APIs that have changed\nare off the beaten path \u2014 like the return value of promise.send.\nI appreciate your desire for stability from core, but this problem keeps\nlooming its head, and my hope is that we can tackle it in a way that all\nparties find acceptable.\n@remy:\nOne motivation for this is that at some point in the next year, V8 (or Chakra)\nwill give Node devs the ability to write:\nconst data = await fs.readFile('/usr/share/dict/words', 'utf8')\nAnd it would be excellent to support that. A bigger motivation, however, is\nthat having a strategy within core lets us start to address places that are\ntrickier to integrate with promises, like streams. That's not to say streams\nare going to be \"promise-based\" in the future, but promise users should have\na first-class experience using the stream APIs since they're exposed throughout\nCore, especially as an alternative emerges in the form of WHATWG streams.",
                            "createdAt": "2016-02-01T17:55:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gx0r",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome discussion and PR! Just some random thoughts I have right now, mainly from the perspective of building/running apps in production. Kind of a brain dump...don't take it too seriously. Still trying to digest this full thread . :-)\n\nI always end up using Bluebird in production/dev on backend and frontend, not just for the performance but the API; any non-trivial application I end up needing all the functions in Bluebird, plus the long async stack traces outweighs the small loss of performance. The V8 native\" promise API is simplistic and more memory vs. Bluebird.\ntry/catching around functions feels like an anti-pattern. I'd need to end up using Promise.try then for everything. And async/await would turn synchronous throws into rejections anyway. On the front end, I always wrap event handling on anyway with Promise.try in order to prevent errors from disappearing into the ether.\nasync/await uses promises, which use callbacks, right? They are built on top of one other, not competing concepts. Some folks seem to think async/await obviates the need for promises. An async function returns a promise.\nI wonder if unhandled rejections should be really strict and log stack then abort the process by default, to parallel how the following aborts the process:\n\nsetTimeout(function () {\n  throw new Error('hi');\n}, 0)\n\nsetTimeout(function () {\n  console.log('hello')\n}, 10000)\n\nThen you'd have to explicitly .catch() when you know you want to prevent that. This may seem radical but we should think about making error handling as good as possible, as this is part of the reason to use promises in the first place.\nI add unhandled error handlers that log unhandled promises into RethinkDB and then exit the process using pattern like https://github.com/llambda/rethink-handle-uncaught/blob/master/index.js . Having to try/catch would mean I lose some kinds of errors. I do this since I run in clusters and can log all errors centrally.\nNow that I think about it, I'm actually still not 100% sure which kind of errors crash the process, and which don't. Actually problem seems to be that normal Node, any unhandled error aborts the process, e.g. thrown, callback error, or event emitter error. However, one you turn into Promises, that behavior is lost.\nconst fs = require('fs');\nconst bluebird = require('bluebird');\nconst bfs = bluebird.promisifyAll(require('fs'));\n\nbfs.readFileAsync('doesnotexist')\n.catch(function (err) {\n  throw err; // process does not exit\n})\n\nfs.readFile('doesnotexist', function (err, file) {\n  if (err)\n    throw err; // process exits\n});\n\nsetTimeout(function () {\n  console.log('Keep alive...')\n}, 100000)\n\n\nE.g., the exception thrown in the callback version exits the process, while the promise version does not.",
                            "createdAt": "2016-02-01T17:57:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Does process.setPromiseImplementation() also change the global new Promise()?\nI'm a bit concerned with the implementation swapping. I get that bluebird is still preferable for many people but we already have platform level features in native Promises and it would make sense to push people more in that direction.",
                            "createdAt": "2016-02-01T18:03:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Phew, y'all are fast. Working to keep up.\n@mattdesl: @RReverser:\nThis provides an alternative to the examples in the ecosystem \u2013 it does not\nreplace the callback API. This is to preempt the larger shift in the ecosystem\nthat will happen when async/await lands. That is to say, even if we do\nnothing, the landscape will change around us.\n@Sequoia:\n@kittens mentioned this, but to reiterate: Promises won't be going away anytime\nsoon \u2014 they're baked into the latest versions of the ECMAScript specification.\nYou do not have to worry about them being the flavor of the day, or that Node\nwill suddenly start implementing observables. This discussion has been\non-again/off-again since the beginning of Node, and Promises seem to have\nmatured to the point that they are being found in foundational parts of the\nlanguage.\nThere are advantages to doing this in core. As I mentioned to @remy, this PR\ngives us a solid foundation to take on more involved integrations, like\nstreams. WHATWG streams are coming, and having a strategy (even one as vague as\n\"figure out how Node streams and promises interoperate\") will be invaluable\nsince otherwise the discussion could quickly grow out of scope.\n@awalgarg:\nShipping with a vendored Promises library is unlikely to be agreeable \u2014 folks\nwill expect the native promises by default and be surprised when they get a\nNode-specific version instead. setPromiseImplementation only allows for this\nat application-level, where users can opt into (or out of!) the surprise.",
                            "createdAt": "2016-02-01T18:16:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal: It doesn't, but it could do that. The goal of that API was to let application- or framework- level authors make the decision about Promise implementation tradeoffs (as well as to shield themselves from any differences between backing VMs in the future.) I'm writing up a more fleshed out response to this topic but wanted to get this reply out quickly \u2014 it'll be a few minutes!",
                            "createdAt": "2016-02-01T18:18:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakearchibald",
                                "__typename": "User"
                            },
                            "bodyText": "The V8 team is currently looking into promise performance, and slow cases that this identifies are of great interest.",
                            "createdAt": "2016-02-01T18:21:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson we had a similar conversation in request-promise and this was where we ended up:\n\nUserland Promise implementations can easily wrap a native promise if the user wants additional methods.\nThe Perf tradeoffs are much more relevant in browsers. Compilers can already swap out the native implementation for another one, so using native internally doesn't prohibit browser users from doing whatever they want. In fact, creating another API to swap it out probably complicates this process.",
                            "createdAt": "2016-02-01T18:23:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Has someone run our benchmarks w/ and w/o this patch to see if it impacts the performance of the existing callback APIs? Should be pretty easy since all of our current perf tests use the existing callback APIs :)",
                            "createdAt": "2016-02-01T18:25:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal I was working on that last night, but it turned to 4AM and I passed out. I would be very happy if someone could run these for me as I'm currently racing to keep up with this issue :)",
                            "createdAt": "2016-02-01T18:25:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "@jakearchibald http://bluebirdjs.com/docs/benchmarks.html can be a good starting point",
                            "createdAt": "2016-02-01T18:25:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Promisify vs. Native Modules\nInvolved:\n\n@domenic\n@Fishrock123\n\nI think there may be two different definitions in play here. To clarify for\nreaders, @domenic is referring to the C++ API for creating promises as\n\"native promises,\" while elsewhere I've used \"native promises\" to mean \"the\npromise you get when you look up Promise from JS.\"\nI chose to go the promisify route primarily because:\n\nEase of implementation while sketching out the API. It's low cost to explore\nthis route, code-wise, and still lets us suss out the rest of these issues.\nUsing that route would likely have to touch all of the MakeCallback APIs,\nwhich are currently under development by @trevnorris. This would make his\nlife harder than it needs to be, and also create hard-to-maintain churn in\nthis PR.\nWe can build down from the proposed API in subsequent PRs if desired. This\nshouldn't be regarded as where the development stops, but as a framework for\nfuture development.\n\nThis also scopes those slightly-more intricate changes to single APIs at a time, so we can do this piecemeal instead of \"all at once\" like this PR.",
                            "createdAt": "2016-02-01T18:29:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "I was working on that last night, but it turned to 4AM and I passed out.\n\n@chrisdickinson ya, you've done plenty, I was kind of directing that comment at everyone else who is in favor of the functionality and is looking for a way to help :)",
                            "createdAt": "2016-02-01T18:32:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I know that it adds a ton of extra complexity, but I'd be far more comfortable having this behind a command line flag, at least for the time being. Something like $ node --core-promises. Alternatively, extending the existing modules with a promisified version... e.g. const fs = require('fs').promisified. I love the idea of getting Promises in to core finally (despite the issues I have with the way Promises work), but I'm concerned that this kind of change is going to be too breaking on the ecosystem. Having something like the promisified would make it entirely opt-in, and if we do ever get to a point where the Promise-based impls are the default, we can simply update so that require('fs') === require('fs').promisified and deprecrate require('fs').promisified.",
                            "createdAt": "2016-02-01T18:33:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Should we allow pluggability?\nInvolved:\n\n@domenic\n@wraithan\n@isaacs\n@getify\n@mikeal\n\nI'm OK with removing this API. Some parting shots for it, though:\n\nIf we build down to the native C++ promises API, the Promise = require('bluebird') approach will stop working, while the swappable-impl approach will still work.\nIt does incur the hit of creating a JS Native Promise regardless of implementation, but subsequent chained promises (i.e., where I imagine the bulk of instantiation will take place) will be of the user-selected variety.\nProbably most importantly: this API lets us alert the user when bad usage patterns\nare detected \u2014 for example, two modules are trying to set the global promise impl.\n\nSince the impl is pluggable, package authors still have to write against the\nspec, so fragmentation should not be a big concern.",
                            "createdAt": "2016-02-01T18:36:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "timoxley",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson can the pluggable decision be deferred? Seems to be a distraction from the key changes here. Perhaps this could be tackled later in a different PR if this one gets the green light.",
                            "createdAt": "2016-02-01T18:42:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell:\nRe: the feature flag: the last time this came up in a major way we seemed to land on not putting the feature behind a flag. Right now I lean towards adding a flag that disables promises support \u2014 so it's opt-out \u2014 that way we have clearly committed to presenting a promise-based API (alongside callbacks) for the future, while still giving folks upgrading the chance to \"flip / flop\" the changes on and off to find any breakage.\n\nHaving something like the promisified would make it entirely opt-in, and if we do ever get to a point where the Promise-based impls are the default, we can simply update so that require('fs') === require('fs').promisified and deprecrate require('fs').promisified.\n\nI don't think there will ever be a point where switching the default in that approach will be worth the breakage we'd cause by doing so. We'd have to maintain two separate sets of APIs for each module \u2014 tests, docs, etc., instead of one. Promisifying the existing API is an attempt to minimize the impact of supporting two async paradigms while making sure that new work on the implementation of any of these APIs will be picked up by both paradigms.",
                            "createdAt": "2016-02-01T18:45:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@timoxley: Once I get a final \"yay\" or \"nay\" on the swappable implementation I'm happy to refine or remove it \u2014 in particular, I'm waiting for benchmarks to see whether or not JS Native Promises have acceptable perf, and for folks interested in swappability to give their blessing on removing it. If everyone seems okay with removing it, I will remove it tonight.",
                            "createdAt": "2016-02-01T18:48:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "I'd say we should use JS Native Promises in core and if users want additional API sugar they can use their favorite libs, and since Promises interoperate well, with time, things will just be faster:",
                            "createdAt": "2016-02-01T18:54:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "stefanpenner",
                                "__typename": "User"
                            },
                            "bodyText": "Should we allow pluggability?\n\nV8 promises will improve, we can also help to improve them (its just JS after-all, and the state-of-the-art for promise performance is well understood). As such shipping native seems very appropriate.\nAs mentioned above, the V8 team is quite interested in (and working with contributors) to improve the performance. What better motivation for the community at large then native promises by default in node.\nthis is coming from one of the many user-land promise lib implementors",
                            "createdAt": "2016-02-01T18:56:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, I have to head to a meeting \u2014 I'll be back around noon PST to continue addressing comments. In particular I'd like to touch on the \"throwing errors on same tick\" debate, since it might prove surprising for promise users, in that it'll usually look like an unrelated promise to the failing operation is rejecting. Both sides have valid points though and I'd like to take a stab at distilling the debate as it stands.\nAll: thank you for taking the time to participate on this issue, pro or con. The current tenor of the discussion is excellent.\nFor folks that would like to see this land, a standing reminder: if you can take some time to look at this tracking issue and raise your hand to take on a tiny task there, it would help immensely. Thank you!",
                            "createdAt": "2016-02-01T18:56:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wraithan",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic\n@chrisdickinson\n@isaacs\n@getify\n@mikeal\n\nIn the same order as you put the bullets in #5020 (comment)\n\nI am not very concerned with the ability to swap out what promises node core uses, it is at most a nice to have in my world.\nSince that performance hit is there already, I'm not concerned with the ability to inject a wrapper promise unless it was layered as we could potentially use a wrapper promise as an instrumentation point in node-newrelic. Short of that use case I can just wrap as needed or use a userland core wrapper.\nI do like the ability to alert on that usage pattern stuff. Problem is as I said, it is application tier only, library devs can't use it, or it will need to be rethought so they can. If library A wants Q, library B wants Native and the application wants Bluebird, it all falls apart. This affects also affects the ability to modularize your application tier since two different teams may make different choices or evolve differently.",
                            "createdAt": "2016-02-01T19:45:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@getify: maybe not meaningful to you, but meaningful to others. I find it quite meaningful. The rest of that paragraph was just nitpicking on what we call \"context\". I don't use silly things like the type of the error to decide how to handle it -- I use where/how it was generated to decide.\n\nCan you give an example of how you infer useful information from the place/manner in which the error was generated - with the 'place' being more granular than can be provided by a .catch in a Promises chain? I'm really not seeing it.",
                            "createdAt": "2016-02-01T19:59:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Added a couple of comments. My key issue with this, as I've mentioned, is the potential for breaking unaware code. This touches quite a few functions whose callbacks are already optional, that currently can Throw even if a callback is provided, or that have existing return values are are overridden. Existing code that is unaware that a Promise would now get returned could end up with some serious bugs.",
                            "createdAt": "2016-02-01T20:14:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "Several issues that need to be addressed before this could be considered to land:\n\nI don't believe this should land until at least an API subsystem as a whole is covered. For example, net.Socket#connect() and net.Server#listen() are not listed. Otherwise I worry about confusion.\nHaving .listen() return a promise will break a lot of code. Since that would then mean .listen() will not throw in cases like EADDRINUSE if the callback is not passed.\nLikewise, since .listen() now returns an instance of itself a lot of code using the pattern of const server = net.createServer().listen(port) will also break. I'm not sure we can justify this level of breakage in the ecosystem. Meaning the API addition of .listenAsync(), and similar for a few others, are required.\nErrors thrown by net.connect() for cases like ECONNREFUSED are done in nextTick(). Which means the call stack will have been unwound, and the wrapped operation will not be able to catch the error for the Promise. Here is an example script from the current PR:\n\n'use strict';\nconst net = require('net');\nconst print = process._rawDebug;\n\nconst server = net.createServer(function() {\n  print('connection received');\n}).listen(8080);\n\nnet.connectAsync(8081).then(function() {\n  print('connection made');\n}, function() {\n  print('connection error');\n});\nOutput:\nevents.js:155\n      throw er; // Unhandled 'error' event\n      ^\n\nError: connect ECONNREFUSED 127.0.0.1:8081\n    at Object.exports._errnoException (util.js:859:11)\n    at exports._exceptionWithHostPort (util.js:882:20)\n    at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1064:14)\n\nAs we can see the implementation must be more invasive than simply wrapping the callbacks if this is going to work.\n\nUnlike much of the current API which will throw on unhandled exception (e.g. no 'error' event callback) which forces the user to notice something went wrong, this forces users to add the 'unhandledRejection' handler. Because it is possible that they, or one of their required dependencies will have not properly handled the error (very likely when updating to a new API), which before would have crashed the application, but instead now will be allowed to live on indefinitely.\n\n\n@thefourtheye\n\n@ChALkeR I was worried that if CTC ends up deciding against this PR all the review and rework done would be of less use. It's a big fat PR :O\n\nThis is exactly why I created the node-eps repo. So these types of changes could be discussed while also removing any code review. Helping focus the conversation and remove the burden of work on the PR author.",
                            "createdAt": "2016-02-01T20:16:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Yeah I'm just generically referring to Promises provided by V8 as \"native promises\". So long as those are way behind user-land promises on perf, I'd rather V8 get on speeding those up before we land anything, if we do.",
                            "createdAt": "2016-02-01T20:29:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris:\n\nI don't believe this should land until at least an API subsystem as a whole is covered. For example, net.Socket#connect() and net.Server#listen() are not listed. Otherwise I worry about confusion.\n\nRight now net.Socket#connect is covered by connectAsync. listen is not covered, as you noted, but would likely be covered by listenAsync.\n\nErrors thrown by net.connect() for cases like ECONNREFUSED are done in nextTick(). Which means the call stack will have been unwound, and the wrapped operation will not be able to catch the error for the Promise. Here is an example script from the current PR:\n\nThat is an excellent catch and I will address this.\n\nAs we can see the implementation must be more invasive than simply wrapping the callbacks if this is going to work.\n\nThis is useful information to have!\n\nThis is exactly why I created the node-eps repo. So these types of changes could be discussed while also removing any code review. Helping focus the conversation and remove the burden of work on the PR author.\n\nAdding promises support to core has been discussed off and on for at least the year or two I've been involved with the project, including different methods of implementing such an outcome. This initial stab is meant to uncover all of the problems we'd have to solve. I'm not confident that an EP would contribute to the issue in this case. EPs are hugely useful for discovering some categories of unknowns and saving developer time ahead of implementation. However, my impression is that we've likely exhausted the benefits of discussing the problem space in the abstract, and this initial spike only took a bit of time and is already leading the discussion in useful directions.",
                            "createdAt": "2016-02-01T20:32:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 I'm not sure what the advantage of waiting for V8 to speed up native JS promises before landing is \u2014 promise initialization is off main path for callback APIs, so the relative speed of promises should be a non-issue (or at least, a sunk constant cost) for callback users, while promise users can look forward to the implementation speeding up in the future.",
                            "createdAt": "2016-02-01T20:34:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell:\n\nAdded a couple of comments. My key issue with this, as I've mentioned, is the potential for breaking unaware code. This touches quite a few functions whose callbacks are already optional, that currently can Throw even if a callback is provided, or that have existing return values are are overridden. Existing code that is unaware that a Promise would now get returned could end up with some serious bugs.\n\nI tend to agree \u2014 where there's potential for breakage we should err towards using an *Async variant API. I'll make sure to move those methods over. It doesn't leave us with the world's most consistent API, but we could possibly address that by exposing *Async variants everywhere, which wouldn't be a huge amount of work.",
                            "createdAt": "2016-02-01T20:41:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris: A follow-up question:\n\nErrors thrown by net.connect() for cases like ECONNREFUSED are done in nextTick(). Which means the call stack will have been unwound, and the wrapped operation will not be able to catch the error for the Promise. Here is an example script from the current PR:\n\nIf that's the case, wouldn't net.connect error out for folks using the callback variant as well? Are errors only handle-able via .on('error') there?",
                            "createdAt": "2016-02-01T20:47:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson ... the API consistency issue is actually why I prefer the require('...').promisified pattern instead of going through and changing these existing method signatures. It makes it so that we don't HAVE to be too worried about the consistency, and allows us to defend against these kinds of issues. It doesn't have to be overly complicated:\nconst promisity = require('internal/promisify');\n\nmodule.exports = function a(callback) {\n  callback(null, 'foo');\n};\n\nObject.setProperty(module.exports, 'promisified', {\n  configurable: false,\n  enumerable: true, \n  value: promisify(module.exports)\n});\nI understand the objections, but I still think it's a cleaner and less dangerous approach.",
                            "createdAt": "2016-02-01T20:50:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson That is correct. It must be handled via the 'error' event. Hence why it doesn't throw until nextTick(). To allow the user to setup any event handlers after the operation has been performed.",
                            "createdAt": "2016-02-01T20:51:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris Would it be out of scope to redirect that error to the connect() callback, if given?",
                            "createdAt": "2016-02-01T20:59:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Errors on same tick\nInvolved:\n\n@domenic\n@bnoordhuis\n@calvinmetcalf\n@MadaraUchiha\n@joepie91\n@getify\n@jakearchibald\n\nThis is an interesting debate. In the initial implementation I forwarded\nsame-tick errors to the returned promise, since as a user of promises, that's\nwhat I would expect. I relented when I found it broke tests.\nThe issue at the heart of this seems to be that core has historically always\nthrown programmer errors eagerly, in an effort to save developer time. Moving\naway from that ethos seems, at least at first glance, to be a non-starter.\nI think considering the likely use case of promise APIs, catching errors on\nfirst tick might not be a bad idea, so long as we limit it only to promise\nreturning API variants. In my experience, most promise use involves directing\nan entire asynchronous operation \u2014 the entire graph of sub-operations, sourced\nfrom multiple potentially asynchronous inputs \u2014 into a single asynchronous\noutput. With promises, this means all of the sub-operations you're performing\nare performed within a .then() handler.\nCombining this with the early-throw behavior is workable (as @getify suggests), but not ideal:\nthe early error is very likely to end up in a promise rejection in either\ncase, so the user is not going to see it until it propagates to a .catch\nhandler. The problem with this approach is that, while it's fairly easy to\ntrack down the source of the error, the wrong promise will appear to have\nrejected.\nLeaving aside whether one prefers the callback approach or the promise\napproach, it wouldn't involve much effort to accommodate the expectations of\nboth sets of users. We can easily change the promisify code to behave as\nusers expect, though it implies that we should probably abandon the \"return a\npromise if you don't pass a callback\" approach and instead focus on the\n.*Async approach. If we go the fs.readAsync approach, then this becomes a\nnon issue \u2014 callback-using code eagerly throws programmer errors, while\npromise-using code rejects the appropriate promise as folks expect. It seems\nthat the discussion with @jasnell is also heading down this path.",
                            "createdAt": "2016-02-01T21:05:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "@joepie91 Can you give an example of how you infer useful information from the place/manner in which the error was generated\n\nThe main pattern this plays out in my various applications is in whether or not the exception is:\n\none that I consider \"fatal\" -- usually some sort of pre-condition assertion that fails as soon as the util in question is called -- that needs to be logged in my system log -- not necessarily to crash the app though.\napplication-level exception that I can gracefully catch and respond to while keeping the program running.\n\nIt's hard without dumping a bunch of bikesheddable code, but let me try to quickly illustrate with a hypothetical:\nfunction find(x) {\n   try {\n      lookupSomeInfo( DataStore, x ) // \n      .then(\n         function onSuccess(data){\n            // yay, found it!\n         },\n         function onFailure(err){\n            // an exception here means the DataStore didn't have the data,\n            // possibly because `x` was malformed, so handle that case gracefully\n            // and opaquely for the user\n         }\n      );\n   }\n   catch (err) {\n      // exceptions here are bad, they mean the DataStore was unavailable,\n      // so we need to log this case to the system log, notify an admin, etc\n   }\n}\nIf lookupSomeInfo(..) were to not have any sync assertions but were to instead funnel the \"Unavailable DataStore\" exception into the promise rejection code right alongside the x was malformed for the data set, try again kind of exception, splitting out those two different cases (where the handling called for is clearly different) is harder. The err might have to be some sort of typed Error subclass, or some object that I do duck-typing checks on, to figure out what to do. I don't like these approaches. I find them harder to reason about/maintain.\nI find it cleaner and more convenient to have assertions throw synchronously, and handle them \"globally\" in a try..catch, whereas recoverable failures are handled \"locally\" in the context of the (async) flow control. That's especially true when onFailure(..) is not an inline function expression but rather a reference to another external function: I most definitely don't want to mix those two exception handling contexts into one piece of code that's located elsewhere.",
                            "createdAt": "2016-02-01T21:10:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I agree with your reasoning and your conclusion. It's a bit sad that you have to shuffle off promises to a suffix or .promised or similar, but I don't see any other way to avoid the back-compat breakage for callback users who prefer the bifurcated error handling. I guess I would rather see .promised (or \"fs/2\" ;) since the Async suffix would require destructuring to rename nicely.",
                            "createdAt": "2016-02-01T21:12:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic:\n\nsince the Async suffix would require destructuring to rename nicely.\n\nOoh, I don't quite follow there, but am curious \u2014 would you mind adding a code example?",
                            "createdAt": "2016-02-01T21:16:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Sure. Assume I am a promise user and don't plan to use callbacks\n// Current PR:\n\nconst fs = require(\"fs\");\nfs.readFile(\"foo.txt\").then(buff => ...).catch(e => ...);\n// Nice to read, but has the bifurcated error problem, so in fact\n// I need a try {} catch (e) { }. No good.\n\nconst fs = require(\"fs\");\nfs.readFileAsync(\"foo.txt\").then(buff => ...).catch(e => ...);\n// A bit annoying; I have to type Async for all my methods all throughout my program.\n\nconst { readFileAsync: readFile } = require(\"fs\");\nreadFile(\"foo.txt\").then(buff => ...).catch(e => ...);\n// OK, this is reasonable at the call site, but is annoying to set up\n\nconst fs = require(\"fs\").promised;\nfs.readFile(\"foo.txt\").then(buff => ...).catch(e => ...);\n// Minor setup cost, but nice call sites.\n// I like this best, modulo bikeshedding on .promised.",
                            "createdAt": "2016-02-01T21:23:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@getify: The err might have to be some sort of typed Error subclass, or some object that I do duck-typing checks on, to figure out what to do. I don't like these approaches. I find them harder to reason about/maintain.\n\nThe problem is that you have to do that anyway. How do you know whether lookupSomeInfo failed as expected (because eg. the item does not exist in the data store), or there's just an implementation error deep inside lookupSomeInfo that you should be treating as a fatal, application-crashing error? You don't, unless you look at what the error is.\nYes, this is 'harder' - which is precisely why I am very frustrated with ES6 Promises' lack of a filtered .catch, whereas eg. Bluebird does not have that problem and actually makes it quite easy - but it is necessary, whether errors are thrown synchronously or not. The assumption that a rejection is always an intentional/known error simply isn't correct.\nThe expected errors and unexpected errors are already mixed into one channel, whether we like it or not. It doesn't make sense to then split out part of the unexpected errors, which increases the amount of error handling code we need to write at no gain (since we can never fully exclude unexpected errors from the rejection channel anyway).\nIn a similar vein, specifying an 'error callback' in .then really isn't a good idea, and that double-callback syntax should really be considered an interoperability API only. This also addresses that.",
                            "createdAt": "2016-02-01T21:24:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "As a side note on *Async as a naming convention... that seems quite onerous to me given that we already have a bunch of *Sync versions all over... so now we'll have 3 versions of (almost) every function: *Sync, *Async, and \u00af\\_(\u30c4)_/\u00af (aka \"AsyncButNotAsNice\"). That's bound to lead to future headaches/learning confusions. It already makes my head hurt thinking about teaching that.",
                            "createdAt": "2016-02-01T21:28:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@getify, @joepie91: I'd like to make sure we don't veer into promise best practices too far, if possible. How does this proposal strike you? Is this workable for both of your cases? Is my assertion correct: associating errors with the appropriate promise is desirable (In my case, I know that's what I would want, but am not sure for other promise users)?\n@getify: Re Async, luckily the naming is probably the most mutable part of this PR! I think this fits in nicely with the course of action @domenic was suggesting, also (the require('fs').promise variant.)",
                            "createdAt": "2016-02-01T21:31:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "Is this workable for both of your cases?\n\nWell, I have already stated that I personally do not like funneling all types of exceptions into the promise chain. So... workable? Meh.\nI imagine I'd find myself using the *Async functions far less (in the cases where I care about the differences in exceptions) in favor of the userland-wrapped-callback+try..catch, than I would be to fork my catch code to handle the mixed different kinds of err objects it may receive.\n\nIs my assertion correct: associating errors with the appropriate promise is desirable\n\nIt's not what I want, unconditionally, no. I like that ES2015 for example still has sync assertions even on the actual Promise APIs rather than funneling all of them into a rejected promise.\nIs this something I'd fall on a sword for? No. It's a reasonable if distasteful compromise I suppose.",
                            "createdAt": "2016-02-01T21:36:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "In fairness to the debate here, I should point out a counterpoint to my own stance... once you use async..await (or the generator+promise predecessor), this funneling/conflation of error \"types\" already happens:\ntry {\n   var x = await someUtil(..);\n}\ncatch (err) {\n   // .. here i have no idea whether the exception was\n   // sync or async :/\n}",
                            "createdAt": "2016-02-01T21:43:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "State of the PR\nHere's the state of the PR as of mid-day. I will take the following actions:\n\nDrop process.setPromiseImplementation(). It seems like there's no desire for this! In any case folks can still monkey-patch with global.Promise = <some implementation>.\n\nLow concern: do we want to alert in the case that someone sets the global promise implementation twice? Resolution: nope!\n\n\nMove promise-returning variants to *Async.\n\nThe require('<module>').promised route works for top-level functions, but it doesn't handle object methods such as ChildProcess#send.\nThe *Async suffix remains up for debate. Ideally the suffix will be short (Promise is probably right out, ironically!)\nThis eliminates practically all runtime CPU overhead for supporting promises.\n\nCallback users won't have to pay a per-operation tax to support promise users.\nThis does potentially make startup a bit slower, since we're increasing\nthe number of APIs.\n\n\nI will continue to use the promisify decorator approach.\n\nThis reduces the immediate maintanence burden and allows us to take specific action to address places in the existing API where errors could leak through.\n\nI am thinking specifically of net.connect, here.\n\n\n\n\n\n\n*Async will capture programmer errors and forward them to the rejection handler.\n\nThis seems to be the best way to go, since it's inline with async/await use as well as expectations set by promise-returning APIs elsewhere in the JS world.\n\n\nDoc and test cleanup.\nBenchmarking \u2014 compare startup times, primarily, so we know what we're paying.\n\nI'm not as interested in callback vs. promise, especially now that the promise API will be separated out. Promises will likely be slower at the outset, but from the thread it appears the V8 team knows about this and is working on it.\n\nIf nothing else, this just provides more incentive to make native promises faster!",
                            "createdAt": "2016-02-01T22:10:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I'd almost consider it worthwhile warning on the first time global.Promise is changed... if a dependency changes it without a user know it could potentially lead to some headaches. Otherwise, +1 on the direction @chrisdickinson",
                            "createdAt": "2016-02-01T22:20:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson In the current approach, I find to confusing that some of the methods that return Promises use old naming, and some use *Async naming \u2014 this way anyone who is using only Promises-based approach would need to either remember those or to constantly check that up in the docs.",
                            "createdAt": "2016-02-01T22:23:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I only support warning on changing global.Promise if we also warn on changing global.Object, global.Array, global.Map, and the rest... which is to say, I don't think we should do it.",
                            "createdAt": "2016-02-01T22:24:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic ... good point ;-)",
                            "createdAt": "2016-02-01T22:25:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "Warning on assignment of global.Promise will require an accessor descriptor too which will make all references to Promise slower.",
                            "createdAt": "2016-02-01T22:26:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Fair enough! Updated direction with the resolution that we're not going to muck with global Promise.",
                            "createdAt": "2016-02-01T22:28:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "node-eps\n\nWhen the EP repo was started it was done explicitly as an \"in addition to\" the existing PR process we have even for potentially large and breaking changes like this one. It should be left to the contributor whether or not they want to write a spec before attempting a PR or whether to just send a PR. The EP process should not turn into a requirement for substantial changes as writing good specs and writing lots of code are not always the same skillset and controversial changes like this one tend to get a lot of theoretical arguments against which you can't make when there's a real implementation in front of you.\nFor changes and contributors the preferred process is to write an EP first, but the CTC has never said this is a hard requirement.",
                            "createdAt": "2016-02-01T22:37:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "Not sure whether it's really a factor in this decision but I think that if we go with e.g. readdirAsync, it will break a lot of code which uses Bluebird.promisifyAll(require('fs')) which is a very common pattern. The bluebird method creates its own *Async methods which return Bluebird promises. If a method with that suffix already exists, it will create readdirAsyncAsync instead, which means any code relying on Bluebird only features will break.",
                            "createdAt": "2016-02-01T22:42:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode .. aha, good point. I forgot about promisifyAll... that is perhaps yet another good reason to go with the require('...').promisified pattern instead...",
                            "createdAt": "2016-02-01T22:44:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode That's not exactly true. When bluebird.promisifyAll hits readdir it will create a readdirAsync method and override the existing one so it does not break that assumption.",
                            "createdAt": "2016-02-01T22:44:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "In the current approach, I find to confusing that some of the methods that return Promises use old naming, and some use *Async naming\n\nIf we can do this without complicating the API and increasing the surface area too much I'm for it. But if we're adding parallel APIs or making huge compromises I doubt this \"everything must be promisified approach.\"\nI'd much rather just add promises to APIs where adding them is easy and at little to no cost, mark them as experimental, and wait for tomorrow to figure out how to handle all the edge cases. If promises dramatically increase in use then we may want to consider moving some of the more problematic cases to new APIs that do a better job of support both usage patterns rather than bolting on new Promise-only ones.\nWe may even want to consider landing this support in master and backing it out prior to v6 release if the community tells us the inconsistency is too confusing. If we had Promise support in our nightlies for a while, even with 95% API coverage, we'd see a pretty big uptake in usage of the nightlies and will enjoy some feedback we are currently missing.",
                            "createdAt": "2016-02-01T22:46:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@kittens ... still, you'd end up with a situation where the core method is being overridden with potentially different semantics without the user necessarily being aware of what those differences are. I wouldn't anticipate it being a huge problem, but still, I'd rather avoid it.",
                            "createdAt": "2016-02-01T22:46:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "Also note the semver-major label. bluebird.promisifyAll polluting objects introducing breaking changes is not a convincing argument IMO.",
                            "createdAt": "2016-02-01T22:47:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@kittens it doesn't overwrite - https://tonicdev.com/56a03700570f0f0d008b9f70/56afdd7b65d8fc0c006325be\n@jasnell require('fs/async') is pretty nice",
                            "createdAt": "2016-02-01T22:47:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode It does if there's a foo method.",
                            "createdAt": "2016-02-01T22:48:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@kittens\n\nAlso note the semver-major label. bluebird.promisifyAll polluting objects introducing breaking changes is not a convincing argument IMO.\n\nUnderstand this position completely but it still breaks a lot of code.\n\nIt does if there's a foo method.\n\nTry it on tonicdev - it's actually worse, it throws with a link to http://goo.gl/MqrFmX",
                            "createdAt": "2016-02-01T22:50:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell, @phpnode:\n\n@phpnode .. aha, good point. I forgot about promisifyAll... that is perhaps yet another good reason to go with the require('...').promisified pattern instead...\n\n.promisified (and require('fs/async')) don't account for promisified object methods, though.\nI'd like to check that promisifyAll indeed breaks on an *Async'd copy of node. Does anyone have any examples of packages that use promisifyAll and include a test suite runnable with npm test?\nIf this proves to be a problem we can approach this a couple of different ways, possibly including simply picking a different suffix name, or making the Promise versions non-enumerable.\n@mikeal:\n\nIf we can do this without complicating the API and increasing the surface area too much I'm for it. But if we're adding parallel APIs or making huge compromises I doubt this \"everything but be promisified approach.\"\n\nAt this point I don't think anyone's making huge compromises: the compromises made thus far seem like a natural outcome of measured discussion of the problem space between interested parties. The separate set of APIs is not a huge maintenance burden, since for the most part they are one line assignments decorating existing APIs. The ergonomics of the promise-based APIs don't seem to be a problem, either.",
                            "createdAt": "2016-02-01T23:09:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "The separate set of APIs is not a huge maintenance burden, since for the most part they are one line assignments decorating existing APIs. The ergonomics of the promise-based APIs don't seem to be a problem, either.\n\nIs there some reason we can't do fs.readFile.promise(*args)?",
                            "createdAt": "2016-02-01T23:15:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal: Ooh, no! That's kind of nice. Another option is to attach a non-enumerable __isPromisified__ to promisified methods. Perhaps @petkaantonov could weigh in on this approach?",
                            "createdAt": "2016-02-01T23:17:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "That seems a lot worse ergonomically. Please keep comparisons like #5020 (comment) in mind.",
                            "createdAt": "2016-02-01T23:19:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson ya, I like it better too. I'm -1 on \"ified\" in API names as I consistently miss-type it :)",
                            "createdAt": "2016-02-01T23:19:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal when you only care about the promisified version then that's a pain to import:\nconst {readdir, readFile} = require('fs/async');\n// vs\nconst {readdirAsync: readdir, readFileAsync: readFile} = require('fs');\n// vs\nconst {readdir: {async: readdir}, readFile: {async: readFile}} = require('fs');",
                            "createdAt": "2016-02-01T23:19:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode I still don't see how that isn't more preferable ergonomically to hitting shift to expand out the API name but maybe I type different than other people :/",
                            "createdAt": "2016-02-01T23:21:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic the .promise() API wouldn't preclude your suggested module level API for const fs = require(\"fs\").promised;.\nI think having both would be fine. Some people may be only using modules that accept promises but other developers may be using some callbacks and some promises or have a legacy module that is being updated to call a single module that accepts a promise, and in that case it's preferrable to use the other.",
                            "createdAt": "2016-02-01T23:24:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic, @phpnode: It seems like the primary concern is about importing \u2014 does this concern extend to methods? e.g. would conn.setTimeout.async be an acceptable API in the below:\nnet.createServer(conn => {\n  conn.setTimeout.async(100).then(() => {\n\n  })\n}).listen(8124)\nWould it weird things too much to pair these approaches, such that you get:\nconst {readFile} = require('fs').async();\n\nnet.createServer(conn => {\n  conn.setTimeout.async(100).then(() => {\n    readFile('some/file').then(data => {\n      // contrived example!\n    })\n  })\n})\ni.e., the canonical location of those methods is <originalMethod>.async, but modules would include an .async() helper to make imports sweeter?",
                            "createdAt": "2016-02-01T23:25:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "-1 on naming them \"async.\" It's super confusing, the other methods are also async, and we have \"Sync\" methods already that are not the alternative to a promise but an actual blocking call.",
                            "createdAt": "2016-02-01T23:27:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "It seems like the primary concern is about importing \u2014 does this concern extend to methods? e.g. would conn.setTimeout.async be an acceptable API in the below:\n\nI think the paired approach seems reasonable, although I still don't see why you use .async instead of Async.",
                            "createdAt": "2016-02-01T23:28:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Why does this not work?\nif (cb === undefined) {\n  const args = arguments;\n  return new Promise((resolve, reject) => {\n    originalFunc.call(this, ...args, (err, result) => {\n      if (err) reject(err);\n      resolve(result);\n    });\n  });\n}\nreturn originalFunc.apply(this, arguments);\nThe only change to the existing behavior is that if you omit the callback you don't get an error anymore. But the promise path still catches all errors.",
                            "createdAt": "2016-02-01T23:34:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson: I'd like to make sure we don't veer into promise best practices too far, if possible. How does this proposal strike you? Is this workable for both of your cases? Is my assertion correct: associating errors with the appropriate promise is desirable (In my case, I know that's what I would want, but am not sure for other promise users)?\n\nApologies, I missed your proposal. That would seem like a reasonable implementation to me, yes - I can't see a compelling reason to change the existing behaviour for non-Promise APIs, as propagation is manual there anyway. Aside from that, as remarked earlier by somebody else (I forgot who), the ES6 Promise specification seems to demand this \"everything next-tick\" behaviour anyway.",
                            "createdAt": "2016-02-01T23:36:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gx0r",
                                "__typename": "User"
                            },
                            "bodyText": "I like @domenic approach. If we add some suffix like *Async or *.async it will live forever...",
                            "createdAt": "2016-02-01T23:39:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic:\n\nThe only change to the existing behavior is that if you omit the callback you don't get an error anymore. But the promise path still catches all errors.\n\nThis was the original approach taken in the PR. The problems were:\n\nThe callback-based API is not 100% consistent.\n\nSome APIs take callbacks but don't resolve to the desired object.\nSome APIs already treat callbacks as optional.\n\nFor example, socket.setTimeout, childProcess.send, crypto.randomBytes.\n\nSome of these also have meaningful return values that get erased by returning a promise (childProcess.send.)\n\n\nWe end up with *Async variants in any case.\n\n\n\n\nGoing with the \"callback optional\" route means that the \"programmer error\" / \"same tick throws\" become a conflict again \u2014 i.e., the promise-returning APIs may have to start throwing errors on same tick again, which is not desirable.\nIt's not a huge cost, but returning a promise in this fashion does mean that callback users are paying for promises without using them.",
                            "createdAt": "2016-02-01T23:41:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "The callback-based API is not 100% consistent.\n\nAgreed.\n\nGoing with the \"callback optional\" route means that the \"programmer error\" / \"same tick throws\" become a conflict again \u2014 i.e., the promise-returning APIs may have to start throwing errors on same tick again, which is not desirable.\n\nI don't understand this point. My code never throws same tick when you do the promise version.\n\nIt's not a huge cost, but returning a promise in this fashion does mean that callback users are paying for promises without using them.\n\nBy this you mean the cost of one branch?",
                            "createdAt": "2016-02-01T23:42:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal the use of async functions (the promise returning, getting implemented in V8 kind) is going to become pervasive in node and every other JS environment, so whatever solution we come to here has to take into account that it will probably become the most used API by a very large margin - i.e. it has to feel \"first class\". The readdir.async() stuff doesn't play nicely with destructuring or the ES6 module syntax so that has to be out.\nAdding readdirAsync() does break modules which use bluebird's .promisifyAll() - it throws an error. Regardless of whether Bluebird's behaviour is right or wrong in this scenario it is a very popular library and the people using it are the people most likely to want this feature. If we add fooAsync we break their code!\n@chrisdickinson what's the objection to adding an extra module for this, fs/async or fs/2 or similar? I know there isn't a precedent but it seems like it has a lot of advantages:\n\nCallback APIs are not penalized\nDoes not break existing promisify implementations\nAllows easy imports / destructuring\nCan still use names like readdir and not readdirAsync etc",
                            "createdAt": "2016-02-01T23:46:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic:\n\nI don't understand this point. My code never throws same tick when you do the promise version.\n\nThat's fair. I can look into this again, but primarily what I found from exploring this approach was that we start running up against idiosyncrasies in the callback API pretty much immediately.\n\nBy this you mean the cost of one branch?\n\nYep! It's not much, but it's something. If there's an acceptable option to provide promise-returning APIs at zero cost to callback users, that's probably ideal.",
                            "createdAt": "2016-02-01T23:47:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson: Yep! It's not much, but it's something. If there's an acceptable option to provide promise-returning APIs at zero cost to callback users, that's probably ideal.\n\nIs there a benchmark for this? The branch sounds like something that a runtime could optimize out fairly trivially, but I'm hardly an expert on the matter.",
                            "createdAt": "2016-02-01T23:49:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "-1 on naming them \"async.\" It's super confusing, the other methods are also async, and we have \"Sync\" methods already that are not the alternative to a promise but an actual blocking call.\n\n@mikeal I'm actually not so sure. Assuming we were in the day and age of async/await, wouldn't this make sense since it works as async with await?\nThat's still a future we are not in, however.",
                            "createdAt": "2016-02-01T23:50:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode That's pretty much where we're working from now. The canonical location for promise-returning apis is fs.readFile.promise. You can get a copy of only the promise- (and stream-) returning APIs by running fs = require('fs').promise(). This plays nicely with const {readFile} = require('fs').promise().",
                            "createdAt": "2016-02-01T23:50:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "the use of async functions (the promise returning, getting implemented in V8 kind) is going to become pervasive in node and every other JS environment, so whatever solution we come to here has to take into account that it will probably become the most used API by a very large margin\n\nThe most used API today for async is Node's standard callback API. We can sit around and try to predict the future all day but that doesn't really mean we can ignore the state of the world today and build something confusing for people today because of what we think the future will be.\nAlso, using promise verbiage is still going to be accurate verbiage in the future as async syntax is essentially a yield for promises. The word promise and an understanding of them won't be irrelevant in a future where people are using the async syntax.",
                            "createdAt": "2016-02-01T23:53:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "A reminder to participants: the goal of this PR is to support promises in addition to the callback API. We are not removing the callback API, we are not making any claims as to whether promises will supersede callbacks, etc. We're attempting to find the most ergonomic solution for both callback and promise users.",
                            "createdAt": "2016-02-01T23:53:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson but not ES6 imports, there's no way to directly import the readdir method for instance:\nimport {readdir} from \"fs/2\";\n// vs\nimport fs from \"fs\";\nconst {readdir} = fs.promise();\nIt's not like it's a huge problem, but it does mean it's harder to statically analyse.",
                            "createdAt": "2016-02-01T23:56:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "I agree with both @Fishrock123 and @mikeal: async slots in nicely with async/await, but we don't have async functions yet, and the difference between the promise-returning and (already asynchronous) callback-utilizing APIs seems like it would be easily missed by new users. .promise seems like a fairly future-proof namespace for these APIs.\n@phpnode: I think that might be best saved for later \u2014 adding <module>.promise() doesn't preclude us from that addressing that approach when the dust settles a bit more around the ES2015 modules/Node interop story, so we shouldn't block on making things perfect for ES2015 modules now.",
                            "createdAt": "2016-02-02T00:00:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RReverser",
                                "__typename": "User"
                            },
                            "bodyText": "Namespacing, especially with call like promise(), really doesn't play nice with ES6 modules coming in parallel discussion.\nPersonally I don't see any problems and would prefer if same methods but with callback being missed would return Promise, otherwise, if that's not an option for some reason, then namespaced modules would be still far better.",
                            "createdAt": "2016-02-02T00:09:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "If you namespace any promise producing functions then they will be cemented as a second class citizen in Node. That seems to be the opposite intention of this PR.",
                            "createdAt": "2016-02-02T00:12:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@RReverser, @kittens, @phpnode:\nI'll experiment with bluebird tonight with an eye towards whether *Async can be made to work with promisifyAll in a straightforward fashion. If it can't, then we fall back to plan B, which is to namespace promise APIs to avoid breaking existing, already-working programs, while providing an API that's ergonomic for destructuring requires. This leaves open the question of how this API is exposed via ES2015 modules, but that's intentional \u2014 it lets us make folks lives better now without having to solve all of the problems in this PR.",
                            "createdAt": "2016-02-02T00:18:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson the interoperability story might not be fully fleshed out yet but the syntax is - we know that won't work.",
                            "createdAt": "2016-02-02T00:18:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode It can be made to work. An ES2015 fs/promise module could be provided that exports the promise variants explicitly, as a later PR and as a separate discussion. This is off-topic for this PR, but I'd be happy to talk to you more about it in IRC or via email, though!",
                            "createdAt": "2016-02-02T00:21:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RReverser",
                                "__typename": "User"
                            },
                            "bodyText": "as a later PR and as a separate discussion\n\nSo it will create yet another abstraction (in addition to couple of existing now and +1 until that moment)? Why not design it future-proof at least against the cases that we already know will break?",
                            "createdAt": "2016-02-02T00:27:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@RReverser Would you mind taking this to IRC?",
                            "createdAt": "2016-02-02T00:28:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RReverser",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Not at the moment. Seems like it'll take a while, and 1 AM is not the best time to install IRC client :D",
                            "createdAt": "2016-02-02T00:30:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@RReverser haha, that's fair :) I'd be happy to communicate over email as well \u2014 christopher.s.dickinson at gmail dot com.",
                            "createdAt": "2016-02-02T00:33:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RReverser",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Np, I'll drop an email if you wish (although I thought it's something directly related to this PR and other people should participate / are interested too?)",
                            "createdAt": "2016-02-02T00:35:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@RReverser An email would be rad. I'd like to avoid pulling the ES2015 interop discussion into this issue for the time being, because it hasn't quite settled down and it is contentious enough that we could lose consensus on this issue by trying to solve for the module issue.",
                            "createdAt": "2016-02-02T00:48:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, signing off for dinner. Will update tonight.",
                            "createdAt": "2016-02-02T01:34:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson I know you're busy dealing with implementation details and the inevitable bike-shedding here but would you mind trying to keep track of, and expanding on the \"why\" argument? I suspect that to make any headway towards actually landing, the answer to that is going to have to be compelling enough to outweigh other concerns and personal preferences wrt Promises.\nSince this could currently be achieved in user-land with multiple mechanisms:\n\nblatant global monkey-patching\nconst fs = promisify(require('fs'))\nconst readFile = promisify(require('fs').readFile)\nconst fs = require('fs-promises')\nvariants of these and probably others I'm not creative enough to think of right now\n\nThe question of what benefit does this add by putting it in core rather than leaving it to user-land, a strategy that has worked so well for Node so far, is the key to bridging the division on the question of promises-in-core. So being able to discuss at that level will be vital for making this PR anything more than a theoretical exercise.\nFrom what I understand, the most compelling argument is that supporting Promise first-class in our APIs will make working with some ES2016 features more straightforward and natural (async/await, others?). The obvious response to this is that those features aren't even properly spec'd (afaik) and we certainly don't have a timeframe, so why do this so early?\nAre there other killer arguments (in your opinion or arising out of this discussion) to add to this?\nThere are also likely to be more subjective or hard-to-measure arguments but it's worth collecting all of those too because they add to the complete picture.\nThis is where the EP process would probably work better because you have to make a clear case for a change rather than devolving straight into technical details and missing the big picture. Although having a concrete proposal does kind help move beyond hand-wavy arguments based on personal preference. (Maybe we need to come up with a middle-ground strategy that combines both somehow?)\nAlso, cheers to everyone on a constructive discussion! There's relatively little superfluous noise, no emotive bickering and even some self-censorship going on.",
                            "createdAt": "2016-02-02T04:11:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "The obvious response to this is that those features aren't even properly spec'd (afaik)\n\nhttps://tc39.github.io/ecmascript-asyncawait/ (edit, copypasta in previous version)\n\nand we certainly don't have a timeframe\n\nChakra already implements it. V8 is committed to implementing it in 2016; I can't remember if it made the Q1 cutoff but it should be quite soon.\n\nAre there other killer arguments (in your opinion or arising out of this discussion) to add to this?\n\nFWIW, nodejs/NG#25 (comment)",
                            "createdAt": "2016-02-02T04:30:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "Will make the observation that this breaks domains. Take the following example:\nconst domain = require('domain');\nconst fs = require('fs');\nconst print = process._rawDebug;\nconst d = domain.create()\n\nd.run(function() {\n  fs.open('/etc/passwd', 'r').then(function(fd) {\n    fs.readFile(fd, function() {\n      print('readFile good');\n      throw new Error('crap');\n    });\n  }, function() {\n    print('open bad');\n  });\n});\n\nd.on('error', function() {\n  print('domain had an error');\n});\nOutput:\nreadFile good\n/tmp/test-pr5020.js:10\n      throw new Error('crap');\n      ^\n\nError: crap\n    at /tmp/test-pr5020.js:10:13\n\nThere is no arguing that a library should simply commit to using Promises, because that discounts usage of modules that may not have moved to such an implementation. It's also unreasonable to request module dependencies create a Promise based alternative to their API.\nThis also violates the contract that is established by AsyncWrap with when callbacks are actually called. Here's example code from existing implementation:\nconst async_wrap = process.binding('async_wrap');\nconst fs = require('fs');\nconst print = process._rawDebug;\n\nasync_wrap.setupHooks(function create() {\n  print('>>> create');\n}, function before() {\n  print('>>> before');\n}, function after() {\n  print('>>> after');\n});\nasync_wrap.enable();\n\nprint('open begin');\nfs.open('/etc/passwd', 'r', function(err, fd) {\n  print('open complete');\n  if (err) throw err;\n  print('readFile begin');\n  fs.readFile(fd, function() {\n    print('readFile complete');\n  });\n});\nOutput:\nopen begin\n>>> create\n>>> before\nopen complete\nreadFile begin\n>>> after\n>>> create\n...\n\nHere's the Promise implementation snippet:\nprint('open begin');\nfs.open('/etc/passwd', 'r').then(function(fd) {\n  print('open complete');\n  print('readFile begin');\n  fs.readFile(fd).then(function() {\n    print('readFile complete');\n  });\n}, function(er) {\n  throw er;\n});\nOutput:\nopen begin\n>>> create\n>>> before\n>>> after\nopen complete\nreadFile begin\n>>> create\n...\n\nAs you can see the \"open complete\" is happening out of order between the before and after callbacks. This type of breakage can't be had from core's own modules. We're in the process of working to make AsyncWrap a public API to help existing complaints that node doesn't have enough tooling available to track asynchronous requests. This API throws that work down the drain.",
                            "createdAt": "2016-02-02T04:58:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg:\nHey, thanks for taking a look and weighing in. As @domenic notes, async/await appears to be on the V8 roadmap for this year, and Chakra already implements it. The latter doesn't weigh as heavily as the former, but the feature seems (roughly) imminent. With that said, it seems prudent to make sure Node is in a good position to take advantage of the feature.\nAs @trevnorris notes, Node's Promise story is currently somewhat buggy \u2014 interoperation with domains is broken, and the microtask queue doesn't appear to be interacting with AsyncWrap as we'd like. One of the advantages of exposing an API like this through core is that it brings these bugs out into the daylight and forces us to address them. As more language and runtime level features begin to use promises, making sure the interactions between Node and Promise's are well-tested and known increases in value for our users. The best way I know to do that is to support it as part of the public API.\nSpeaking to the existing promisifyAll options in the ecosystem: these are workable solutions, but it's apocrypha that's difficult for newcomers to Node to pick up. My impression \u2014 and perhaps it would be worthwhile to check this impression with polls of some sort \u2014 is that async/await is going to garner a lot of interest, and hence a lot of newcomers. It would be nice to smooth that learning curve (even just a bit) ahead of time.\nPromises may not be everyone's cup of tea! However, I think providing these APIs for users that prefer them will make their lives a little bit easier, and make Node's relationship with the spec-mandated async primitive a lot more solid. Plus, it positions Node users to be able to take advantage of async/await out of the gate.\n@trevnorris:\nThese are fairly big bugs, especially the latter. I'm not sure they invalidate the work put into solidifying AsyncWrap or preclude us from providing a Promise-returning API, though. The latter bug definitely needs to be fixed regardless of whether we ship a Promise-returning API. Otherwise, Node's interoperation with a core primitive is buggy, and that would prevent users from relying on AsyncWrap calling hooks as expected.\nWhat's needed to fix this? Does V8 give us the tools we need to instrument the microtask queue to make sure async hooks fire as expected? Could the microtask and nextTick queues run \"between\" the AsyncWrap before / exit pair to avoid this?",
                            "createdAt": "2016-02-02T06:40:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "reqshark",
                                "__typename": "User"
                            },
                            "bodyText": "In general: any API that would have thrown with no callback most likely does not throw now.\n\nbtw, I'm strongly in favor of this point! Promises aside, this would be a huge win for node IMO\nFor the sake of doing fire-and-forget operations when I don't care whether it was successful or not. (why waste instruction sets?)",
                            "createdAt": "2016-02-02T07:41:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nWhat's needed to fix this? Does V8 give us the tools we need to instrument the microtask queue to make sure async hooks fire as expected?\n\nThe necessary v8 API is not available to solve our needs. I've put in a feature request that should help with this issue (https://bugs.chromium.org/p/v8/issues/detail?id=4643), but it hasn't gone anywhere. Also realize that the issue with domains relies on the same API being made available.\nThe only alternative for the moment would be to replace Promise with our own that wraps the callback. Even so, understand that user-land Promise implementation will likely break this contract regardless, causing the same issues to occur.\nIt's been a known issue that Promises break our timing contract with AsyncWrap, but it's been because of lacking API on v8's part. Though providing an officially supported Promise-based API would imply that it works in conjunction with all our other mechanics. So these issues are blockers for an implementation to be introduced.",
                            "createdAt": "2016-02-02T09:10:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "For reference:\nnodejs/node-v0.x-archive#8648\nHere is a sketch of v8 patch: nodejs/node-v0.x-archive#8648 (comment)",
                            "createdAt": "2016-02-02T09:29:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "Fun fact: looks like ChakraCore has API that is sufficient for this purpose: https://github.com/Microsoft/ChakraCore/wiki/JsSetPromiseContinuationCallback",
                            "createdAt": "2016-02-02T09:30:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "satazor",
                                "__typename": "User"
                            },
                            "bodyText": "It might be confusing for new comers to look at the NodeJS apis and see:\n\nfs.readFile -> read file asynchronously\nfs.readFileSync -> read file synchronously\nfs.readFileAsync -> wat? is this the pinnacle of asynchronously-ness?\n\nI understand that for performance reasons we should not mangle with the current methods but perhaps we could have a better signature. Some suggestions:\nfs.readFilePromise('foo.txt')\n.then((buffer) => {});\n\nfs.readFileAsPromise('foo.txt')\n.then((buffer) => {});\n\nfs.readFile.asPromise('foo.txt')\n.then((buffer) => {});\n\nfs.readFile.promise('foo.txt')\n.then((buffer) => {});",
                            "createdAt": "2016-02-02T12:04:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@satazor I know it's a long thread but please read through before making further suggestions - we've already discussed this and the issue is that it doesn't work with destructuring or ES6 module syntax. Moreover, it makes the promise version a second class citizen.",
                            "createdAt": "2016-02-02T12:08:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "Is it possible that we could pass some value in place of the callback that lets the method know that we want \"promise behavior\" instead of \"callback behavior\"?. I'm thinking, for instance, the Promise() function itself, which to me has a decent semantic to it...\nfs.readFile(.. , function(err,data){ .. } );\n\nvar pr = fs.readFile(.., Promise );\nOf course, we can bikeshed what the value might/should be, but I'm just curious if there'd be any support for this style of behavior switching? Seems like it would have low-to-zero perf impact, preserve the current behavior unchanged, and afford promise use-cases without compromise.",
                            "createdAt": "2016-02-02T13:16:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@getify that sounds great! Let's make the value chosen undefined.",
                            "createdAt": "2016-02-02T13:21:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@getify I like that idea. We could use a special Symbol as the magic value.",
                            "createdAt": "2016-02-02T13:23:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "If you have some magic value then you're still effectively namespacing. Passing Promise or a symbol is super gross. This is basically the semipredicate problem, polymorphic return types are a bad idea.",
                            "createdAt": "2016-02-02T13:27:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@getify like @domenic says the only value that would work here would be undefined any other option is worse than the current situation where users just promisify manually. All of these suggestions make promises feel second class rather than the core language feature that they are.\nThe lowest impact option is to introduce require('fs/2') which could use a purely async, promise based API and drop support for deprecated things like fs.exists(). Adding new versions of core modules gives node the ability to refine and restructure its API based on modern use cases and modern language features without throwing the existing ecosystem under the bus. As the language continues to change, node will face this dilemma more and more, e.g. streams. Adding versioned core modules should keep everyone happy because there is no performance impact, no breaking changes, no API ambiguity and no kludges like passing in a special parameter.",
                            "createdAt": "2016-02-02T14:21:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode I don't think he was serious, passing undefined is the same as omiting the callback here.",
                            "createdAt": "2016-02-02T14:24:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@YuriSolovyov I think he was completely serious, and it's a reasonable suggestion.",
                            "createdAt": "2016-02-02T14:25:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "I find @phpnode's suggestion most reasonable here. No idea why nobody wants to even discuss it. Does it have any hidden drawbacks?",
                            "createdAt": "2016-02-02T14:29:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "calvinmetcalf",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode @inikulin this has come up previously in this discussion but the main idea here is that promises are going to be first class citizens and that suggestion would not do that, on the other hand you can totally make a promise version of the api in userland right now.",
                            "createdAt": "2016-02-02T14:40:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "any other option is worse than the current situation\n\nDisagree. Please explain this assertion. There's a whole bunch of weird/negative tradeoffs being discussed, from divergence around Promise error handling expectations, to the destructuring woes around differently named methods, etc. I made my suggestion because I think it's significantly lower impact to the current ecosystem and use-case expectations, so I don't follow your reasoning at all.\n\nthe ability to refine and restructure its API based on modern use cases and modern language features\n\n-1. Having parallel APIs that diverge over time is the worst possible way I could see promises coming into node. Just think about the nightmares of tech blogs/tutorials discussing some behavior or quirk that applies only to the callback* or only to the promise* versions of the APIs.",
                            "createdAt": "2016-02-02T14:41:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "@calvinmetcalf From the current state of PR I see that current approach is require('<module>').promised. I don't see how it differs from `require('module/promised') in context of \"Promises as first-class citizens\".",
                            "createdAt": "2016-02-02T14:43:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Just think about the nightmares of tech blogs/tutorials discussing some behavior or quirk that applies only to the callback* or only to the promise* versions of the APIs\n\nThis is almost certainly guaranteed to happen with another layer of API, unfortunately.",
                            "createdAt": "2016-02-02T14:44:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "I don't see how it differs...\n\nIt doesn't... both (and many other options here) make promises second-class citizens. It's been claimed that the idea of passing a special value to switch to promise behavior would do the same, but I find that claim unbased at the moment. In my mind, the only way that claim holds any weight is if your definition of \"first class\" is \"replaces callbacks entirely as preferred\".\nPassing a special value as signal is an active opt-in rather than the passive (accidental) opt-in of the initial idea of leaving off a callback to switch.\nI want promises as first-class. But I recognize that there's a ton of code and inertia that's based around callbacks so I don't think bulldozing that is healthy or likely to succeed. The only strategy that I think balances this tension is some sort of switching signal.",
                            "createdAt": "2016-02-02T14:46:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "calvinmetcalf",
                                "__typename": "User"
                            },
                            "bodyText": "@inikulin\n\nThe require('').promised route works for top-level functions, but it doesn't handle object methods such as ChildProcess#send.\n\nis from my reading why that is not being used\n@getify the issue with your idea is that it is extreamly non-idiomatic from both a node and a JavaScript perspective",
                            "createdAt": "2016-02-02T14:47:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "The only strategy that I think balances this tension is some sort of switching signal.\n\nI agree. However, I don't think it's safe/ergonomic to do it in per-call basis as you suggested. Module-level switch looks more reasonable in that context.",
                            "createdAt": "2016-02-02T14:48:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@getify\n\nDisagree. Please explain this assertion\n\nAs a user of promises, I always use the promise version of an API if it's available. I should not have to pass in a special parameter at every call site to opt into it, I always want that behaviour. With a promisified version of a callback based API then at least I can just use await readdirAsync(someFile), with your suggestion it's incredibly unintuitive for beginners and awkward for the rest of us - await readdir(someFile, Promise)\n\nJust think about the nightmares of tech blogs/tutorials discussing some behavior or quirk that applies only to the callback* or only to the promise* versions of the APIs.\n\nThis is exactly the future that you're advocating with your special signalling suggestion - it's the same problem, exasperated by it being the exact same methods of the exact same module.",
                            "createdAt": "2016-02-02T14:49:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "it is extreamly non-idiomatic from both a node and a JavaScript perspective\n\nYeah. But sometimes you take a path like that because all the other options are worse. That's what I'm claiming.",
                            "createdAt": "2016-02-02T14:49:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "This is exactly the future that you're advocating with your special signalling suggestion\n\nI find that claim very much off-base. There's actually a fair bit of precedence around the initial idea of leaving off callbacks to \"switch on\" promise behavior. I've seen this in a number of places before. It didn't cause the roof to come crashing down, and it hasn't made explaining/teaching those APIs untractable.\nThe difference is, that precedence has only been in userland before. I think it points to a path where it can make a difficult tradeoff in core more reasonable.",
                            "createdAt": "2016-02-02T14:52:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "@calvinmetcalf\n\nis from my reading why that is not being used\n\nYes, my bad, misread that. However:\n\nMove promise-returning variants to *Async\n\nDoesn't change things drastically regarding \"first-class citizenship\". The only right way to do that is to completely obsolete old API, and let all non-sync functions return promises. But, nobody ever will do that for the obvious reason.\nI'm trying to say that \"first-class citizenship\" is not something that can be really ever achieved, so I don't believe we should use it as an assertion criteria.",
                            "createdAt": "2016-02-02T14:54:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@getify are we arguing past each other? I'd be happy with a solution which omits the callback to return a promise, but it seems other people are against it. What I dislike is the idea of passing in a special value instead of the callback to opt in for promises, so to be clear:\nreaddir(someDir, (err, files) => {}); // still works\nawait readdir(someDir); // this would be awesome\nawait readdir(someDir, Promise); // No, that's disgusting\nBut it seems that many of those members of the community who still overwhelmingly use callbacks are unhappy with this solution and there are some cases where it doesn't work because node already alters its behaviour based on the presence or lack of a callback.\nThe only way to break free from the constraints of backwards compatibility whilst still providing an idiomatic API is to introduce a new module. Promises are not going to be the only scenario where we want to do something like this, so setting a precedent seems appropriate.",
                            "createdAt": "2016-02-02T14:59:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "it seems that many of those members of the community who still overwhelmingly use callbacks are unhappy with this solution and there are some cases where it doesn't work because node already alters its behaviour based on the presence or lack of a callback.\n\nAnd that's exactly what I meant as an improvement over \"leaving it off\" because...\n\nPassing a special value as signal is an active opt-in rather than the passive (accidental) opt-in of the initial idea of leaving off a callback to switch.\n\nMaking it an active signal (you have to intentionally pass it, not accidentally omit it) changes the situation, -- slightly but enough IMO -- because callback fans still get their \"i left off the callback and it still does what it always did.\"",
                            "createdAt": "2016-02-02T15:02:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "I'm operating under the assumption that the promise-purists view (all functions should unquestionably be promise-returning only) isn't going to work, and the callback-purists view (keep those promises to yourself -- preferably as userland or second class citizens) have to be balanced. Neither is going to succeed. I'm trying to find a compromise that has minimal (not zero) offense on both sides.\nI well-know that promise fans won't love passing a signal value. I'm one of them, and I don't love it. But I can stomach it more easily than some of the other ideas in this thread.",
                            "createdAt": "2016-02-02T15:08:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@getify to repeat myself - opting in for promises at every call site is a terrible solution. It is worse than the existing situation for literally no benefit, and it opens up a huge can of worms, e.g. If I pass in a Promise does it have to be global.Promise or can it be e.g. Bluebird? If so how do we differentiate between a Promise constructor and a callback function?\nIt's confusing, adds complexity to every call site, is too easy to forget and introduces even more traps for new users. Why are you advocating this?",
                            "createdAt": "2016-02-02T15:08:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "@getify The other issue with the signaling approach:\nWithout it:\ngetFileName().then(fs.readFile);\nwith it:\ngetFileName().then(filename => fs.readFile(filename, Promise));\nYes, it's synthetic example. However it illustrates how much boilerplate code this approach may introduce. I bet people will start publishing modules to npm that will produce thunks for the core functions to omit Promise argument. From that perspective it's not different from the current state of the art.",
                            "createdAt": "2016-02-02T15:09:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode to repeat myself\n\nis a terrible solution\n\nhasn't been backed up with anything other than personal distaste.\n\nfor literally no benefit\n\nIt literally has a benefit, which is preserving the \"omit the callback, does what it always did\".\n\nBut this part of the debate is clearly not productive.",
                            "createdAt": "2016-02-02T15:10:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@inikulin I don't think that's synthetic - that kind of pattern is very common",
                            "createdAt": "2016-02-02T15:10:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "hasn't been backed up with anything other than personal distaste.\n\nIt's much worse than just calling promisifyAll and being done with it. There was plenty of \"backing\" given:\n\nIf I pass in a Promise does it have to be global.Promise or can it be e.g. Bluebird? If so how do we differentiate between a Promise constructor and a callback function?\nIt's confusing, adds complexity to every call site, is too easy to forget and introduces even more traps for new users. Why are you advocating this?\n\nAny solution here has to be better than promisifyAll, otherwise there is no point.\n\nIt literally has a benefit, which is preserving the \"omit the callback, does what it always did\".\n\nThrowing on omitting callback is very questionable even by itself. It makes the case of wanting to just run something without caring about its result inconvenient. If you forget to pass the callback, you will realize it without any error because how are you going to access the result otherwise? So even without promises it would be a massive improvement not to throw when callback is not passed.",
                            "createdAt": "2016-02-02T15:26:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg: Are there other killer arguments (in your opinion or arising out of this discussion) to add to this?\n\nI don't know if this point has been raised before, but a major issue with userland promisification of modules is that it isn't always straightforward, or even cleanly possible.\nA major problem case, for example, are the functions that return an object with more functions - even implementations like promisifyAll necessarily only operate on a single level, and thus each resulting object has to be promisified individually. Some modules will let you promisify a prototype, some will not. Sometimes it's not even technically possible.\nThere are also some particularly egregious cases (like connection pools) where it's almost impossible to cleanly promisify a module, simply because the API design does not take into account the possibility of Promises being used. That then leads to hacks like this one.\nThere's a third problem case: methods that accept an error-first callback and return some kind of (state) object. These cannot be promisified automatically without breaking functionality.\nBy making Promises a first-class citizen in modules (both the core and userland modules), this issue is almost entirely resolved - it provides a fairly neutral 'state' or 'placeholder' object for other abstractions to build upon (even if they don't directly expose the Promises to the user), in a manner that 1) is guaranteed to be compatible with the rest of the API, and 2) does not require copious amounts of boilerplate.",
                            "createdAt": "2016-02-02T15:36:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "I've just looked at breaking changes and they does not seem too scary to me:\n1:\n\nIn general: any API that would have thrown with no callback most likely does not throw now.\n\nThis sounds like something huge, but really, how can you depend on that?\nLike so:\ntry {\n  api.call(foo, bar); // no callback\n} catch (e) {\n  api.call(foo, bar, callback); // maybe I should pass that thing?\n}\n?\nAm I getting it right?\nAll modules are either working correcly and passing a callback right now, or does not exist at all.\n2:\n\nfs APIs called without a callback will no longer crash the process with an exception.\n\nKind of the same, but not quite, needs more discussion on how can people/modules depend on this.\n3:\n\nChildProcess#send with no callback no longer returns Boolean, instead returns Promise that resolves when .send has completed.\n\nMeh, just another semver-major change.\nAs of other APIs that treated callback omission as a sigal of something,\nI think we should say: \"yes, this is breaking, but for good\"; and \"signaling\" of such API can be moved to explicit parameter, or options object if present.",
                            "createdAt": "2016-02-02T16:15:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg ... while I have significant issues with the way Promises are defined, one argument for having them in core is essentially the same argument why something like domains would be difficult or impossible to pull off in userland: essentially, they require enough of a paradigm shift in how the code is written that unless the turtles go all the way down it's difficult or impossible to get completely right or consistent. I know that's not a great argument but still.\nWhat I would very much like to see here is a very clean separation between our existing core APIs and an currently experimental promisified subset that the community can use to figure out longer term what all of the issues are. I don't want to get into modifying our existing APIs yet until we have a better handle on the problem and the benefits.. which will only come through experimentation.\nI know it has been discussed before, but this is the main reason why I think we should put this behind a runtime flag initially and make sure we're using separate methods (fooAsync or require('').promise or foo.promise, whatever). We can make it absolutely clear in the documentation and via runtime warnings that the Promise support is unsupported and experimental in v6 -- we could even treat it similarly to how we have handled AsyncWrap updates, allowing potentially changes to roll out through the stable v6 as we progress. When v6 rolls over into LTS, we can make it absolutely clear that none of the Promise method versions are supported. Once we get a bit further down the road, after users have had a chance to experiment and we've had the opportunity to play around with a few variations, we can decide if the experiment was worth it.",
                            "createdAt": "2016-02-02T16:31:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "defnorep",
                                "__typename": "User"
                            },
                            "bodyText": "Everyone seems to be in agreement that Promises should be first class citizens, except for within existing legacy code. That means that eventually, fs.readDir should just return a Promise. So what's wrong with implementing fs/promise or fs/2 now, deprecating fs, and migrating the new API to the default fs import on next LTS release?\n\"But userland can do that right now\" isn't a very good reason to me. A good way is a good way, and having core contributors maintain the APIs is usually better than userland doing so. Plus, it provides a nice migration path to having everything unified within core eventually. The release cadence is stable and long enough that we could deprecate successfully.\nWith everyone programming against fs/x with Promises, all that is required is to change the import to fs. That's a pretty minimal change.\nPruning the old callback APIs upon migration would also have to be within scope unless we want to maintain legacy APIs too.\nFailing this thinking, some kind of a variadic signature is preferable in my eyes. Signalling with types in function calls increases likelihood for failure and confusion, and is also overly verbose.",
                            "createdAt": "2016-02-02T16:34:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell the thing is that people have been experimenting with this for years - we know what promisified versions of node modules looks like, we know what is and is not going to work with ES6. Putting this behind a flag does not buy us anything apart from more time. Personally I would rather have a solid well thought out solution in the near future compared to a feature flag now which exposes something which is very likely to change. No one will use it because it will be less reliable and performant than Bluebird.promisifyAll()",
                            "createdAt": "2016-02-02T16:37:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "evanlucas",
                                "__typename": "User"
                            },
                            "bodyText": "@daekano the problem with your assumption is that not everyone is going to only use promises. I don't see the callback APIs as being legacy.",
                            "createdAt": "2016-02-02T16:39:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "defnorep",
                                "__typename": "User"
                            },
                            "bodyText": "@evanlucas That's fair. I am certainly making an assumption that Promises will be the default paradigm in the future. It could be possible to maintain fs/callback, or fs/1 with fs being our Promise-based API. But that's just naming.",
                            "createdAt": "2016-02-02T16:41:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode ... yes, I get that. When I say experiment I mean specifically in terms of how Promises are supported and manifest within the Node core API. The key challenge with not putting it behind a flag or marking it experimental is that as soon as we add it, users expect us to support it forever... and if we don't get it right that ends up adding a significant burden on everyone. Yes, I'd also like to have a solid well thought out solution but I want it to be proven and mature a bit before we commit to supporting it long term as part of our LTS plan. Time to make sure it's done properly is well worth the investment in my view... and it's ok to me if more users end up using Bluebird.promisifyAll() during that initial period of time.",
                            "createdAt": "2016-02-02T16:44:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "achievement unlocked: I read it all!\n@chrisdickinson, thank you this pull-request\n\nThere is a Promise spec landed in ES2015, so I\u2019d say Promises should land in NodeJS by default too, implementing with respect to spec obviously, so im happy about rejecting this part process.setPromiseImplementation(require('your-favorite-promise-lib'));\n\n\nAdding readdirAsync() does break modules which use bluebird's .promisifyAll() - it throws an error. Regardless of whether Bluebird's behaviour is right or wrong in this scenario it is a very popular library and the people using it are the people most likely to want this feature. If we add fooAsync we break their code!\nIf we add fooAsync we break their code!\n\nBluebird is nice and i love it, that said statement still seems wrong to me, nodejs dont need to take this into account, because bluebird consumers should either not upgrade to next major node, either remove promisifyAll from their codebase, or Bluebird can just publish new versions with fixes.",
                            "createdAt": "2016-02-02T16:47:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "Some words about basic naming convention\n\nI would like not to break es6 modules static analysis feature with upcoming in core promises.\n*Async-ish makes a lot of confusion because it callback approach is async too.\nfs/2 or fs.promised seems fine to me, but i guess it will make promises 2nd class citizens, though i still didnt get why.\n\nMy preferred way to use fs.foo as promise method if i decided to omit callbacks, because it still async method and nodejs have been non-blocking and asynchronous from the very start.\nI\u2019m keeping python zen mantras in mind \"Special cases aren't special enough to break the rules\" and \"Although practicality beats purity.\" in mind in following suggestion.\nAs far as i can see there are a lot of edge cases with inconsistent callback-ish methods, so I would like to suggest review each built-in module to narrow scope of investigation/code-review and in each case try to implement callback-promise compromise if its possible, and if its not, create workarounds in inconsistent methods. In result community will get consistency in most methods with some exception in few modules.",
                            "createdAt": "2016-02-02T16:48:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "I don't see why this has to be so intrusive. Can we not achieve the same effect, without affecting performance in callback-style'd hot code?\nvar foo = function(opt1, opt2, callback){\n  if(!opt1){\n    var err = new Error('opt1 required!');\n\n    if(callback)\n      return callback(err);\n\n    return Promise.reject(err);\n  }\n\n  if(opt2 instanceof Function){\n    callback = opt2\n    opt2 = undefined;\n  }\n\n  // Do Stuff\n\n  // Something happened\n  if(callback)\n    return callback(err);\n\n  return Promise.reject(err);\n\n  // Or, nothing happened\n  if(callback)\n    return callback();\n\n  return Promise.resolve(err);\n};",
                            "createdAt": "2016-02-02T16:56:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@tflanagan that does affect callback performance (in an incredibly minor way, especially so in operations whose performance is limited by I/O)",
                            "createdAt": "2016-02-02T16:58:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gx0r",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe this is a pipe dream, but what about a wholly separate API with exclusively promise-returning functions (that would not even accept callback arguments in order to reduce API complexity), but the promises returned would have the .asPromise method for cases where callbacks are desired. That way we don't mix the two worlds. Then we also keep the original callback API and nothing changes there with no loss of performance. I generally prefer promises but don't want to inconvenience callback usages or hamper performance.",
                            "createdAt": "2016-02-02T17:03:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@iamstarkov\n\nBluebird is nice and i love it, that said statement still seems wrong to me, nodejs dont need to take this into account.\n\nKnowingly breaking the code of the people most likely to use this feature should be avoided if possible, that's simple politeness. And it's not necessarily as easy as you make out to remove or replace it - the promisification could be occurring in third party modules which the application developer has no control over, and users might actually be relying on bluebird only features (of which there are many). Also it's not an ideal solution, as readdir and readdirAsync are both async.",
                            "createdAt": "2016-02-02T17:04:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@llambda\n\nbut what about a wholly separate API with exclusively promise-returning functions (that would not even accept callback arguments in order to reduce API complexity)\n\nThat approach is what i'm advocating for with fs/2, stream/2 etc. This does not deprecate the existing callback API, it adds to it. require('fs') would keep on working as normal.",
                            "createdAt": "2016-02-02T17:06:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joepie91",
                                "__typename": "User"
                            },
                            "bodyText": "I would like to ask again whether there are any actual benchmarks, that show that the additional branching (as a result of optionally accepting callbacks) would actually yield a real-world performance difference.\nAgain, this sounds to me like something that is fairly easy for an optimizer to catch and optimize out. I don't think we can really be making statements about performance until we have the numbers to show it.",
                            "createdAt": "2016-02-02T17:27:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "I would like to ask again whether there are any actual benchmarks, that show that the additional branching (as a result of optionally accepting callbacks) would actually yield a real-world performance difference.\n\nThat point is moot now anyway, there are several APIs that this just won't work for and if we want to actually do this consistently it'll need to be another parallel API. If it were possible to do with 100% consistency then we could have a debate about the performance impact but doing so now would just derail a potentially productive discussion.",
                            "createdAt": "2016-02-02T17:45:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, I'm back at it for the morning. \ud83d\udc4b",
                            "createdAt": "2016-02-02T17:54:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell Just a friendly reminder that this can't happen until v8's added the APIs necessary to allow us to maintain the proper AsyncWrap timing contract. Or we wrap Promise, then, catch so we can setup/tear down state the way we need to.\nTake the following example:\nconst fs = require('fs');\nconst d = require('domain').create();\nvar p;\nd.run(function() {\n  p = fs.readFile('/etc/passwd');\n});\np.then(resolve, reject);\nShould the domain propagate with the resolve/reject in the above? I'd think it should since it's an asynchronous branch of the instantiated Promise (same argument applies to net.createServer()). But we don't have near the necessary internal tools to accomplish this.",
                            "createdAt": "2016-02-02T18:05:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode, @inikulin, @daekano: New user-facing modules are out of scope for this PR and discussion. That's an issue that can be held elsewhere, later. It relies on adding a new user-facing module, which represents a lot of scope creep and increases the surface area that everyone concerned has to agree on, making the proposal much more tenuous. For the sake of making progress here and now, I ask that you to drop the module line of inquiry in this PR. If this lands, we can  and should revisit the issue. The two things do not have to land together; tying progress in this PR to getting a new module landed sacrifices \"better\" for \"perfect.\"\n@trevnorris, @jasnell: I will see what I can do to fix that today. Bluebird provides a very nice model for how this can work. I am optimistic.",
                            "createdAt": "2016-02-02T18:06:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg @domenic\n\nA given project may end up containing all of these [API wrapping] libraries in the same project. I'd much prefer to just have core supply a single implementation that everyone uses, especially for something as basic as fs.\n\nThis problem is dramatically worse for users of js compilers. It means that several versions of several wrapping libraries get included in the bundle for front-end assets that all essentially do the same thing. Progress has been made in npm to flatten dep trees and help people to remove duplicate versions of the same library but having several competing libraries for simple wrapping of core APIs can't be de-duplicated without maintaining forks of all the libraries that use them.\nI think the biggest argument for this PR is this: when Promises landed natively in V8, and soon after in Node.js, we were able to make some serious improvements to Node.js as a platform for Promise users. Not simply because of the fact that they were supported \"natively\" but because the Node.js platform was able to add features specifically for native Promises that weren't available to user-land Promises.\nLooking at the current breaks in domains and our lack of AsyncWrap, I see these as reasons to add these APIs, not as arguments against. Landing broader support for Promises should increase the opportunity for Promise users to solve these problems in Node.js and land patches for support. It should increase the drive of Promise users to become contributors to Node.js to work on these issues.\nI'm not of the mind that the moment these land the ecosystem adopts them wholeheartedly and in the future we stop seeing callbacks, I find that view of the future somewhat delusional. But I do think a future where Promise users are engaged in the platform more is likely a good thing for Node.js and that this isn't a zero sum game between people who like Promises and people who prefer callbacks.",
                            "createdAt": "2016-02-02T18:08:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris: In your example, per bluebird's existing semantics: the promise generated by fs.readFile will be bound to the domain. It, and any then clause it generates, will be bound to the domain. If it uses a callback variant in a .then clause, it will be bound to the domain.",
                            "createdAt": "2016-02-02T18:08:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@tflanagan, @getify: the problem I ran into with omitting the callback applies to including a sentinel value as well \u2014 we end up mutating the the return value based on input type. In some cases the return value is meaningful and separate from callback value (http.get, for example.) A sentinel value is an ingenious solution! Unfortunately, since the same problem applies to it as applies to the no-callback approach, it's unlikely we can take that route.",
                            "createdAt": "2016-02-02T18:11:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris ... yep, which is precisely the kind of thing I'm concerned about. There are lots of ways this can go wrong, some of which we know, most of which we don't yet. Getting something in as experimental is good, having it be a first class supported feature is extremely premature.",
                            "createdAt": "2016-02-02T18:11:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell:\n\nThere are lots of ways this can go wrong, some of which we know, most of which we don't yet. Getting something in as experimental is good, having it be a first class supported feature is extremely premature.\n\nWhat about landing this after the next major? That may give us enough time to back it out of the canary/master branch while giving folks builds to experiment with.",
                            "createdAt": "2016-02-02T18:15:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson ... That could work. That would make sure that it doesn't make it's way into the v6 LTS (which is good) and that we have almost a year to get it right before it went into an LTS version. I'm down with that.",
                            "createdAt": "2016-02-02T18:18:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell @chrisdickinson any way we can put it behind a flag?",
                            "createdAt": "2016-02-02T18:26:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal, @jasnell: it's totally possible to do so. Maybe flagged in v6, unflagged in v7, with the final go/no-go for v8.0.0?",
                            "createdAt": "2016-02-02T18:44:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson @mikeal +1",
                            "createdAt": "2016-02-02T18:48:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ide",
                                "__typename": "User"
                            },
                            "bodyText": "Regarding the \"Async\" suffix -- I've seen this work very well in practice at several companies. One way to think about it is that \"Async\" means it's compatible as an async function and works with await.\nAnother thing that's nice is that it's really clear whether you need to await (or call then()) the result of the function, just by reading the call site. The migration path forward is also simple since you can grep for all the old call sites that don't have \"Async\" and incrementally upgrade some of them to use the new API on your own schedule.",
                            "createdAt": "2016-02-02T19:00:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "So we are talking about adding unflagged, supported, core promises in 3 major versions (18 months)? That seems a little too far down the road",
                            "createdAt": "2016-02-02T19:02:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jonathanong",
                                "__typename": "User"
                            },
                            "bodyText": "is require('lib/internal/promises').Promise going to be a public API? if the user could set the current promise implementation, they (and module developers) should be able to get it too. i'm hoping that libraries like any-promise will be replaced by this.\nso... const Promise = process.getPromiseImplementation()?",
                            "createdAt": "2016-02-02T19:04:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Rather that hypothesize about which version it will come out from under a flag maybe we can just list the issues that need to be resolved prior to it coming out behind a flag (AsyncWrap support, works with domains, etc).",
                            "createdAt": "2016-02-02T19:05:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Flagged and unsupported in v6, unflagged and unsupported in master\nimmediately after cutting v6, supported officially in v8. Which means it\nshould be usable by v7 in October.\nOn Feb 2, 2016 11:02 AM, \"Tristian Flanagan\" notifications@github.com\nwrote:\n\nSo we are talking about adding unflagged, supported, core promise support\nin 3 major versions (18 months)? That seems a little too far down the\nroad\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-02T19:09:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell, @domenic: It's my impression that that timeline lines up nicely with bringing in a V8 release that may support async/await \u2014 is that accurate?",
                            "createdAt": "2016-02-02T19:10:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "That's my understanding as well.\nOn Feb 2, 2016 11:11 AM, \"Chris Dickinson\" notifications@github.com wrote:\n\n@jasnell https://github.com/jasnell: It's my impression that that\ntimeline lines up nicely with bringing in a V8 release that supports\nasync/await \u2014 is that accurate?\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-02T19:14:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal\n\nLooking at the current breaks in domains and our lack of AsyncWrap, I see these as reasons to add these APIs, not as arguments against. Landing broader support for Promises should increase the opportunity for Promise users to solve these problems in Node.js and land patches for support.\n\nThen you're clearly missing the point that this is an issue that must be solved first in v8. That is a blocker. If v8 had proper support, and we could work out how to implement it while under the flag, that's a reasonable argument. But putting a feature behind a flag when a dependency has no roadmap of feature development is not a good way to go.\n\nthat need to be resolved prior to it coming out behind a flag (AsyncWrap support, works with domains, etc).\n\nI want to make perfectly clear, it's not AsyncWrap that needs to support Promises. It's v8 that needs to give us APIs so Promises can work with AsyncWrap. At this moment we are not capable of fixing the problem. Unless we write the v8 patch, that is.\n@chrisdickinson\n\nIn your example, per bluebird's existing semantics: the promise generated by fs.readFile will be bound to the domain. It, and any then clause it generates, will be bound to the domain.\n\nAnd this is the behavior that it should exhibit. The point I'm making is that v8 doesn't offer the API to allow state propagation with the Promise instance. We can't even be notified when a Promise executor runs.\n@jasnell\n\nGetting something in as experimental is good, having it be a first class supported feature is extremely premature.\n\nExcept that the majority here have seemingly decided that Promises must be a \"first class citizen\". Thus must be fully integrated with the existing API. A feature as experimental as this, lacking even necessary dependency API support, should exist in another branch. At the minimum in a separate set of files that don't interfere with the current implementation. It's unreasonable that every stack trace has a call to \"promisified\" or whatnot because of an experimental feature.\n\nFlagged and unsupported in v6, unflagged and unsupported in master immediately after cutting v6, supported officially in v8. Which means it should be usable by v7 in October.\n\nThis timeline is dependent on when v8 can land the necessary APIs for us to work with Promises. Giving solid releases is pointless right now.",
                            "createdAt": "2016-02-02T20:18:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Going back to the net.Server#listen() example, I completely phased out that it's an Event Emitter. Which means the appropriate check would be:\nconst server = net.createServer().listen(port);\n\nserver.on('error', function() {\n  // check if listen() succeeded\n});\nSo I'll assume that listen() wouldn't in fact return a Promise, or is the proposal to also overwrite Event Emitter events as well?",
                            "createdAt": "2016-02-02T20:21:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I think the lack of support for promises in AsyncWrap due to V8 needing to give you an API/you needing to contribute an API to V8 is a reason to not ship AsyncWrap until that's ready. But I don't think it has any bearing on this PR.\nPromises are an official part of the language, used widely in the ecosystem, which AsyncWrap currently does not support; AsyncWrap is not shippable until that gets fixed. Exposing them in core APIs doesn't change the equation at all.",
                            "createdAt": "2016-02-02T20:24:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris\n\nthis is an issue that must be solved first in v8. That is a blocker. If v8 had proper support, and we could work out how to implement it while under the flag, that's a reasonable argument. But putting a feature behind a flag when a dependency has no roadmap of feature development is not a good way to go.\n\nV8 is an open source project. People from Node.js land patches in V8 from time to time. I don't think that V8 would not allow a change to land that wasn't on their roadmap if it improved support for something in Node.js.\nGetting this in Node.js, even if it is behind a flag, will encourage Node.js Promise users to increase their involvement and maybe even land something in V8, or yell at Google enough to implement it.\nThis continues to be treated as a zero sum game, where either existing Node.js or V8 committers are burdened in some way, rather than another example of somewhere that we can increase the contribution base and enable the people who are not yet contributing that are passionate about these features to fix and maintain them themselves.",
                            "createdAt": "2016-02-02T20:27:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris, @domenic:\nSupporting AsyncWrap and domains is possible with the resources we have on hand. It is not an ideal solution, but it works, and puts pressure on the appropriate teams to provide the desired APIs (in a, \"Hey! Promises are slower than they need to be in Node because we need these APIs!\" fashion.)\n@trevnorris:\nThis PR is scoped only to single async operations. Events and streams are a separate discussion for a different PR and time.",
                            "createdAt": "2016-02-02T20:28:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris:\n\nIt's unreasonable that every stack trace has a call to \"promisified\" or whatnot because of an experimental feature.\n\nThat was a concern that was echoed above, I believe \u2014 as a result, we moved away from the \"return a promise on no callback\" approach, and towards a \"fs.readFileAsync\" approach. The promise APIs depend on the callback APIs, the callback APIs are agnostic of the promise APIs \u2014 callback users pay no tax, so to speak, for the promise APIs.",
                            "createdAt": "2016-02-02T20:30:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic\n\nI think the lack of support for promises in AsyncWrap due to V8 needing to give you an API/you needing to contribute an API to V8 is a reason to not ship AsyncWrap until that's ready.\n\nIt's not our fault that the language authors had so little insight as to think they could create a black box and that no embedder would ever need access to its internals. That's like saying you'll write the implementation for ES6 modules and we just have to deal with it. Instead of how ES6 modules are currently being discussed by having the necessary hooks and depending on the embedders to properly implement it.",
                            "createdAt": "2016-02-02T20:35:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris: While I appreciate your frustration, that is off-topic and not appropriate for this PR. Please moderate that comment.",
                            "createdAt": "2016-02-02T20:37:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson My comment was an appropriate response to the proposed solution of removing AsyncWrap. By pointing out that it was fundamentally flawed.",
                            "createdAt": "2016-02-02T20:39:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Nobody suggested removing async wrap. Just delaying shipping it until it can cope with one of the more popular async things that people writing Node.js want to wrap.",
                            "createdAt": "2016-02-02T20:41:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Nobody suggested removing async wrap. Just delaying shipping it until it can cope with one of the more popular async things that people writing Node.js want to wrap.\n\nThis isn't that widely understood outside the CTC but AsyncWrap is already marked as experimental and is being worked on as a spec in node-eps prior to the next iteration that may make it non-experimental.",
                            "createdAt": "2016-02-02T20:45:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "techjeffharris",
                                "__typename": "User"
                            },
                            "bodyText": "@techjeffharris:\n\nI am hugely against promises whatsoever. However could the promisification be an explicit opt-in process.promisify(true) // conditional export in libs instead of affecting any function there is?\n\n\n@chrisdickinson:\nYou may have already come to this conclusion, but this comment was made by @eljefedelrodeodeljefe.\nI haven't used promises enough (or at all, for sake of conversation) to have any opinion other than \"I don't use these yet because they're different from what I'm used to and I've heard that native v8 promises are slower than userland implementation.\"",
                            "createdAt": "2016-02-02T20:45:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@techjeffharris: Oh geez, I'm sorry about that! It won't happen again.",
                            "createdAt": "2016-02-02T20:48:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic, @trevnorris: I've added a commit that begins to make promises work with domains + async_wrap. It's a shim (and hopefully not a long-lived one) to remove the blocker of making promises work as expected. This solution should be regarded as a temporary bridge: once we have the necessary APIs we need from V8, we can get rid of it. With that in mind: are there places where the abstraction leaks through?",
                            "createdAt": "2016-02-02T21:00:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson well, async functions for example will not use your shim (they don't read global.Promise). And any native modules that use the V8 API will produce native promises, not yours.\nAnd you broke a bunch of minor stuff like the property descriptors for all the methods... you made global.Promise callable (seems quite bad)... changes toString() output of course... from code inspection at least, (new global.Promise()).prototype is not equal to global.Promise.prototype due to the return override (also pretty bad)...\nI would rather defer this kind of patching until asyncwrap is ready to ship; hopefully as part of doing that, the async wrap authors can work on a more principled solution involving a patch to V8 or similar.\nIf you're just going to overwrite the global promise, it seems better to overwrite it with something fast like Bluebird than this kind of thing.",
                            "createdAt": "2016-02-02T21:05:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "There's absolutely nothing that says that both AsyncWrap and Promises have to coexist peacefully together while both are marked as experimental and neither negatively impacts the stuff that's currently supported. Both can be active experiments in the code even if they don't play nice currently or there are bits that still need working out. This either or kind of thinking and the back and forth around it is not actually that helpful.",
                            "createdAt": "2016-02-02T21:13:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic:\n\nI would rather defer this until asyncwrap is ready to ship; hopefully as part of doing that, the async wrap authors can work on a more principled solution involving a patch to V8 or similar.\n\nI believe a patch has already been submitted, but my impression is that there hasn't been any movement on it. This shim does fix existing promise <-> domain interaction in userland, though, so it may be best to consider landing it until such time as the V8 patch gets in.",
                            "createdAt": "2016-02-02T21:14:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell: True, domain interaction is probably the more immediate blocker, even if domains are deprecated. I would like to avoid blocking async_wrap work from progressing with this PR, and if we can solve both of those with a shim for the time being while the V8-level work progresses, that seems like an OK solution.",
                            "createdAt": "2016-02-02T21:16:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Again, if you are going to overwrite global.Promise, with all the problems that entails (as described in my post), I'd rather it be worth it. Just bring in Bluebird, strip out the sugar methods, and give everyone a speed boost.",
                            "createdAt": "2016-02-02T21:16:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I believe a patch has already been submitted, but my impression is that there hasn't been any movement on it.\n\nIf that's the case, we can poke the V8 team, and just float the patch in the meantime.",
                            "createdAt": "2016-02-02T21:17:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "True, domain interaction is probably the more immediate blocker, even if domains are deprecated. I would like to avoid blocking async_wrap work from progressing with this PR\n\nI don't understand this. Both domains and async wrap already fail to work with promises. Solving that seems like a separate thread, and off topic for this one.",
                            "createdAt": "2016-02-02T21:19:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "BTW it's not 100% clear how this stuff should work with promises. At what point do we capture context (domain, zone, etc)? There are 2 possibilities:\n\nwhen promise is created;\nwhen then is called.\n\n1 is how pure js implementations work. 2 make more sense though, especially if you consider async await.",
                            "createdAt": "2016-02-02T21:23:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin: I'd expect it to work like the existing pure JS promise implementations \u2014 introducing a different system would require users to identify the source of their promises in order to take into account their domain interaction, which may prove difficult/confusing.",
                            "createdAt": "2016-02-02T21:26:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson true, but I'm pretty sure that promise implementors didn't really think of this. (Also I doubt that someone uses promises with domains, since they call all errors anyway).\n2 is more less what's proposed by angular people: https://gist.github.com/mhevery/63fdcdf7c65886051d55\nThis makes since for async await:\nasync main() {\n  const z1 = Zone.current();\n  await getSomePromise();\n  const z2 = Zone.current();\n}\nYou'd expect that z1 === z2, but it depends on whether it was created just now or earlier.",
                            "createdAt": "2016-02-02T21:33:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "I feel like this PR should be making no effort to try and hackily half support async_wrap, given that it too is an experimental feature and no one really even uses it yet. As for the domains side of the equation: they are already deprecated, kind of broken, and can do horrible things to process state--leaving promises alone and letting them trigger unhandledRejection events as usual doesn't really seem all that much worse to me.\nDon't get me wrong, living in a magical future where everything Just Works\u2122 would be great. I don't want to wait for all the planets to align in just the configuration for that to occur though.",
                            "createdAt": "2016-02-02T21:33:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin:\n\n@chrisdickinson true, but I'm pretty sure that promise implementors didn't really think of this. (Also I doubt that someone uses promises with domains, since they call all errors anyway).\n\nBecause we use restify and bluebird, we use domains with promises in production. Granted, the likelihood of someone using native Promises alongside domains is much lower, but anecdotally the pattern exists in userland.",
                            "createdAt": "2016-02-02T21:36:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "In TC39 for the zones proposal you definitely capture the context at .then() time. You can use a given promise in multiple zones, calling .then() in each of them. I would expect the same thing here.",
                            "createdAt": "2016-02-02T21:36:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "(Also I doubt that someone uses promises with domains, since they call all errors anyway)\n\nA lot of people are using domains as async version of ThreadLocals, so for instance bluebird supports domains for this reason.",
                            "createdAt": "2016-02-02T21:38:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin, @domenic:\nMy impression is that the ship has sailed for defining promise to domain interaction, but this shouldn't affect promise to zone interaction. As @petkaantonov notes, userland already seems to have an answer for how promises interact with domains, and we should match the expectations already set there. Zones can work differently, and that's okay \u2014 domains are deprecated in any case, so there shouldn't be any confusion about which to use going forward.",
                            "createdAt": "2016-02-02T21:41:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov so, do you capture domain on then explicitly?",
                            "createdAt": "2016-02-02T21:41:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Yep, we really go the extra mile",
                            "createdAt": "2016-02-02T21:42:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Could you take a look at lib/internal/promise.js and lib/domain.js and give me your impressions? Does this match up with what bluebird does, roughly?",
                            "createdAt": "2016-02-02T21:43:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov cool. As far as i remember https://github.com/othiym23/node-continuation-local-storage patches then, so should work the same",
                            "createdAt": "2016-02-02T21:44:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\nIn bluebird there is one central location through which all method calls go through (_then). _then simply just binds all the passed handlers (success and fail) to the currently active domain I.E. basically success = process.domain.bind(success) etc.\nSo it's somewhat different from what is in lib/internal/promise.js. If you don't patch .catch as well, I don't see how it will work with catch? Also, shouldn't the domain just be whatever is the process's currently active domain, rather than storing domain in promise?,",
                            "createdAt": "2016-02-02T21:54:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov OK, cool \u2014 I'll ditch passing promise.domain as a baton and add .catch.",
                            "createdAt": "2016-02-02T21:59:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": ".catch just calls this.then(undefined, onRejected) so you should get it for free.\nI maintain this is not a good idea.",
                            "createdAt": "2016-02-02T22:01:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Also a gotcha you should watch out for: because success and fail can be any type, not just functions, and because domain.bind doesn't check for types, you will get really weird errors in strangest places if you do process.domain.bind(nonFunction).",
                            "createdAt": "2016-02-02T22:01:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hayes",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson not sure if this makes sense at all for domains, but async-listener and newrelic, (and I guess cls would work this way too). The state gets propagated from promise resolution to the callback, rather than from promise creation to the callback.\n// state/domain a\nnew Promise(resolve => thing.on('foo', () => {\n  // state/domain b\n  resolve()\n}).then(() => {\n  // async-listener polyfill would set state/domain to b\n  // I believe the current implementation would set state/domain to a\n})",
                            "createdAt": "2016-02-02T23:04:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "OK, here's the plan of record at this point:\n\nMake sure domains work. Giving @petkaantonov's recent feedback, we may be able to get away with patching .then for the time being, which means we don't have to monkeypatch Promise. This solution can fall away when the microtask queue API work completes.\nBoth this PR as well as the AsyncWrap feature depend on getting the microtask queue API issue figured out. That issue does not block releasing either of them as flagged or unsupported features; this is a case where \"perfect\" is the enemy of \"better.\" Moving forward with these features increases pressure on the microtask queue API issue, which means it'll get attention sooner, which is what everyone wants.\nFlagging. If this API ships in v6, it will ship behind a flag of some sort, becoming unflagged (but unsupported) in v7, to become supported and eligible in v8. That means that users that want it can get to it quickly, while folks who are waiting for async/await to land will likely be able to use it in v7. Official support is a ways off, but this gives us a nice opportunity to knock the kinks out of the API in the meantime.\n\nThis is a rough plan, and is not a guarantee.\nIf you want to see promises land, please consider pitching in on this issue.\nThe primary blocker seems to be the microtask queue callback API, and I'm not sure who (if anyone) is working on that right now.\n\n\nNaming. *Async runs into problems with bluebird's promisifyAll, and isn't super comfortable when requiring the module. Returning a promise when no callback is given, or otherwise switching on a sentinel value means that callback users would pay a (very slight) for an API they don't use, which isn't acceptable, and worse, makes return types variable, which is dangerous and could break backwards compatibility.\n\nThe front-running solution is that the canonical location of promise-returning APIs is namespaced under the callback variant. E.g., fs.readFile.promise.\nWe can make requiring these modules more ergonomic by providing a module-level shortcut: require('fs').promise().\n\nThis would iterate the exports of the module, a la [exports[k].promise || exports[k] for k in exports].\nThis purely exists for ease-of-require \u2014 const {readFile} = require('fs').promise().\nThis says nothing about the future existence of a module, especially a ES2015 module. The discussion is left open for us to revisit at a later time, in a separate issue. Again, \"better\" > \"perfect\", and there's a lot of potential for disagreement with regards to modules.\n\n\n\n\n\nI want to thank you all again for participating and keeping this conversation calm and productive!",
                            "createdAt": "2016-02-02T23:06:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "This seems reasonable, assuming (1) works out.\nOn (3), I don't think the flag is necessary; as you said upthread there has already been a lot of experimentation already. But whatever.\nOn (4), I think it is weird to use the noun \"promise\" as a property when the value is not a promise; it is weird to use the verb \"promise\" too, for the method. (Although, why is it a method? A symmetric property seems better.) \"promised\" (or maybe \"promisified\") would make more sense. The require(\"fs\").promised (assuming better name and property not method) idea is pretty reasonable for now, and I appreciate you keeping things open for require(\"fs/2\") in the future.",
                            "createdAt": "2016-02-02T23:13:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Flagging. If this API ships in v6, it will ship behind a flag of some sort, becoming unflagged (but unsupported) in v7, to become supported and eligible in v8. That means that users that want it can get to it quickly, while folks who are waiting for async/await to land will likely be able to use it in v7. Official support is a ways off, but this gives us a nice opportunity to knock the kinks out of the API in the meantime.\n\nThis may be a reasonable timeline but I worry about this kind of planning on a per version basis.\nWe have a release train. The definitions for when things ship is defined by what makes it into the tree on time to ship in the train.\nCan we define, instead, the requirements for this coming out from the behind the flag? When that work is complete it will ship. What version that is will be entirely based on when the work is completed, reviewed, and committed to master. If the LTS WG wants to backport that it's up to them (although I highly doubt it).",
                            "createdAt": "2016-02-02T23:24:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal ... I think the intention on the versions is more to give a rough\nrealistic idea, not to set anything in stone. I would hope this could get\ndone and stable sooner, I just don't want to set unrealistic expectations\nof support tho.\nOn Feb 2, 2016 3:24 PM, \"Mikeal Rogers\" notifications@github.com wrote:\n\nFlagging. If this API ships in v6, it will ship behind a flag of some\nsort, becoming unflagged (but unsupported) in v7, to become supported and\neligible in v8. That means that users that want it can get to it quickly,\nwhile folks who are waiting for async/await to land will likely be able to\nuse it in v7. Official support is a ways off, but this gives us a nice\nopportunity to knock the kinks out of the API in the meantime.\nThis may be a reasonable timeline but I worry about this kind of planning\non a per version basis.\nWe have a release train. The definitions for when things ship is defined\nby what makes it into the tree on time to ship in the train.\nCan we define, instead, the requirements for this coming out from the\nbehind the flag? When that work is complete it will ship. What version that\nis will be entirely based on when the work is completed, reviewed, and\ncommitted to master. If the LTS WG wants to backport that it's up to them\n(although I highly doubt it).\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-02T23:27:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell I get that, but for the purposes of encouraging those contributions, it would be good to lay out the blockers people can work to resolve rather than place it on a \"roadmap\" because potential contributors will assume that work will be done by someone else and it landing is a foregone conclusion.",
                            "createdAt": "2016-02-02T23:32:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell, @mikeal: Good point, I'll update my tracking issue with what needs to be done technically in just a second.",
                            "createdAt": "2016-02-02T23:35:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "yoshuawuyts",
                                "__typename": "User"
                            },
                            "bodyText": "Though I do not doubt intentions, I feel that the core premise of this thread\nis misguided. Adding ~100 methods to Node core's API should be unacceptable,\nand addition of new API's that provide the same functionality without\ndeprecating an equal amount first will unnecessarily lead to a maintenance\nnightmare. Ideally we'd be in a state where every line in core is understood by\nthe maintainers, and every API exposed is understood by its users. This PR\nmoves in the opposite direction.\nIn earlier discussions @mikeal talked about exposing a minimal API on top of\nwhich any flavor of API can be built. In my limited knowledge I would expect\nthat between a sync call and async bytereader most other interfaces could be\ncreated. Node's core should be minimal, where providing a convenient user\nexperience is a different concern.\nThese comments are made with the streams api's in mind, which have slowly\ndevolved into an unmaintainable mess that is inherently flawed, but cannot be\nfixed lest we break Node's promise of stability. These comments are made with\nObject.observe\nin mind, which was specced to solve all data flow issues, but turned out to be\na broken model. Thinking that Promises are somehow different and will fix all\nasync woes would be naive.\nI don't see a problem in liking different thing, I do see a problem with adding\na new mode of API's to core whenever something in userland becomes popular.\nInstead of creating a larger core, I'd prefer we work towards finding the\nsmallest common ground to create the distinct API's we prefer, and a method of\ndistributing these API's so that everyone can get an interface they like and\nsuits their needs.",
                            "createdAt": "2016-02-02T23:39:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "I don't see a problem in liking different thing, I do see a problem with adding\na new mode of API's to core whenever something in userland becomes popular.\nInstead of creating a larger core, I'd prefer we work towards finding the\nsmallest common ground to create the distinct API's we prefer, and a method of\ndistributing these API's so that everyone can get an interface they like and\nsuits their needs.\n\nWhile I find this argument compelling from a personal point of view it doesn't match the objective reality we're now in.\n\nPromises were in user-land, that changed when they landed in V8. Whether we like it or not that means they are part of the base platform we ship.\nUnderstanding the previous point we've been adding APIs to Node.js already that improve the experience of using those native Promises. APIs specific to Node.js, not just things we inherit from V8, are there for native Promise users today and they are actually informing future browser APIs that do similar things.\nIt is not unreasonable to think that expanding Core's API to return these native Promises, that are already part of the platform we ship, will provide us more opportunities to improve that experience for those users in a way that user-land Promises cannot.",
                            "createdAt": "2016-02-02T23:45:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "brianleroux",
                                "__typename": "User"
                            },
                            "bodyText": "this is awesome! thx @chrisdickinson for owning such a heated topic with code instead of commentary.\n@yoshuawuyts I am not a fan of promises however I am very happy to see support land for the audience that appreciates them. this gives all of us a path out of userland conflicts and polyfills which are a huge nightmare, yes today, for library maintainers and consumers alike. since it is opt-in everyone gets the api they are comfortable with.",
                            "createdAt": "2016-02-02T23:49:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "require(\"fs\").promised\n\nWhat about require(\"fs/promised\") instead? I know we've talked about \"fs/2\" but that has a bit more finality to it than people seem comfortable with.",
                            "createdAt": "2016-02-02T23:50:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "BTW, the error users get when attempting require(\"fs/promised\") on older versions of Node.js is much more obvious that the eventual property error they get using const fs = require(\"fs\").promised.",
                            "createdAt": "2016-02-02T23:55:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@yoshuawuyts:\n\nThough I do not doubt intentions, I feel that the core premise of this thread\nis misguided. Adding ~100 methods to Node core's API should be unacceptable,\nand addition of new API's that provide the same functionality without\ndeprecating an equal amount first will unnecessarily lead to a maintenance\nnightmare. Ideally we'd be in a state where every line in core is understood by\nthe maintainers, and every API exposed is understood by its users. This PR\nmoves in the opposite direction.\n\nI appreciate your concerns about maintainability \u2014 as part of the Streams WG I can definitely commiserate with the difficulty of maintaining complex, interconnected APIs. One of the primary goals of this PR is to make sure that Node is well-positioned to take advantages of upcoming new syntax in a maintainable, low-touch fashion. To that end, wherever possible, the promise-returning APIs are a layer based on top of the callback-accepting API. Pulling this into a single layer dependent on the existing API means that changes to the callback layer will automatically be reflected in the promise layer, in a deterministic fashion applied to the callback API as a whole. In other words, while at first glance this change seems like a massive increase in surface area, the maintenance surface area is much smaller.\nFWIW, I am optimistic about streams \u2014 the problem there is that there's deep interconnection and an unclear separation of layers, but I think a descriptive spec / more exhaustive documentation of the current workings will make it possible to improve that situation.\n@mikeal:\nWith regards to modules, I'm hoping to leave the door open for a future discussion on that so we can avoid pinning progress on exposing an API to agreement on modules: naming, how to expose a submodule, whether to expose a submodule to both require and ES2015 modules or just one or the other \u2014 there are a lot of valid concerns there, and it might be hard to build consensus around at the outset. Leaving the door open now gives us a solid foundation to build upon as the dust settles on the module conversation.",
                            "createdAt": "2016-02-02T23:58:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "As an update, as of this commit we're no longer monkeypatching Promise entirely, just Promise.prototype.then \u2014 and it appears to work with the test that @trevnorris provided.",
                            "createdAt": "2016-02-03T00:04:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "DonutEspresso",
                                "__typename": "User"
                            },
                            "bodyText": "I am generally \ud83d\udc4e on this without a more detailed discussion around the why. The benefits are not particularly clear to me, and I would have really liked to see a deep dive in an EP. My concerns are less about the technical aspects of this PR as they are about future implications of such a change.\nMy chief concern is that callbacks and Promises are fundamentally different in terms of how they behave. I think we are massively underestimating the confusion that will inevitably arise from exposing the same API via two different interfaces, especially given that each interface now has its own async error handling semantics. IMHO, core's mission is to provide a small set of stable and consistent APIs that satisfy the lowest common denominator. Adding Promises to the story unnecessarily complicates this mission without a clear value add.\nThe two main arguments I'm seeing are:\n\nUnify the promisified set of core modules\n\nI think this is a great idea, but I don't think core needs to be involved at all. There's no reason a dedicated WG couldn't get together today and put together the definitive set of promisified core modules. There is no immediate value in getting this into core short of declaring a winner. Plenty of \"winners\" have surfaced to the top in userland without core's help.\n\nPromises are supported natively now, so core should support it to reduce friction\n\nIf we take this a step further, and Observables eventually make it into the spec, does that mean we now have to add another set of interfaces that expose Observables? Observables have their own error handling semantics as well (though IIRC they are closer to callbacks in terms of how they handle programmer errors). Where does it stop? Like Promises, Observables are higher level abstractions that can be easily built on top of callbacks. If the surface area of core stays small, userland can easily adapt them to any future abstractions down the road.\nJust my 2c.",
                            "createdAt": "2016-02-03T00:52:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zebateira",
                                "__typename": "User"
                            },
                            "bodyText": "@DonutEspresso Hypothetically, if Promise adoption in userland becomes the most popular approach to async flows, so that the core's API is used by a very small portion of userland, would it still be okay to maintain the core's API as it is,  without giving support to the most required/wanted interface?",
                            "createdAt": "2016-02-03T01:11:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@DonutEspresso:\nHi, thanks for taking the time to weigh in. We've touched on some reasons to add this to core, but GitHub has started clipping the thread down. If you've already read those, I apologize for re-linking them.\n\nMy chief concern is that callbacks and Promises are fundamentally different in terms of how they behave. I think we are massively underestimating the confusion that will inevitably arise from exposing the same API via two different interfaces\n\nOne of the driving factors behind this PR is that async/await is coming down the pipe, and not having an answer in core for how to use that language-level feature seems like it would be very confusing for newcomers.\nThis is an important distinction between Promise support and, e.g., Observable support: promises are starting to be exposed directly by syntax-level constructs, vs. plain user-accessible objects. This means that native Promises will become more of a forced issue than they have been previously. As @domenic noted, await value will coerce non-promises to the native promise type, which means that Promise is part of the core platform. I hesitate to mention it, but they also peak through the modules spec. As time goes on, the language itself requires that we consider promise support.\nRight now our promise support is buggy: it interacts poorly with existing and upcoming APIs. Exposing a promise-returning API aligns with our goal of providing a modern, stable JavaScript platform: by supporting a native promise version of the API, we are bound to make sure that a key part of the platform we expose works as expected, with the benefit of also making life easier for folks who prefer that flavor of JS. This implementation aims to make the support surface area of that API as small as possible in the process, by including the callback API in the promise path, and making sure that the promise transformation of callback APIs is as regular as possible \u2014 this means that changing the callback API changes the promise API, and that tests for one reinforce tests for the other.\nAgain, this isn't about replacing the callback API \u2014 even absent our user's preferences, there is an absolutely enormous amount of value in the code that's been written against it since 2009. It's as valid an approach to async programming as promises are, and will continue to be long into the future. By making the promise API dependent on the callback API, we've reinforced the assertion that callbacks are a solid practice, while making sure that we interoperate well with upcoming language features.",
                            "createdAt": "2016-02-03T01:23:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danbucholtz",
                                "__typename": "User"
                            },
                            "bodyText": "Hi - first of all, great work!  It is much appreciated!\nI agree with @domenic that this should exclusively use native/core promises. If someone wants to use a different implementation, then they can hijack global.Promise.\nI also agree that rather than throwing directly in the error case, it should be a rejected promise.",
                            "createdAt": "2016-02-03T03:35:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@danbucholtz: Hi! Thanks, and thanks for participating! You'll be pleased to know that that's the current direction we're heading as of this afternoon \u2014 I'm working on a way to avoid patching Promises at all right now (currently there's a need because of a bad interaction between Promises and domains), but the setPromiseImplementation bits have been discarded entirely. Additionally, the promise-based APIs all reject instead of throw now.",
                            "createdAt": "2016-02-03T05:28:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not even seeing why landing this behind a flag would be a good idea. To best experiment with this, how about we make a new npm package, that exposes the API being suggested and refined here and encourage people to use that to try it out and provide feedback. It could even be maintained under the nodejs org to give it an air of an official experimental API.\nThere are many of us who work really hard to keep core small, and even reduce its surface area where possible, because we're convinced of the benefits of having a small core and the harm in an expansive standard library. This is a massive expansion in that surface area in a way that can be achieved perfectly well in userland and I'm still not seeing a good case for core needing to jump on this in such a big way right now. Do it in userland, prove its utility beyond simply making it easier for people who want to use promises (because that argument can be made, and is regularly being made, for the inclusion of so many things), then core can pave the cowpath if one emerges. Even the argument that it will make language features that rely on Promises easier to use in Node isn't convincing because that can still be achieved in userland. Plus, we don't even have those language features or the ability to experiment with how any changes we make in core will be impacted by them. Core should be an enabler of the ecosystem rather than the leader. So far, there's nothing particularly enabling about this that can't be achieved by other means.\nAlso, let's not get too far ahead of ourselves with talk of roadmaps or timeframes. There's a lot of positivity in here which is great but there are also lots of people who are mostly staying out until the dust settles (to avoid spoiling the party, like I guess I'm doing) and even some who are dismayed that this is even being considered by core. I suspect there's a lot of convincing yet to be done before this can make progress beyond a PR. We're consensus seeking around here and that means it's going to take a whole lot of work because we well know how divided Node users are regarding Promises.",
                            "createdAt": "2016-02-03T10:15:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg: Thanks for replying \u2014 no need to worry about spoiling the party, I'm happy to discuss your concerns! Sorry in advance for the long response.\n\nI'm not even seeing why landing this behind a flag would be a good idea. To best experiment with this, how about we make a new npm package, that exposes the API being suggested and refined here and encourage people to use that to try it out and provide feedback. It could even be maintained under the nodejs org to give it an air of an official experimental API.\n\nThe constituent bits of this PR have been proven out in the ecosystem already \u2014 promisify as an generic approach to wrapping callback-based API's, packages that wrap core modules and expose a promisified version \u2014 the technical underpinnings of how this PR exposes promises are less important than what this PR represents: an attempt to find an optimally palatable way to expose a promise-based API from core. The experiment the flag runs is to determine whether it's something that we can support, that folks want, that doesn't cause issues with the codebase at large in the long run. We can't get those results from a package in userland.\n\nThere are many of us who work really hard to keep core small, and even reduce its surface area where possible, because we're convinced of the benefits of having a small core and the harm in an expansive standard library. This is a massive expansion in that surface area in a way that can be achieved perfectly well in userland and I'm still not seeing a good case for core needing to jump on this in such a big way right now.\n\nThat work is appreciated \u2014 and I agree, keeping core small is desirable. I think promises highlight a disagreement along the metrics of what makes an API small, though: I don't think a straightforward count of functions determines the perceived size of an API, and I don't think it necessarily relates to the surface area exposed to support. Buffer exposes 36 methods for reading and writing integer values, the bulk of which could be done with a single method \u2014 but I would not consider it a large API, because those methods follow a regular pattern and the variants cost relatively little to support compared to the utility they give users. On the other hand, streams expose ~9-11 methods that are common across nearly every API in node \u2014 by function count, it's a relatively small API, but because those methods interact in enormously complicated ways the maintenance burden is exceedingly high. I think defining \"size of API\" by \"function count\" doesn't get to the heart of what we mean when we say \"core should be small\".\nI think \"core should be small\" means that every module and method has to pay its due: the maintenance cost of keeping it in core has to be small relative to the degree it allows Node users to operate effectively. Nearly every Node user needs an HTTP parser. Not every Node user needs an SMTP protocol parser. Some number between the those two need a WebSocket parser. How much does it cost us to maintain an HTTP parser? It's largely a sunk cost, so at this point, not much. How much does it cost us to maintain an SMTP parser? An unknown amount, possibly a great deal. Assuming that the maintenance cost includes the potential downside of time and effort it'll take to fix it if we expose a bad API, it's unlikely that an SMTP parser will make it in \u2014 especially since it's not enabling Node users to do anything particularly new, so we're not adding any value for them. Adding an HTTP2 parser, OTOH, does buy something for our users, in that by maintaining it inside of core we could conceivably make it faster than userland implementations (courtesy the C++ JSStream interface), version it alongside our other dependencies, and provide a common API for our users to build around. Since the problem space is more fleshed out \u2014 we have an existing API to pattern it after, the maintenance cost to us is lower (but still not zero!), and as a result it's a thing we've collectively been considering. It's unclear whether websocket fall into this category or not \u2014 though with semirecent developments with the debugger, bringing an implementation in might buy our users a lot more than it costs us.\n\"Keeping core small\" becomes about value to our users vs. cost to us, then \u2014 if a user can already do something in userland, the value to them is small (modulo performance concerns, having to build C++ deps on windows, etc.) So, back to promises and the PR at hand:\n(Perhaps unsurprisingly!) I think the value of exposing a promise-returning API is high, and the cost to us is low.\nFirst, re: the cost: this PR implements the API with an eye towards regularity \u2014 the promise API is a transformation applied regularly to the callback API, for the most part. This means that when we test the promise API, we're testing the callback API indirectly \u2014 so tests on one reinforce the other; when we change the callback API, the promise API changes in a corresponding fashion \u2014 so changes in one are picked up in the other; and when we change the promise API, the callback API is unaffected \u2014 so if we need to change something about promisification, we can do so without affecting the majority of modules in the ecosystem. This is to say, these concerns are separated, specifically to reduce the cost of maintaining them \u2014 the promise API isn't the Buffer.prototype.unmask to the callback API's Buffer.prototype.indexOf, this is more like the Buffer.prototype.read{U,}Int{8,16,32} pattern of APIs sharing a similar purpose but different return types.\nThis does mean we need to care about how our APIs interact with Promise's, which does cost us time and attention \u2014 however, I agree with the sentiment expressed elsewhere in this thread that the Promise API is a de-facto part of our platform as it stands. As it stands, some of our APIs do not work well with Promises, in buggy and surprising ways. Having used Promises alongside restify (which uses domains) in Node v4, I have lived in this world for about half a year now I will attest that the bugs we expose into userland are hard to diagnose and track down. This is primarily due to a lack of necessary V8 APIs to make the interaction work as expected. However, it appears that the primary time Node puts pressure on the V8 team about this is during PRs proposing bringing promise-backed APIs into core. That pressure tends to be short-lived, though, as the API PR doesn't tend to make it in. Since the breakage is constrained to native promises, interest fizzles out. Meanwhile, native Promises continue to broken with regards to domains (and with regards to the upcoming AsyncWrap API, as we're finding out.) @domenic points out also that async/await will resolve immediate awaited values to native Promises, so this will only become a bigger problem as time goes on.\nBy committing to promises as a return value of our platform, we acknowledge that they are part of the platform, and are subject to the same rubrics of quality as any other part of our platform \u2014 we can come to the V8 team with what we need to make it work, as well as a clear indication their time will be well spent in helping us out on this.\nWhat it buys for users is that the platform has a clear story with regards to the TC39-mandated async primitive. Newcomers can use await out of the box with Node when it lands \u2014 I think this is hugely valuable for newcomers. It buys our users the chance to deal with fewer bugs because the Promise implementation switched out on them mid-chain. It buys them an assurance Promises are part of the platform, and that core is dedicated to making sure they work with our APIs. It grows our potential contributor base to include Promise users by implicitly stating that they're welcome here. Core stating that the preference between callback and promise is really not that big of a deal, may even help to start smoothing that lilliputian rift in our community. This is some of the value that the existing ecosystem solutions can't offer, that we can.\n... And with that, I'm off to bed. Looking forward to your response!",
                            "createdAt": "2016-02-03T11:58:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "Following up on @trevnorris: the problem with any API change in core is to estimate how userland will react/embrace it. As soon as we release this, we are stuck with whatever API we release (even if we have semver, but breaking changes are generally bad). So, I'm definitely \ud83d\udc4d on forming up a core-maintained module to bring promises to node, in an official way. Once that module is ironed out and that API is stable enough, we can move things forward here.\nFrom a consensus seeking perspective, it's hard here. We have worked on top of node for years, and the API had time to be tested and tweaked for production usage. A massive change like this to the API will be problematic.\nI think this module should target far down to 0.10, just to maximize exposure. It will also form a nice ponyfill, so that we can add support for promises to old node versions. People are already using these solutions, what is missing is a story from core point of view.",
                            "createdAt": "2016-02-03T17:26:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pesho",
                                "__typename": "User"
                            },
                            "bodyText": "What about require(\"fs/promised\") instead? I know we've talked about \"fs/2\" but that has a bit more finality to it than people seem comfortable with.\n\nThis would be my preference as well. It's the proposal which violates the KISS principle the least (I took the time to read all of them).\nAlternatively, I suspect it is possible to implement the return-promise-if-callback-omitted variant with true zero overhead in the callback case. That's because the core APIs already check whether the callback is a valid function, and we could reuse the existing checks. This would be much more complicated/intrusive than the current decorator-based approach though, and I don't think it's really worth pursuing.",
                            "createdAt": "2016-02-03T18:06:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina:\n\nFollowing up on @trevnorris: the problem with any API change in core is to estimate how userland will react/embrace it. As soon as we release this, we are stuck with whatever API we release (even if we have semver, but breaking changes are generally bad). So, I'm definitely \ud83d\udc4d on forming up a core-maintained module to bring promises to node, in an official way. Once that module is ironed out and that API is stable enough, we can move things forward here.\n\nAs I noted to @rvagg, I don't think the value of this PR can be captured in userland \u2014 a package doesn't capture the intent to support a promise API like bringing one into core does, and I'm not sure there's much valuable usage information we gain by releasing it as a package. The approach applied here has already been validated by userland, for the most part \u2014 the only particularly novel artifice is where we attach the promise API to the callback API and expose it, and I think we can mutate that for the better over time. That said, while I wouldn't make such a package a blocker for this PR, I would be totally unopposed to someone picking that approach up and trying it out \u2014 if it's not blocking this, it can't hurt!\n@pesho:\nWhile I agree that a module-based approach is probably technically the most comfortable way to access such an API, that takes a lot more consensus-building \u2014 there are a bunch of unanswered questions between here and there. I don't think we have to answer them here. A slightly less-than-perfect API is still a big step forward, and we can always revisit the module conversation after that.",
                            "createdAt": "2016-02-03T19:50:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ktrott",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson:\n\nA slightly less-than-perfect API is still a big step forward, and we can always revisit the module conversation after that.\n\nI have to strongly disagree with this perspective. We should take the time to build consensus and get the APIs right. While APIs aren't forever, they are difficult to change. Backwards compatibility is a consideration for the community, even if the feature is behind a flag. Why a rush to get this in vs. getting it right?",
                            "createdAt": "2016-02-03T20:38:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@ktrott:\n\nI have to strongly disagree with this perspective. We should take the time to build consensus and get the APIs right. While APIs aren't forever, they are difficult to change. Backwards compatibility is a consideration for the community, even if the feature is behind a flag. Why a rush to get this in vs. getting it right?\n\nThanks for voicing your concern! I would not characterize this approach as a rush, but as a scoping-in of concerns. In approaching a promise-based API separately from the question of exposing the API as a dedicated module, this PR aims to reduce the set of decisions on which consensus is necessary. A common problem I've seen with large change proposals is a tendency to predicate the proposal on finding agreement for a lot of constituent decisions. That is, finding the \"perfect\" proposal, vs. finding a workable solution.\nThis has a cost \u2014 progress is blocked on finding consensus across all issues, even if agreement could otherwise be found for a smaller subset. Often, progress is blocked indefinitely. This isn't necessarily a sign that the subset of agreed-upon decisions lead to a bad outcome! This only means that agreement couldn't be found on the additional decisions. This could be due to an earnest disagreement, a lack of data, or any number of other reasons.\nWere we to land a combined fs.readFile.promise + require('fs').promise API, it would not go away if a module-based approach landed. A require('fs/promise') proposal would be a strict addition to this approach, meaning programs that use the proposed API here would not break. Going forward, the module-based approach would exist as a layer re-exporting the require('fs').promise layer, meaning that the additional cost of maintaining the module is low. At that point, we have more data to bring to a require('fs/promise') proposal, in addition to having experience living with an alternate-paradigm API for at least some time. Additionally, this gives other concurrent efforts, like the ES2015 Modules integration effort, time to settle before we make decisions that could be informed by their results. On the other hand, waiting for ES2015 modules to settle before moving forward here doesn't particularly change or inform the decisions we'd have to make to land this as a module.\nBy scoping this PR just to the decisions around whether or not to provide promises and how to join them to the existing API, we set ourselves up to have a more productive conversation about if and how we'd like to go about exposing submodules and versioned modules \u2014 right now we don't have the data necessary to make a case either way for versioned/sub-modules, and there's a lot of points to agree on that depend on that data (what do we put into them? how do we name them? do they create value for our users?)\nThis is not to compare the relative merits of require('fs/promise') to require('fs').promise: I believe that to get to the best API possible, we have to take intermediate steps to solidify agreement and inform future decision making. I strongly believe that this proposal is in alignment with the stated desire to expose a submodule \u2014 I do not think we can get to that outcome in one discussion, though.\nThe hard part is not the implementation, it's the consensus: finding what we agree on in order to make forward progress, while making sure that concerns are addressed and everyone is comfortable with the direction the implementation is going in. Consensus is not iron-clad, it can be dissolved by trying to expand it to include too many decisions at once. We have to be very careful about the issues we want to address if we want to make progress. If we can ship a promises API without a module, that allows us to defer those decisions to another discussion, which makes it more likely to find points of agreement on the issue at hand, which in turn improves the quality of the modules discussion down the line.\nHopefully this addresses your concern, and thanks again for raising it / sorry for the wordy response!",
                            "createdAt": "2016-02-03T22:31:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "The big negative possible outcome that something will be broken and all of us want to avoid it. There two ways to not break things (from my point of view):\n\n\"scoped modules\": fs/2, fs/promised or fs.promised\n*Async-ish naming model\nif-callback-ommited-return-promise approach\n\nThere are no consensus on scoped modules, as far as i can see due to #5046 and nodejs/NG#9 and it seems to long on going discussion.\nAsync-ish approach will introduce a lot of confusion to documentation and naming (because callbacks are async also) to newcomers and a lot of boilerplate/copypaste code for everybody else, its maybe just me, but i personally don't like this approach.\nSo third option is more easy to implement and to agree on implementation but there is a high risk to break something. It's pretty hard to overview all changes and find all caveats in this one pull-request, so if we are going to stick this option, i suggest to bring promises to every module in different pull-requests. It will be easy to cover updating docs, finding edge-cases, errors and discuss issues. Obviously all of these will help to decrease chance/risk to break something.\nAm i missing something and what do you think?",
                            "createdAt": "2016-02-03T23:48:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@iamstarkov require('fs').promise is a separate solution from require('fs/promised'), one which appears to have a minimum of downsides. With regards to splitting the work and going with the \"callback eliding\" route on a per-method basis, that will run into the same problems as the initial implementation here \u2014 namely, some methods have meaningful return values in addition to meaningful callback values; so that ends up necessitating a separate API in order to mitigate breakage \u2014 essentially, we land back at the require('fs').readFile.promise + require('fs').promise approach.",
                            "createdAt": "2016-02-03T23:52:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "You are right, require('fs').promise seems like a best approach. One thing that make it a bit weak though \u2014 once it landed it will impossible to include promises back into fs in next major nodejs version, because a lot of 3rd party node modules will already rely on this notation and it will make them incompatible through different nodejs versions.\nMaybe updating major versions of those userland node modules is a solution",
                            "createdAt": "2016-02-04T00:21:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "Strongly agree with @ktrott on taking the time to get this right.\nI personally don't see the benefit of require('fs').promise. I already use require('fs-promise') which is the same number of characters\nI do think it's valuable for Node to return a Promise when async work is being done, as opposed to undefined.\nLet's forget that we've been writing Node for years. If I do this:\n\n\u2026it seems to me that the function is synchronous. On the other hand, Promise is already in V8. Any new Web API will return Promise. This is what I see with fetch.\n\nFor newcomers in the future, the question will be: why are Node APIs not returning promises? And the only adequate response will be \"because they weren't in the spec when we designed it\".",
                            "createdAt": "2016-02-04T01:15:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "yoshuawuyts",
                                "__typename": "User"
                            },
                            "bodyText": "Something to me has felt off about the argumentation in this thread. Here's an\nattempt to enumerate the arguments that have been made in favor of Promises,\nand the concerns that I have with them.\nPromises are inevitable, they're part of the language now\nAs a language feature Promises are fully supported in Node; work has been done\nto support unhandled rejections amongst others. As a language feature they're\nperfectly usable right now. However, this does not automatically mean we should\nexpand the API surface to provide syntactical sugar. Sugar belongs in userland,\nnot core.\nPromises make the Node API more friendly for beginners\nGood API documentation makes Node friendly for beginners. Having a small API\nsurface is friendly for beginners. Promises are a superset of callbacks, and\njust a different flavor of async; I don't see how adding a hundred-so methods\nto the API makes things less confusing for newcomers. Also: the assumption that\nbeginners will either flock towards Promises or have strong opinions on\nPromises vs Callbacks shouldn't be made.\nEither style of async has its supporters, and its complexities. Exposing a\nsingle form of async API's will inherently be less confusing than exposing\nmultiple types, and thus easiest for beginners. If we want to create a better\nexperience for newcomers we should think of ways to document and trim the API\nfurther, not expand it.\nPromises have been proven in userland, and should be part of core\nThe smaller the core, the better. If success in userland is a metric for\nexpanding core, the async package should be amongst the first to be pulled\nin. But it hasn't, because it doesn't belong in a minimal core. Same goes for\nrimraf, mkdirp, readdirp, etc. which are more relied upon than promises\nare. If you feel npm isn't a good enough method of distribution for these\nstaple packages, then npm should be improved. Minimalism is achieved when\nthere is nothing left to take away, not when there's nothing left to add.\nPromises need to land before async / await is implemented\nI feel this contradicts the argument that Node should only adopt things that\nhave been proven. At best Promises have shown adoption in userland, and even\nthough I understand excitement, async / await should be left out of this\ndiscussion until it actually lands and shows adoptation. In the past core\ndidn't quickly jump the gun for generator function and class, and in\nhindsight that was a good thing - async / await shouldn't be treated any\ndifferently.\n\nFinally I would like to add that I have concerns regarding performance if\nPromises are included in Node. Node core has a reputation for being fast, and I\nthink it's beneficial to keep it that way. So far I feel this issue has been\nsidestepped, analyzing perf deltas is not something that should be neglected\neven if it doesn't affect existing API's.\nThanks! \u2728",
                            "createdAt": "2016-02-04T01:31:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "DavidTPate",
                                "__typename": "User"
                            },
                            "bodyText": "For newcomers in the future, the question will be: why are Node APIs not returning promises? And the only adequate response will be \"because they weren't in the spec when we designed it\".\n\nAgreed but that's not a compelling enough reason to justify this change. Not sure if you had a chance to review @chrisdickinson's updated notes in the PR but there's a handful of interfaces that I definitely didn't know about which make this difficult (take a look at his summary if you haven't had a chance).\n@jasnell for example pointed out how child.send(...) returns a boolean which can be significant, I personally was under the incorrect impression that the APIs that utilized callbacks did everything through the callback (therefore always returning undefined) but I was clearly incorrect after further investigation of the docs.\nAs a daily user of Node.js, core support for Promises within the APIs would really simplify my life for a few reasons:\nMore Succinct Code That is Easier to Manage\nFor me the core benefit of supporting Promises is that they make my code even easier to manage in user land. Callback are clunky and in more complex use cases they lead to the dreaded pyramid of doom which I tend to solve by Promisifying the function.\nA good example where Promises made my life significantly easier was with one of my module where I was putting together mixins for fs to support recursive operations and other functionality. I have no doubt that utilizing callbacks and creating a few pyramid of dooms I could have accomplished the same functionality, but Promises allowed me to create a more succinct function which should be less error prone and easier to manage for user land.\nKeeping Interfaces Consistent\nFrequently I'm having to deal with multiple entry points to the same set of code, Promises allow me to do simple memoization by passing around the Promise and being able to better manage concurrency. If for example I am requesting the same resource for a number of incoming requests I could easily use memoization of Promises to provide a consistent interface (through a read-through cache) of getting the resource.\nI have multiple cases for example where I need to go through and retrieve a remote file to serve up to one or more users. To accomplish this I utilize a read-through cache that is done through memory (if available), then redis (if available), and finally the remote file. By utilizing Promises here I'm able to provide a completely consistent interface (a promise, or chain of promises is returned) without having to deal with the pyramid of doom that would need to happen otherwise. I know this use case doesn't apply 100% to Node.js APIs, but it's one of my most used cases.",
                            "createdAt": "2016-02-04T01:52:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "@DavidTPate I've definitely found cases where it makes sense to return something other than a Promise (like a cancelation callback), but it's not the common case. Basically, pretty much everywhere we return undefined, a Promise is more suitable. A notable exception being code that can invoke the callback in the same stack.",
                            "createdAt": "2016-02-04T01:56:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "(It's probably getting old hearing me say this, but!) Thanks all for participating in this discussion \u2014 whether you're for or against this, everyone has been totally great about expressing their concerns in a constructive way.\n@DavidTPate:\nIn the interest of keeping this discussion on topic, would you mind self-moderating out your comments about callbacks? This topic is for discussion around the addition of an API that is a peer to the callback API, not one that is going to replace it \u2014 and comparisons like you've posted are unlikely to facilitate that discussion. Thanks!\n@rauchg:\nI understand the desire to present a clean API \u2014 that's why I went with the \"elide callback / get promise\" version at the outset. However, for the purposes of making progress here, cleanliness matters less than safety \u2014 existing working code shouldn't break. There are a few (heavily used!) bits of the Node API that are infeasible to change, given how many folks rely on them (for example, http.request and http.get.) However I'm confident that this solution sets us up to discuss a cleaner approach for accessing promise-returning APIs down the line, without predicating all progress on making those hard decisions at this juncture.\n@yoshuawuyts: Thanks for voicing your concern \u2014 I'm working on a reply, but got pre-empted by the arrival of a burrito \u2014 will reply post-dinner! Sorry for the wait.",
                            "createdAt": "2016-02-04T01:59:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson I understand the idea of trying to go with a safer approach, for which I always advocate as well.\nIn this case, however, trying to preserve maximum safety doesn't seem to give us a tangible advantage over userland modules.\nNowadays, I'm writing code and tests that work just fine with request-promise. I would love to see request return a Promise in the future so I don't have to suffix all my module requirements with -then, -promise, -promised, but other than that it's great.",
                            "createdAt": "2016-02-04T02:14:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tunnckoCore",
                                "__typename": "User"
                            },
                            "bodyText": "Before I start reading...\nI want to point that I dream and realize that before 1 year and half or more - called Hybrids.\nOr just https://github.com/hybridables, using hybridify and hybridify-all you can easy wrap a function or object of functions. Then what? Then you can use when you want callbacks when you want promises, or both in same time. I'm in about to publish update on hybridify and bigger readme.\nI even started a book initially titled \"Javascript Hybrids\" - and no, it's not a thing only for some promises and callbacks - my mind is hybrid and build anything in hybrid way, hybrid meaning \"two ways or more (in same time)\".\nThis \"hybrid\" thing born a huge amount of other libs (that can be found in hybridables, at all) and initially there was 2-3 big libs, than i modularize them in time, so i finallized the smallest part of all before few weeks - relike and relike-all for object.\nAnother lib on upper level is letta - wrapping everything in promise and handles uncaughtException and unhandledRejection process events, that's means you can't crash your app. Plus adds support for passing generator function, so now you can promisify synchronous, asynchronous and generator function.\nAnd it's not \"yet another promisify\" thing. You can pass custom Promise constructor to all of them. And yea, all of them works from 0.10 to latest.\nSo yea, i can't realize why the discussion is so huge, when it is a matter of wrap an object with some promisify library. But will read it.\nCheers,\nCharlike.",
                            "createdAt": "2016-02-04T04:23:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@yoshuawuyts: This is excellent: this highlights a lot of points where we're not quite looking at the arguments being made from the same angle.\n\nAs a language feature Promises are fully supported in Node; work has been done\nto support unhandled rejections amongst others. As a language feature they're\nperfectly usable right now.\n\nUnfortunately, that's not currently the case \u2014 some userland implementations work well, but interoperation between packages can be arduous, and native promises don't work with other features of the platform, like domains (and the upcoming AsyncWrap.) As it becomes easier to (unintentionally) generate and return native promises in the future, this becomes more of a problem. Since promises can cross package boundaries, it can be hard to track down the source of bugs relating to indirectly being handed a (currently broken-with-respect-to-domains) native Promise.\nOutside of whether or not native Promises are usable right now, we agree: \"Promises are an inevitable as they are part of the language now\" has been used as a supporting argument for putting promises in core.\n\nPromises have been proven in userland, and should be part of core\n\nWhile I agree with both clauses here, I don't think there's been a claim of causation. That is to say, promises have been proven in userland. People use them to get their work done, and many like them. There do not appear to be any large fissures in the spec \u2014 it seems stable and interoperable, as long as one remembers to cast to one's preferred primitive at thresholds.\nWhile all of this is true, it's not being used as a direct reason to include them in core. Rather, this claim is used to assuage fears that promises are a flavor-of-the-week distraction, and that supporting them would be an ill-considered move given quickly the JavaScript world appears to move. Promises won't be going anywhere for a while: they've got known semantics, are well specified, and their use in the ecosystem pins the implementation. However, this is not a reason to include them in core, and I've tried to avoid implying that it is a reason to include them. We agree on this.\n\nHowever, this does not automatically mean we should\nexpand the API surface to provide syntactical sugar. Sugar belongs in userland,\nnot core.\nPromises make the Node API more friendly for beginners\n\nI think we may not be seeing eye to eye on this, though: the claim hasn't been made that promises are easier to teach than callbacks. I've been attempting to steer the discussion away from making claims about the relative virtues of callbacks vs. promises. I don't have an opinion about whether one is easier to teach than the other \u2014 I suspect one paradigm might click for some subset of learners, and the other paradigm might click for others.\nThe claim that has been made is that async / await is much anticipated, and that it's going to bring an influx of new folks to the language. If the primary platform for running JavaScript outside of the browser doesn't support the syntax through the API and points folks at some other implementation instead, I believe beginners will run into lots of issues with that. That is a strange divergence for Node, since the platform performs some level of acrobatics to ensure that the JavaScript you write in the browser work in Node \u2014 from setTimeout down to providing our own version of ArrayBuffer in the past.\nWith regards to sugar: I agree that at some point in the past, one could reasonably regard Promises as sugar over the top of callbacks. However, with their inclusion in the spec, and their subsequent appearance as a builtin, they've gone from being sugar to being a first-class container data type.\nOne could imagine a version of Node built on a hypothetical JavaScript-sans-Arrays. In such a world, packages would have to invent array types for themselves. The lingua franca array would be a number-keyed object, and packages would have to downcast their interpretation of arrays down to number-keyed objects at their thresholds. If a package missed doing this, their definition of an array would leak into calling packages. What if contemporary arrays were introduced into this ecosystem? At some level, they're still just sugar for objects-with-numeric-keys; but they'd have the potential to give packages a global interchange datatype for arrays. At the very least users would start passing them between packages. They'd expect native Arrays to work. Eventually there would be pressure on core to adopt the native Array. Would we do it?\nThe result of the above hypothetical is not that arrays replace objects, it's that native Arrays replace ad-hoc definitions of arrays. Native Arrays standardize the interchange format. Similarly, exposing native Promises from core doesn't replace callbacks, it standardizes promises. Only core can do this, because core is the ultimate well from which asynchrony springs.\n\nPromises need to land before async / await is implemented\nI feel this contradicts the argument that Node should only adopt things that\nhave been proven. At best Promises have shown adoption in userland, and even\nthough I understand excitement, async / await should be left out of this\ndiscussion until it actually lands and shows adoptation. In the past core\ndidn't quickly jump the gun for generator functions and classes, and in\nhindsight that was a good thing - async / await shouldn't be treated any\ndifferently.\n\nCore has a track record of attempting to work with new language features \"as expected\" out of the box. From including Symbol.iterator on Buffers in expectation of for...of, or adding a \"magic mode\" to the builtin REPL so that folks downloading Node v4 to test out classes wouldn't immediately get an error \u2014 where possible, core tries to make using new language features feel natural.\nWith regards to jumping the gun: as far as I understand it, core didn't play a part in keeping generators flagged for as long as they were. That was a side effect of the time between V8 upgrades due to the delay between Node v0.10 and io.js v1.0.0. When V8 landed unflagged generators, generators were available (and IIRC, we had Buffer iterator support waiting for them.) Classes landed in a similar fashion.\nDepending on how you're using Node, async/await is anywhere from \"already here-ish,\" to \"nearly imminent,\" to \"coming this year\" \u2014 depending on whether one uses babel, Chakra, or V8. We've got usage that indicates the syntax is workable from the babel side, and we've got usage that indicates promises are workable from the ecosystem side. The only bit that doesn't work as expected out of the box is the Node API, and I think that is something we should avoid if possible.\n\nFinally I would like to add that I have concerns regarding performance if\nPromises are included in Node. Node core has a reputation for being fast, and I\nthink it's beneficial to keep it that way. So far I feel this issue has been\nsidestepped, analyzing perf deltas is not something that should be neglected\neven if it doesn't affect existing API's.\n\nThat's totally fair \u2014 I haven't compared perf runs since the outcome is predictable at present: the promise variant will be slower than the callback variant, because one is written on top of the other. While I wouldn't predicate landing a promise-returning API based on its performance relative to callbacks, it would be nice to be able to provide those results to the V8 team by way of feedback.\n@rauch: I think the benefit of exposing the proposed API is that:\n\nIt standardizes Promises as an interchange format for packages, which only core can do.\nIt preempts or reduces the pain of accidentally receiving a native Promise vs. your expected primitive.\nIt commits core to considering Promises a first-class member of the platform \u2014 as a peer to the callback API.\nBy including a promise-based API, we connect Node's users with the team providing our Promises.\n\nPotentially growing the contributor base,\n... and sending a message to the community at large that core doesn't think callback vs. promise is a big deal: JIFASNIF, and it doesn't matter if you use Promises or callbacks to have that fun.",
                            "createdAt": "2016-02-04T04:27:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\nAren't 1, 2 and 3 solved by V8? In other words, if global.Promise is there, that's all you need in order to standardize on the same primitive.",
                            "createdAt": "2016-02-04T04:34:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@tunnckoCore: Could you self-moderate that comment by removing it or pulling the contents off to a linked gist? It's off-topic: this thread is for the discussion of exposing a native promise API through core. It's not an appropriate place to link a personal project, even if it is interesting. Thank you!",
                            "createdAt": "2016-02-04T04:34:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tunnckoCore",
                                "__typename": "User"
                            },
                            "bodyText": "this thread is for the discussion of exposing a native promise API through core.\n\nI understand that and can be done using some type of \"promisify\" no matter what - you using some custom approach and custom \"callbackify\" and \"promisify\" thing - that's not bad, but believe me i faced tons of problems in the hundreds of use cases which now are passing tests.  And hybrids can help, it's not promotion. They have hundreds of passing tests and use cases and compatibility with other popular modules.\nOther than that. I like the idea for process.setPromiseImplementation.",
                            "createdAt": "2016-02-04T04:46:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@rauchg:\n\nAren't 1, 2 and 3 solved by V8? In other words, if global.Promise is there, that's all you need in order to standardize on the same primitive.\n\n3, at least, has not proven true. We've definitely deprioritized Promise \u2194\ufe0e Domain interaction in the past because core doesn't have a stake in the Promise API, which is why that's buggy now.\nWith regards to:\n\n\nIt standardizes Promises as an interchange format for packages, which only core can do.\nIt preempts or reduces the pain of accidentally receiving a native Promise vs. your expected primitive.\n\n\nWe've had the native Promise for a while now, and I don't believe we've seen movement on either of these fronts. This is (at least partially) because obtaining a Promise API from core means picking a shim library and picking a Promise implementation. If core exposes a Promise API, the need for shim libraries is reduced, and more folks can \"just\" use native promises. If an advanced application-level user wants to change their promise implementation, that avenue is still open to them \u2014 they can replace the global Promise object. Exposing a Core Promise API would not have an immediate effect, but over time the ecosystem could come to rely on Core's definition of a Promise as a common point of agreement, which would make the ecosystem healthier. Right now we are forcing folks who agree (two packages say \"Yes, we want Promises\") to deal with the specifics of their agreement (\"Well, I want Bluebird at version 2. You want Bluebird at version 3.\") in a way that's somewhat counterproductive. Folks who want alternate implementations can swap globally or continue to marshal/unmarshal at the edges, folks who want to rely on the loose agreement can do so.",
                            "createdAt": "2016-02-04T04:49:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "I still mantain fs.readFile() should return a Promise, but I see your point of core \"endorsing\" the usage of global.Promise to help standardize \ud83d\udc4c",
                            "createdAt": "2016-02-04T04:59:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Unfortunately, that's not currently the case \u2014 some userland implementations work well, but interoperation between packages can be arduous, and native promises don't work with other features of the platform, like domains (and the upcoming AsyncWrap.) As it becomes easier to (unintentionally) generate and return native promises in the future, this becomes more of a problem. Since promises can cross package boundaries, it can be hard to track down the source of bugs relating to indirectly being handed a (currently broken-with-respect-to-domains) native Promise.\n\n@chrisdickinson I fail to see how this relevant.\n\nWith regards to sugar: I agree that at some point in the past, one could reasonably regard Promises as sugar over the top of callbacks. However, with their inclusion in the spec, and their subsequent appearance as a builtin, they've gone from being sugar to being a first-class container data type.\n\nStill sugar, but it's also sugar that is distinctly slower and significantly more complex, unlike arrays vs maps.",
                            "createdAt": "2016-02-04T18:47:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson I'm wondering about the impact of this PR on post-mortem debugging.\nAlthough I never used promises and thus lack experience to validate my concerns, it seems that the current design and implementation suffers from problems discussed elsewhere (like on Twitter and during a recent meeting): by default promises implicitly swallow uncaught errors thrown synchronously, and thus make post-mortem debugging unusable.\nMaking node's core API available as a promises-based API doesn't prevent anyone from using the original callbacks-based API, and thus it would be tempting to think that this PR doesn't have an impact on post-mortem debugging.\nHowever, it seems that it would make third-party modules more likely to use an API that is not compatible with post-mortem debugging techniques, and thus would have a significant negative impact on users who depend on that to run applications in production. In other words, by merging the changes in this PR, it seems we would endorse using an API that is incompatible with post-mortem debugging. I would think this contradicts the efforts of the @nodejs/post-mortem working group.\nI consider these concerns as blockers for this PR, and I would think they'd need to be addressed before merging it.\nIt also seems these concerns have been already discussed in this thread, and there's an entry in the summary that mentions these discussions (Should programmer errors throw, or reject?), but the link seems to be broken. I would like to see that fixed so that these concerns are properly represented.\nI would appreciate reading your thoughts about the impact of this change on post-mortem debugging, and how to solve the problems mentioned above. I would also like to invite other members of the @nodejs/post-mortem WG to weigh in and share their thoughts.\nLast but not least, if you need any help, I would be more than happy to work with you in finding solutions for the concerns mentioned above, and I imagine other members of @nodejs/post-mortem would feel the same.",
                            "createdAt": "2016-02-04T19:55:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gx0r",
                                "__typename": "User"
                            },
                            "bodyText": "@misterdjules This is why Promises should log and abort the process (on the next tick) by default, unless explicitly caught (e.g., adding a dummy .catch(function() {}) handler). You can always catch the same promise again later in the next tick if you need logic there. That behavior would parallel the behavior of a throw in a callback aborting the process. (This discussion is probably orthogonal to this PR.)",
                            "createdAt": "2016-02-04T20:05:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "inikulin",
                                "__typename": "User"
                            },
                            "bodyText": "@llambda\nWe have an unhandledRejection for post-mortem.\n@misterdjules\n\nThis is why Promises should log and abort the process (on the next tick) by default, unless explicitly caught (e.g., Promise.reject('blah').catch()).\n\nThis is just incorrect. One of the benefits of promises that they encapsulate errors. What if I would like to handle rejections on timeout? Process will exit before I will be able to do that.",
                            "createdAt": "2016-02-04T20:16:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@misterdjules Hi! I appreciate your concern. As it stands, the unhandledRejection event hook does not unwind the stack \u2014 SetPromiseRejectCallback works in a similar fashion to SetAbortOnUncaughtExceptionCallback, in that it happens at top of stack and a process may abort at that point while preserving stack information in the resulting core dump.\nThe fly in the ointment seems to be that if an promise does have a rejection handler, the stack is unwound \u2014 cores generated by promises that delegate error handling down the operation graph will not preserve the stack. This is a pretty common operation with promises, so it is a tradeoff to be aware of when using them. Users should be informed of that consequence so they can make an informed choice whether to use promises or not \u2014 or to make use of packages that use promises internally.\nI'm not sure I agree that it's a blocker, though: promises already exist in the ecosystem, so the problem is already there. Yes, exposing them through core APIs lowers the barrier to using them, but not doing so doesn't eliminate the problem \u2014 some users will continue to use promises. If we expose them, we have a good way to document that behavior for our users, and let them make an informed choice. I think that this lets Node's users choose the async primitive & associated set of tradeoffs that match their use-case the best, and gives us a venue to inform users about the tradeoffs. Post-mortem debugging may not be a priority for every Node programmer; likewise, promises may not be a priority for every Node programmer; that doesn't mean that either is reduced in value for those they serve.\n\nIt also seems these concerns have been already discussed in this thread, and there's an entry in the summary that mentions these discussions (Should programmer errors throw, or reject?), but the link seems to be broken. I would like to see that fixed so that these concerns are properly represented.\n\nAh sorry \u2014 I just tried that link and it worked \u2014 it takes a long time to load all of the comments on this thread, and since some comments are clipped by GitHub I am guessing it has to run an XHR to fetch the rest before it jumps to the anchor. You might try again!",
                            "createdAt": "2016-02-04T20:24:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@llambda: This is a separate discussion that is tangential to this PR \u2014 there are good points on both sides of what to do on unhandled rejection, and it would do both that topic and this PR a disservice to try and intermingle them.",
                            "createdAt": "2016-02-04T20:25:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Thank you for taking the time to reply, it is very much appreciated.\n\nAs it stands, the unhandledRejection event hook does not unwind the stack\n\nDo you mean that at the point where node's process' unhandledRejection event is handled, the stack is not unwound? It seems to me that it's not the case as emitPendingUnhandledRejections seems to be called from a nextTick queue or after the nextTick queue is processed. I haven't looked at this code before, so I may very well be missing something.\n\nSetPromiseRejectCallback works in a similar fashion to SetAbortOnUncaughtExceptionCallback, in that it happens at top of stack and a process may abort at that point while preserving stack information in the resulting core dump.\n\nI may also be missing how this works internally, but looking at the current promises implementation in V8 shipped in node's master branch, from what I understand, if one writes the following code:\nfunction boom() {\n  return new Promise(function (fulfill, reject) {\n    console.log('boom!');\n    throw new Error('boom');\n  });\n}\n\nboom();\n\nthen the callback set by SetPromiseRejectCallback will be called from the catch block, and thus part of the stack may have been unwound.\nAgain, this is the first time I take a look at this code, I may very well miss something and I should take the time to experiment these theories with code, but for now I would appreciate your feedback.\nOnce  I develop a proper understanding of promises internals and the impact of their implementation on post-mortem debugging, I'll comment on the other points you made if my concerns are still relevant.\n\n\nIt also seems these concerns have been already discussed in this thread, and there's an entry in the summary that mentions these discussions (Should programmer errors throw, or reject?), but the link seems to be broken. I would like to see that fixed so that these concerns are properly represented.\n\nAh sorry \u2014 I just tried that link and it worked \u2014 it takes a long time to load all of the comments on this thread, and since some comments are clipped by GitHub I am guessing it has to run an XHR to fetch the rest before it jumps to the anchor. You might try again!\n\nOK, for some reason I need to manually reload the page after clicking on that link, thanks for pointing me in the right direction :)",
                            "createdAt": "2016-02-04T21:16:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Raynos",
                                "__typename": "User"
                            },
                            "bodyText": "I opened an issue about post mortem debugging with promises ( #5084 )\nI agree with @misterdjules that this is a blocking issue. Adding any features to node that make post mortem debugging harder is silly.\nWe need to start with having an --abort-on-unhandled-rejection flag that has the correct behavior.",
                            "createdAt": "2016-02-04T21:21:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "olalonde",
                                "__typename": "User"
                            },
                            "bodyText": "The proposed API will not be quite as elegant for people who use ES2015 modules, though I suppose we could do the following:\nimport { promise as fs } from 'fs';\nconst { readFile } = fs;\nEdit: oh in fact the second line really is optional. it actually looks pretty good... If you want nodeback API, you do:\nimport fs from 'fs';\nfs.readFile('somefile', (err, data) => { \n  if (err) return console.log(err); \n  console.log(data);\n});\nand if you want promises:\nimport { promise as fs } from 'fs';\nfs.readFile('somefile').then(console.log).catch(console.error);",
                            "createdAt": "2016-02-04T22:22:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "@olalonde import { promised: { readFile, readDir }} from \"fs\"",
                            "createdAt": "2016-02-04T23:24:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@Raynos, @misterdjules:\n\nI opened an issue about post mortem debugging with promises ( #5084 )\nI agree with @misterdjules that this is a blocking issue. Adding any features to node that make post mortem debugging harder is silly.\nWe need to start with having an --abort-on-unhandled-rejection flag that has the correct behavior.\n\nI agree that if we can make this better we should. I don't think it's a blocker for this issue, though \u2014  unhandled promise rejections unwinding stack is already extant in the ecosystem, so while this API might change the frequency of this occurrence, it doesn't introduce it as a new shortcoming \u2014 but it gives us a good venue to communicate the tradeoff.",
                            "createdAt": "2016-02-04T23:30:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "olalonde",
                                "__typename": "User"
                            },
                            "bodyText": "@iamstarkov are you sure this is valid syntax? babel doesn't support it and IIRC I don't think it's possible at all to do nested destructuring like this in import statements",
                            "createdAt": "2016-02-04T23:41:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@olalonde, @iamstarkov: Would you mind taking that conversation to this issue? It's a bit off topic for this issue.",
                            "createdAt": "2016-02-04T23:42:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Raynos",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nunhandled promise rejections unwinding stack is already extant in the ecosystem, so while this API might change the frequency of this occurrence, it doesn't introduce it as a new shortcoming\n\nThis kind of argument is flawed. Everything in npm and the ecosystem, by default is low quality and it's \"use at your own risk\".\nPeople assume that node core is high quality and does not have shortcomings. You are introducing a new shortcoming into node core, that is not acceptable. The core must stay small, performant and be debuggable.\nJust because threads exist as modules on npm doesn't mean that introducing threads to node core is NOT a new shortcoming.",
                            "createdAt": "2016-02-05T00:02:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nI should take the time to experiment these theories with code\n\nDone, I'd be interested in getting your feedback.",
                            "createdAt": "2016-02-05T00:10:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@llambda @inikulin Please see #5084 for details on what @Raynos and I are talking about.",
                            "createdAt": "2016-02-05T01:36:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Promise usage existing in userland and not working with tools we ship with isn't really relevant. They may not care, but that is a poor excuse for us not to. We wouldn't ship anything else like that and we are definitely not going to ship new APIs that don't even work with existing tooling.",
                            "createdAt": "2016-02-05T05:30:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123:\nThe current incompatibility of promises and core-based post-mortem debugging is a viable concern, and we're looking to find a resolution for this. However, this is not a new problem: this is something that already breaks for users of post-mortem tooling \u2014 we've already shipped with this problem. The proposed API puts pressure on finding a usable solution. In the case that promises cannot be made to avoid unwinding stack, we're in a position where we can message to our users clearly about the tradeoffs in using promises, and in the best case we've improved the lives of post-mortem debugging users over what they're currently experiencing.",
                            "createdAt": "2016-02-05T07:17:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nHowever, this is not a new problem: this is something that already breaks for users of post-mortem tooling \u2014 we've already shipped with this problem.\n\nThe fact that some non-core code breaks post-mortem debugging is inevitable, but adding APIs to core that break post-mortem debugging can, and in my opinion should, be prevented. At the very least we need to research potential solutions so that the project can make an educated decision.\n\nIn the case that promises cannot be made to avoid unwinding stack, we're in a position where we can message to our users clearly about the tradeoffs in using promises\n\nI think that would be one step towards a more inconsistent, and thus more confusing core platform. Communicating this inconsistency to users is a very difficult task, and we've seen numerous examples in the past where communicating to users is not a solution: domains, \"private\" APIs, uninitialized buffers' backing store, etc.. Users use whatever is in the platform and expect it to work.\n\nand in the best case we've improved the lives of post-mortem debugging users over what they're currently experiencing.\n\nWe won't improve the lives of post-mortem debugging users by adding an API that doesn't work for their use case.\nHowever we can improve their lives by documenting the existing problems with using promises and post-mortem debugging (although that's obviously a separate issue) and researching solutions for making promises work for their use case.",
                            "createdAt": "2016-02-05T18:08:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wraithan",
                                "__typename": "User"
                            },
                            "bodyText": "Sounds like the fixes to post-mortem debugging should be part of the gate\non when this feature leaves flagged status. Much like v8 APIs for better\nobservability. I do no see why a flagged feature would need to have the\npost-mortem story figured out completely before going in. To return to the\nstance taken so far, perfect should not get in the way of better,\nespecially for a flagged feature.\nOn Fri, Feb 5, 2016 at 10:09 AM Julien Gilli notifications@github.com\nwrote:\n\n@chrisdickinson https://github.com/chrisdickinson\nHowever, this is not a new problem: this is something that already breaks\nfor users of post-mortem tooling \u2014 we've already shipped with this problem.\nThe fact that some non-core code breaks post-mortem debugging is\ninevitable, but adding APIs to core that break post-mortem debugging\ncan, and in my opinion should, be prevented. At the very least we need to\nresearch potential solutions so that the project can make an educated\ndecision.\nIn the case that promises cannot be made to avoid unwinding stack, we're\nin a position where we can message to our users clearly about the tradeoffs\nin using promises\nI think that would be one step towards a more inconsistent, and thus more\nconfusing core platform. Communicating this inconsistency to users is a\nvery difficult task, and we've seen numerous examples in the past where\ncommunicating to users is not a solution: domains, \"private\" APIs,\nuninitialized buffers' backing store, etc.. Users use whatever is in the\nplatform and expect it to work.\nand in the best case we've improved the lives of post-mortem debugging\nusers over what they're currently experiencing.\nWe won't improve the lives of post-mortem debugging users by adding an API\nthat doesn't work for their use case.\nHowever we can improve their lives by documenting the existing problems\nwith using promises and post-mortem debugging (although that's obviously a\nseparate issue) and researching solutions for making promises work for\ntheir use case.\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-05T18:14:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "The fact that some non-core code breaks post-mortem debugging is inevitable, but adding APIs to core that break post-mortem debugging can, and in my opinion should, be prevented. At the very least we need to research potential solutions so that the project can make an educated decision.\n\nSure, but does adding this to master behind a flag help us move towards better debugging by increasing the usage of native promises and pulling more of this community in than blocking it until everything is perfect?\nThis is something that most definitely must be resolved before it comes out from behind a flag, but I see getting it in as a positive step towards improving the debugging.",
                            "createdAt": "2016-02-05T18:14:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@wraithan @mikeal I had somehow missed (or forgotten) the intent was to land this PR behind a flag. Maybe because the original description was updated with that detail after it was first posted, and because the code changes don't seem to reflect that.\nI can definitely see how landing this behind a flag might address my concerns, and the concerns of other post-mortem debugging users/maintainers. At the same time I don't think we have a lot of experience with flagged features, so it's hard to tell. I may be missing something though, do we have some previous experience with that in node, that is not with V8 flags?\nIn any case, I would expect the project to try to understand (not necessarily solve) fundamental technical and design issues before moving forward with adding features, even behind flags. In this case it shouldn't take too long for myself and/or others to write a document supported by code that describes precisely and thoroughly the problems that adding this API raises for post-mortem debugging users/maintainers. Pushing to land these changes before that work has had a reasonable amount of time to get done (let's say, around 2 weeks) seems to me like we'd be rushing.",
                            "createdAt": "2016-02-05T19:03:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@misterdjules we've rarely added stuff to Node.js that is behind a flag but we ship features behind flags all the time that V8 is putting out for early user feedback before considering ready, so we know the process works a bit. The entire generator ecosystem in Node.js started and spent its first year of growth behind a flag in Node.js.",
                            "createdAt": "2016-02-05T19:26:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "adding APIs to core that break post-mortem debugging can, and in my opinion should, be prevented\n\nI think it's not fair to say that promises break post-mortem debugging. It works as expected. Core dumps are probably not that useful but at least the behave consistently. Imagine a lib doing this:\nfunction doAThingWithStuff(stuff, cb) {\n  doAnotherThing(stuff, function(err, res) {    \n     var cbErr; \n      try {\n         cb(err, res)\n      } catch(e) {\n         cbErr = e;\n      }\n      cleanupStuff(function() {\n        if (cbErr) throw cbErr;\n      });\n  });\n}\nThis will have the same problem. So post mortem only works as expected because libs usually don't do this. But they can.",
                            "createdAt": "2016-02-05T19:35:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Thanks for this!\nI read through several hundred comments last night.  I am concerned by some of the issues @domenic raises here and previously.\nI believe this is extremely important to address.\nParaphrasing, @bnoordhuis (I think; I apologize if that's incorrect) wrote about how core's philosophy is to separate \"user errors\" (which are thrown) from others (which are returned as the first parameter to a callback).\n@domenic wrote that this strategy is (paraphrasing) fundamentally incompatible with Promises.  I agree.  For a contrived but concrete example, please do not expect a user to write code like:\nfunction myFileReader(filepath) {\n  var promise;\n  try {\n    promise = fs.readFile(filepath);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n  return promise.then(function(result) {\n    return munge(result);\n  });\n}\n\n// this causes an exception to be thrown, which is caught, and returned\n// as a rejected Promise\nmyFileReader(null);\n\n// this does not cause an exception to be thrown, but returns a rejected Promise\nmyFileReader('/something/that/does/not/exist');\nMy unsolicited opinion is this:\nIf Promises are to be in core, a function returning a Promise encounters any error, it must not throw an exception and only return a rejected Promise.  Yes, this is incompatible with the way core has historically addressed things.  That does not mean the strategy cannot differ for Promises, because (IMO) it must.\nWhile the original PR may have been trivial to implement, supporting this behavior across the board is likely not.  I am unsure what other implications this has except to add more lines of code and thus increase the likelihood of breaking things.\nI apologize if this has been addressed already.  Again, @chrisdickinson, thank you for submitting this PR.\nGreetings from Userland!\nEDIT: FWIW, if this didn't make it into the first flagged release, I don't think the above code would break per se, because it'd just be a useless try/catch at that point.",
                            "createdAt": "2016-02-05T20:29:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Post-Mortem debugging works just fine. It's exactly why we added the unhandledRejection and rejectionHandled hooks. You have full access to the stack trace there.\nAs for APIs: I think all the core APIs need a common subclass to indicate something is not an operational error but a programmer error.",
                            "createdAt": "2016-02-05T20:35:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "As for APIs: I think all the core APIs need a common subclass to indicate something is not an operational error but a programmer error.\n\nI believe bluebird differentiates between these two with error() vs catch(), unless I'm misunderstanding its API.  While somewhat confusingly named, that may be a solution.",
                            "createdAt": "2016-02-05T20:38:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull your understanding is correct, however we cannot just add methods to native promises :D\nI was just pointing out it would be useful to differentiate between times when core does something that's fundamentally a programmer mistake (passing a port number above 65K) and when an operational error occurs (like a file not existing). That semantic can be easily replicated to promises by having a subclass of Error and proper errors for rejections. @chrisdickinson what do you think? You could have it wrap the regular Errors and subclass it - bluebird also does this by default (Until 3 which adds a property instead) where OperationalErrors are thrown.",
                            "createdAt": "2016-02-05T20:44:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin post-mortem debugging requires using the --abort-on-uncaught-exception command line flag. Thus, if one explicitly adds a try/catch handler in code, or uses code that explicitly adds a try/catch handler, then an error that is thrown from within that try/catch block is caught, and doesn't make the process abort to produce a core file that can be used for post-mortem debugging.\nIt's consistent because the command line flag mentions uncaught exceptions and adding a try/catch blog explicitly catches exceptions. The code sample you pasted uses try/catch explicitly, and thus doesn't abort. It all behaves as expected.\nThe problem with the changes we're discussing here regarding post-mortem debugging can be illustrated e.g with this code sample, provided by @chrisdickinson (thank you!) in #5084:\n'use strict'\nconst fs = require('fs')\n\nfunction bar () {\n  throw new Error('unhandled rejection');\n}\n\nfunction foo () {\n  return bar();\n}\n\nconst p = new Promise(function (resolve, reject) {\n  fs.readFile(__filename, (err, data) => { err ? reject(err) : resolve(data) })\n}).then(() => {\n  foo()\n});\n\nHere, an error that is not explicitly caught does not make the process abort when using --abort-on-uncaught-exception, which is inconsistent. It was demonstrated in #5084 that even when aborting in a PromiseRejectCallback setup by V8's SetPromiseRejectCallback API, that callback is called when part of the stack is unwound, which makes a core dump useless.\nNow we could think the user who wrote this code knowingly used a promise, and thus should be aware of this inconsistency. However, it's not always that obvious. For instance, that promise could be used as part of a callback-based API provided by a third party module, or even a core module, that takes the function foo as a parameter and call it back from the then handler. The user who call throw in foo now expects that throw to not be caught, and to generate a core dump for post-mortem debugging.\nOk, but since the callback API is still present, the fix is easy: that user should rewrite her code to use the callback API. Again, the problem is that it's almost never that simple. Rewriting code to reproduce a problem is antithetical to post-mortem debugging, as users use post-mortem debugging explicitly to avoid as much as possible having to rewrite and redeploy applications to reproduce and debug problems.\nSo my concern with supporting these APIs in core is that it adds more inconsistency to the platform. It's very difficult to communicate that inconsistency clearly to users, as we've learned with domains and post-mortem debugging. I've done a lot of work to improve that specific situation, and I speak from experience when I say that this is a precedent we should consider.",
                            "createdAt": "2016-02-05T21:14:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull, @benjamingr: In current state of the PR, programmer errors \u2014 the \"throw on same tick\" errors \u2014 are returned as rejected promises. Right now I'm -0 on subclassing error, at least in this PR \u2014 it would mean that errors thrown by the callback API and the errors rejected by the promise API would be of different types. However, this would be a good thing to look into applying to the callback layer as a separate PR, to see if it has value separate from the Promises proposal! Edit: Also, thanks for reading through and sharing your concerns @boneskull!",
                            "createdAt": "2016-02-05T21:28:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "The code sample you pasted uses try/catch explicitly, and thus doesn't abort.\n\nNo, it's code of the lib. User doesn't explicitly catch anything. So there is no guarantee that lib doesn't break post mortem even if it doesn't use promises",
                            "createdAt": "2016-02-05T21:33:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin, @misterdjules: to keep the discussion on this PR focused, would you mind if we moved future comments on this thread into this issue? I'll reply to your points there.",
                            "createdAt": "2016-02-05T21:35:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "misterdjules",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson Not at all, good point!",
                            "createdAt": "2016-02-05T21:38:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "In updating the PR I've noticed one bit of difficulty with the <callback>.promise approach \u2014 namely, for methods we lose the appropriate object context. As a result, I'm going to return to the <callback>Suffix approach, but retain the shortcut require('fs').promised API. We can discuss the appropriate attribute decoration here \u2014 Async appears to be off the table, since it stands the chance of breaking user code, and it's somewhat confusing to newcomers.\n*Promise \u2014 as in readFilePromise \u2014 seems like a good compromise, especially since promise users will primarily interact with the API via const {readFile} = require('fs').promised in any case.",
                            "createdAt": "2016-02-05T23:40:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sandro-pasquali",
                                "__typename": "User"
                            },
                            "bodyText": "Given that Bluebird is used by developers to promisfy anything that needs promisifying, why bother with this? Seems a great place to validate the goal of a small core with userland trusted to innovate.",
                            "createdAt": "2016-02-07T18:12:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "@sandro-pasquali Please read the entire thread. That question has been answered more than once.",
                            "createdAt": "2016-02-07T18:13:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cantremember",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83d\udc4d\nseroiusly.  \"+1\".  let's do this.  the Comment chain here is immense, brings up some great discussions from great minds, and has an excellent summary Documentation trail\nNode.js devs have gotten used to fs.readFileSync -- give us this perfectly feasable Promise implementation, put it in the Manual, and we'll all be happy as clams.  folk who aren't happy can build an alternate elegant & performant module of our own that the community will be free to use",
                            "createdAt": "2016-02-07T18:27:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sandro-pasquali",
                                "__typename": "User"
                            },
                            "bodyText": "the technical underpinnings of how this PR exposes promises are less important than what this PR represents: an attempt to find an optimally palatable way to expose a promise-based API from core. The experiment the flag runs is to determine whether it's something that we can support, that folks want, that doesn't cause issues with the codebase at large in the long run. We can't get those results from a package in userland.\n\nSeems like this is solely useful to those who need to have a Promise-based Node API exposed from Node core. It is not known if it can be supported, or if folks actually want it, or if it will cause issues with the codebase in the long run. Developers do not need this in order to use Promises (Bluebird, etc) when developing on the Node platform. So this is an effort to create an experiment to prove a theory (conclusion?): that the Node project will be usefully advanced if its API is Promise-based and exposed from core.",
                            "createdAt": "2016-02-07T18:52:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@sandro-pasquali again, please read the entire thread. It is certainly known that many folks do want it, and that it can be supported.",
                            "createdAt": "2016-02-07T19:44:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sandro-pasquali",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb I've quoted the OP/PR owner, and what was written was done so a few days ago. I'd value your guidance as to where in the thread the mentioned concerns have been successfully dismissed (no doubt at all as to whether this can be supported, that a majority consensus has been tracked and verified in the last few days (how was certainty arrived at...poll?), and that it has been proven that there is no danger of regressions in the future). Because if all that is true, then this should be integrated immediately, as there is no need to run an experiment.",
                            "createdAt": "2016-02-07T20:02:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@sandro-pasquali it's a long thread but if you want to make informed contributions to the discussion then you're going to have to read and understand it. If you don't, please don't comment.",
                            "createdAt": "2016-02-07T20:13:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sandro-pasquali",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode Thanks. I was hoping that the reasoning of the person who submitted the PR was a useful base for understanding. I'll have to look elsewhere. Looking forward to seeing this in core!",
                            "createdAt": "2016-02-07T20:18:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@sandro-pasquali: Hi! Thanks for commenting. With regards to the \"experiment\" bit, I was referring to the feature flag and this specific approach to promises in core, in comparison to another proposed approach, which was to create a core-blessed userland module with this API. In specific, I was expressing that I don't believe a core-blessed userland package will give us more useful information than landing this implementation behind a feature flag.\nWith regards to \"do users want this\", I believe the answer is yes: as a promises user, while I can (and do!) use promises through a userland implementation like bluebird, there are a few problems I run into \u2014 and have heard echoed by other promise users:\n\nThe interchange format problem: In every package I write that uses bluebird, I have to perform two steps:\n\nMarshall outgoing calls from my package into dependencies into callbacks or the promise implementation I desire, using .promisify, .promisifyAll, or Promise.resolve.\nUnmarshall incoming calls from downstream users into promise form, using .nodeify(cb).\n\n\nThe peer dependency problem: if I have a set of packages that my application depends on and I want to use promises, each of those packages must specify a dependency on a promise implementation \u2014 e.g., bluebird. If I wish to update bluebird in my application, I have to update all packages that return bluebird promises to use the same version. Otherwise I can end up with Promises of multiple different versions and sources floating through my application.\nImpedance mismatch with core. In the absence of PRs introducing promise APIs, there's not a lot of momentum in core dedicated to making sure that promises work well on the platform. Native promises currently don't work with some Node platform features, like Domains, or the upcoming AsyncWrap. We don't have a good post-mortem debugging story for them, yet. These are not problems inherent with promises, but without a promise api exposed through core there's not a lot of incentive for core to look into these problems. Given that the conversation between callback users and promise users up until this PR has been rather heated, I imagine most promise users would not feel like their time would be well spent contributing to core to help fix these problems.\n\nBringing promises into core doesn't eliminate all of the problems above, but it does make many of them optional problems that users can choose to address. If I am coming from browser development, and I want to use promises now, I have to choose an implementation and a shim, and become versed in the peer dependency & interchange format problems. If we land a promise-based API, a user can just start using promises as expected. If they find they need different tradeoffs, they can pick a different implementation and become versed in the interchange and peer dep problems. Or, if they're operating at application level, they can swap the promise implementation globally, so the implementation they pick can more closely reflect the tradeoffs they find acceptable for their application.\nBringing promises into core doesn't mean callbacks are going away, but in the same sense, it doesn't mean alternative userland implementations are going away. Instead, it empowers them by reducing the need for them to maintain both an implementation and a shim API; and it lets users opt in to selecting an alternative promise implementation, rather than frontloading that decision.\nHopefully this addresses your concern \u2014 thanks for taking a look at this PR!",
                            "createdAt": "2016-02-07T22:29:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "winterland1989",
                                "__typename": "User"
                            },
                            "bodyText": "Wow, as an async library author, i'm very concerned that this pull request would be such a great way to promote promise that leave all the other solutions into dust.\nPromise have fundamentally flaws regarding to error handling, and it's not suitable to every situation, maybe it's just my personal concerns, but isn't too early to adopt promise to core?",
                            "createdAt": "2016-02-09T00:46:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wraithan",
                                "__typename": "User"
                            },
                            "bodyText": "This is not to the exclusion of callbacks but rather in addition to. This\ndoesn't leave other solutions in the dust but instead elevates a common\nsolution to behind a flag in core, which is still lower in status than\ncallbacks live.\nOn Mon, Feb 8, 2016 at 4:48 PM winterland notifications@github.com wrote:\n\nWow, as an async library https://github.com/winterland1989/Action.js\nauthor, i'm very concerned that this pull request would be such a great way\nto promote promise that leave all the other solutions into dust.\nPromise have fundamentally flaws regarding to error handling\n#830, and it's not suitable to every\nsituation petkaantonov/bluebird#147, maybe\nit's just my personal concerns, but isn't too early to adopt promise to\ncore?\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-09T00:54:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Wow, as an async library author, i'm very concerned that this pull request would be such a great way to promote promise that leave all the other solutions into dust.\n\nThe language has already left callbacks behind a while ago. Node.js is therefore actually playing catch up instead of rushing.\nThe issues you linked to don't have anything to do with your claims.",
                            "createdAt": "2016-02-09T00:55:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "winterland1989",
                                "__typename": "User"
                            },
                            "bodyText": "This is not to the exclusion of callbacks but rather in addition to. This\ndoesn't leave other solutions in the dust but instead elevates a common\nsolution to behind a flag in core, which is still lower in status than\ncallbacks live.\n\nRight, right, we have to see how all this goes : )\n\nThe issues you linked to don't have anything to do with your claims.\n\nWhy? The link to Default Unhandled Rejection Detection Behaviour clearly showed the way promise handle uncaught errors are not optimal, but i think it's a complex problem and it's meaningless to discuss here.",
                            "createdAt": "2016-02-09T01:06:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Discussion of what should be the best default for something that usually depends on the needs of an application is not the same as having \"fundamental flaw\". For example command line apps would want to crash, server apps would want to log, and some special setup might keep a live list of errors.\nFeature request for sugar (that was fulfilled, if you read the issue fully) is not the same as promises not being suitable to that situation which was made better with sugar.",
                            "createdAt": "2016-02-09T01:12:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@winterland1989:\n\nWhy? The link to Default Unhandled Rejection Detection Behaviour clearly showed the way promise handle uncaught errors are not optimal, but i think it's a complex problem and it's meaningless to discuss here.\n\nI think the resolution there is workable \u2014 it allows application authors to pick the settings that work best for them. In turn, package authors have to be conservative about their rejection usage if they expect to run in all instances, so there's a subtle pressure to avoid bouncing between unhandledRejection and rejectionHandled.",
                            "createdAt": "2016-02-09T01:14:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jclulow",
                                "__typename": "User"
                            },
                            "bodyText": "server apps would want to log, and some special setup might keep a live list of errors.\n\nFor certain classes of software defect, server applications should crash immediately and be restarted by the system service supervisor.  If you have a typographical error, or have attempted to use a property or variable that turns out not to be set in the way you expected, your program has a bug.  It is (by definition) no longer in a known state that you can reason about.  All bets are, as they say, off.\nThese defects are generally implicitly thrown by the interpreter itself, can be thrown in any (even seemingly innocuous) line of code, and are thoroughly obscured by Promises.",
                            "createdAt": "2016-02-09T01:20:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "winterland1989",
                                "__typename": "User"
                            },
                            "bodyText": "Discussion of what should be the best default for something that usually depends on the needs of an application is not the same as having \"fundamental flaw\". For example command line apps would want to crash, server apps would want to log, and some special setup might keep a live list of errors.\n\nI would like to say it's because the way promise handle throwing, and all the Default Unhandled Rejection Detection Behaviour is just hacking around this silent uncaught semantic of promise, and i do think it's a flaw by design. There's no better way without change the error handling semantic.\n\nFeature request for sugar (that was fulfilled, if you read the issue fully) is not the same as promises not being suitable to that situation which was made better with sugar.\n\nThrottling is not going to added into promise but to functions which produce promise, it's because promise's strict behaviour, and i can't see a sugar can solve that. But i agree yes we can solve that with a layer of wrapper.\n\nI think the resolution there is workable \u2014 it allows application authors to pick the settings that work best for them. In turn, package authors have to be conservative about their rejection usage if they expect to run in all instances, so there's a subtle pressure to avoid bouncing between unhandledRejection and rejectionHandled.\n\nYes, yes, it's workable, but it's not standardised yet or am i miss something?",
                            "createdAt": "2016-02-09T01:28:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "For certain classes of software defect, server applications should crash immediately and be restarted by the system service supervisor. If you have a typographical error, or have attempted to use a property or variable that turns out not to be set in the way you expected, your program has a bug. It is (by definition) no longer in a known state that you can reason about. All bets are, as they say, off.\n\nAll bets are off in JavaScript even without any errors. For every bug  that explicitly throws an error, there is thousand others that don't (but they would in languages you should be using instead) and you should have already restarted a thousand times (I.E. self-inflicted DoS).",
                            "createdAt": "2016-02-09T01:30:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@winterland1989:\n\nYes, yes, it's workable, but it's not standardised yet or am i miss something?\n\nSince it's a dial that application developers can turn to adjust behavior to their liking, there's not much to standardize \u2014 as a hypothetical, while I might think that Promise.reject(new Error('failure')).catch(err => {}) is perfectly cromulent, others may disagree, and since it bubbles to application level, we leave it to application authors to decide what's best for their particular application \u2014 whether to log, abort, or track.",
                            "createdAt": "2016-02-09T01:33:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "junosuarez",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov please keep the thread civil and refrain from making judgements about programming languages which aren't germane to this thread.\n@chrisdickinson is it perhaps time for a recap of the objections raised so far in this thread so we can focus further comments? This is the size at which GitHub issue threads become tricky.",
                            "createdAt": "2016-02-09T01:34:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow:\n\nFor certain classes of software defect, server applications should crash immediately and be restarted by the system service supervisor. If you have a typographical error, or have attempted to use a property or variable that turns out not to be set in the way you expected, your program has a bug. It is (by definition) no longer in a known state that you can reason about. All bets are, as they say, off.\nThese defects are generally implicitly thrown by the interpreter itself, can be thrown in any (even seemingly innocuous) line of code, and are thoroughly obscured by Promises.\n\nIn practice, in a complex system that uses promises, I've found that these cases are found by tests. Of course, saying this invites the exception :)\nSome set of promise users find this behavior acceptable, others find it unacceptable \u2014 we are working to find a good solution to this problem, but given the timeline it seems reasonable not to consider it a blocker for the initial staging of the feature.",
                            "createdAt": "2016-02-09T01:35:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jden: Indeed! I'll update the FAQ in the issue text above with the latest responses this evening.",
                            "createdAt": "2016-02-09T01:36:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "junosuarez",
                                "__typename": "User"
                            },
                            "bodyText": "One theme I've seen brought up in this thread is that of \"debuggability\" at dev time and finding errors that get swallowed up as rejected promises. Since the web platform has whole-heartedly embraced promises as the fundamental async primitive, v8 and Chrome dev tools have added features to help developers. Here's a good overview of this debugging experience and feature set.\nIf Node.js adopts promises into core, developers can hope for similar support, and Node.js as a platform would be more aligned with the greater JavaScript community.",
                            "createdAt": "2016-02-09T01:45:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "winterland1989",
                                "__typename": "User"
                            },
                            "bodyText": "Since it's a dial that application developers can turn to adjust behavior to their liking, there's not much to standardize \u2014 as a hypothetical, while I might think that Promise.reject(new Error('failure')).catch(err => {}) is perfectly cromulent, others may disagree, and since it bubbles to application level, we leave it to application authors to decide what's best for their particular application \u2014 whether to log, abort, or track.\n\nI understand that it's becoming the standard way, but the implementation is also under discussing, for example, and that's why i thought it's not ready, but correct me it's not the case.\n@jden Thanks for bringing this onto table \ud83d\udc4d",
                            "createdAt": "2016-02-09T01:47:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@winterland1989:\n\nI understand that it's becoming the standard way, but the implementation is also under discussing, for example, and that's why i thought it's not ready, but correct me it's not the case.\n\nAh! I think I understand. There are some efforts \u2014 documented in that issue \u2014 to make sure that there's an option for unhandledRejection that prevent stack unwinding. This is for the purposes of users that employ post-mortem debugging tools. It should not affect the unhandledRejection / rejectionHandled API as it has been exposed to users.",
                            "createdAt": "2016-02-09T01:51:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jclulow",
                                "__typename": "User"
                            },
                            "bodyText": "Some set of promise users find this behavior acceptable, others find it unacceptable \u2014 we are working to find a good solution to this problem, but given the timeline it seems reasonable not to consider it a blocker for the initial staging of the feature.\n\nI am elated to find that you are working to solve the problem.  At the moment, though, it seems like the implicit catch is an irreducible part of the promises model as specified.  I struggle to see how any \"timeline\" is going to change that.\nIntegrating this at all (flag or no flag) prior to sorting this out increases the likelihood that the project will get stuck holding the bag in the long term.  We have experienced this in the past with cluster and with domain, and it seems like it would be prudent to avoid piling on more questionable API surface area in the core of Node.\nIt also significantly increases the likelihood that the general population will see the Node project as having blessed a control flow abstraction with some egregious error-handling drawbacks.  I completely understand that you do not agree.  If your intent is to steam-roll over the myriad concerns raised by myself and others, and it must be said that so far it seems that this is the case, then I don't really know where to go from here.",
                            "createdAt": "2016-02-09T01:56:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow I repeat that application being in inconsistent state after a thrown error is completely arbitrary. Referencing undeclared object fields doesn't throw any error (while same with variables does), parsing invalid dates doesn't throw any error (while same with json does), dividing by zero doesn't throw any error, trying to concatenate a string and a object doesn't throw any error etc etc.\nIf you claim that an application is in an inconsistent after an error then you need to either prove that any of these non-throwing errors somehow don't put the application in inconsistent state or you must simply accept that JavaScript application is always running in an inconsistent state and pretending otherwise is futile.",
                            "createdAt": "2016-02-09T02:10:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow:\n\nIntegrating this at all (flag or no flag) prior to sorting this out increases the likelihood that the project will get stuck holding the bag in the long term. We have experienced this in the past with cluster and with domain, and it seems like it would be prudent to avoid piling on more questionable API surface area in the core of Node.\n\nTo unpack this statement: I think we disagree on the size of bag this represents, and the likelihood that we will be stuck holding it. Since the implementation involves wrapping the existing API in a regular way, the bag we're stuck with maintaining in the unlikely case that promises are backed into Annex B of the language is relatively small \u2014 a single module containing wrapper functions. To maintain the callback API is to maintain the promise API, since the promise API is a regular transformation on top of the callback API. With regards to the likelihood, again I think disagree \u2014 as a current promise user in a reasonably complicated system, I haven't experienced any shortcomings of the primitive. Many others have been using promises without finding shortcomings. From my perspective, the risk seems very low. We disagree on this, and that is fine.\n\nIt also significantly increases the likelihood that the general population will see the Node project as having blessed a control flow abstraction with some egregious error-handling drawbacks. I completely understand that you do not agree. If your intent is to steam-roll over the myriad concerns raised by myself and others, and it must be said that so far it seems that this is the case, then I don't really know where to go from here.\n\nMy intent has not been to steam-roll over concerns \u2014 I am happy to discuss them! Identifying these concerns is important to me: often these highlight areas where we can focus effort to make everyone's life better. There will be some disagreements that are strongly held. In the case of the post-mortem WG, I think we have surfaced some improvements we can make on the current state of promises.\nHowever, it seems like the use cases of promise users and the current post mortem WG tooling are somewhat disjoint. The existing promise use in the ecosystem does not appear to have invalidated the use cases of the PMWG, and making life easier for promise users doesn't seem like it will worsen that situation. For application-level users that wish to disallow promise use, it's a one line change that would be easy to implement operationally using the -r \"preload modules\" mechanic. Combined with the several go/no-go checks at each major version between here and officially supporting the API, that gives me confidence that better supporting promise users is not likely to be a disastrous undertaking.\nThe assertion that building a maintainable, debuggable, performant application on top of promises is impossible rings false to me, based on my day-to-day experience. This PR does not attempt to replace callbacks with promises: it makes it easier to disable them entirely in an application, while making the lives of promise users easier. It is okay for us to disagree, but I am not sure that that should block Node support for promise users.",
                            "createdAt": "2016-02-09T02:32:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "Has there ever been any discussion (in the Promises universe) of allowing a get-out-of-jail with Promises' implicit catch to allow certain types of errors to bypass and bubble-up outside of any Promises chain? e.g. is there any possibility that a user might be able to get TypeError, ReferenceError and SyntaxError (which typically make up the bucket of \"programmer errors\") to do something special, a global handler perhaps process.on('promisesReferenceError', logAndExit) regardless of an error being handled or not by a Promises chain. It may be that such a feature, combined with a default unhandledRejection handler that is closer to uncaughtException (and is properly tied in to GC to avoid false positives) could address some of the error handling concerns that many people have with accepting Promises first-class in Node.",
                            "createdAt": "2016-02-09T03:53:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "stefanpenner",
                                "__typename": "User"
                            },
                            "bodyText": "o do something special, a global handler perhaps process.on('promisesReferenceError', logAndExit)\n\n@rvagg yes ->  Event 'unhandledRejection', this or something similar makes all the difference. All the popular promise libraries either implement that, or offer something aligned in spirit. Primarily positive experiences.",
                            "createdAt": "2016-02-09T03:55:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov that's why --abort-on-unhandled-rejection makes sense. It's a way of asserting that within that particular node program, an unhandled rejection is synonymous with an inconsistent state (i.e: you're not expecting them to occur).",
                            "createdAt": "2016-02-09T03:58:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "stefanpenner",
                                "__typename": "User"
                            },
                            "bodyText": "@rauchg unfortunately, an entirely valid program can (for a time) have an unhandledRejection, which is then later handled.  At first this may seem entirely unexpected, but it does legitimately pop up often during handled failure scenarios, especially when coordinating failure and failure handling between multiple concurrent actors. Introducing zalgo by aborting on blanket unhandled-rejections events (which promises are designed to combat) during failure scenarios would be unfortunate.\nAlthough false-positives occur, this type of event can be an aid during development and debugging, but aborting in such scenarios would be problematic.",
                            "createdAt": "2016-02-09T04:09:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jclulow",
                                "__typename": "User"
                            },
                            "bodyText": "@rauchg\n\nthat's why --abort-on-unhandled-rejection makes sense. It's a way of asserting that within that particular node program, an unhandled rejection is synonymous with an inconsistent state (i.e: you're not expecting them to occur).\n\nIn principle I would like to agree, but it seems like this will conflict with another property of putatively correct usage of promises as specified.  That is: it appears to be legitimate, in some cases, to be \"bouncing between unhandledRejection and rejectionHandled\".  To avoid this deeply unfortunate behaviour all package authors are directed \"to be conservative about their rejection usage if they expect to run in all instances\".\nIt is especially unlikely that this level of discipline will just appear in the NPM module ecosystem, any more than a uniformly disciplined approach to error handling has emerged to date.  It's hard enough to get error handling right in an environment with good support for it; the idea that we're going to deal well with \"subtle pressure\" to use promises in a way that would be amenable to --abort-on-unhandled-rejection usage seems specious at best.",
                            "createdAt": "2016-02-09T04:12:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg Yep! This is the approach Jacob Groundwater and I hit on in our discussion this afternoon.",
                            "createdAt": "2016-02-09T04:13:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "stefanpenner",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow yes, an in-addition to the lack of discipline. A system of individually strict and abiding components can easily be strung together in ways that violate the above required strictness, worse the failure would likely only occur during specific scenarios, essentially introducing fatal race conditions into a system designed to combat them.",
                            "createdAt": "2016-02-09T04:22:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rauchg",
                                "__typename": "User"
                            },
                            "bodyText": "@stefanpenner\n\n@rauchg unfortunately, an entirely valid program can (for a time) have an unhandledRejection, which is then later handled.\n\nI agree with this, in the same way that an entirely valid program might ignore passing the callback to fs.unlink() and only have it fail (or care about it failing) 1/1000000 of the times it runs. This is how Node works today.\nThe point is, in certain controlled environments you should be able to opt-into that behavior. If you know you're juggling promises with rejections and only catching them in a different tick, you wouldn't use the flag?",
                            "createdAt": "2016-02-09T04:28:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow, @stefanpenner:\n\nIn principle I would like to agree, but it seems like this will conflict with another property of putatively correct usage of promises as specified. That is: it appears to be legitimate, in some cases, to be \"bouncing between unhandledRejection and rejectionHandled\".\n\nIn practice, applications that choose to abort on unhandled rejection should expose such dependencies very quickly, with an associated core that points to the offending module. It should be possible to rewrite any program that contains an unhandled rejection to eliminate it, so it seems like userland would be able to exert that pressure effectively.",
                            "createdAt": "2016-02-09T04:30:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jclulow",
                                "__typename": "User"
                            },
                            "bodyText": "In practice, applications that choose to abort on unhandled rejection should expose such dependencies very quickly, with an associated core that points to the offending module. It should be possible to rewrite any program that contains an unhandled rejection to eliminate it, so it seems like userland would be able to exert that pressure effectively.\n\nI would love to see any kind of data at all to back up that conjecture.",
                            "createdAt": "2016-02-09T04:31:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@jclulow:\n\nI would love to see any kind of data at all to back up that conjecture.\n\nIt seems like it follows pretty naturally: at the moment, as an author of promise-returning modules, I would not write a package that creates unhandled rejections that userland cannot handle. Similarly, I would not write a callback-using package that intentionally throws an error on asynchronous spur route that a consuming package cannot intercept. I cannot rely, in either case, that the consuming package hasn't turned on abort-on-un{caught-exception,handled-rejection}, and so I avoid that behavior.",
                            "createdAt": "2016-02-09T04:35:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "stefanpenner",
                                "__typename": "User"
                            },
                            "bodyText": "It should be possible to rewrite any program that contains an unhandled rejection to eliminate it\n\nThis statement is true (at-least has been in my experience), but such scenarios can be non-obvious and equally rare/unpredictable to encounter.\n\napplications that choose to abort on unhandled rejection should expose such dependencies very quickly\n\nThis statement isn't true, if it was it would be possible to assert systems are race/bug free. I do not believe any reasonably complex system could assert make this claim. (Although I wish they could)\n\nWe should be careful, as this choice (although some tend to be apposed) was by design. Logging (even with possible positives) really does make a difference here and does so without compromising what I believe to be a valuable feature.",
                            "createdAt": "2016-02-09T04:39:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jclulow",
                                "__typename": "User"
                            },
                            "bodyText": "It seems like it follows pretty naturally: at the moment, as an author of promise-returning modules, I would not write a package that creates unhandled rejections that userland cannot handle. Similarly, I would not write a callback-using package that intentionally throws an error on asynchronous spur route that a consuming package cannot intercept. I cannot rely, in either case, that the consuming package hasn't turned on abort-on-un{caught-exception,handled-rejection}, and so I avoid that behavior.\n\nThis is still just conjecture.  Your personal world view or development habits are really not at issue here.  We're talking about the broader module ecosystem, which contains a vastly wider level of skill levels in general and experience with the robust usage of promises (to the extent that such a thing is even possible) in specific.\nThe current default behaviour for programmer errors of the kind synchronously thrown, but not caught, is that they stop the process.  Under promises, those same synchronously thrown exceptions are implicitly caught and potentially dropped directly on the floor.  If not dropped on the floor, they might be handled some time later by the module or some other part of the running process -- assuming there are no bugs in either that prevent the correct handler from being installed.  This also assumes that a logical or reference error in a program is not mistaken for a connection timeout or some other operational problem.",
                            "createdAt": "2016-02-09T04:44:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "junosuarez",
                                "__typename": "User"
                            },
                            "bodyText": "Under promises, those same synchronously thrown exceptions are implicitly caught and potentially dropped directly on the floor. If not dropped on the floor, they might be handled some time later by the module or some other part of the running process\n\nCorrect. This is the desired property and behavior for promises users. For some (many?) classes of programming, this makes writing robust programs easier, and makes the platform more valuable.",
                            "createdAt": "2016-02-09T06:01:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "winterland1989",
                                "__typename": "User"
                            },
                            "bodyText": "It seems that discussion around the way how promise handle errors will never stop...\nIt has been argued in several places, what makes everything complex is that, it's not clear that the responsibility should fall on library's authors, application authors or even eco-system authors, since all we got is a global hook built into node's core.\nFor those who interested in a different take on how error handling are done, please review my work: action-js, it's similar to haskell's way regarding errors: using algebraic data type(here using instanceof in js). It may not be the best solution, but at least it's much cleaner than just have a global hook.",
                            "createdAt": "2016-02-09T06:20:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mpareja",
                                "__typename": "User"
                            },
                            "bodyText": "@jden Handling operational errors makes programs more robust because you are explicitly addressing faults as part of your system's fault model. I don't agree that handling exceptions resulting from programmer errors makes a program more robust since, by definition, one was not anticipating the fault and cannot assume anything about the fault. The recommendation to restart a program upon encountering an unexpected fault is a sound bit of advise in an effort to prevent the fault from putting the system into an error state and further failing to provide the expected services.",
                            "createdAt": "2016-02-09T06:23:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iamstarkov",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson can you share latest status of this PR and related discussions?",
                            "createdAt": "2016-02-12T22:01:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jadbox",
                                "__typename": "User"
                            },
                            "bodyText": "Observable support would be awesome: why just settling on the extension with promises? The idea of having RxJS 5 work natively (as it works with any Observable sources) with Node's \"stdlib\" is very exciting to me. @staltz",
                            "createdAt": "2016-02-13T20:08:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@jadbox that's completely unrelated at this point. Observables are only phase 1 and would presumably replace methods that interact with event emitters (and not callbacks).\nIf you want to see Observables in Node eventually - help with es-observable and RxJS 5. Both projects could really use more support and more eyes reading the code when it changes. Lots of different and interesting challenges to solve.\nTalking about Observables here would only likely derail the conversation unless you have a clear point to make. Hope to see you participate more in es-observable discussions.",
                            "createdAt": "2016-02-13T20:33:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "I've written a summary of the current state of the PR, including the problems being worked on at present. Thanks all!",
                            "createdAt": "2016-02-14T08:54:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson that's helpful, but I don't think people who are not already part of the discussion would be able to reason about the post-mortem part.",
                            "createdAt": "2016-02-14T10:27:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Also, the fact all approaches are being portrayed as equally valid is somewhat unnerving, I don't know a single promises user who is on-board with let [err, data] = await someCall(...) or with altering the behavior of try/catch in the language (if you are that user, please step up and let me know).",
                            "createdAt": "2016-02-14T10:31:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I am not on board with making a separate module (or any suffix), let alone with the changes that ruin promises for promise users in the entire ecosystem. Not having promises at all is much better.",
                            "createdAt": "2016-02-14T10:56:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I don't know a single promises user who is on-board with let [err, data] = await someCall(...)\n\nI am) It's so much cleaner thant try-catch.  I don't expect it to be mainstream, though and it's easy to wrap manually:\nlet [err, data] = await someCall(...).then(_ => [null, _], _ => [_, null] )",
                            "createdAt": "2016-02-14T11:38:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "In the 99% case where errors are just propagated to the caller it's not \"cleaner\" in any sense of the word\nlet [err, data1] = await someCall1();\nif (err) return [err];\n\nlet [err, data2] = await someCall2();\nif (err) return [err];\n\nlet [err, data3] = await someCall3();\nif (err) return [err];\n\nlet [err, data4] = await someCall4();\nif (err) return [err];\nlet data1 = await someCall1();\nlet data2 = await someCall2();\nlet data3 = await someCall3();\nlet data4 = await someCall4();",
                            "createdAt": "2016-02-14T11:46:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov in most cases I deal with I have to catch immediately anyway, otherwise I lose context.",
                            "createdAt": "2016-02-14T11:54:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The error object is the context, say, in case of a file read error it will tell you which file was not read and why. If you mean context for debugging then the error object also has .stack for that.",
                            "createdAt": "2016-02-14T11:57:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I mean that almost always I need to do something very specific to handle each rejection, so I don't want this anyway:\ntry {\n  let data1 = await someCall1();\n  let data2 = await someCall2();\n  let data3 = await someCall3();\n  let data4 = await someCall4();\n} catch (e) {\n  switch(e.type) {\n    ...\n  }\n}\nWhen a file read fails, I want to know immediately to provide useful logging and fallback behaviour.",
                            "createdAt": "2016-02-14T12:03:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "I don't understand why people who want [err, data] are even using promises in the first place",
                            "createdAt": "2016-02-14T12:05:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin that's still much nicer as it keeps all the processing logic in one place and the error handling logic in the next. If you have meaningful error types that carry context with them - then you can deal with it cleanly. For example with a hypothetical syntax:\ntry {\n  let data1 = await someCall1();\n  let data2 = await someCall2();\n  let data3 = await someCall3();\n  let data4 = await someCall4();\n  return data4.content;\n} catch (e: FileError) {\n  log(`${e.fileName} failed reading`, e.stack);\n  throw e;\n} catch (e: NetworkConnectionError) {\n  log(`${e.endpoint} failed connecting`, e.stack);\n  throw e;\n} catch (e) {\n  return \"Something bad happened\";\n}\nThat e.type is still a lot better than mixing and matching the data and its error paths. Anyway, it's how the language behaves - if people want a language with (err, data) return types they might as well write in Go.",
                            "createdAt": "2016-02-14T12:08:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nI am exploring making V8\u2019s Microtask Queue pluggable, in the style of V8's ArrayBuffer::Allocator API. This should allow us to add the necessary hooks for AsyncWrap and domains\n\nThis is not enough if we want to capture context on then calls.\n@kittens because async-await\n@benjamingr I don't think that conditional catch is a good idea in a dynamically typed language.\nFileError can be thrown from any of this calls for what I know.\n\nAnyway, it's how the language behaves - if people want a language with (err, data) return types they might as well write in Go.\n\nLanguage allows you to return errors, so this statement is confusing. I don't wont to use another language just because it does one thing right.",
                            "createdAt": "2016-02-14T12:13:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "I don't know a single promises user who is on-board with let [err, data] = await someCall(...)\n\nThat's not for node to decide. It's specified by ES6. And fortunately it's a throw.",
                            "createdAt": "2016-02-14T12:15:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Language allows you to return errors\n\nBut because it has exceptions you will always have to deal with them as well. Even if we can't agree that exceptions are cleaner for common cases and typical non-critical programming, we can probably agree that exceptions are cleaner than both exceptions and error returns?",
                            "createdAt": "2016-02-14T12:16:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "s/ES6/ES7/",
                            "createdAt": "2016-02-14T12:16:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov\n\nBut because it has exceptions you will always have to deal with them as well.\n\nIf I wrap all the code or write it myself I can treat rejections as programmer errors and let them bubble.\n@bjouhier\n\nThat's not for node to decide. It's specified by ES6. And fortunately it's a throw.\n\nAgain, not entirely true. Async await turns rejections into throws, but you are free not to reject.",
                            "createdAt": "2016-02-14T12:20:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "If I wrap all the code or write it myself I can treat rejections as programmer errors and let them bubble.\n\nAnd will all node users want to write all the code themselves?",
                            "createdAt": "2016-02-14T12:22:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin\n\nAgain, not entirely true. Async await turns rejections into throws, but you are free not to reject.\n\nOf course, but they you will be resolving the promise with promise.resolve([err, result]) and banning promise.reject. That's weird.\nA lot of people mis-understand exceptions and try/catch. The whole beauty is that you are not forced to catch locally, and you should let the exception bubble. In (our) typical code, the ratio of throw to catch is 7 to 1: we throw liberally but we catch only in a few strategic places. Then code is not polluted by error handling boilerplate all over the place.",
                            "createdAt": "2016-02-14T12:26:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "And will all node users want to write all the code themselves?\n\nI've never said this should be in node. I just like the approach.\n\nIn (our) typical code, the ratio of throw to catch is 7 to 1: we throw liberally but we catch only in a few strategic places\n\nThis will change with async-await, unfortunately. Error handling is the essence of most production code.",
                            "createdAt": "2016-02-14T12:32:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "This will change with async-await, unfortunately. Error handling is the essence of most production code.\n\nWe are already using async-await and we have actually been using it for the last 5 years (through streamline.js). So nothing would change for us if we were to switch to async-await. The ratio would still be 7 to 1.\nAsync-await restores classical EH in async code. So you can let exceptions bubble. You don't need to trap them at every level.",
                            "createdAt": "2016-02-14T12:37:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin  Before continuing this argument I hope you look at any production project using language without exceptions e.g. on github. I think you are going to conclude they either don't even check errors or return it to the caller most of the time, or worse, return a successful value that is an error message string.",
                            "createdAt": "2016-02-14T12:41:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "I'm also with @kittens I have an idea, I'll bring it up in a separate issue.",
                            "createdAt": "2016-02-14T12:45:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I suspect our discussion is off-topic. I don't propose this approach to be used in node, so let's no pollute this thread.",
                            "createdAt": "2016-02-14T12:47:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin\n\n@benjamingr I don't think that conditional catch is a good idea in a dynamically typed language.\n\nFor what it's worth, almost every other dynamic language has it (e.g. Python) and people use it all the time. In addition, it could be a predicate - but I just wanted to give an example of how I'd deal with it.\nPeople have been using promises with async/await, Node and Babel for years now. The whole reason the TC added async/awaic is to enable people to write code this way - otherwise we'd just stick with generators.\n\nIf I wrap all the code or write it myself I can treat rejections as programmer errors and let them bubble.\n\nPromise rejections do not only symbolize programmer errors. This is fundamental and goes to the mental model of promises - it's what they do conceptually. Promises were born to serve as proxies for values - rejections symbolize regular exceptions and regular exceptions are not always programmer errors in the JavaScript language.\nEven things that are not programmer errors you'd want to bubble - it is about ownership and control - very often you can't deal with the vast majority of errors - it is about responsibility and passing it on the same way returning passes it on. My readCSVFile method should not be in charge of what to do when the file is not there - that's why Node code is typically full of if(err) return cb(err) because the error is very often propagated manually and when it is not most of the times it is a mistake.",
                            "createdAt": "2016-02-14T12:53:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin\n\nI suspect our discussion is off-topic. I don't propose this approach to be used in node, so let's no pollute this thread.\n\nThis is an important discussion to have and I honestly do appreciate you stepping up and representing the side I don't agree with. I don't think it's polluting the thread or off topic but of course if you feel like you'd like to take it elsewhere or alternatively not continue it - that's entirely up to you and I'm 100% cool with whatever you choose.",
                            "createdAt": "2016-02-14T12:59:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin\nA good way to reason about exceptions and organize EH code is to follow the contract metaphor:\n\nevery function that you write implements some kind of contract\nif the contract succeeds, the function returns normally.\nif the contract cannot be fulfilled the function throws.\n\nIf f1 calls f2, f3 and f4, and if f3 cannot fulfill its contract, then most of the time f1 will not be able to fulfill its own contract either. So the best it can do is fail (throw). Catching locally does not help (try { f3(); } catch (ex) { throw ex; } is just plain silly).\nThere are a few places in an application where contracts get looser. In these functions you can catch exceptions and still satisfy the contract. A typical example is a top level HTTP request dispatcher. At this level the contract becomes very loose and very generic; something like: \"dispatch the request and return an HTTP response, either a success one (2xx, 3xx) or an error one (4xx, 5xx)\". This is the right place to catch and return normally.\nYou also need to be careful about releasing resources and restoring program invariants but that's where try/finally comes to the rescue.\nThese classical EH patterns had become unusable in callback code because exception bubbling goes to the event loop instead of the logical caller. Async/await restores them.",
                            "createdAt": "2016-02-14T13:39:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "We can discuss it here: nodejs/NG#4",
                            "createdAt": "2016-02-14T13:50:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks @vkurchatkin, I'll post there.",
                            "createdAt": "2016-02-14T14:02:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "geppy",
                                "__typename": "User"
                            },
                            "bodyText": "For separating operational errors from programmer errors, has extending the Promise interface been considered?  e.g. catchUncheckedError?  The checked/unchecked distinction could either be made based on the error's type, or it could be made by module authors with e.g. return Promise.rejectUnchecked(error).",
                            "createdAt": "2016-02-14T15:40:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@geppy yes, it has been considered and @chrisdickinson seems to object to it because of implementation issues (subclassing Promise and adding a method that only fires on operational errors unlike .catch).",
                            "createdAt": "2016-02-14T15:51:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "geppy",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr Okay, great.  Thanks!",
                            "createdAt": "2016-02-14T15:54:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "Why distinguish between operational and programmer errors? If a function fails, why would you care if it is because of an operational or a programmer error?\nYou may want to trap very specific errors (timeout, file not found) locally, at the low level, because they can give you an alternate path to fulfill your contract (retry the operation, use default values) but all other errors, regardless of their type (operational or programmer), should just bubble up to the place where they will be caught and logged, with full stack trace (of the original exception of course).\nLater, someone will look at the logs, fix the bug if it is a programming error, fix the config/environment if it is an operational error, etc. but this will happen post-mortem.",
                            "createdAt": "2016-02-14T18:43:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I've written a summary of the current state of the PR, including the problems being worked on at present. Thanks all!\n\nI hesitate to post this because I do not feel safe voicing my opinions in the Node.js community, and especially around its TSC. The exclusive environment and tone, and desire to find ways to twist my words and smear groups I am a part of when I comment, make any engagement here potential deleterious to my mental/emotional well-being (as well as the reputation of said groups). So I will be immediately unsubscribing from this thread, and ask that you do not @-mention me going forward, so as to avoid at least the personal impact.\nBut I was asked offline by a few people to voice my opinion, with some urgency, so for their sake I am posting this here.\n\nThe summary blog post makes it very clear this discussion has been derailed in the name of \"compromise\". The invasive changes suggested there all have bad effects on the promise ecosystem. They bake in patterns that are not used by promise users in the wild, on behalf of people who don't use and often actively argue against promises.\nIt's unclear why non-promise users can come in and derail a discussion of a feature meant to help promise users, but that's been the modus operandi of this thread ever since its inception, and seems to be part of Node's decision making process (where experience with the feature being presented is not necessary qualification for commenting on how it should be changed).\nAs such, at this point I have already given up on this PR. Waiting a year for promise-based APIs to land unflagged in core, second-class behind a .promised, and in some mutated form or with some baked in syntactic sugar and documentation for the as-yet-unheard-of-in-the-promise-community .catch(e => errMap[e.code](e)) pattern, does not serve the needs of promise users. I plan to continue recommending people use shim packages from npm, which are derived from years of promise-community experience in exactly how promises are expected to behave.\nSo I think this PR is largely pointless; I believe promise people will continue to use packages from npm, and non-promise people will continue to use the existing interfaces. This PR just adds maintenance burden to core, and if it gets low adoption as I predict, only serves to give promise-detractors something to point to: \"well, we tried it, and nobody used it, so clearly promises are inferior to callbacks.\"\nBut its worse than that. Several of the work items suggested in that post, e.g. modifications to V8 or to the workings of the unhandledRejection event, will affect everyone in unfortunate ways---even if they never touch the new compromise-APIs. They will make the Node ecosystem even more hostile to promise users, at a technical level---beyond just the social hostility.\nAs such at this point I'd personally prefer this PR just be closed, and the matter be reconsidered in a year or two. Maybe by then enough of a critical mass of promise users will be engaged in core to be able to push back against the non-promise users who are \"compromise\"-ing this PR into something that actually hurts the promise community more than it helps.\n\nAgain, please do not try to re-engage me on this thread. I've laid out my opinion here on the request of others, and don't feel safe discussing it here personally. (Or, it goes without saying, on social media.)",
                            "createdAt": "2016-02-14T18:53:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "For what it's worth, I completely agree with domenic here. As a promises user, I don't really see how this pull request would benefit me at all. I've been trying to stay neutral and constructive but this is hard.\nI appreciate the discussion and would like to see progress on the post-mortem subjects mentioned. However, even if this API were to land I would personally not use the promise APIs exposed.\nPromises in ES are still young, the V8 implementation still isn't fast and promises are only now evolving (slowly but surely) capabilities such as cancellation and more extensive APIs.\nThe promise users who have been around more than a year or two are not in favor of this PR, we're frankly pretty terrified by the aggression level and the willingness to compromise for poor alternatives such as the let [err, data] = and quirky additional parameters. We feel like we've dealt with problems you describe in the past very well.\nThat's why I personally only ever asked for hooks and not for APIs with unhandledRejection. You have driven away one TC member (Domenic) and completely ignored the input of another (Sebastian (kittens)). You have suggested breaking the flow of libraries with over 6 million downloads a month (Q and Bluebird) as a valid path forward - when promises were called the language standard way to do things you objected defensively although that is very clearly the spec.\nI'm getting more and more convinced that despite the very sincere attempts of people here - nothing constructive will come out of this - promise users will not use these APIs anyway.",
                            "createdAt": "2016-02-14T19:13:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson ... Excellent summary. Thank you very much. I know this has\nbeen, and is continuing to be, a difficult process. I think this is heading\nin the right direction, even if there are still many details to work out\nthrough subsequent iterations... That's why it's experimental for now after\nall :) I doubt we'll get it right the first time and there are obviously\nmany issues to work out. We'll get there. +1 on the proposed direction.\nOn Feb 14, 2016 12:55 AM, \"Chris Dickinson\" notifications@github.com\nwrote:\n\nI've written a summary\nhttps://medium.com/@isntitvacant/adding-promise-support-to-core-a4ea895ccbda#.bjc9oixft\nof the current state of the PR, including the problems being worked on at\npresent. Thanks all!\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-14T19:16:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I will say also that I know there are people unhappy with where things sit\ncurrently with this. The reason for doing this behind an experiential flag\nis specifically to say that this isn't fully baked and needs to be looked\nat more in depth. It's very possible that everyone arguing against this\napproach are correct and that the experiment will fail and that we'll end\nup with something closer to what the detractors are arguing for. It's also\npossible that we'll all learn something new and come up with a solution\nthat's more in the middle that works even better. Let's get something\nstarted and see where the experiment takes us.\nOn Feb 14, 2016 11:13 AM, \"Benjamin Gruenbaum\" notifications@github.com\nwrote:\n\nFor what it's worth, I completely agree with domenic here. As a promises\nuser, I don't really see how this pull request would benefit me at all.\nI've been trying to stay neutral and constructive but this is hard.\nI appreciate the discussion and would like to see progress on the\npost-mortem subjects mentioned. However, even if this API were to land I\nwould personally not use the promise APIs exposed.\nPromises in ES are still young, the V8 implementation still isn't fast and\npromises are only now evolving (slowly but surely) capabilities such as\ncancellation and more extensive APIs.\nThe promise users who have been around more than a year or two are not in\nfavor of this PR, we're frankly pretty terrified by the aggression level\nand the willingness to compromise for poor alternatives such as the let\n[err, data] = and quirky additional parameters. We feel like we've dealt\nwith problems you describe in the past very well.\nThat's why I personally only ever asked for hooks and not for APIs with\nunhandledRejection. You have driven away one TC member (Domenic) and\ncompletely ignored the input of another (Sebastian (kittens)). You have\nsuggested breaking the flow of libraries with over 6 million downloads a\nmonth (Q and Bluebird) as a valid path forward - when promises were called\nthe language standard way to do things you objected defensively although\nthat is very clearly the spec.\nI'm getting more and more convinced that despite the very sincere attempts\nof people here - nothing constructive will come out of this - promise users\nwill not use these APIs anyway.\n\u2014\nReply to this email directly or view it on GitHub\n#5020 (comment).",
                            "createdAt": "2016-02-14T19:22:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@not-domenic\nNot everything under discussion is likely to be implemented, this is just the process of considering all the options available.\nNot everyone, and maybe no one, you are perceiving as hostile is a CTC/TSC member. Most have stayed out of this conversation except for @chrisdickinson who is trying to get this actually implemented. No decision has been made yet, so conjecture that the CTC/TSC or \"Node Core\" are hostile towards any Promise related change is unwarranted.\nCharacterizing the JS world as \"promise users\" and \"callback users\" is not a productive way to move forward. 8 years ago the JS world was entirely front-end browser developers. Since then the JS world has grown and expanded into a lot of other areas including systems programming and IoT and those platforms have very different needs and have arrived at some practices that enable JS developers to operate well on those platforms.\nThe feedback you're seeing from some systems programmers on Promises being unsuitable should be considered if you want Promises to be usable for system programming. Not having these considered prior is the natural result of the standards process having been completed without input from people who do systems programming at scale or from Node.js core developers that are aware of these kinds of use cases.\nIf Promises are to be suitable outside of the browser, and \"Promise users\" to eventually include people who do systems programming, we're going to need to find comparable solutions. Those solutions may not be exactly what we're doing right now for the non-Promises ecosystem, and continuing to hammer on the exact things we do around errors right now is no productive either, but these are valid concerns that eventually need to be addressed.\nThat said, we need to come up with something we can land that starts to make progress for Promise users even if it doesn't solve every problem in the entire world. This is too big of a shift to handle any other way than iteratively and the more we have people using platform level promises the more we learn and can inform these iterations.",
                            "createdAt": "2016-02-14T19:23:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal\n\nThat said, we need to come up with something we can land that starts to make progress for Promise users even if it doesn't solve every problem in the entire world.\n\nWhy? It seems like promise users are a-ok with userland solutions until the spec stabilizes and async/await lands.\n\nNot everyone, and maybe no one, you are perceiving as hostile is a CTC/TSC member.\n\nI respect you greatly, but I think you know exactly what and who domenic is talking about here.\n\nNot having these considered prior is the natural result of the standards process having been completed without input from people who do systems programming at scale or from Node.js core developers that are aware of these kinds of use cases.\n\nQuite a few promise libraries have received continuous input from server programmers (not sure what systems programming has to do with this). Most promise libraries I know, namely Q and bluebird are built with Node as a (if not the) primary consumer. For bluebird, the browser is just a secondary consumer - every feature in every step of the way is node first - browser second.",
                            "createdAt": "2016-02-14T19:28:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "Totally agree with Domenic and Benjamin here, as a promise user for several years, I will not use this implementation because it doesn't offer any advantages over the existing options. It is not better than Bluebird.\nDespite the heroic efforts of @chrisdickinson the discussion here has been derailed by repeated posts from people who are either ideologically against Promises or have extremely limited experience with them. It is effectively \"concern trolling\" at this point. There is no way to offer an implementation which will keep these people happy because they're actually looking for reasons to kill the feature entirely.\n@mikeal\n\nIf Promises are to be suitable outside of the browser\n\nThis is really the problem, you ask a question as if we're doing an experiment that we don't yet know the result of (another stated reason for releasing behind feature flags), but we do know the result, because many of us have been doing this for years. Promises are not just some alternative way to do async in 2016. They are the standardized, blessed, idiomatic One True Way core language feature. Node is waaaaaay late to this party, the experimentation happened years ago.",
                            "createdAt": "2016-02-14T19:40:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pesho",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal\n\nIf Promises are to be suitable outside of the browser\n\nI can assure you that Promises are very suitable outside the browser already (have been for a couple of years) and are used in many successful production systems.",
                            "createdAt": "2016-02-14T19:43:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Why? It seems like promise users are a-ok with userland solutions until the spec stabilizes and async/await lands.\n\n@chrisdickinson already did a pretty good job of outlining several issues that can't be solved without platform Promises. Additionally, all of these post-mortem concerns can't be solved without them either.\n\nI respect you greatly, but I think you know exactly what and who domenic is talking about here.\n\nThis thread is 400 comments deep and there are also other related threads so I may have missed some comments, but the comments I see as being hostile (and btw, I'm not happy with the way this is going) are not from CTC/TSC members -- but perhaps I missed something.\n\nQuite a few promise libraries have received continuous input from server programmers\n\nA lot of people write servers in languages and other platforms that don't have the same level of transparency and debuggability as we have built into Node.js over time -- so sure, lots of people are using and getting input in server programs using these Promise libraries. But a fair number of Node.js users at large companies managing Node.js at scale could not have adopted Node.js without these features.\nThe fact that none of this came up until we considered extending Core APIs to include Promises is a sign that the process we've been using for standards does not include enough input from JavaScript users that have only recently been able to use it. The places JavaScript is now relied upon has grown incredibly fast and we need to do some real work to get that feedback into the standards process. This is not the only example of this problem and several people are now working to try and improve this, but in the meantime I don't think it's healthy to not consider changes in these new standards given feedback from this broader user base and hopefully Node.js can be a vehicle for collecting and representing that feedback back into the process.",
                            "createdAt": "2016-02-14T19:45:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "They [promises] are the standardized, blessed, idiomatic One True Way core language feature. Node is waaaaaay late to this party, the experimentation happened years ago.\n\nThis is not productive.\nWhat we're trying to figure out here is \"what is the best way to enable Promises across Node.js' use cases.\" We have to consider the incredibly large and broad input of existing Node.js users in that process, anything less is irresponsible.",
                            "createdAt": "2016-02-14T19:56:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "I will not use this implementation because it doesn't offer any advantages over the existing options. It is not better than Bluebird.\n\nYa, I don't think that matters right now. Node.js Core is much more conservative about what is added than what can be done in the ecosystem, there's always going to be reasons to use ecosystem over native (performance being one that people have brought up constantly).\nThe important thing to do here is iteratively improve native Promises. Things that land in core have to be supported forever so taking our time and iteratively making the experience better based on feedback is the appropriate thing to do.\nPower users of Promises are likely to opt for more bleeding edge ecosystem libraries in the meantime.",
                            "createdAt": "2016-02-14T20:04:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "Catching up on this thread now \u2014 thanks all for your replies.",
                            "createdAt": "2016-02-14T20:06:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "One thing that I immediately note: I did a bad job of explaining the recovery object approach.\nThe recovery object does not touch promises at all. It is purely a pattern under consideration for the Node API \u2014 it gives users a chance to swap out the resolution value, but it doesn't touch the promise at all. Promises won't be augmented with extra methods, nor will their internal mechanics be altered. The recovery object allows users who wish to replace operational errors with resolution values to do so, without changing the promise itself (this is a pre-resolve/reject step). Users who do not wish to use the recovery object can simply omit the argument, and promises will work as-expected, rejecting on operational errors. This is currently the front-running approach for addressing the concerns of the error symposium group, since it doesn't modify the A+ spec and makes the default behavior the one most promise users expect, while letting others opt-in to \"recovering\" from operation error before promise resolution.\nI'll note the concerns with the const [err, value] = async destructuring approach \u2014 I think with what folks have expressed here, it's unlikely that we'll go that route.",
                            "createdAt": "2016-02-14T20:18:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal\n\nWe have to consider the incredibly large and broad input of existing Node.js users in that process,\n\nI didn't suggest otherwise. I singled out that particular fragment because it is reflective of the attitude of several of the post(er)s in here - there is no doubt as to their viability on the server because many, many large and successful applications are built on them. I also think that a lot of the other concerns raised in this very long thread are a result of people trying to misapply callback semantics to promises, when they are different. This is especially true of the operational errors vs programmer errors argument. It doesn't behave like a callback would because it is an asynchronous try...catch, and obviously if you catch an error it doesn't bubble. If you want to bubble, you rethrow, just like in synchronous code.",
                            "createdAt": "2016-02-14T20:40:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bjouhier",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode\nExceptions don't bubble with promises alone; but with promises + async/await they do.\nI'm a bit of an outsider to this debate but I feel that it is important to listen to the promise users here. Obviously they don't want a half-baked solution, they want the real thing.",
                            "createdAt": "2016-02-14T21:00:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "junosuarez",
                                "__typename": "User"
                            },
                            "bodyText": "I admire @chrisdickinson's considerable work in this thread. As a user of Node.js and of Promises who has used both in large scale production environments for quite some time, it is encouraging to see some parts of the community pushing for keeping Node.js up to date with the changing language and JavaScript platform. Unfortunately, I'm not at all surprised by the tone, tenor, and obstructionism I see in this thread, and in discussions surrounding it on social media. I would love to see features that make programmers' lives easier, such as ES2015 modules and Promises, treated as first-class features of the Node.js platform as part of a genuine commitment to make Node.js a friendly programming environment, but what I see instead is a heavy dose of conservative, _not-invented-here_ism that is really disappointing to see in a community so young.\nThis thread has devolved into a philosophical discussion of error handling in programs, which is not productive and beyond the scope of the change suggested in the PR.",
                            "createdAt": "2016-02-14T21:01:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@bjouhier they absolutely do bubble because promises don't exist in isolation - they form a chain and an error thrown will be handled by something along that chain in correct code. (By \"correct code\" I mean something which doesn't just outright ignore errors, analogous to ignoring the first argument in a callback, or an empty catch block)",
                            "createdAt": "2016-02-14T21:09:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@phpnode propagation in a sense, but very different. See the issues outlined in nodejs/post-mortem#16 .\n@bjouhier there have been whispers that await could be treated synchronously (if the promise already resolved), but if we unwind the stack we still will the problems of the post-mortem issue.",
                            "createdAt": "2016-02-14T21:15:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@bjouhier, @phpnode: None of the proposals affect the direct propagation mechanism that Promises use (and thus, that async/await relies on). One mitigation strategy involved immediately crashing on synchronous rejection (vs. hitting unhandledRejection), but it appears fairly unpopular so I do not believe we will be pursuing that route.\n@petkaantonov, Domenic, @phpnode, @benjamingr, thank you for weighing in. Your concerns are important to me and I'd like to make sure we end up with a promise API that is ergonomic for users. Noting that the recovery object aligns the default case of using the promise API with the existing shims, and that the recovery object does not modify the Promises/A+ spec, I'd propose that we move forward with that approach. This means that all errors are rejections, but users that wish to hook into certain error cases before the promise is settled can do so and prevent the rejection.\nWith regards to the needs of the post-mortem working group: I believe introducing an --abort-on-unhandled-rejection that skips non-user-installed rejection handlers and aborts immediately would be the best way to go. Unflagged, unhandled rejections continue to be computed at end-of-tick. It introduces some divergence between flagged and unflagged behavior, but the action of flagging makes the program more strict & produces a consistent outcome.\nWith regards to making the microtask queue pluggable, I believe that this work has to happen regardless of this API, since our lack of control over the queue makes implementing AsyncWrap and Domains as-expected for promises and Object.observe impossible. This does not necessarily imply that we must change rejection immediacy OR default unhandled rejection behavior.\nWith regards to making unhandledRejection crash if no user-installed rejection handler is present, I am curious to hear your thoughts. As a promise user, I personally avoid situations where I'll temporarily trigger unhandledRejection, since I can't rely on my consumers to not crash when I do so. I believe that this is a fairly common rule of thumb. It's optional that we do this, but it does bring us closer to the flagged --abort-on-unhandled-rejection behavior, and makes the default behavior a bit more consistent with how the rest of Node operates, which would be nice.\nWith regards to a require('fs/promise') API, if this PR is landed I will immediately follow up with a PR proposing a submodule approach so we can have that discussion. Your concerns that the existing approach does not work well with ES2015 modules are well-founded and I'd like to start addressing that as soon we get an idea of how we want to move forward with this API. We can work towards making the submodule approach the official approach to using the promise API before unflagging.\nThe API we are working towards in this PR, at present, looks like this:\nconst fs = require('fs')\n\ntry {\n  const data = await fs.readFilePromise('file/path')\n} catch (err) {\n  // ENOENT, etc\n}\n\n// for folks that _opt in_ to the recovery object:\nconst data = await fs.readFilePromise('file/path', {\n  ENOENT() { return fs.readFilePromise('other/file') }\n})\nAnd if merged, I will introduce a subsequent PR that will propose the following use:\nconst fs = require('fs/promise')\n\ntry {\n  const data = await fs.readFile('file/path')\n} catch (err) {\n  // ENOENT, etc\n}\nPromise users, is this direction desirable?\n\nIn closing, I know that this discussion can be frustrating and I appreciate your continued participation. There are more stakeholders than just promise users, and I believe we're working towards solutions that address their concerns while balancing the needs of promise users. It's a delicate balance, and it can easily get shifted too far to one side, and I appreciate you calling that out. I don't think that this conversation will become easier to have in the future \u2014 the folks involved now are the folks that will be involved for some time to come, and we're going to have to work to make sure everyone's comfortable with adding promises no matter how many users there are in the future. It's tough work, but I believe it's valuable to keep coming to the table and making sure that we're working towards a solution that will make life easier for our users. My goal is to mediate the concerns of all involved, to make sure that we're adding something that makes our users' lives better, without making anyone's life worse.",
                            "createdAt": "2016-02-14T21:23:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nPromise users, is this direction desirable?\n\ntry {\n  const data = fs.readFilePromise('file/path')\n} catch (err) {\n  // ENOENT, etc\n}\nI sure do hope that this isn't a synchronous throw. Is your example missing an await?",
                            "createdAt": "2016-02-14T21:26:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr Hah! Excellent catch. I did indeed intend an await. Fixing now :)",
                            "createdAt": "2016-02-14T21:31:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "In that case I am satisfied with the behavior. I still don't like the error recovery object as I still think a subclass could be a better approach - but I'll argue that on the related thread.",
                            "createdAt": "2016-02-14T21:33:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "idk if it matters to anyone but I've been working to make 'unhandledRejection' a bit more robust and have a default (Which has already been bikeshedded to death so don't yell at me here for it please.)\nstuck on what appears to be a V8 bug but hopefully I can get that sorted out this week",
                            "createdAt": "2016-02-14T21:43:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 I don't understand - there was a lot of discussion about how unhandledRejection works, when the hooks should fired and what the default behavior should be.\nAnything that's as much as adding any sensible default could break tens of thousands of Node programs and packages in the wild.\nI'm not against a default but this is something that should be discussed openly first, and so should changing the timings of the hook.",
                            "createdAt": "2016-02-14T21:52:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr To clarify, as I understand it @Fishrock123 is looking into making it so that promises that represent unhandled rejections abort the program when they are garbage collected by V8 \u2014 that is, when there is no longer a way for the user to handle the rejection. This shouldn't break any programs, and was discussed as a possible approach (IIRC) during a CTC meeting when the unhandled rejection behavior was being landed. When unblocked by the V8 hook, the changes will be PR'd so they can be discussed by the community before landing. We can definitely discuss the approach at that time. Hopefully that clarifies things a bit!",
                            "createdAt": "2016-02-14T21:57:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "To clarify, as I understand it @Fishrock123 is looking into making it so that promises that represent unhandled rejections abort the program when they are garbage collected by V8\n\nThat was the original plan but it changed somewhat. We can discuss when the PR is up.",
                            "createdAt": "2016-02-14T23:48:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "spion",
                                "__typename": "User"
                            },
                            "bodyText": "FWIW here is my final opinion\n(1) The postmortem concerns are valid. They cannot be solved without breaking current promise behaviour. I personally am not convinced that PM debugging is worth breaking promises, but I'd be willing to give one of the experiments a try (forbid async error handler attachments) as it doesn't affect userland solutions.\nAdding uncatchable exceptions on the other hand is very harmful and completely unacceptable. It breaks things for userland Promise users. For example, it will break bluebird's Promise.using guarantees and all the other similarly nice guarantees that promises provide.\n(2) The error concerns are invalid. The distinction between programmer errors and operational errors are imaginary in a dynamic language. Yes that goes even for the \"worst\" cases: e.g. in JavaScript you can generate a function from a string that was given by the user user. Its completely expected that this function might have typos. This extreme case is less likely but possible.\nThere are only expected and unexpected errors, and only the consumer side can decide which errors are expected and which aren't. (i.e. most consumers don't expect typos, but not all consumers). Even more, expected / unexpected errors don't always align with async / sync errors.\nThe above can be argued against, for sure, but the fact is that promises are designed in a way that fundamentally assumes it. Thanks to that, they provide guarantees and techniques to write robust and resilient code based on finally cleanup blocks (or handlers).\nI don't see how the method-based approach adds anything of value. Here is how you can achieve it with regular promises without adding anything. All you need is one combinator function and predicate functions for error types:\nfunction ifErr(predicate, handler) { if (predicate(e)) return handler(e); else throw e; }\nfunction ENOENT(e) { e.type == 'ENOENT' }\nThen\nawait fs.readFilePromise(file)\n    .catch(ifErr(ENOENT, e =>  fs.readFilePromise('other/file')))\nBut thats not the most important problem. The central problem is you can't really treat try/catch like panic/recover and use promises, at the same time. Thats just not how promises work: if someone wants things to work that way, they should just not use promises.",
                            "createdAt": "2016-02-15T00:07:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pesho",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson\n\nWith regards to a require('fs/promise') API, if this PR is landed I will immediately follow up with a PR proposing a submodule approach so we can have that discussion. Your concerns that the existing approach does not work well with ES2015 modules are well-founded and I'd like to start addressing that as soon we get an idea of how we want to move forward with this API. We can work towards making the submodule approach the official approach to using the promise API before unflagging.\n\nWhy provide several interfaces, instead of just picking the best one? The Perl ideology (\"There's more than one way to do it\") has been judged wrong by history.\nTo me require('fs/promise') is much more preferable than require('fs').promised and I'd rather skip the second one completely. This has several benefits:\n\nES6-style imports: import { readFile } from 'fs/promise'; vs ???.\nrequire('fs') will not load promisified variants, saving memory (for people who don't care about promises).\nThe changes to the existing modules will be minimal, thus minimizing the need for consensus-seeking.",
                            "createdAt": "2016-02-15T01:04:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@pesho\nTo address ???, it'd be:\nimport {promised: fs } from `fs`\n// or only a single function\nimport {promised: {readFile} } from `fs`\nWhich would let you do readFile with promises easily.",
                            "createdAt": "2016-02-15T09:26:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr I don't think you can use destructuring in import statements.\nThe first line has to be written as import {promised as fs} from 'fs'\nThe second is not possible in one line AFAIK.",
                            "createdAt": "2016-02-15T09:43:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sebmck",
                                "__typename": "User"
                            },
                            "bodyText": "@targos is correct. The promised property is not going to be ergonomic for promise users due to this. An alternate module source would be best like the suggested fs/promise.",
                            "createdAt": "2016-02-15T09:47:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Oh yeah, that's definitely my bad @targos - indeed it would require a second line. I never had to do it and I guess I just assumed it'd work.",
                            "createdAt": "2016-02-15T11:18:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "chrisdickinson",
                                "__typename": "User"
                            },
                            "bodyText": "@pesho, @kittens, @benjamingr: Yep \u2014 I'll be following up this PR with a PR that creates a require('fs/promise') module just for that use case. If we can get consensus on that before unflagging promises the promise API, that will be the official way to access top-level Promise APIs.",
                            "createdAt": "2016-02-15T19:17:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "balupton",
                                "__typename": "User"
                            },
                            "bodyText": "As no one has mentioned it yet. Discussion of this PR has been split up into individual discussions on https://github.com/nodejs/promises to improve digestion - discussion will likely continue here for things related specifically to this PR only, and using https://github.com/nodejs/promises for commenting on any topics that are already over there (see its issue tracker).",
                            "createdAt": "2016-02-16T15:08:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "One other point. Please keep any further discussion on this PR focused on the technical review of this PR. The proper venue to discuss the more meta level issues of promises in core is the new promises repo. Comments in this PR that are off topic can and likely will be moderated. It's also possible that we may lock the thread for non collaborators. We don't like doing that and don't want to do that so please keep the conversation focused and on topic.",
                            "createdAt": "2016-02-16T15:38:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danbucholtz",
                                "__typename": "User"
                            },
                            "bodyText": "@chrisdickinson, there's a lot to take in here \ud83d\ude04 . Is there an update on the general topic of Node.js core API supporting promises instead of callbacks?\nThanks,\nDan",
                            "createdAt": "2016-10-26T05:44:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Closing given the lack of forward progress on this. We'll definitely want to revisit this later tho.",
                            "createdAt": "2017-02-28T23:08:58Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 18131,
            "title": "esm: provide named exports for all builtin libraries",
            "author": {
                "login": "devsnek"
            },
            "state": "CLOSED",
            "closedAt": "2018-04-29T13:41:39Z",
            "comments": {
                "totalCount": 274,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83d\udc4d strongly for merging this.\nMy only comment would be if there might not be a maintenance burden being created by this approach that might be mitigated with enumeration of the exports at load time, provided we can ensure we don't expose the wrong things (perhaps filtering _... properties etc). Would be interested to hear thoughts on this approach.",
                            "createdAt": "2018-01-13T12:08:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford i chose this over runtime enumeration because of the results in my last pr where i attempted forward evaluation but i guess if we can guarantee our libs won't have errors on evaluation it should be fine? i don't think our public api changes that much for it to be a real burden. this also lays groundwork for writing core parts of node in esm, although i don't know if that matters much to people. it should be noted that if we switch to runtime enumerating with out of order evaluation then the current issues i'm having with tests will also go away, and it will get rid of people who make loaders worrying about resolving both kinds builtins, which is definitely a confusing process.",
                            "createdAt": "2018-01-13T16:24:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek thanks for clarifying. Personally I think the runtime creation would be better as it would avoid the need for the new builtin interpretation mode, remove the maintenance burden of maintaining the wrappers (generated or not), and it would effectively be exactly the same algorithm to build up the exports, saving an extra file load anyway to do that.",
                            "createdAt": "2018-01-13T16:28:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford i just know there was significant opposition to out-of-order evaluation in my previous pr, but maybe @bmeck its fine in this case?",
                            "createdAt": "2018-01-13T16:29:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Personally I don't seen an issue with considering core modules \"preevaluated\" (from the esm loader perspective). It's user dependencies with circular references and errors that we have to worry about for that issue.",
                            "createdAt": "2018-01-13T16:34:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "I don't like that the exports can go out of sync but am not blocking that at this point. I'd love it if the backing object could stay in sync for a variety of reasons, but all approaches I've tested are problematic for performance.",
                            "createdAt": "2018-01-13T16:36:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek could you make the ESM facades eagerly populate even when required so that they stay the true primordial form of the exports?",
                            "createdAt": "2018-01-13T16:39:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck i'm not sure what you mean by \"true primordial form\" but my method would basically be:\nloaders.set('builtin', async (url) => {\n  const module = InternalModule.require(url.slice(5));\n  const properties = Object.getOwnPropertyDescriptors(module);\n  const keys = ['default'];\n  for (const [name, prop] of Object.entries(properties)) {\n    if (!prop.enumerable || !prop.value)\n      continue;\n    if (/(^_)|(_$)/.test(name))\n      continue;\n    keys.push(name);\n  }\n  return createDynamicModule(keys, url, (reflect) => {\n    reflect.exports.default.set(module);\n    for (const key of keys)\n      reflect.exports[key].set(module[key]);\n  });\n});",
                            "createdAt": "2018-01-13T16:41:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek I just want to be sure that if you mutate fs it does not mutate the named export value depending on timing.\nconst fs = require('fs');\nfs.readFile = () => {}\nimport {readFile} from 'fs';\n// should never be that noop function (even if this file is loaded after the one above)",
                            "createdAt": "2018-01-13T16:43:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck i don't know of any way to guarantee at all, even requiring every builtin before user code runs and keeping a cache would still allow user mutation of the exports object.",
                            "createdAt": "2018-01-13T16:45:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek the same sort of technique we use to eagerly inject CJS modules into the loader registry for this should work here for the core modules I think?",
                            "createdAt": "2018-01-13T16:46:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "(I know it's not pretty, but it provides the invariants)",
                            "createdAt": "2018-01-13T16:47:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "New approach looks good.",
                            "createdAt": "2018-01-13T19:25:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Note that require('crypto') will throw an error if openssl is not available.",
                            "createdAt": "2018-01-13T22:24:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/12520/",
                            "createdAt": "2018-01-13T22:40:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Compiling with ./configure --without-ssl .. then running the test:\n$ ./node --experimental-modules test/es-module/test-esm-wrappers.mjs\n(node:6990) ExperimentalWarning: The ESM module loader is experimental.\nError [ERR_NO_CRYPTO]: Node.js is not compiled with OpenSSL crypto support\n    at Object.assertCrypto (internal/util.js:89:11)\n    at internal/http2/core.js:5:26\n    at NativeModule.compile (bootstrap_node.js:653:7)\n    at NativeModule.require (bootstrap_node.js:564:18)\n    at http2.js:19:5\n    at NativeModule.compile (bootstrap_node.js:653:7)\n    at Function.NativeModule.require (bootstrap_node.js:564:18)\n    at Function.NativeModule.requireNamespace (bootstrap_node.js:586:18)\n    at loaders.set (internal/loader/ModuleRequest.js:61:31)\n    at new ModuleJob (internal/loader/ModuleJob.js:24:26)",
                            "createdAt": "2018-01-13T23:08:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell i removed crypto from the test in my last push (along with inspector, punycode, domains)",
                            "createdAt": "2018-01-13T23:14:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "shouldn't remove crypto, but can skip it by checking for common.hasCrypto\nalso... the http2 and tls  modules will also fail to load when compiling with --without-ssl.",
                            "createdAt": "2018-01-13T23:28:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell we can't really \"skip\" modules because they're static, the only real fix is to remove them",
                            "createdAt": "2018-01-13T23:38:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "ah, right forgot about that fun little feature. The way to do it then would be to create the test as a cjs that launches another node child process with either a \"has ssl\" or \"does not have ssl\" variant.",
                            "createdAt": "2018-01-13T23:42:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton i'm not sure what your comment means, if its in reference to filtering out underscore props, i see no reason to expose and continue to allow people do use things like fs._toUnixTimestamp (which i'm about to pr move to internal/fs actually), and my docs for this say that only the publicly documented api is available as named exports.",
                            "createdAt": "2018-01-14T02:44:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek\n\ni'm not sure what your comment means\n\nFilters as with your code to exclude exports with leading or trailing _ isn't how Node handles removal of APIs. If it's exported in CJS then it should be accessible as a named export. If the export is not desired then there is a process in place of deprecation and removal of the exported value.\nSee my comment on a similar discussion for Module.builtinModules.",
                            "createdAt": "2018-01-14T02:46:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i feel like we're at an impasse here. i'll leave it unless a node person has a problem with it. my docs for this say that only the publicly documented api is available as named exports, and you can do like import x from 'x' x._notDocumentedThing, just not import { _notDocumentedThing } from 'x'",
                            "createdAt": "2018-01-14T02:48:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "and you can do like import x from 'x' x._notDocumentedThing, just not import { _notDocumentedThing } from 'x'\n\nThat seems like unnecessary code juggling. Accessible is accessible.",
                            "createdAt": "2018-01-14T02:59:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I tend to agree with @jdalton. It doesn't seem necessary to filter those exports out. If we don't want to expose them, we must go through a proper deprecation cycle and remove them entirely (on a case by case basis).",
                            "createdAt": "2018-01-14T12:20:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not too strongly opinionated one way or the other with regards to exposing undocumented properties. OTOH I would like to point out that as of right now, it is not too easy to deprecate exports in ESM. In CJS, we would just make exports.deprecatedExport a getter so that the user sees the warning the first time the export is used, but that's not really possible for ESM unless V8 adds more hooks. Because of this, a part of me likes the simplicity of not exposing the deprecated export at all.",
                            "createdAt": "2018-01-14T19:17:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "In CJS, we would just make exports.deprecatedExport\n\nNode's ESM pipeline should know the requested named exports up front and can warn as needed.",
                            "createdAt": "2018-01-14T19:44:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton V8 currently doesn't expose that; hence \"unless V8 adds more hooks\".",
                            "createdAt": "2018-01-14T19:45:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "In CJS, we would just make exports.deprecatedExport a getter so that the user sees the warning the first time the export is used, but that's not really possible for ESM unless V8 adds more hooks.\n\nThen Node should change their policy of deprecations from getters to something else for future releases to reduce bookkeeping and simplify CJS/ESM interop. I still think filters should continue to be avoided. If a limited set is unavoidable due to implementation constraints then it is what is it. But as is in this PR it's too restrictive (it excludes things without getters too).",
                            "createdAt": "2018-01-14T19:47:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "FWIW, _-prefixed properties are already covered by the public/private API distinction and the deprecation policy. Specifically, they are explicitly considered private API unless publicly documented. To make them a public API, a public alternative alias should be created and the _-prefix deprecated. This is the pattern we have followed in the past.\nI'm -1 on exporting _-prefixed properties via ESM unless they are already documented as part of the public API. I'd be +1 on having a public supported variant created for those if a case can be made for it.",
                            "createdAt": "2018-01-14T21:31:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell\n\nSpecifically, they are explicitly considered private API unless publicly documented.\n\nFrom a user perspective I see it as \"Why does\nconst { _extend } = require(\"util\")\nand\nimport util from \"util\"\nconst { _extend } = util\nwork, but not\nimport { _extend } from \"util\"\nIt seems like an unnecessary stumbling block when the API is already accessible.\nConfusing to users for sure.",
                            "createdAt": "2018-01-14T21:46:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "_extend is internal and (as i understand it) using it is unsupported anyway because of that, so a user asking about it would probably just get pointed to that url that jasnell posted. additionally in my pr i say that only the public api is namespace'd.",
                            "createdAt": "2018-01-14T21:53:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I'm using _extend as an example of an accessible API. We shouldn't be looking for excuses to shortchange the user experience here. Step back and look at it.\nWe're giving users named export support for builtin modules so they can have that oh-so-nice Babel-like-syntax they're used to. If we're doing it, we should do it. Named exports isn't the hill to fight what should be accessible and what shouldn't. These things are already accessible.",
                            "createdAt": "2018-01-14T21:54:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton ... what I'm saying is that if it makes sense to expose _extend() as something userland can use, then it makes sense to expose it as util.extend() (that is require('util').extend() and import { extend } from 'util';) rather than exposing it with the _-prefix. The _extend() alias can then be deprecated.",
                            "createdAt": "2018-01-14T22:55:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Another thing to keep in mind: just because something is not exposed by default in this iteration, does not mean a future PR cannot expose something if a case can be made for it.",
                            "createdAt": "2018-01-14T22:57:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell\n\nwhat I'm saying is that if it makes sense to expose _extend() as something userland can use, then it makes sense to expose it as util.extend().\n\nThat's not really for named exports to decide. If the change comes, it should come to CJS and naturally shake out of named exports.\n\nAnother thing to keep in mind: just because something is not exposed by default in this iteration, does not mean a future PR cannot expose something if a case can be made for it.\n\nWhy not side on being more open and consistent with similar design choices by default.",
                            "createdAt": "2018-01-14T23:04:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "I'll just add my -1.  If we're introducing a parallel module system, we might as well clean up a little.  Most underscored properties are accidents of history, they're not by design.\n(I should know, I authored a couple.)",
                            "createdAt": "2018-01-14T23:15:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis can you be more explicit about what that -1 is for? i can't tell if you mean the pr or something about the export filters.",
                            "createdAt": "2018-01-14T23:16:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek re-exporting everything wholesale, same as what James mentioned.",
                            "createdAt": "2018-01-14T23:18:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis\n\nI'll just add my -1. If we're introducing a parallel module system\n\nThis is a bit of an interesting space as we're adding named exports to meet the existing CJS/Babel ecosystem expectation. I agree underscored prefixes aren't great but don't think cherry-picking one syntax flavor to omit it from while leaving it accessible everywhere else (even ESM default imports) is a good thing. Let's work to remove them from CJS, to remove the root issue, instead of this one-off syntax exception.",
                            "createdAt": "2018-01-14T23:32:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "Current tally among Collaborators folks on the issue of underscore filtering:\n\n\n\nFor\nAgainst\n\n\n\n\n@guybedford\n@targosTSC\n\n\n@jasnellTSC\n@TrottTSC\n\n\n@bnoordhuis\n@iarna\n\n\n@mcollinaTSC\n@jdaltonnot Collaborator\n\n\nme\n@ljharbnot Collaborator\n\n\n@devsneknot Collaborator\n\n\n\n\nCC'ing @nodejs/tsc.",
                            "createdAt": "2018-01-15T03:58:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "I'd prefer we don't filter on the grounds that making behavior of named imports different from default ESM imports seems like something that will annoy/confuse users and be ineffective as people will rewrite to use default ESM imports rather than not use the underscore-prefixed properties.",
                            "createdAt": "2018-01-15T04:16:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "iarna",
                                "__typename": "User"
                            },
                            "bodyText": "I agree with @jdalton here, esm exports should always be the same as cjs exports. Having different interfaces based on module type is not user focused. I feel your pain, I wish we could say \"the contract are documented interfaces only\", but in reality users will use everything available and if we want to actually serve their needs, we need to treat them as part of the contract.\n-1 on filtering",
                            "createdAt": "2018-01-15T05:47:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "not sure if i get a vote or not, but i'm +1000 on removing underscored properties as quickly as semver allows, and -1 on making ESM and CJS have different APIs.\nReachable is public, regardless of what your documentation desperately insists.",
                            "createdAt": "2018-01-15T06:45:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I am +1 to filtering until we have a way for us to do runtime-deprecation for ESM. I think that should happen anyway, because otherwise we\u2019ll have no way to deprecate things. If this is not possible (by the spec), we should revist our deprecation policies before implementing this.\nI propose we land this with filtering, and we start a separate discussion around deprecation and ESM, and remove filtering when that is done.",
                            "createdAt": "2018-01-15T06:53:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "I'm with @jdalton, where for me it's a question of predictability: the less exceptions there are, the better. It's easier to explain and understand \"const {readFile} = require('fs') is exactly like import {readFile} from 'fs'\", and not same, with \"except for...\". The simpler the better.\nAnd if we/you want to kill the underscore methods that are visible, deprecate them in CommonJS too.",
                            "createdAt": "2018-01-15T07:30:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "I agree with @jdalton. A huge codebase should be able to be converted from require to import with nothing but a regexp, whether it uses internals or not. Adding blocks to prevent that here is piggy-backing to solve an issue that should have nothing to do with this.",
                            "createdAt": "2018-01-15T07:46:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "A huge codebase should be able to be converted from require to import with nothing but a regexp, whether it uses internals or not. Adding blocks to prevent that here is piggy-backing to solve an issue that should have nothing to do with this.\n\nExactly. I'm sure we all want to make the migration to ESM as easy as possible. Filtering some of the exports for non-technical reasons is just going to make users unhappy.\nAbout deprecation: the vast majority of our deprecated APIs are exported in a way that is compatible with named imports: exports.xyz = deprecate(xyz, 'xyz is deprecated'). I don't think we are likely to change this in the future.\nIt's true that we have an issue with getters and setters, but this is not related because they are filtered regardless of the presence of an underscore",
                            "createdAt": "2018-01-15T08:27:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "A huge codebase should be able to be converted from require to import with nothing but a regexp\n\nThis sounds useful, but isn't if you really think about it. To convert a huge codebase, all access to exports would also need to be changed, and there are a lot of ways to export things with CJS: module.exports = { a: function () { ... } };, exports.abc = abc;, module.exports.abc = ..., ... A codemod is the way to go.",
                            "createdAt": "2018-01-15T08:42:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "I'd like to pose an example of a case where ESM is successfully used as a barrier for old/new paradigms: the language itself. By forcing strict mode, the Module parse goal is able to get rid of a lot of things that are considered bad practices, some of the most notorious being eval('var a = 0'); assert(a === 0); and with statements. I don't see why Node.js shouldn't be allowed to do the same.",
                            "createdAt": "2018-01-15T08:46:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ericelliott",
                                "__typename": "User"
                            },
                            "bodyText": "Against underscore filtering.",
                            "createdAt": "2018-01-15T08:49:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@TimothyGu I would agree with you if it was completely impossible to access those APIs from ESM. IMO, if someone was adventurous enough to go against the documentation and best practices to use an undocumented API, they will try to do the same with a named import, lose time to find that they can access it from the default import and continue to use it from there.",
                            "createdAt": "2018-01-15T08:54:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "The blanket conversion rule is to convert require(\u2018x\u2019) into import x from\n\u2018x\u2019 for any require. This will still provide the private properties.\n\nNamed exports here are only for core modules, making them a convenience in\nnewly written code only. Private properties can always be added later if\nthis is a problem as mentioned.\n\nThe lack of consistency does create a friction for users yes, but that is\nintentional. It encourages private properties not to be used while there is\nstill that escape hatch through the default import form to use them.\n\nMany users new to the APIs will inspect objects to see what they can use.\nKeeping private properties on this interface implicitly encourages their\nuse.\n\u2026\nOn Mon, 15 Jan 2018 at 10:49, Eric Elliott ***@***.***> wrote:\n Against underscore filtering.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiyum-3QZLf-zMwL4nQuI_qojuMOP2ks5tKxEpgaJpZM4RdLYy>\n .",
                            "createdAt": "2018-01-15T08:55:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Many users new to the APIs will inspect objects to see what they can use.\nKeeping private properties on this interface implicitly encourages their\nuse.\n\nTo inspect the properties, they would be using a default import, so they'll see the private properties anyway. (Or am I mistaken?)",
                            "createdAt": "2018-01-15T10:28:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "To look at a module\u2019s shape would be the import * form or console.log(await\nimport(\u2018fs\u2019)). Also named exports hints will be given by IDE and typing\nsystems illustrating this shape which then would or wouldn\u2019t enumerate\nprivate names on the outer shell depending what we decide here. Although\ncertainly the inconsistency will be visible if they look directly at the\ndefault.\n\nAre there any existing cases for core modules where these private names are\nconsidered endorsed for use?\n\u2026\nOn Mon, 15 Jan 2018 at 12:28, Rich Trott ***@***.***> wrote:\n Many users new to the APIs will inspect objects to see what they can use.\n Keeping private properties on this interface implicitly encourages their\n use.\n\n To inspect the properties, they would be using a default import, so\n they'll see the private properties anyway. (Or am I mistaken?)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiynooudSUdL1hRkEcrvVJ7rMqkd4nks5tKyg4gaJpZM4RdLYy>\n .",
                            "createdAt": "2018-01-15T11:05:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fuzzyma",
                                "__typename": "User"
                            },
                            "bodyText": "It makes no sense to filter it there and have it there. Code should always follow the least path of confusion.\nI would be confused when I inspect the objects and notice it. You can be sure to have a few stackoverflow topics only around this issue as soon as you include that inconsistency. It event might be reported as bug here and you are allowed to deal with it then.\nThe question is: Will it harm anyone to not filter it? I dont think so. The opposite on the other hand is not true.",
                            "createdAt": "2018-01-15T11:31:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "The question is: Will it harm anyone to not filter it?\n\nIt will harm people who actually use these properties, in the sense that they\u2019re putting themselves into a position where their code has a higher likelihood of being broken in the future.",
                            "createdAt": "2018-01-15T11:41:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fuzzyma",
                                "__typename": "User"
                            },
                            "bodyText": "It will harm people who actually use these properties, in the sense that they\u2019re putting themselves into a position where their code has a higher likelihood of being broken in the future.\n\nAnd they do that at their own risk and they know it! The API is documented so you know what you should use and what you shouldnt (and its wide spread knowledge that properties prefixed with '_' are private). Beside this simple fact, you can still access the property in another way and people will do that no matter what you do. So \"the harm\" will not go away by removing underscored props from the export list.\nThey are still there - it just makes no difference. It only introduces confusion",
                            "createdAt": "2018-01-15T11:46:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "realityking",
                                "__typename": "User"
                            },
                            "bodyText": "Not sure if that\u2019s feasible but have you considered filtering the default export as well?\nThis would prevent monkeypatching modules but given how ESMs work that seems like a good thing.",
                            "createdAt": "2018-01-15T12:08:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "satya164",
                                "__typename": "User"
                            },
                            "bodyText": "-1 on filtering. deprecating should be done with a proper process, not by piggybacking a new syntax.",
                            "createdAt": "2018-01-15T13:09:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "styfle",
                                "__typename": "User"
                            },
                            "bodyText": "I think ESM and CJS should work and the underscores should not be filtered out.\n\nWill it harm anyone to not filter it? It will harm people who actually use these properties, in the sense that they\u2019re putting themselves into a position where their code has a higher likelihood of being broken in the future.\n\nOn the contrary...I'll give you a use case why it will harm people to filter: because they have already written the \"broken\" code with ESM. Many many many people have already author ESM using Babel or TypeScript and transpiling to CJS. When Node.js ships with ESM enabled, people will begin to disable their transpilation step and ship the code as-is. That old code will break if you filter out those properties.\nThis will hinder the adoption of ESM! Removing deprecated properties is completely orthogonal to ESM implementation and should be a separate PR removing it from both CJS and ESM exports.\n\nTo reiterate some responses above that are very sensible:\n\nI agree underscored prefixes aren't great but don't think cherry-picking one syntax flavor to omit it from while leaving it accessible everywhere else (even ESM default imports) is a good thing. Let's work to remove them from CJS, to remove the root issue, instead of this one-off syntax exception.\n\n\nfor me it's a question of predictability: the less exceptions there are, the better. It's easier to explain and understand \"const {readFile} = require('fs') is exactly like import {readFile} from 'fs'\", and not same, with \"except for...\". The simpler the better.\n\n\nPerhaps we should vote on it?",
                            "createdAt": "2018-01-15T15:01:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/tsc ... this needs to be on this weeks agenda for possible vote. (ping @mhdawson and @Trott)\nThere is another possibility here: we export the _-prefixed options via ESM with a deprecation warning right off the start.",
                            "createdAt": "2018-01-15T16:12:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I'm confused why those wanting filtering have not mentioned/endorsed filtering from the default export too. This makes me think the drive to remove API warts (a good drive) is overriding all-the-things (maybe not so good). I could more easily understand their view if those same folks where in favor of a more consistent filter for ESM, but this one-off syntax exception isn't great as others have pointed out.\n@jasnell\n\nThere is another possibility here: we export the _-prefixed options via ESM with a deprecation warning right off the start.\n\nYou mean triggering a warning for when imported as a named export import { _extend } from \"util\" but not when just import util from \"util\" right? I didn't think that was technically possible for named exports at the moment (requires V8 hooks). However, if it was on named exports I'd expect them deprecated on access from the default export and in CJS equivs too \ud83d\udc4d",
                            "createdAt": "2018-01-15T18:37:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "How exactly could you cause a deprecation warning to be triggered upon a named import?",
                            "createdAt": "2018-01-15T19:29:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb i think the idea is warning on first function call instead of using a getter",
                            "createdAt": "2018-01-15T19:37:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "i think the idea is warning on first function call instead of using a getter\n\nNice! As long as it's also deprecated in CJS \ud83d\ude4c",
                            "createdAt": "2018-01-15T19:42:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "On a side-note, why do we even need import fs from 'fs' if import * as fs from 'fs' is possible? Seems weird to me to export all the exports as the default export, why the exportception?\nTo me it seems like that can create inconsistencies down the line because other core modules might want to have a real default export.",
                            "createdAt": "2018-01-15T21:04:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, that's actually a really good point - the ESM versions should probably only have a default export if the default export is a function.",
                            "createdAt": "2018-01-15T21:14:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "having a default lets people have a channel for synchronization w/ the CJS equivalent, access properties that are not valid identifiers, and monkey patch things.",
                            "createdAt": "2018-01-15T21:16:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck could you explain what you mean by \"synchronization\"? What exports are there that are not valid identifiers? If I monkey-patched readFile, would that even update named imports?",
                            "createdAt": "2018-01-15T21:19:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck what specific properties of module.exports on a core module are invalid identifiers that they'd need to access?",
                            "createdAt": "2018-01-15T21:21:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "How exactly could you cause a deprecation warning to be triggered upon a named import?\n\nTBD :-) ... I'd have to dig in to the details on the loader implementation to work it through, and even then I doubt we'd be able to cover it 100%... which actually raises an interesting point about how we are going to support deprecation of ESM exported APIs in general... but that's a separate topic.",
                            "createdAt": "2018-01-15T21:43:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamn",
                                "__typename": "User"
                            },
                            "bodyText": "As an alternative to filtering underscored properties (caveat: I don't really want to do this, but I thought it might be a helpful suggestion), what if you exposed only enumerable properties as named exports, and gradually began the process of hiding properties like _extend by making them non-enumerable? That way, you'd be reusing a concept already present in the language (enumerability) without giving special meaning to the names of certain properties.",
                            "createdAt": "2018-01-15T22:32:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "That doesn\u2019t address the existing code and expectation that named exports are like destructuring; which doesn\u2019t depend on enumerability.",
                            "createdAt": "2018-01-15T22:46:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamn",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb To be clear, I would be happiest if we rejected filtering of any kind. If we must do filtering, I would prefer a strategy where we do not assign special meaning to underscored method names.",
                            "createdAt": "2018-01-15T23:38:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb\n\nmodule.exports on a core module are invalid identifiers that they'd need to access?\n\nAnything they tack on after node boots up, anything that is mutated after node boots up (since named imports only return primordial form [not APM tooled form etc]).",
                            "createdAt": "2018-01-15T23:48:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck sure, but those things would never need to be named exports, and there need be no expectation that adding a property to require('fs') would somehow expose that property on any import of 'fs'.",
                            "createdAt": "2018-01-15T23:58:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb correct to an extent, but thats why we want default because people actively do that.",
                            "createdAt": "2018-01-16T00:00:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "My understanding is that ES modules were designed so that exports and imports are frozen as a feature. Should Node really work around that? What are the use cases?",
                            "createdAt": "2018-01-16T00:04:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@felixfbecker not sure what you mean. ES imports are shared bindings that are not able to be assigned to by the importer, they can observe changes. ES exports are bindings that are visible in other modules and can be mutated.",
                            "createdAt": "2018-01-16T00:06:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck Right, but why do we need to enable that kind of hacky mutation, rather than the absence of it motivating a proper solution?",
                            "createdAt": "2018-01-16T00:09:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb if people want to completely disable it and not give graceful-fs/APMs/etc. hooks immediately, that seems fine to me.",
                            "createdAt": "2018-01-16T00:12:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck Sorry, I mean that a modules exports are declared statically and cannot be changed later at runtime and consequently import * as foo makes foo frozen object that cannot be mutated (properties added, changed or removed) afterwards by neither the importer, the exporter or any other file.\nSo if we look at fs as a module with readFile etc as its exports, in the ESM world there is no way to add, change or remove exports of it (and affect the imports) at runtime. E.g. I would not be able to change the readFile that some other file imported through import {readFile} from 'fs'.\nPlease correct me if I'm wrong",
                            "createdAt": "2018-01-16T00:13:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@felixfbecker correct, thats why we were talking about the default export which is currently the module.exports value of the CJS form, which can add/remove properties since it is not a Module Namespace.",
                            "createdAt": "2018-01-16T00:17:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck So if I monkeypatch the default export, it would also only affect other import fs from 'fs' imports of that module. import * as fs and import {readFile} from 'fs' would not be affected. I think that would be incredibly confusing behaviour, I can see countless SO questions about why monkey-patching works for some files but not for others. The difference will not be clear to users, and there will still be no reliable way to affect all imports, making the workaround mostly useless.",
                            "createdAt": "2018-01-16T00:19:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@felixfbecker I'm somewhat neutral, though lots of tools replace existing core module properties, and they won't be able to simulate that behavior with this approach. They would need to use a --loader in current impl.",
                            "createdAt": "2018-01-16T00:24:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "So the only way I see to satisfy consistency (and the needs of users that want to reliably change core module behaviour) is to either have only the default import and no named exports at all or to have only named exports. I personally see the whole static nature of modules as a feature, so I would omit the default export for ESM and work on better solutions for those use cases (use CJS, use wrapper libraries instead, make libraries accept a different fs implementation as an option as seen with Promises, add a hook API, ...). No named imports from fs would be very sad.",
                            "createdAt": "2018-01-16T00:34:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@felixfbecker Neither necessarily must be the outcome; for some modules it makes perfect sense to have a default export and named exports. The issue is attempting to minimize (even if it can't be fully achieved) exposing the specific module.exports object, to reduce the surface area for mutations to pollute unrelated code.\nA default export is what a module is, a named export is something a module has. There are important use cases for both, sometimes in the same module.",
                            "createdAt": "2018-01-16T00:40:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamn",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck Will --loader be able to override resolution of Node built-in modules (for ESM import as well as CJS require)? If so, that seems like a reasonable hook strategy for graceful-fs. If not, it sounds like graceful-fs will need special hooks to wrap named exports.",
                            "createdAt": "2018-01-16T00:41:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamn it has complete control of resolution but limited hooks intentionally.",
                            "createdAt": "2018-01-16T00:42:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb to clarify, with \"default export\" I only meant the default export discussed here (essentially an object that has the same properties as all the named exports). Nothing against default exports in general (e.g. url could default-export URL).",
                            "createdAt": "2018-01-16T00:45:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ericelliott",
                                "__typename": "User"
                            },
                            "bodyText": "So if I monkeypatch the default export, it would also only affect other import fs from 'fs' imports of that module. import * as fs and import {readFile} from 'fs' would not be affected. I think that would be incredibly confusing behaviour, I can see countless SO questions about why monkey-patching works for some files but not for others. The difference will not be clear to users, and there will still be no reliable way to affect all imports, making the workaround mostly useless.\n\nThe monkey in the room:\nMonkeypatching exports is an edge case. It's rare. I can think of only a handful of modules in the OSS wild that actually depend on it, and one of them (RxJS <5.5) has a new version that doesn't need the monkeypatching anymore.\nThe majority case is simple. People expect these to be equivalent in most situations:\nimport foo from 'foo';\nconst foo = require('foo');\nIt's true there are subtle differences and they'll never be exactly equivalent, but it can be good enough, and there are work-arounds for when it's not.",
                            "createdAt": "2018-01-16T05:44:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@ericelliott I think this is more about applications doing things like globally replacing fs implementation with e.g. graceful-fs. rxjs only patches things on the Observable class, not the module, that will always work fine.\nBut I agree that it is an edge case, and maybe we should hear some real-world cases of people who did this here and can absolutely not avoid it. I have the feeling that that group of users and the group of users that are going to update to ES modules anytime soon are disjoint.",
                            "createdAt": "2018-01-16T05:54:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Personally I would rather remove filtering and see this PR land than make\nthis issue a blocker. Private properties being exposed isn\u2019t such a big\ndeal, it just would have been nice to be able to clean up the encourager\npaths that\u2019s all.\n\nThe APM use cases have been there from the start in all the design docs and\ndiscussions on this. @bmeck has put a massive amount of time and effort\ninto exploring the possibilities here - the research has been done. Modules\nare still flagged and we can continue to integrate out these workflows\nafter this lands. But we need to be able to continue making real progress\ntoo. There\u2019s still a long list to go, which will require some give to\ncover, please let\u2019s not stall on every single bikeshed.\n\u2026\nOn Tue, 16 Jan 2018 at 09:24, Matteo Collina ***@***.***> wrote:\n ***@***.**** requested changes on this pull request.\n\n I\u2019m marking my -1 to this PR explicitly.\n A lot of the ecosystem relies on APM tools which currently monkey patch\n some parts of Node.js.\n I didn\u2019t realize this was not compatible with them.\n cc @nodejs/diagnostics <https://github.com/orgs/nodejs/teams/diagnostics>.\n\n IMHO we should have:\n\n a. deprecation support 100% figured out for named exports, getters,\n functions etc.\n b. diagnostics support on par with CJS (I\u2019m ok with \u201cyou have to use a\n loader\u201d, but that approach should be documented).\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18131 (review)>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiyr4DbX64JYd76FOeFYHbCq3BdDFpks5tLE7LgaJpZM4RdLYy>\n .",
                            "createdAt": "2018-01-16T08:10:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina I can write an example for APM/docs but we don't have a composition workflow for loaders standardized right now, APMs would need to define their own way to compose with other loaders. On the plus side for APM, by making the exports primordial only in this PR APMs don't need to try to stay in-sync.",
                            "createdAt": "2018-01-16T15:41:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamn / @mcollina example APM (needs this PR for the APM to function properly due to changing of imports) is up at https://github.com/bmeck/node-apm-loader-example",
                            "createdAt": "2018-01-16T16:58:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamn",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck Thanks!\nGiven that the resolve function is async, I'm guessing this strategy won't change the behavior of require(\"fs\"), since CJS require has to resolve synchronously? Am I missing something there?",
                            "createdAt": "2018-01-16T17:05:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamn correct this does not affect require. I was unable to find a hooks solution that lets you instrument both. APMs could also patch up the CJS side by loading CJS like the example does with dirname.js",
                            "createdAt": "2018-01-16T17:12:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I think the loader behavior should get some unit tests and docs with this PR, as this change mandates the use of a loader for every module that monkeypatches core.\nI reviewed again the comments and I changed my mind on the deprecation issue, I think we should have 1-1 correspondence with CJS.",
                            "createdAt": "2018-01-17T11:56:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "my general opinion on this pr is that the changes it makes should be able to be swapped with actual esm modules written from scratch and no one would know. There also seems to be this dislike of having to monkey patch with loader hooks but that's how it should work. esm isn't meant to be undermined by some other random module loading system that happens to have been built with a lot of safety flaws. To these two points, i don't see private exports as a bikeshed, but rather something that kinda ruins this pr. There are lots of people here who want to see certain things but i hope we can all just take a step back and think about what you would expect to see esm modules for builtins implemented like if there was no such thing as \"create dynamic module\" and re-exporting the cjs modules and then you have your answer.",
                            "createdAt": "2018-01-17T14:13:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina I'm curious why you changed your mind, was there a particular topic of interest?\nFor the most part I agree with the fact that ESM doesn't need to completely carry the burden of CJS, indeed import \"module\" seems non-sensical even if you do things like drop transparent interop.\nI'd like to gather a list of use cases for things and expose them as *first class parts of ESM rather than placing all tech debt onto ESM in first iteration. It is much easier to add things as they are needed than remove them. In all situations that have been discussed there has been breakage in minor ways when porting from babel style modules to areal implementation, therefore I'm curious to what extent such divergence is acceptable. For me, divergence is fine as long as all use cases are possible, such as with the above you could always import a CJS module to get a hold of these private properties, further emphasizing that using them is not recommended but keeping it possible to do so. I'm not convinced the deprecation discussion is clear with things like warnings and this is a way to really show that while we don't have a mechanism to warn on import of a named and deprecated export.",
                            "createdAt": "2018-01-17T14:59:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I'm curious why you changed your mind, was there a particular topic of interest?\n\n@bmeck I did a more throughout review on how we currently deprecate. I had some fear that our current deprecation strategy would not work in ESM. What we are doing is compatible with ESM, and it might possible to emit a deprecation warning on import instead of on execution. This would have to be a good thing to have, but it's not a blocker on this PR.\nWe should have a more in-depth discussion about deprecation, but it's not needed right now. As a side note, I think we would have to rethink our deprecation strategy for ESM in another issue/thread.\n\nThere also seems to be this dislike of having to monkey patch with loader hooks but that's how it should work.\n\nI think it is a must-have. It is not currently possible to integrate an APM agent without monkeypatching, and this PR prevents APM to work with ESM.",
                            "createdAt": "2018-01-17T15:12:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina\n\nI think it is a must-have. It is not currently possible to integrate an APM agent without monkeypatching, and this PR prevents APM to work with ESM.\n\nThey must use a loader to do this. It is not possible to support monkey patching in a way that properly propagates without new V8 implementation that has hooks like described above. If using a loader is a blocker, we need to discuss that before anything further.\n\nWe should have a more in-depth discussion about deprecation, but it's not needed right now.\n\nIf our deprecation strategy relies on adding deprecated features to new interfaces that is something we need to discuss as well before moving forward with anything. As described above the use cases and values are still obtrainable and I am wondering why they need to be added to a new interface. Named imports have various incompatiblities with treating them as a 1-1 mapping with CJS. Are you stating that the ESM interface that is not mutable, cannot fire deprecation warnings on use, needs a loader to override, and cannot produce a callable namespace object should be treated the same as CJS? I feel like there are a number of differences and treating them as the same is misleading.",
                            "createdAt": "2018-01-17T15:23:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "They must use a loader to do this. It is not possible to support monkey patching in a way that properly propagates without new V8 implementation that has hooks like described above. If using a loader is a blocker, we need to discuss that before anything further.\n\nI am stating that this PR needs to add docs and include tests for the loader approach. Landing it without them would be incomplete.\n\nAre you stating that the ESM interface that is not mutable, cannot fire deprecation warnings on use, needs a loader to override, and cannot produce a callable namespace object should be treated the same as CJS?\n\nI'm a bit lost on this question. As far as I understand, it can fire deprecation warnings on use, but this PR does not support support deprecation warnings at import-time.\nI am saying that CJS should support the same range of features and use cases, in this case deprecation and APM. I'm ok if it works through different means and/api.",
                            "createdAt": "2018-01-17T15:43:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "you can't do \"deprecation warnings at import-time\" because importing must expose the entire namespace. i'm about to push a deprecation weakset which helps map deprecated functions from getters that emit to functions that emit on the esm side (just adding tests for it atm)\nimport { createCredentials } from 'crypto' // no dep warning\n\ncreateCredentials(...) // dep warning",
                            "createdAt": "2018-01-17T15:46:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "I am stating that this PR needs to add docs and include tests for the loader approach. Landing it without them would be incomplete.\n\n+1\n\nI am saying that CJS should support the same range of features and use cases, in this case deprecation and APM. I'm ok if it works through different means and/api.\n\nThat seems fine, but I'm wondering why already deprecated things should be added to a new interface that has a different means of working for various use cases and different syntax/API.",
                            "createdAt": "2018-01-17T16:06:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "That seems fine, but I'm wondering why already deprecated things should be added to a new interface that has a different means of working for various use cases and different syntax/API.\n\nThe vast majority here would like to have it landed without filtering. As long as we can polish and deprecate things as we go, I'm ok in having deprecated things in here - it would just be a missed opportunity.",
                            "createdAt": "2018-01-17T16:10:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "The filtering is also for \"private\" undocumented things not on the deprecation cycle if I read correctly above?",
                            "createdAt": "2018-01-17T16:11:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "The filtering is also for \"private\" undocumented things not on the deprecation cycle if I read correctly above?\n\nYes, as long as I can deprecate them in future.",
                            "createdAt": "2018-01-17T16:16:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, as long as I can deprecate them in future.\n\nIf we can get a timeline for that I'd be happy with non-filtering, but without a timeline and since this is a new interface I'd be against non-filtering. Timeline can be even a couple of LTS cycles but I wouldn't want further.",
                            "createdAt": "2018-01-17T16:24:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "If we can get a timeline for that I'd be happy with non-filtering, but without a timeline and since this is a new interface I'd be against non-filtering. Timeline can be even a couple of LTS cycles but I wouldn't want further.\n\nI think the only limit is people willing to do the work.",
                            "createdAt": "2018-01-17T16:36:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Where this is going to bite us is on deprecation of properties that are not functions. For instance, if we hypothetically wanted to deprecate os.EOL (or some other module-level property) for whatever reason. We need to make sure we have a way of reasonably deprecating properties exported via ESM that are not functions.\nAlso, there are some existing APIs that simply cannot be exposed 1-to-1 with ESM. For instance, crypto.DEFAULT_ENCODING is a getter/setter. Setting the value changes the behavior of every crypto function. That would not be possible with this approach and there's currently no alternative API and we would have no way of deprecating crypto.DEFAULT_ENCODING if we did export it now via ESM but came up with an alternative API later. crypto.fips is another example within that same module. We also have other examples such as process.title (getter/setter), process.exitCode (neither getter nor setter but is definitely mutable and important), tls.CLIENT_RENEG_LIMIT (mutable property), tls.CLIENT_RENEG_WINDOW (mutable), process.config (mutable), require('events').defaultMaxListeners (getter/setter), cluster.schedulingPolicy (mutable), buffer.INSPECT_MAX_BYTES (mutable).  (yes, process is still available as a global under esm so process.title still just happens to work, but the others do not)\nAlso consider that some modules have getters for properties that will print deprecation messages. For instance, fs.SyncWriteStream is a getter that will print a deprecation warning (which, btw, appears to be filtered out by this PR currently).\nThe point is: there are existing and functional parts of the current supported Node.js API that simply cannot translate over into a 1-to-1 mapping exported from an ESM module.\nupdate actually I think the example for events below is a bit off... point still stands tho\nimport * as EventEmitter from 'events';\nEventEmitter.defaultMaxListeners = 10;  // throws\nas opposed to:\nconst EventEmitter = require('events');\nEventEmitter.defaultMaxListeners = 10; // works\nupdate: Actually, better example:\nimport * as buf from 'buffer';\nconsole.log(buf.INSPECT_MAX_BYTES); // outputs 50\nbuf.INSPECT_MAX_BYTES = 10  // throws\nimport { INSPECT_MAX_BYTES } from 'buffer';\nconsole.log(INSPECT_MAX_BYTES); // outputs 50\nINSPECT_MAX_BYTES = 10; // throws for obvious reasons\nIf the goal truly is 1-to-1 between ESM and CJS, then we will need to deal with these discrepancies.",
                            "createdAt": "2018-01-17T16:42:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "we could just migrate all those to things like crypto.setDefaultEncoding, process.setTitle, etc before the v10 release\nlist of detected setters/getters:\n\n\n\nGET\nSET\nNAME\nNOTE\n\n\n\n\n\u2714\ufe0f\n\u2714\ufe0f\ncrypto.fips\n\n\n\n\u2714\ufe0f\n\u2714\ufe0f\ncrypto.DEFAULT_ENCODING\n\n\n\n\u2714\ufe0f\n\u2716\ufe0f\ncrypto.createCredentials\nhandled by weakset\n\n\n\u2714\ufe0f\n\u2716\ufe0f\ncrypto.Credentials\nhandled by weakset\n\n\n\u2714\ufe0f\n\u2714\ufe0f\nevents.defaultMaxListeners\nalready handled by default export\n\n\n\u2714\ufe0f\n\u2714\ufe0f\nfs.SyncWriteStream\n\n\n\n\u2714\ufe0f\n\u2714\ufe0f\nprocess.domain\n\n\n\n\u2714\ufe0f\n\u2716\ufe0f\nprocess.stdout\n\n\n\n\u2714\ufe0f\n\u2716\ufe0f\nprocess.stderr\n\n\n\n\u2714\ufe0f\n\u2716\ufe0f\nprocess.stdin",
                            "createdAt": "2018-01-17T16:50:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "We could introduce functions for those, yes. However, we would not be able to remove the existing properties without a proper deprecation cycle and the argument is that we need to export everything to ESM without filtering so those deprecated properties would still need to be exported and we would have no way of marking them deprecated.\nFor instance, suppose we did decide to deprecate buffer.INSPECT_MAX_BYTES after this landed and replace it with a buffer.setInspectMaxBytes(). Typically, we would do that by changing the export in buffer.js to a getter that emits a deprecation message (using util.deprecate() does not work in this case because of when buffer.js is first loaded during node.js bootstrap)\n// hypothetical code....\nlet inspectMaxBytes = 50;\nObject.defineProperty(exports, 'INSPECT_MAX_BYTES', {\n  enumerable: true,\n  configurable: true,\n  get() {\n    process.emitWarning('this is deprecated', 'DeprecationWarning');\n    return inspectMaxBytes;\n  },\n  set(val) {\n    process.emitWarning('this is deprecated', 'DeprecationWarning');\n    // set the value\n    inspectMaxBytes = val;\n  }\n});\nThis Just Works (tm) with the commonjs module and follows along with our current practice up to this point. With the current implementation in this PR, before making this change, INSPECT_MAX_BYTES would be a named export but after the change, it would no longer be, breaking any code that expected it to be there. With an implementation that does not filter, the deprecation warning would end up being emitted when the module record is built regardless of whether the user actually made use of it.",
                            "createdAt": "2018-01-17T17:12:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "as much work as it would be, it appears that auditing the apis of all modules for these properties like \"INSPECT_MAX_BYTES\" and deprecating them now for removal in node 10 would be the only solution that works in both directions, its just a lot of work.",
                            "createdAt": "2018-01-17T17:14:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "we could also use a different deprecation system with esm where deprecations are docs only, which is a lot easier to deal with but potentially not as noticable.",
                            "createdAt": "2018-01-17T17:24:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "That would end up forcing us to not use runtime deprecations in the commonjs module also... at least for anything that can be exported as a named import ... otherwise we get right back in to filtering and special case logic.",
                            "createdAt": "2018-01-17T17:26:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fuzzyma",
                                "__typename": "User"
                            },
                            "bodyText": "That's what I was thinking, too! That would erase all the current problems with depreciation",
                            "createdAt": "2018-01-17T17:28:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek ... that table also needs to include things like process.env ... again, since process is a global, it is possible for ESM users to use it and access it's properties without import, but in CJS modules, require('process') still works so a 1-to-1 mapping needs to at least consider import * as process from 'process'.\nSpecifically, process.env = {} works in commonjs, but would not work when using import * as process from 'process' ...\nalso ... process.debugPort (getter/setter)\n(oh, and the answer to the process items may simply be that process is a global and cannot be imported from making import whatever from 'process' impossible.)",
                            "createdAt": "2018-01-17T19:35:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "So, IF this only works for core modules and not user modules (I'm currently uncertain), then we would need to be clear somewhere in the documentation that this is the case. (Or even possibly display a warning if someone attempts to, if that is possible.)",
                            "createdAt": "2018-01-17T22:44:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 it only effects builtin modules (crypto, fs, etc) and i did modify the docs in this pr for it.\nhowever deprecations are basically blocking this anyway.",
                            "createdAt": "2018-01-17T22:57:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "There are a couple of blockers on being able to land this:\n\n\nWe need to determine the deprecation strategy for things exported via ESM. We don't necessarily need to have the new deprecation strategy implemented before this can land, but we do need to have an idea of how it would work. Specifically, we need to be able to deprecate properties exported on an ESM (functions are easy because we can emit the deprecation within the function)\n\n\nWe need to deal with mutable properties exported on the module itself.. such as crypto.DEFAULT_ENCODING and process.title. While these can be used via the default export, they fundamentally (and necessarily) break on named imports and the import * as foo pattern. Again, we do not necessarily need to have a solution implemented here before this can land, but we need to know that a solution does exist.",
                            "createdAt": "2018-01-17T23:21:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "satya164",
                                "__typename": "User"
                            },
                            "bodyText": "Doesn't having only default exports for these modules instead of named exports solve most of the issues around getters, setters and deprecation warnings on access etc.?",
                            "createdAt": "2018-01-17T23:24:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "For (2), it seems like a great solution would be to migrate everything, as fast as possible, from getters/setters and shared mutable properties to explicit \"getFoo\"/\"setFoo\" functions (following the deprecation cycle, ofc).",
                            "createdAt": "2018-01-17T23:24:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "For (1), I believe introspection of exports through either hooks or just a regular getter on v8::Module should be implemented in V8. Some open questions remain on how import * or export * should act.\nFor (2), I agree with @ljharb. There doesn\u2019t seem to be any other way of doing it within the framework of ESM.",
                            "createdAt": "2018-01-18T04:38:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "For getters, making the property a live binding would avoid the need for an explicit getter, if technically feasible.",
                            "createdAt": "2018-01-18T04:41:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@TimothyGu a live binding still wouldn\u2019t provide any ability to run code upon binding access; it would only provide the ability to change the binding later.",
                            "createdAt": "2018-01-18T04:46:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "I think we should merge this PR without filtering, following up with further work to alter the specific APIs as separate tasks. Modules are flagged, so if we can acknowledge that the API is not final here, we can at least start to work through the cases as a process to align with the unflagged modules release.",
                            "createdAt": "2018-01-20T13:11:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford i'm just worried about deprecations, i think we should figure out how those will work with esm before we merge esm",
                            "createdAt": "2018-01-20T20:03:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek we don't need deprecation paths on the ESM interface until it lands unflagged. But then it seems like the most likely option is functional deprecations, along with deprecating value settters. My suggestion is that we then start working on the CJS side on these. The final interface surface should also be fully reviewed before unflagging.",
                            "createdAt": "2018-01-20T20:15:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "This goes along with the TSC trend of having \"exit conditions\" for removing an experimental flag. Having deprecations sorted as a condition for unflagging esm modules is a good idea.",
                            "createdAt": "2018-01-20T20:49:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell \u2764\ufe0f",
                            "createdAt": "2018-01-24T00:57:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I would like to move this PR forward. Can we reach an agreement and add the things that have been asked by the reviewers?",
                            "createdAt": "2018-01-31T17:28:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina at this point the pr doesn't filter and is waiting on how deprecations will work moving forward to support esm, which i thought was going to be a tsc item :/\nas you can see above the process of getting rid of getters/setters has started for the other point.",
                            "createdAt": "2018-01-31T17:40:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I think landing this with the current behavior but emitting a process warning that clearly notifies users that named imports from core modules is still experimental and will likely change would be very good here.",
                            "createdAt": "2018-01-31T18:51:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell to clarify the only possible way to do that would be emitting the first time any builtin is imported with or without the named exports, does that work for you?",
                            "createdAt": "2018-01-31T18:54:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "If that's the only approach, then yeah, that works.",
                            "createdAt": "2018-01-31T19:01:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "wow that ui is a mess but uh, @jasnell i added the warning",
                            "createdAt": "2018-02-01T00:55:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I just noticed:\n\nBuiltin modules will provide a default export if they export a function\ntop-level, such as assert or events. Their public api will be exposed\nas named exports.\n\nSo this is removing the ability to do?\nimport fs from \"fs\"\nimport path from \"path\"\nSince neither fs or path have a function module.exports?",
                            "createdAt": "2018-02-01T06:52:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Generally i'd expect to have to do import * as fs from 'fs' since fs isn't itself anything but a namespace object.",
                            "createdAt": "2018-02-01T06:54:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Ya, maybe. Kind of a mess of it though. It was one way which was consistent with non-builtin cjs and close to the ecosystem (minus named exports), now it's shifting another way plus named exports, but neither gives devs quite what Babel does today.",
                            "createdAt": "2018-02-01T07:01:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "isaacs",
                                "__typename": "User"
                            },
                            "bodyText": "I apologize for only briefly skimming this issue.\nHowever, for those of us who write and maintain a lot of extremely widely used fs userland utilities, no, fs is not \"just a namespace object\".\nThe ability to monkeypatch the fs object, and have those changes be used by anything that pulls in const fs = require('fs') is basically the only way that many of my most widely used modules can achieve 100% test coverage.\nI often use the mutate-fs module to do this.  Please consider how this type of testing approach will work while making decisions like these.  100% test coverage on low-level FS libraries is extremely vital to this community's ability to get stuff done.",
                            "createdAt": "2018-02-01T19:48:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@isaacs i'm fairly sure you'll be able to monkey patch the exports with per-package loader hooks as described in #18233",
                            "createdAt": "2018-02-01T19:50:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "felixfbecker",
                                "__typename": "User"
                            },
                            "bodyText": "@isaacs to be fair, that's a problem that is not specific to core modules, but esm in general. In CJS we can do sinon.stub(require('some-module'), 'someExport') and replace e.g. an exported function with stub, whether that is an HTTP request function or fs.readFile(). That's not possible with esm, and applications/libraries might need to rethink their testing story by e.g. not depending on modules for things like that but accepting object interfaces as parameters to do those tasks, and then you could pass an fs in or a mock object (that can have other benefits, for example you can then run tests in parallel that had to be sync before).",
                            "createdAt": "2018-02-01T19:55:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Or... Rather than monkeypatching and shimming core code, the right thing to do is either layer on top or provide completely alternative implementations. Key issue here is that the existing ecosystem is built around a module system that is fundamentally different than ESM. There are many ok partial solutions, but few great ones. Developers are going to have to develop new strategies.",
                            "createdAt": "2018-02-01T20:00:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "Should we make a more explicit example in the docs for something like how to replace module specifiers entirely , kind of like we do for C++ addon examples?\n@devsnek it depends if it is intended to be scoped to a package or global, right now --loader works if global patching is the intended use case.",
                            "createdAt": "2018-02-01T20:04:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "isaacs",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell That's not really a satisfactory answer.  As a responsible author of fs utils, if using ESM means I don't get to 100% test-cover my modules that touch fs, I'm not going to use ESM.  So why do this?  Why not just a single export default fs, and have people import fs from \"fs\"?  It's a smoother transition, and doesn't break an important part of the ecosystem.",
                            "createdAt": "2018-02-01T20:30:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "isaacs",
                                "__typename": "User"
                            },
                            "bodyText": "My point is, Node.js has shipped with mutable singleton core modules for over 8 years.  If you want to make core modules no longer mutable singletons, call the project something different.  That's too big for a semver major and deprecation in the docs.\nIt's not like it's not an option to keep shipping mutable singletons in ESM-land.  Default exports.  That's what it's there for.  If anyone wants to only import a single name, they can do import {readdir} from \"fs\" easily enough, which is already a common idiom thanks to Babel and friends.",
                            "createdAt": "2018-02-01T20:37:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, hooks are able to intercept loads to provide instrumentation. And we will be extending these use cases. For example a new \"module\" hook or similar could allow altering the exports of a module externally via a loader something like:\nexport function module (url, ns, exports) {\n  // iterate all export names of module \"ns\" and update their\n  // exported bindings to instrumented values\n  Object.keys(ns).forEach(exportName => {\n    exports[exportName].set(instrument(ns[exportName]));\n  });\n}\nThese kinds of approaches will be fleshed out.\nAbout the default exports I'm strongly against arbitrarily not having them though.\nIf we didn't have backwards compatibility with CommonJS to worry about ideally we could write core modules like:\nimport * as self from './my-own-module-name.js';\nexport async function readFile (...) {}\nexport default self;\nAllowing the import fs from 'fs' and import * as fs from 'fs' to be exactly the same namespace binding, while providing workflow consistency for developers.\nIt's a really nice thing to have users just assume import x from 'x' will work in Node core and CJS compatibility cases... to arbitrarily break that contract will definitely catch people out.",
                            "createdAt": "2018-02-04T11:28:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "Elsewhere @devsnek mentioned (and I feel it's most appropriate to follow up here):\n\n18131 is possible because we know internal modules won't error on evaluation, and that's why the other pr was turned down, it creates inherent instability in the module record if it fails like that.\n\nIf that's the only invariant you need, could package authors have a flag they could set to allow their consumers to import them using named imports, the flag simply indicating \"I assure you, my package/file will not throw an error during parse or initial evaluation\"? (And then if there is an error during evaluation, fail hard and fast, likely invalidating the entire graph/cache?) I can only assume many third party packages have at least as good code hygiene as the node core packages, and this would just be another caveat added to the interop caveat pile (like how exports would be a snapshot). And then the inevitable followup: why can't this be the default behavior so only people with broken code would need to think about flagging eager evaluation off?\nOr is the invariant that needs to be maintained not actually related to errors thrown during initial evaluation?",
                            "createdAt": "2018-02-06T09:18:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@weswigham they can just provide a mjs wrapper at that point, and there's no telling how many packages would be broken by default out of band evaluation",
                            "createdAt": "2018-02-07T04:17:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek In any case, it could be opt-in (ideally on the consuming side), then, right? If a package written in ESM can say \"by the way, these dependencies are OK to preexecute\" in it's package file, then it could get named imports for pretty much free, yeah?",
                            "createdAt": "2018-02-08T02:49:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "If a package written in ESM can say \"by the way, these dependencies are OK to preexecute\" in it's package file, then it could get named imports for pretty much free, yeah?\n\ndid you mean cjs? assuming you did, i refer you to my last comment. they can create index.js/index.mjs and \"main\": \"index\" and that's their opt-in.",
                            "createdAt": "2018-02-08T03:00:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "But then they'd need to continuously keep it up to date with all their exported members just to interop, which is a bit of a drag, especially for a large API surface. It also risks the two shapes drifting out of sync if something gets missed... Lots of pitfalls.",
                            "createdAt": "2018-02-08T03:06:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "Like, if a module facade is the way to go, node should be using module facades for the builtin packages, too (dogfooding its own interop). Otherwise you should be letting packages opt in to the same behavior.",
                            "createdAt": "2018-02-08T03:09:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "personally i would like to leave this to userspace per-package loaders, assuming they go through. just because node does something internally doesn't mean users should do it and vice-versa.",
                            "createdAt": "2018-02-08T03:10:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "You should definitely expose this behavior as a built-in per-package loader, then.",
                            "createdAt": "2018-02-08T03:12:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "there are no built-in per-package loaders, i was referring to bmeck's proposal for letting packages define transparent loaders for their code, none of which would be built in to node",
                            "createdAt": "2018-02-08T03:13:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "Yeah. And this acts a lot like one would. So we should write it as one, use it as one, and expose it, so others can use it without needing to rely on a third party package. It helps the community and dogfoods the per-package loader feature.",
                            "createdAt": "2018-02-08T03:19:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "I would be happy to continue this conversation on irc, freenode/#node-dev",
                            "createdAt": "2018-02-08T03:25:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell do you have any ideas on how to provide first class importing for fs promise methods? ideally people shouldn't have to make two statements for it which leads me to maybe think of fs/promises instead of fs.promise or something like that but i dunno how much though already went into this.",
                            "createdAt": "2018-02-11T04:40:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "This got unblocked as far as I see and could be worked on again.",
                            "createdAt": "2018-02-18T01:48:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR as soon as #18712 lands this can land",
                            "createdAt": "2018-02-18T01:53:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "isaacs",
                                "__typename": "User"
                            },
                            "bodyText": "Unless there\u2019s a way to do this without breaking utils like mutate-fs, it is a huge mistake. You can\u2019t just stop exporting a mutable fs singleton like it\u2019s no big deal. That\u2019ll make it impossible to test any of the modules I maintain if I use esm. Think about this, please. You\u2019re about to fork the ecosystem.",
                            "createdAt": "2018-02-18T03:30:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "if whatever mutate-fs is supports loader hooks then mutate-fs is fine. (https://github.com/bmeck/node-apm-loader-example)\n@jdalton\n\nno default export for those built-in modules that export a function bit.\n\nthey have a default export, i'm not sure i understand",
                            "createdAt": "2018-02-18T03:49:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek\n\nthey have a default export, i'm not sure i understand\n\nTypoed: I meant that don't export a function. It's the same thing I, and others, raised a half a month ago, and that @isaacs is re-raising now.\nI don't think the loader hooks sample you linked to would really work out as CLI hooks are more for applications and not dep packages. Maybe the per package loader hook proposal? Even then though I think it would need to be a bit further along.",
                            "createdAt": "2018-02-18T04:03:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Can I get some clarification on the points of contention? It seems like the issues are:\n\nthings that are typically used as named exports from core CJS modules should be explicit named exports from core ESM modules\n\nnobody seems to have an issue with this (correct?)\nexcept for property getters/setters, which will be deprecated and replaced with explicit getFoo/setFoo methods which will be named exported\n\n\nfor core CJS modules that do export a function, this would be the default export in ESM, whether or not it had additional properties that became named exports\nfor core CJS modules that do not export a function, and instead export an object (conceptually, a bag of named exports) the choices are:\n\ndo not have a default export for the corresponding core ESM modules; import * as would be used to get an immutable object bag that conceptually was the same as the CJS export\nor, also default-export a mutable object, so that people can mutate\n\nif we do this, and someone mutates the object, how would the named export bindings get summarily updated, or would they not be?\nif they wouldn't be updated, how do we resolve the user confusion of the following:\n\n    import { readFile } from 'fs';\n    import fs from 'fs';\n    function foo() {}\n    fs.readFile = foo;\n    assert(readFile === foo); // this would throw?\n\nif they are updated, should a mutation to the default export of 'fs' be visible to require('fs'), and vice versa? If so, how would that be achieved? If not, how would the above-mentioned user confusion be resolved?\n\n\n\n\n\nIn general, it seems to me that if we do allow mutation via ESM imports, then we have to be sure that such mutation is two-way, in both ESM and CJS, to avoid user confusion and to allow for seamless migrations.\nPlease correct me if I'm missing anything or if anything I've said is inaccurate.",
                            "createdAt": "2018-02-18T05:31:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "except for property getters/setters, which will be deprecated and replaced with explicit getFoo/setFoo methods which will be named exported\n\nI mean, there's contention all right, These are changing for technical reasons and the change is breaky - it will not help any transition. It's just the more understandable tradeoff under the current design.\n\nnobody seems to have an issue with this (correct?)\n\nI just contend that if builtin packages can easily promise to be well-behaved and get better interop, userland ones should, too. Otherwise they should behave the same way and be forced to interop in the same way.\n\nif we do this, and someone mutates the object, how would the named export bindings get summarily updated, or would they not be?\n\nThe namespace object is immutable. The bindings, however, are just that - live bindings. Update the binding to point at the new thing, as expected. There's only trouble if someone expects to replace the entire namespace object (which shouldn't be possible, except in cjs it was via multiple assignments to module.exports). Take your example:\n    import { readFile } from 'fs';\n    import fs from 'fs';\n    function foo() {}\n    fs.readFile = foo;\n    assert(readFile === foo); // this would throw?\nI can write a module of this shape and behavior in chrome that doesn't throw.",
                            "createdAt": "2018-02-18T06:46:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "we can make the default export a proxy i guess, i don't have any huge issues against that other than perf concerns but i'm not too read up on proxy perf.",
                            "createdAt": "2018-02-18T06:55:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@weswigham sure, I accept that it's possible to implement an intuitive two-way mutability (such that the default export object itself isn't replaceable) - my question there was more, how would we implement it? If we have to use a Proxy, would the perf hit to the common use case (which is decidedly not mutating core modules) be worth it to enable the edge cases of mutating core modules?",
                            "createdAt": "2018-02-18T07:04:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "To add to @weswigham's browser example,\nin my own local loader implementation I got this working as well.\nimport fs, { readFileSync } from \"fs\"\nimport * as ns from \"fs\"\n\nfs.readFileSync = 1\nconsole.log(readFileSync, fs.readFileSync, ns.readFileSync)\n// 1, 1, 1",
                            "createdAt": "2018-02-18T07:06:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb Only people using the default import proxy object would even get the perf hit anyway, so there's a clear way to avoid it (use the named imports). In this way the overhead is only forcibly incurred by people who want to cause mutations (ie, use the default object).",
                            "createdAt": "2018-02-18T07:07:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "we can make the default export a proxy i guess, i don't have any huge issues against that other than perf concerns but i'm not too read up on proxy perf.\n\nHow about a getter/setter filled namespace-like object generated from the bindings detected on initial import with a prototype object of a proxy? This way the proxy is only invoked for things not in the original fs library? That way only additive changes (which can't be named imports, mind you, since that set is locked in on initial load) hit the proxy and incur any overhead.",
                            "createdAt": "2018-02-18T07:11:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "If we want fs (and others?) to be mutable (and I have misgivings about that) and yet leave the default/ns import performant, we can always create an fs/mutable that exports a default export that allows mutation. Only those packages that mutate (and migrate to ESM) will use it. 99.999% of code will use the regular fs.",
                            "createdAt": "2018-02-18T08:42:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I rather not travel too far down the perf what-if trail before anything has been measured.\nThe approach here is, in general, good advice (which is defer until accessed). If things need tweaking there is a Node Benchmark WG where emerging perf concerns can be raised.",
                            "createdAt": "2018-02-18T09:23:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "I'd also assume that there's no huge perf. but there is a hidden assumption in @weswigham's comment\u2014that people won't use the default fs export (e.g. fs.readFile) but will mostly use named imports.\nSince destructuring was available in NodeJS, I've moved to const {readFile} = require('fs'),  i.e. \"CJS named imports\" in my CJS, and would easily migrate to \"ESM named imports\", but I'm guessing that a lot of projects still use const fs = require('fs') and would probably migrate to default import.\nJust so it's clear\u2014I wouldn't mind the (probably really small) perf hit, even if there was one. I just wanted to describe another option to people who would mind.",
                            "createdAt": "2018-02-18T09:33:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i implemented a proxy and a test (imo the most exciting test of 2018 \ud83d\ude04) and it all seems to work \ud83c\udf89",
                            "createdAt": "2018-02-19T04:12:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek Rock, so rad!\nCan you explain the fall through scenarios a bit more\nset(target, name, value) {\n  target[name] = value;\n  if (name in module) // <-- this fall through\n    module[name] = value;\n  if (name in reflect.exports)\n    reflect.exports[name].set(value);\n  return true;\n}",
                            "createdAt": "2018-02-19T04:21:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton its technically not needed because the cache shouldn't be needed more than once but i thought it would be good to keep one source of truth, so i update the ns cache.",
                            "createdAt": "2018-02-19T04:24:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "its technically not needed because the cache shouldn't be needed more than once but i thought it would be good to keep one source of truth, so i update the ns cache.\n\nAh yes, module is from module = NativeModule.requireNamespace(id). Cool cool.",
                            "createdAt": "2018-02-19T04:29:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Perhaps the difficulty here is in trying to mentally constrain this to an\napproach that can work for userland modules.\n\nIf we stick to considering core modules - surely there\u2019s no reason why the\noriginal CommonJS versions cant be the proxy instances of the ns surely, or\nhave all setters for exports?\n\u2026\nOn Mon, 19 Feb 2018 at 21:12, Gus Caplan ***@***.***> wrote:\n ***@***.**** commented on this pull request.\n ------------------------------\n\n In lib/internal/loader/Translators.js\n <#18131 (comment)>:\n\n >      debug(`Loading BuiltinModule ${url}`);\n -    const exports = NativeModule.require(url.slice(5));\n -    reflect.exports.default.set(exports);\n +    for (const key of keys)\n +      reflect.exports[key].set(module[key]);\n +    reflect.exports.default.set(new Proxy(module.default, {\n +      set(target, name, value) {\n +        target[name] = value;\n +        if (name in module)\n +          module[name] = value;\n +        if (name in reflect.exports)\n +          reflect.exports[name].set(value);\n +        return true;\n +      },\n +    }));\n\n i meant more like require('any builtin').existingProperty = somethingElse\n because by the time it gets modified the ns cache is already built and\n detatched.\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiyrnbysFwYGUNdsIZRo8zNnxP-2O-ks5tWceWgaJpZM4RdLYy>\n .",
                            "createdAt": "2018-02-19T19:17:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i personally have no problem with that approach, and i've started planning out how it might be done",
                            "createdAt": "2018-02-19T19:19:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i have run into a roadblock which can be summed up as follows:\n> new Proxy(new WeakSet(), {}).add(5)\nTypeError: Method WeakSet.prototype.add called on incompatible receiver [object Object]\n    at Proxy.add (native)\n> new Proxy(process, {}).cwd()\nTypeError: Illegal invocation\nping @ljharb @bmeck cuz you guys are js gurus. aren't proxies supposed to be completely transparent? i was surprised enough when they didn't have equality with what they wrap, and now i'm just hitting more weird stuff",
                            "createdAt": "2018-02-19T19:36:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek It appears the this is of the proxy object\no = {\n  add() {\n    console.log(\"this\", this)\n  }\n}\n\nw = new Proxy(o, {\n  get(target, name, reciever) {\n    return Reflect.get(target,name)\n  }\n})\n\nw.add()\n// => \"this\", Proxy\u00a0{add: \u0192}\nI'm guessing it's probably not an issue most of the time, unless for like WeakSet where it requires the specific type and doesn't unwrap.\nReflect.get(target,name).bind(target)\n\nworks around it though.",
                            "createdAt": "2018-02-19T19:52:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "interesting, but i feel like doing a type check and maybe .bind on every get would be a perf hangup",
                            "createdAt": "2018-02-19T19:53:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Would be annoying to be binding everything repeatedly on access. Perhaps we just need to manually check these cases and include bind where necessary in the original CommonJS sources.\nAs for performance I think it would still be useful to compare against a getter/setter alternative here.",
                            "createdAt": "2018-02-19T19:54:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "interesting, but i'm pretty sure doing a type check and maybe .bind on every get would be a perf hangup\n\nBinding is one way, but who says you have to do it on every access?\nMemoize that jazz and only do it when the target isn't a plain object or function.",
                            "createdAt": "2018-02-19T19:55:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "digging around i found https://bugs.chromium.org/p/v8/issues/detail?id=5773, i guess that explains process.cwd",
                            "createdAt": "2018-02-19T20:05:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek That Chromium issue is for something else, namely wrapping a native function with Proxy. What you have observed with process.cwd() is the exact same issue as the one for WeakSet, namely that the this value doesn\u2019t have the necessary internal slots.",
                            "createdAt": "2018-02-19T20:09:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "Oops, I misspoke. That is the same issue as the V8 issue. I don\u2019t think it is a bug however.",
                            "createdAt": "2018-02-19T20:11:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I got it working on my end with something like\nconst proxyValueMap = { __proto__: null }\nconst realValueMap = { __proto__: null }\n\nmod.exports = new Proxy(exported, {\n  get(proxy, name) {\n    const value = Reflect.get(exported, name)\n\n    if (name in realValueMap &&\n        value === realValueMap[name]) {\n      return proxyValueMap[name]\n    }\n\n    realValueMap[name] = value\n\n    if (typeof value === \"function\" &&\n        GenericFunction.toString(value).indexOf(\"[native code]\") !== -1) {\n      return proxyValueMap[name] = GenericFunction.bind(value, exported)\n    }\n\n    return proxyValueMap[name] = value\n  },\n// ...\nI test against projects in the ecosystem and was hitting os.release being a native method.",
                            "createdAt": "2018-02-19T20:44:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton won\u2019t that native code check mean that if value is a native function that\u2019s not bound, it won\u2019t end up getting bound?",
                            "createdAt": "2018-02-19T20:46:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "won\u2019t that native code check mean that if value is a native function that\u2019s not bound, it won\u2019t end up getting bound?\n\nIt means native functions get bound.\nAbstracted away into a helper it would read\nif (isNative(value)) {\n  proxyValueMap[name] = GenericFunction.bind(value, exported)\n} \nUpdate:\n@ljharb\nRE \ud83d\ude15:\nNative functions, when exposed via Function.prototype.toString.call, all have the [native code] bit. They don't have to be bound with Function#bind to have [native code] in their toString'ed form. You can also do this with process.binding(\"util\").safeToString\nprocess.binding(\"util\").safeToString(os.release)\n// => 'function getOSRelease() { [native code] }'",
                            "createdAt": "2018-02-19T20:50:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "All in all it means the proxy could end up looking smth like this:\n(swap out object maps with weakmaps to taste)\nconst proxyValueMap = { __proto__: null }\nconst realValueMap = { __proto__: null }\n\nconst proxy = new Proxy(exported, {\n  get(target, name) {\n    const value = Reflect.get(exported, name)\n\n    if (name in realValueMap &&\n        value === realValueMap[name]) {\n      return proxyValueMap[name]\n    }\n\n    realValueMap[name] = value\n\n    if (! isNative(value)) {\n      return proxyValueMap[name] = value\n    }\n\n    return proxyValue[name] = function (...args) {\n      const thisArg = this === proxy ? exported : this\n      return GenericFunction.apply(value, thisArg, args)\n    }\n  },\n  set(proxy, name, value) {\n    exported[name] = value\n    entry.update()\n    return true\n  }\n})\n\nmod.exports = proxy\nSo not too much extra work.\nUpdate:\nUpdated implementation per #18131 (comment).",
                            "createdAt": "2018-02-19T21:05:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton ah, i misunderstood; i thought the bind was to ensure they had the target as the this value, as opposed to just trying to set the \"native code\" thing.\nI think that \"ensuring that the target is the this value when not otherwise bound\" might be tricky to get right.",
                            "createdAt": "2018-02-19T22:46:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "ah, i misunderstood; i thought the bind was to ensure they had the target as the this value, as opposed to just trying to set the \"native code\" thing.\n\nI think you may still be missing it. The problem is calling native methods from a proxy because the native methods expect a 'this' of a specific type and bork on a 'this' of proxy. So we detect that a method is native, with as robust a mechanism as desired (e.g. Lodash has a robust isNative implementation  or Node could make a fancy C++ one), and bind it to its expected 'this' value. We then memoize the result and only update it if the value changes.\nFWIW I have this working in my local implementation without error.",
                            "createdAt": "2018-02-20T00:25:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Ah, because only native methods depend on internal slots. With the imminent advent of private instance fields, that assumption will soon break, i think, but for now that makes sense - although if my value is x => Function.toString.call(x), wouldn\u2019t the lack of a bind break it?",
                            "createdAt": "2018-02-20T00:35:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "although if my value is x => Function.toString.call(x), wouldn\u2019t the lack of a bind break it?\n\nNo, I'm using the equiv of a primordial helper, not calling bind from the prototypal lookup of the given value.\nUpdate:\nArrow functions are essentially bound functions so further bindings have no effect on them. So since they are pre-bound they will not have the this of the proxy (the root of the problem).",
                            "createdAt": "2018-02-20T00:43:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "What i mean is, if the proxy doesn\u2019t pass along the proper/original this value, then the nested internal slot check will break due to the presence of the proxy.\nedit: i meant function () { return Function.toString.call(this); }, not an arrow function :-p.\nAlso, sorry to the thread for the noise; jdd, I\u2019ll ping you offline to address my confusion :-)",
                            "createdAt": "2018-02-20T01:06:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I don't think that's a problem for these builtin modules and something manageable for wider use esp. with a proper C++ helper. I dig a game of what-if as much as anyone, but again the implementation works.",
                            "createdAt": "2018-02-20T01:31:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "current problem:\nwe need to trap set, defineProperty, and delete\ncurrent non-solutions:\n\n\nProxy because it doesn't transparently expose the target, so things like new Proxy(new Map(), {}).set('a', 1) will fail. (binding methods on the fly with or without cache is not a solution here because it would be breaking)\n\n\ngetters and setters because we can't trap people definePropertying or deleteing on the object\n\n\ncurrent solutions:\nnada",
                            "createdAt": "2018-02-20T03:55:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "we can't use Proxy because it doesn't transparently expose the target, so things like new Proxy(new Map(), {}).set('a', 1) will fail. (binding methods on the fly with or without cache is not a solution here because it will break users who want to call .bind on them)\n\nNaw, I don't think is a problem (or insurmountable problem) for builtin modules and not a major issue for the ecosystem as most exports are plain objects or functions and not natives like map.\nUpdate:\nOkay, so instead of using a primordial bind I've used something like:\n(updated example above)\nfunction (...args) {\n  const thisArg = this === proxy ? exported : this\n  return GenericFunction.apply(value, thisArg, args)\n}\nThis means that with a module like this:\nbar.js\n// make `set` have an enumerable form of `add` as `set.add1`\n// because by default `set.add` is non-enumerable, so not treated as named export.\nconst set = new Set([\"a\", \"b\"])\nset.add1 = set.add\nmodule.exports = set\nfoo.mjs\nimport bar, { add1 } from \"./bar.js\"\nimport * as ns from \"./bar.js\"\n\nconst add2 = bar.add1\n\nconst a = new Set\nadd2.call(a, \"c\")\n\nconsole.log([...a])\n// => [\"c\"]\n\nbar.add1 = 2\n\nconsole.log(add1, bar.add1, ns.add1)\n// => 2, 2, 2",
                            "createdAt": "2018-02-20T04:06:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Yay, that seems to address the things i was asking about earlier.",
                            "createdAt": "2018-02-20T05:03:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "the following code works standalone outside of node core, but when i try to integrate the same exact get method things break\nconst proxy = new Proxy(process, {\n  get(target, prop) {\n    const value = Reflect.get(target, prop, target);\n    if (typeof value === 'function') {\n      function wrap(...args) {\n        if (new.target)\n          return Reflect.construct(value, args, new.target);\n        const thisArg = this === proxy ? target : this;\n        return Reflect.apply(value, thisArg, args);\n      }\n      Object.defineProperties(wrap, {\n        name: { value: value.name },\n        length: { value: value.length },\n      });\n      Object.setPrototypeOf(wrap, value);\n      wrap.prototype = value.prototype;\n      return wrap;\n    }\n    return value;\n  },\n});\n\n// works fine yay\nconsole.log(proxy.cwd());\n// this proxy also works absolutely fine with console in this simple test\nhowever when i run node-dev --experimental-modules with the above in the core:\n> bootstrap_node.js:673\n              return Reflect.apply(value, thisArg, args);\n                             ^\n\nTypeError: Illegal invocation\n    at Proxy.bound consoleCall (bootstrap_node.js:673:30)\n    at writeOut (internal/process/warning.js:18:20)\n    at output (internal/process/warning.js:69:3)\n    at process.on (internal/process/warning.js:100:7)\n    at process.emit (events.js:129:13)\n    at process.emit (domain.js:437:20)\n    at internal/process/warning.js:74:13\n    at process._tickCallback (internal/process/next_tick.js:113:11)\nit seems only console methods have this problem at this point",
                            "createdAt": "2018-02-20T06:30:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek\nKeep digging!\nFor me (I know slightly different) but I can get the following to work:\n(I even adopted the wrapper.name, wrapper.length, wrapper.prototype, and new.target checks)\n(minor nit: the name and length properties are configurable:true)\nimport process, { cwd } from \"process\"\n\nconsole.log(process.cwd())\n// => logs /Users/jdalton/projects/bar\nconsole.log(cwd())\n// => logs /Users/jdalton/projects/bar\n\nimport con, { log } from \"console\"\n\ncon.log(\"a\")\n// logs \"a\"\nlog(\"b\")\n// logs \"b\"\nUpdate:\nBesides guarding for a this of proxy you'll also want to check that the this isn't that of the namespace object. By namespace object I mean the null prototype, toStringTag of \"Module\", ESM namespace object.",
                            "createdAt": "2018-02-20T06:54:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton can you post your code? nothing i do will get console to work, which is really really odd considering its already bound",
                            "createdAt": "2018-02-20T09:36:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "You should start from a place that should work, with a hardcoded 'thisArg' of the explicit 'exports' object (so not the target param or other vars). You can even hardcore it as 'console'. If those work then you know it's just a var value mixup for 'thisArg'",
                            "createdAt": "2018-02-20T10:14:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i cannot make console throw an invocation error (because its already bound), and yet it throws without fail in node core\n> for (const x of [new Error(), Error, undefined, null, Object.create(null), 7, global]) Reflect.apply(console.log, x, [1])\n1\n1\n1\n1\n1\n1\n1\nin node core:\n        Reflect.apply(value, thisArg, args);\n                ^\nTypeError: Illegal invocation\n    at Proxy.bound consoleCall (bootstrap_node.js:677:32)\n    at writeOut (internal/process/warning.js:18:20)\n    at output (internal/process/warning.js:69:3)\n    at process.on (internal/process/warning.js:100:7)\n    at process.emit (events.js:129:13)\n    at process.emit (domain.js:437:20)\n    at internal/process/warning.js:74:13\n    at process._tickCallback (internal/process/next_tick.js:113:11)\n\nvalue [Function: bound consoleCall]\n\nthisArg Console {\n  log: [Function: bound consoleCall],\n  debug: [Function: bound consoleCall],\n  info: [Function: bound consoleCall],\n  dirxml: [Function: bound consoleCall],\n  warn: [Function: bound consoleCall],\n  error: [Function: bound consoleCall],\n  dir: [Function: bound consoleCall],\n  time: [Function: bound consoleCall],\n  timeEnd: [Function: bound consoleCall],\n  trace: [Function: bound consoleCall],\n  assert: [Function: bound consoleCall],\n  clear: [Function: bound consoleCall],\n  count: [Function: bound consoleCall],\n  countReset: [Function: bound countReset],\n  group: [Function: bound consoleCall],\n  groupCollapsed: [Function: bound consoleCall],\n  groupEnd: [Function: bound consoleCall],\n  Console: [Function: Console],\n  table: [Function: table],\n  markTimeline: [Function: markTimeline],\n  profile: [Function: profile],\n  profileEnd: [Function: profileEnd],\n  timeline: [Function: timeline],\n  timelineEnd: [Function: timelineEnd],\n  timeStamp: [Function: timeStamp],\n  context: [Function: context],\n  [Symbol(counts)]: Map {} }\n\nargs [ '(node:44857) ExperimentalWarning: The ESM module loader is experimental.' ]",
                            "createdAt": "2018-02-20T16:25:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek We should chat/screenshare. I'm on google hangouts",
                            "createdAt": "2018-02-20T16:36:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton #node-dev on freenode",
                            "createdAt": "2018-02-20T16:37:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "",
                            "createdAt": "2018-02-20T16:46:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i'll be honest, i'm not really looking for a pair programming experience right now. if you have working code please share it so we can move forward with this pr, otherwise i'm not really sure why you bother bringing it up.",
                            "createdAt": "2018-02-20T16:51:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "My code is for my loader so not 1:1. As you saw it's pretty close. You were able to take it and carry it 95% there. So lets work to finish the last 5%. Have you tried replacing thisArg with console directly just to see if it works?\nThanks for committing the WIP bits btw. It'll help let folks poke around and see what's up.",
                            "createdAt": "2018-02-20T17:03:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "/cc @nodejs/v8 #18131 (comment) seems to suggest a bug with v8\nthe exact same proxy all by itself and created around console will not throw",
                            "createdAt": "2018-02-22T20:12:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek Can you post a small test case?",
                            "createdAt": "2018-02-23T09:38:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis nope, it doesn't repro outside of the core, but everyone I talk to agrees that an illegal invocation on a bound function is extremely iffy behavior.",
                            "createdAt": "2018-02-23T13:30:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis compile node with the changes from this PR and run node --experimental-modules.\nThis is the check that doesn't pass:\n\n  \n    \n      node/deps/v8/src/builtins/builtins-api.cc\n    \n    \n        Lines 72 to 76\n      in\n      3cef3e6\n    \n  \n  \n    \n\n        \n          \n           if (!receiver->IsJSObject()) { \n        \n\n        \n          \n             // This function cannot be called with the given receiver.  Abort! \n        \n\n        \n          \n             THROW_NEW_ERROR( \n        \n\n        \n          \n                 isolate, NewTypeError(MessageTemplate::kIllegalInvocation), Object); \n        \n\n        \n          \n           }",
                            "createdAt": "2018-02-23T14:23:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Is console created in JS or in C?",
                            "createdAt": "2018-02-23T17:30:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb Without knowing the context of your question, both global.console and the built-in require('console') module are implemented entirely in JS and implemented in terms of Node.js writable streams \u2013 I hope that is an answer you were looking for. :)",
                            "createdAt": "2018-02-23T17:32:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax it is, thanks :-) given that, why would \n  \n    \n      node/deps/v8/src/builtins/builtins-api.cc\n    \n    \n        Lines 72 to 76\n      in\n      3cef3e6\n    \n  \n  \n    \n\n        \n          \n           if (!receiver->IsJSObject()) { \n        \n\n        \n          \n             // This function cannot be called with the given receiver.  Abort! \n        \n\n        \n          \n             THROW_NEW_ERROR( \n        \n\n        \n          \n                 isolate, NewTypeError(MessageTemplate::kIllegalInvocation), Object); \n        \n\n        \n          \n           } \n        \n    \n  \n\n trigger for a receiver of the console object?",
                            "createdAt": "2018-02-23T17:34:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb as @devsnek said, it could be a V8 bug. It triggers for any receiver.\nI tried: console.log(), const log = console.log; log();, const log = console.log; log.call({})",
                            "createdAt": "2018-02-23T17:36:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "Ah :) No, it\u2019s not a V8 bug.\nThe bindings for the inspector hook up all methods on the global console object:\n\n  \n    \n      node/lib/internal/bootstrap_node.js\n    \n    \n        Lines 413 to 428\n      in\n      a29089d\n    \n  \n  \n    \n\n        \n          \n           for (const key of Object.keys(wrappedConsole)) { \n        \n\n        \n          \n             if (!originalConsole.hasOwnProperty(key)) \n        \n\n        \n          \n               continue; \n        \n\n        \n          \n             // If global console has the same method as inspector console, \n        \n\n        \n          \n             // then wrap these two methods into one. Native wrapper will preserve \n        \n\n        \n          \n             // the original stack. \n        \n\n        \n          \n             wrappedConsole[key] = consoleCall.bind(wrappedConsole, \n        \n\n        \n          \n                                                    originalConsole[key], \n        \n\n        \n          \n                                                    wrappedConsole[key], \n        \n\n        \n          \n                                                    config); \n        \n\n        \n          \n           } \n        \n\n        \n          \n           for (const key of Object.keys(originalConsole)) { \n        \n\n        \n          \n             if (wrappedConsole.hasOwnProperty(key)) \n        \n\n        \n          \n               continue; \n        \n\n        \n          \n             wrappedConsole[key] = originalConsole[key]; \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nAnd apparently it does so unconditionally, even if we\u2019re not using the inspector \u2013 I am surprised by that? /cc @eugeneo",
                            "createdAt": "2018-02-23T17:41:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "based on the above i still don't understand why i can't trigger this bug outside of core",
                            "createdAt": "2018-02-23T18:04:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax @targos do you guys have a way forward for this issue?",
                            "createdAt": "2018-02-24T17:13:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek Can you show code that you\u2019re trying to use that is failing, or open an issue or sth similar? I\u2019m definitely missing context & this thread already has 300+ comments\u2026",
                            "createdAt": "2018-02-24T17:17:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax\nhttps://github.com/nodejs/node/pull/18131/files#diff-cc63475f116262e9cbea02374e344c01R678\nthis line throws for any call to any consoleCall bound console method\n        Reflect.apply(value, thisArg, args);\n                ^\nTypeError: Illegal invocation\n    at Proxy.bound consoleCall (bootstrap_node.js:677:32)\n    at writeOut (internal/process/warning.js:18:20)\n    at output (internal/process/warning.js:69:3)\n    at process.on (internal/process/warning.js:100:7)\n    at process.emit (events.js:129:13)\n    at process.emit (domain.js:437:20)\n    at internal/process/warning.js:74:13\n    at process._tickCallback (internal/process/next_tick.js:113:11)\n\nvalue [Function: bound consoleCall]\n\nthisArg Console {\n  log: [Function: bound consoleCall],\n  debug: [Function: bound consoleCall],\n  info: [Function: bound consoleCall],\n  dirxml: [Function: bound consoleCall],\n  warn: [Function: bound consoleCall],\n  error: [Function: bound consoleCall],\n  dir: [Function: bound consoleCall],\n  time: [Function: bound consoleCall],\n  timeEnd: [Function: bound consoleCall],\n  trace: [Function: bound consoleCall],\n  assert: [Function: bound consoleCall],\n  clear: [Function: bound consoleCall],\n  count: [Function: bound consoleCall],\n  countReset: [Function: bound countReset],\n  group: [Function: bound consoleCall],\n  groupCollapsed: [Function: bound consoleCall],\n  groupEnd: [Function: bound consoleCall],\n  Console: [Function: Console],\n  table: [Function: table],\n  markTimeline: [Function: markTimeline],\n  profile: [Function: profile],\n  profileEnd: [Function: profileEnd],\n  timeline: [Function: timeline],\n  timelineEnd: [Function: timelineEnd],\n  timeStamp: [Function: timeStamp],\n  context: [Function: context],\n  [Symbol(counts)]: Map {} }\n\nargs [ '(node:44857) ExperimentalWarning: The ESM module loader is experimental.' ]",
                            "createdAt": "2018-02-24T17:22:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek I think you could port consoleCall from inspector_js_api.cc to JS. That\u2019s probably a good idea anyway, the only advantage to having it in C++ is hiding an extra stack frame.",
                            "createdAt": "2018-02-24T17:38:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax Any idea why it errors inside the bootstrap but not outside? The value is already bound by JS-land, is that right?, as it's [Function: bound consoleCall].",
                            "createdAt": "2018-02-24T17:58:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83c\udf89 re-implementing that method in js has fixed this bug, all tests passing",
                            "createdAt": "2018-02-24T18:41:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "re-implementing that method in js has fixed this bug, all tests passing\n\nNice! Any other methods like that? It'd be nice to know the root cause.",
                            "createdAt": "2018-02-24T19:01:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "iirc process.title is the only remaining thing blocking this\n\nAny other methods like that? It'd be nice to know the root cause.\n\nnothing else in core is implemented in the same way as far as i can tell. it seems the root cause was basically the wrapping function was undoing all my hard work making sure to call the method with the right binding.",
                            "createdAt": "2018-02-24T19:04:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "iirc process.title is the only remaining thing blocking this\n\nWhat's the blocker there?\n\nnothing else in core is implemented in the same way as far as i can tell. it seems the root cause was basically the wrapping function was undoing all my hard work making sure to call the method with the right binding.\n\nYa, odd that it doesn't happen outside the bootstrap phase.",
                            "createdAt": "2018-02-24T19:09:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton process.setTitle/process.getTitle",
                            "createdAt": "2018-02-24T19:12:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "process.setTitle/process.getTitle\n\nCan't setters be supported now?\nIn my implementation this works...\nimport { title } from \"process\"\nimport p from \"process\"\n\np.title = \"yay\"\ntitle+\"\"\n// 'yay'",
                            "createdAt": "2018-02-24T19:14:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i guess that does work but it doesn't follow the other things we've been deprecating.\n@nodejs/modules this is ready for a proper review\nsummary:\n\n named exports\n live bindings\n cjs and esm sync together",
                            "createdAt": "2018-02-24T19:18:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Many getter/setters were deprecated in a defensive move because it was thought live binding wasn't a thing that was possible but now they are possible \\o/",
                            "createdAt": "2018-02-24T19:19:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I think we should add a util.inspect.custom function to the proxy that returns the original exports object. We don't want console.log(require('fs')) to show the proxy.",
                            "createdAt": "2018-02-24T19:50:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I think we should add a util.inspect.custom function to the proxy that returns the original exports object. We don't want console.log(require('fs')) to show the proxy.\n\nOn my end I'm not seeing it show the proxy with console.log.\nIf I use inspect with the showProxy option though then it shows up.",
                            "createdAt": "2018-02-24T19:54:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I think I saw it in the repl yesterday.\nEdit: the repl has showProxy: true:\n\n  \n    \n      node/lib/repl.js\n    \n    \n        Lines 104 to 108\n      in\n      da886d9\n    \n  \n  \n    \n\n        \n          \n           // This is the default \"writer\" value if none is passed in the REPL options. \n        \n\n        \n          \n           const writer = exports.writer = (obj) => util.inspect(obj, writer.options); \n        \n\n        \n          \n           writer.options = Object.assign({}, \n        \n\n        \n          \n                                          util.inspect.defaultOptions, \n        \n\n        \n          \n                                          { showProxy: true, depth: 2 });",
                            "createdAt": "2018-02-24T19:58:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I think I saw it in the repl yesterday\n\nYa that'll need to be double checked.\nFor me when I set a util.inspect.custom I still see the Proxy bit.\nimport { inspect } from \"util\"\nimport p from \"path\"\n\np[inspect.custom] = () => \"foo\"\ninspect(p, { showProxy: true })\n// 'Proxy [ foo,\\n  { get: [Function: get],\\n    set: [Function: set] } ]'\nUpdate:\nMy build was earlier before the default showProxy:true was set set.",
                            "createdAt": "2018-02-24T20:03:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I see. It doesn't seem possible to bypass that.",
                            "createdAt": "2018-02-24T20:13:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I see. It doesn't seem possible to bypass that.\n\nI mean it totally could be possible. It just means tweaking inspect.\nIt could even key off of another symbol.\nFWIW from this PR\n~/projects/gus on \ue0a0 esm-builtin-module-namespaces\n\u279c ./out/Release/node -v\nv10.0.0-pre\n\nthen\n\u279c ./out/Release/node\n> console.log(new Proxy({}, {}))\n{}\nundefined\n>\n> console.log(require(\"path\"))\n{ resolve: [Function: resolve],\n  normalize: [Function: normalize],\n  isAbsolute: [Function: isAbsolute],\n\nUpdate:\nAh it's just when entered into the repl directly (so not with console.log)\n> new Proxy({}, {})\nProxy [ {}, {} ]\n\nUpdate:\nI solved this locally without introducing a new symbol into inspect by tracking all facade created proxies and when inspecting if it's one of them I swap it with the original unwrapped value.",
                            "createdAt": "2018-02-24T20:15:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83c\udf89 re-implementing that method in js has fixed this bug\n\nWe don\u2019t want to implement the method in JS, since doing so would result in an additional stack frame in the stack trace displayed in Inspector when a console method is called.",
                            "createdAt": "2018-02-25T00:27:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton right now showProxy is handled before customInspect. It might in general be considered to switch that as it is currently not possible for users to have a custom inspect function and handle proxies on their side if they activate showProxy as you do in your example above.",
                            "createdAt": "2018-03-02T04:05:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR maybe we could switch that, but also provide the \"is proxy\" information to the custom inspect function, since there's no other way for it to get it?",
                            "createdAt": "2018-03-02T05:05:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb See #16485, which I was against in the first place.",
                            "createdAt": "2018-03-04T22:30:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/modules - can we please start with this in the next meeting and come to a consensus? It would be great if people came to the meeting with a formulated opinion. Optimally someone would present the dilemma and we could vote.",
                            "createdAt": "2018-03-05T08:46:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "I know it's pretty late in the game, but there is something VERY weird in having fs being both a default export object with properties, and having those properties being named exports of the same module.\nThe ESM syntax forbids implementing such a pattern (try it, you'll see), and while I'm sure this can be overriden using lots of proxies and getters and setters, the implementation would not be trivial.\nSo why are we creating an ES module which it is almost impossible to write as an ES module using the regular ESM syntax? Is doinh \"magic\" inside fs (and other native modules) a good approach? How would we even explain such a thing in terms that make sense in an ESM world? We can't. We can only explain it in terms that CJS people would understand!\nBut there is a neat solution for fs, a solution from ESM:  if the fs module just exported everything only as named exports! Then, if somebody wants to use specific functions, they do import {readFile} as 'fs', and if they want the whole fs object, they use import * as fs from 'fs'.\nEasily used, easily understood, and fits nicely in the ESM world.\nSo I submit we should make most of the NodeJS modules export their stuff as named exports only, without any default export.\n(The above is relevant for most of the NodeJS modules. For some special cases, like event, default exports make more sense.)",
                            "createdAt": "2018-03-15T19:15:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "The ESM syntax forbids implementing such a pattern (try it, you'll see)\n\nNo it doesn't. You just make the default export a proxy that updates the other exports... Which is how it's implemented.",
                            "createdAt": "2018-03-15T19:24:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "The ESM syntax forbids implementing such a pattern\n\nexport let a = 1;\nexport default {\n  get a() { return a; },\n  set a(v) { a = v; },\n};",
                            "createdAt": "2018-03-15T19:25:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "True, but my point is still valid. It's still an unnatural thing for ES modules. Difficult to explain, and not something that will be done by most ES Modules.\nBut given that it's late in the game, if there is no real support for my proposal, I will step down. :-)",
                            "createdAt": "2018-03-15T19:38:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "justinfagnani",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar fwiw, I agree with you. I think this pattern will be exceedingly rare in the user modules, and that a default export in this case brings very little value on top of import * as.",
                            "createdAt": "2018-03-15T19:49:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "the default export is specifically provided such that the named exports can be overridden",
                            "createdAt": "2018-03-15T19:51:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "the default export is specifically provided such that the named exports can be overridden\n\nDefinitely, but this is very CommonJS-ish. It doesn't translate well to the ESM world.",
                            "createdAt": "2018-03-15T20:01:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "Definitely, but this is very CommonJS-ish. It doesn't translate well to the ESM world.\n\nThese builtin packages are written in cjs... And will need to be forever, since cjs that depends on them is supposedly guaranteed to continue to work forever. This is just about exposing the same APIs in ESM as are available in CJS to ease a transition. If you wanted to provide an opinionated \"fs-better\" that blocks or prevents certain patterns, go right ahead (looks sideways at graceful fs); but that's not really what's needed or desirable from core for people to actually be able to migrate existing code that already uses these builtin libraries to newer syntax.",
                            "createdAt": "2018-03-15T21:22:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "What is the status here?",
                            "createdAt": "2018-04-10T00:26:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR modules team isn't merging anything atm while we talk about use cases etc",
                            "createdAt": "2018-04-10T01:11:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "This feature has got go-ahead in the modules meeting when we discussed it.\nI believe we\u2019re currently blocked on a proxy issue.\n\u2026\nOn Tue, 10 Apr 2018 at 03:11, Gus Caplan ***@***.***> wrote:\n @BridgeAR <https://github.com/BridgeAR> modules team isn't merging\n anything atm while we talk about use cases etc\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiyhTmZ4kVypWXPPcZwqX-fEuv3_M3ks5tnAasgaJpZM4RdLYy>\n .",
                            "createdAt": "2018-04-10T07:26:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford there is no technical limitation here, if nothing bureaucratic is holding this back i'd love to finish it up",
                            "createdAt": "2018-04-10T10:28:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Definitely, let's get this going then.\nI think we've solved all the main issues here with this mutatable default approach. I was just thinking, it would be nice to do some simple benchmarks of this for existing code, and perhaps comparing that to having setters on module.exports for reassignments instead of a proxy, just in terms of retaining property access performance on builtins. If proxy is fast enough at this point then it shouldn't be a problem though.",
                            "createdAt": "2018-04-10T14:49:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Can we remove the filter for setters too since there is no technical block on them.",
                            "createdAt": "2018-04-10T14:56:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek is this pending further review then?",
                            "createdAt": "2018-04-17T12:07:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford its been a very long time since i looked at this so i kinda need to go through the whole thing again and i was on vacation all last week. i hope to do something with this in a few days.",
                            "createdAt": "2018-04-17T12:34:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "I'd be pretty bummed if setters were still filtered. It complicates and diminishes something intended as an ecosystem olive branch by making things more complex for tools and users. For example, projects like webpack or babel 7 that want to allow limited .mjs use will now have to maintain a list (not great) or runtime check (complicates things) to throw errors when a user requests one of these filtered names. If instead, getters/setters were handled via the process established for APIs then tools wouldn't have to bake in more rules here and changes to the API would shake out naturally in this compat feature without extra work.",
                            "createdAt": "2018-04-17T15:19:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton don't worry I'll address that, I'm just trying to figure out this implementation a bit more... I'm not very happy with it at the moment",
                            "createdAt": "2018-04-22T20:03:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i rewrote this a bit if people wanna take a look. i consolidated stuff and made it a bit more streamlined and easier to reason with",
                            "createdAt": "2018-04-23T03:31:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@TimothyGu\naverage startup time with child process + loop + console.log(perf_hooks.performance.nodeTiming) + shameless rounding:\nwithout proxy (1000 runs) 79.71845515598729\nwith proxy (1000 runs) 90.33686945802346\ni didn't bother testing time of an individual require because it can only happen at max once. its also worth nothing this increased time should be more than handled by snapshots, whenever we finish those.",
                            "createdAt": "2018-04-24T02:38:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "alright so this is the 400th comment in this thread and i'm starting to consistently get the github unicorn when loading this. at the moment it works and this pr seems to be ready. that being said, i need some approvals on this. i would love to land this by the end of next week.",
                            "createdAt": "2018-04-28T23:08:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83d\udc4d As an initial landing of an experimental feature I think it's great. Every time I look at this implementation I find something in my own to improve! There are some things to dry-up and tweak here but they can be tackled in follow-up PRs.",
                            "createdAt": "2018-04-28T23:26:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "And, given that it's not a semver change (I think...), I believe there\nshould be no problem to land it?\n\u2026\nOn Sun, Apr 29, 2018 at 2:26 AM John-David Dalton ***@***.***> wrote:\n \ud83d\udc4d As an initial landing of an experimental feature I think it's great.\n Every time I look at this implementation I find something in my own to\n improve! There are some things to dry-up and tweak here but they can be\n tackled in follow-up PRs.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAYnRN0X4rkV7THOoKvx1uxnqEepfnzRks5ttPq_gaJpZM4RdLYy>\n .",
                            "createdAt": "2018-04-29T05:31:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "My greatest concern here is the potential 10% performance slowdown for NodeJS app startup having all core modules as proxies in CommonJS code, as Gus provided in some numbers at #18131 (comment).\nIt may turn out that creating setter-based core modules could be an alternative to the proxy approach that is also faster, so I do think this would still be worth seriously considering, or at least comparing for performance.\nThe benefit of a proxy over just a setter is supporting dynamic properties and object.defineProperty configuration cases. But dynamic properties are already not supported, so perhaps benefits may be worth the loss of configuration hooks.",
                            "createdAt": "2018-04-29T09:27:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford as long as the experimental flag is around i'd rather take it as an opportunity to experiment with the behaviour rather than perf optimisation. come time to ship it we can always make it more performant if needed. i'm also exceedingly hopeful that we will finish up snapshots by that time and then we won't have to worry this at all",
                            "createdAt": "2018-04-29T13:28:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "There is an important distinction between experimentation that doesn't\naffect legacy at all, and experimentation that creates a performance\nregression for existing code. I really don't think a 10% reduction in\nNodeJS startup time for existing codebases is a trivial matter to push\nthrough. Yes lets move fast with the modules work, but let's not slow down\nexisting NodeJS apps in the process.\n\nI'm also starting to get the unicorn for this page consistently - it is\nprobably worth closing this PR and opening a new one at this point I think\nto reset discussion for review.\n\u2026\nOn Sun, Apr 29, 2018 at 3:28 PM Gus Caplan ***@***.***> wrote:\n @guybedford <https://github.com/guybedford> as long as the experimental\n flag is around i'd rather take it as an opportunity to experiment with the\n behaviour rather than perf optimisation. come time to ship it we can always\n make it more performant if needed. i'm also exceedingly hopeful that we\n will finish up snapshots by that time and then we won't have to worry this\n at all\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18131 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiykOyOSII3TlhpYZvz4DcudoJs4Sjks5ttcAKgaJpZM4RdLYy>\n .",
                            "createdAt": "2018-04-29T13:40:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford this code doesn't run unless the flag is given, and yes i would agree a new pr is probably a good idea",
                            "createdAt": "2018-04-29T13:41:39Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 26540,
            "title": "async-hooks: introduce async-storage API",
            "author": {
                "login": "vdeturckheim"
            },
            "state": "CLOSED",
            "closedAt": "2020-02-23T19:25:03Z",
            "comments": {
                "totalCount": 208,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim build started: https://ci.nodejs.org/blue/organizations/jenkins/node-test-pull-request-lite-pipeline/detail/node-test-pull-request-lite-pipeline/2831/pipeline",
                            "createdAt": "2019-03-09T10:07:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@mscdex This was talked about at the diagnostics summit. I don\u2019t think the feature has to exist in this particular form, but having it in core made sense in general, and in particular performance-wise, since a good implementation could allow us to skip calling async_hooks callbacks.\nFYI @nodejs/tsc",
                            "createdAt": "2019-03-09T11:08:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I think this functionality belongs in core. We should offer a single way to do cls that is high performant, stable and reliable. It\u2019s not an ecosystem concern, it\u2019s a runtime concern (as much as a ThreadLocal implementation is for Java/.NET/.. etc).",
                            "createdAt": "2019-03-09T11:42:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I agree that this should be in core and there was consensus among the @nodejs/diagnostics WG members attending the diagnostics summit. Sure, we can bikeshed around the specific API, and I would like to get some of the APM vendors to review this before it lands, it would be generally better to have a single authoritative API and implementation of this than multiple userland implementations so that APM solutions built on top can be implemented consistently.",
                            "createdAt": "2019-03-09T11:54:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vsemozhetbyt",
                                "__typename": "User"
                            },
                            "bodyText": "Should we create npm placeholder for this name as per our guide?",
                            "createdAt": "2019-03-09T12:09:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "Go ahead. I kind of expect this to go under `@nodejs/async-storage` but\nbetter safe than sorry.\n\nIl giorno sab 9 mar 2019 alle ore 13:10 Vse Mozhet Byt <\nnotifications@github.com> ha scritto:\n\u2026\n Should we create npm placeholder for this name as per our guides?\n\n \u2014\n You are receiving this because your review was requested.\n Reply to this email directly, view it on GitHub\n <#26540 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AADL4xdIdUUD6v4zX5DYe6C_E1y5GCinks5vU6SmgaJpZM4bmmI4>\n .",
                            "createdAt": "2019-03-09T12:21:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vsemozhetbyt",
                                "__typename": "User"
                            },
                            "bodyText": "Sorry, I am not experienced in registering placeholders in npm, so anybody more confident please do it.",
                            "createdAt": "2019-03-09T12:28:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "There is https://www.npmjs.com/package/async-storage, which makes calling this module async_storage not a great idea. @nodejs/async_storage is ok.",
                            "createdAt": "2019-03-09T12:39:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Does this require a separate new top level module? Could this be exposed alternatively through the existing async_hooks module? Or via util?",
                            "createdAt": "2019-03-09T12:44:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell I actually think it would make sense to have that in util too. I am just worried potential future features would make this API big enough for us to regret it was not a module. That said, I'd be happy to move this to another module.",
                            "createdAt": "2019-03-09T14:13:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "I will update the PR over the week end and start to contact APM and RASP vendors to ensure thay can comment.\nThanks a lot to all of you for the comments and suggestions!",
                            "createdAt": "2019-03-09T14:17:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "if this is going to be in core I'd want it to be more similar to https://github.com/WICG/kv-storage",
                            "createdAt": "2019-03-09T14:20:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim ... One thing to consider is that by putting this into a new module, it automatically becomes semver-major and significantly harder to backport. My hope is that we could at least get this into 10.x also.",
                            "createdAt": "2019-03-09T14:22:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell good point, I'll move it to util then (this is a killer argument for me indeed ;) )\n@devsnek I did not know about this proposal. I'd be interested in other opinions here but the solutions I could see would probably be a bit slow.",
                            "createdAt": "2019-03-09T14:25:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim reading over this again it seems i was confused as to what this pr is adding to node.\ni think it might lend itself better to a different name like \"async_closure\" or \"async_context\" something.\ni'd be strongly in favor of making the class available as an async_hooks.Context",
                            "createdAt": "2019-03-09T14:29:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I think it would be better placed in async_hooks instead of util.",
                            "createdAt": "2019-03-09T14:31:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "othiym23",
                                "__typename": "User"
                            },
                            "bodyText": "As a developer and co-maintainer of continuation-local-storage, I\u2019m very happy to see this functionality coming to Node core, and am amused to see how positive the reception is this time. A lot can change in 6 years. If anyone wants to reuse the name, or join this with the existing continuation-local-storage, I\u2019m happy to hand the name over to the Foundation, although I understand that this implementation is simpler to use than CLS.",
                            "createdAt": "2019-03-09T17:11:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim I have the feeling that enter()/exit() APIs are misleading here. Usually I would expect every enter() call requires a matching exit() but at least in your samples/tests this is not the case. Seems exit() is optional. Maybe use createStore() instead enter()?\nMaybe we could even add one more abstraction here to avoid exposing a Map via getStorage() instead let users simply attach some value to the current async context/resource via e.g. set(key, value),  get(key) and clear(key).\nI'm also not clear about the current implementation. On the one hand it uses executionAsyncId() and a Map<asyncId, resource> and then it uses the resource as key in a WeakMap. At least now it's not guaranteed that resources get not reused. Seems to me like half way to the only resource based async_hooks implementation. But maybe I just misunderstood the implementation.",
                            "createdAt": "2019-03-12T13:26:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna\n\nI have the feeling that enter()/exit() APIs are misleading here. Usually I would expect every enter() call requires a matching exit() but at least in your samples/tests this is not the case. Seems exit() is optional. Maybe use createStore() instead enter()?\nindeed exit is optional. I am not a big fan of createStore as I want to keep the idea of some kind of transaction. I tried start/stop but it created confusion for tome people too. Maybe something like run/finish could work?\n\n\nMaybe we could even add one more abstraction here to avoid exposing a Map via getStorage() instead let users simply attach some value to the current async context/resource via e.g. set(key, value), get(key) and clear(key).\nThe only way I see to do it is through a getter or a proxy and I am not sure about the performance impact of using them.  In the long run, we could also allow people to pass a factory function to constructor and use it ti create the store, enabling users to have any data structure they want as a store.\n\n\nI'm also not clear about the current implementation. On the one hand it uses executionAsyncId() and a Map<asyncId, resource> and then it uses the resource as key in a WeakMap. At least now it's not guaranteed that resources get not reused. Seems to me like half way to the only resource based async_hooks implementation. But maybe I just misunderstood the implementation.\n\nThis used to be 100% resources-based but enter/exit had to be asynchronous (in order to garantee the existence of at least 1 parent scope. When moving to a synchronous API, I had to find a hack for when the triggerAsyncResource is not known.",
                            "createdAt": "2019-03-12T14:37:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@othiym23  thanks a lot for this posivitve message. I love the CLS and use it daily. Indeed, this current proposal aims at being simpler than it but a userland module could totaly offer the CLS API over it.\nI assume in 6 years the need for monitoring in Node.js has only raised making such API much needed.",
                            "createdAt": "2019-03-12T14:39:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax @mcollina @targos I have resolved a few conversations after updates based on your comments. Thanks a lot for them!",
                            "createdAt": "2019-03-12T14:41:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "Great to see this so soon after the discussion in the Diagnostic WG summit.",
                            "createdAt": "2019-03-12T21:28:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "I wonder if there is some way to make this separate from Async Hooks so that we could move it out of experimental separately from the rest of the API.  Part of the discussion at the summit was that if we had a CLS API there might be less need to expose the lower level details that come out through AsyncHooks or that it might be easier to change AsyncHooks more easily as many users would be using the Async Context APIs instead.",
                            "createdAt": "2019-03-12T21:31:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "Or at least some plan that allows for the CLS part being moved out of experimental separately from the reset of the Async Hooks API.",
                            "createdAt": "2019-03-12T21:32:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mhdawson Would documentation warnings be enough in that case? I actually think the CLS part is not that tied to Async Hooks as it is pretty high level, I could play the devil's advocate and say that, it could be backported on pre-async-hooks versions of Node using domains.",
                            "createdAt": "2019-03-13T16:05:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim I think we are thinking along the same lines, it is just it being part of the asynchooks \"namespace\" that seems to imply the binding.",
                            "createdAt": "2019-03-13T19:01:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kibertoad",
                                "__typename": "User"
                            },
                            "bodyText": "Is any help needed on this PR? Would be awesome to push it over the finish line before v12 lands.",
                            "createdAt": "2019-04-09T13:49:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@kibertoad thanks for the heads up. I have been a bit busy in the past weeks. I will go back at this PR this weel and over the week end :D",
                            "createdAt": "2019-04-09T13:56:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "I have a really hard time fixing this test (https://github.com/nodejs/node/pull/26540/files#diff-d3db248b4e7cc8e452bda97ee22c43bbR1) without going asynchronous.\n@kibertoad / @mcollina / @targos do you get what's going wrong? I will probably reverst for an asynchronous version later this week.",
                            "createdAt": "2019-04-15T18:02:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kibertoad",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim What error are you getting? CI seems to fail before actually executing tests.",
                            "createdAt": "2019-04-15T23:54:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@kibertoad yes: the context is lost in this case.",
                            "createdAt": "2019-04-16T11:02:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim I think the reason is that your implementation uses trigger path to propagate context.\nIn the testacase a Promise is created at the beginning/before the async function testAwait() with Id 2 which is not the current asyncId when asyncContext.enter() is called (it's 1). Then further promises are created with the above promise as triggerId but as this one has no entry in your map undefined is propagated and finally used.",
                            "createdAt": "2019-04-19T22:35:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "Hi!\n@vdeturckheim as we discussed, can you please take a peek on this gist of additional tests:\nhttps://gist.github.com/wentout/e048b59621ae875a65e287b0b7433623",
                            "createdAt": "2019-06-15T11:35:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@wentout thanks! actually this is a queue-related issue. I don't think there is an out-of-the-box solution (except from having queue creator to use the async_hooks API )",
                            "createdAt": "2019-07-15T16:13:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "This PR seems to be abandoned, or it's not?\nI'm curious if there is a chance that it'll be shipped in one of the upcoming releases and Node.js finally gets an CLS-like built-in API. The main advantage of the standard API that I see is that it'll motivate maintainers of popular libraries to make them more Async Hooks friendly.\nAt the moment it's a pain for developers who want to start using any library built on top of Async Hooks (like cls-hooked) into their apps. In case if they have any dependency that doesn't play nice with Async Hooks, they're either completely blocked, or have to deal with monkey patching (see this library as a good example https://github.com/abhiche/cls-redis-patch).",
                            "createdAt": "2019-09-06T08:25:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I have a few challenges to find time to fix this PR right now. I still hope to be able to to it before the end of the year. I agree with you, we really need this API in core.",
                            "createdAt": "2019-09-06T08:29:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "Hi @vdeturckheim\nIs there a chance that I could help you with finalizing this PR? If yes, could you send me items from your TODO list, so I could pick them up?",
                            "createdAt": "2019-10-19T07:03:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz thanks!\nBasicaly I am trying to find a way to have it work synchronously or at least, in a promise-friendly way without the potential memory leak that happened a while ago in domain (that's why I am using a weakref). I still have a context issue preventing this but I can't put my finger on it.",
                            "createdAt": "2019-10-20T15:25:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nBasicaly I am trying to find a way to have it work synchronously or at least, in a promise-friendly way without the potential memory leak that happened a while ago in domain (that's why I am using a weakref). I still have a context issue preventing this but I can't put my finger on it.\n\nIf I'm understanding your approach correctly, you're trying to trace CLS via resource path (just as @Flarna mentioned above). With this approach you need to capture the \"root\" resource in the #enter method. But the only way to do it is through Aysnc Hooks API.\nThat's why you came up with the current API: in #enter you first enable the hook and then you create a \"root\" resource with the process#nextTick call. Such API should work, but it also means that all subsequent resources should be created in the callback provided by the user. This API certainly has some restrictions (as it may be seen in the existing tests) and I'm not sure if #enter can be converted into a sync method without changing the approach to the execution path (similar to the one used in #27172).\nPlease correct me if I'm wrong.",
                            "createdAt": "2019-10-24T14:19:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nI have some ideas on how to improve current implementation. These ideas may be seen in this commit. Namely, they are:\n\nRename enter() into run() as the name is misleading. The signature of the callback argument was also changed, as well as the way how this method is used in tests.\nImplement copy-on-write semantics for the store (see test/async-hooks/test-context-propagation.js to understand why it's important). I had to remove explicit getStore() in favor of get()/set() to achieve it.\n\nOf course, my branch is an early draft, which is sufficient to show these ideas. Before continuing with TODOs, documentation and tests I'd like to hear your feedback on the approach. Do you think it's the right direction?\nAlso I'm curious if it's OK if I go further with polishing my branch and then create a separate PR that will refer to this one or it's better to merge my changes into your branch somehow?",
                            "createdAt": "2019-10-30T15:41:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz wow thanks a lot!\nI think this is the right direction. Friday is off here and I will finally secure some time to work on that.\nI will:\n\nreview your changes by Saturday evening (Paris time)\nanswer to you in details\n\nI really appreciate you helping/pushing here. Sometimes that boost of energy is much needed!",
                            "createdAt": "2019-10-30T16:10:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz thanks a lot!\n\nI really appreciate you helping/pushing here. Sometimes that boost of energy is much needed!\n\n@vdeturckheim\nThank You very much! Indeed this is the API to move further...\n@watson\nSorry for asking, please, as a diag CLS Champion what do you think of discussing this PR there?",
                            "createdAt": "2019-10-30T16:36:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nThanks for the quick reply! I'll be waiting for any updates from you.",
                            "createdAt": "2019-10-30T16:36:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I just reviewed your commit:\n\nRenaming: all good for me.  Probably a discussion to have with the other reviewers\nCopy on propagation: I am not a big fan of this point.  It would bring a significant performance impact on  the API - What is the main goal here?",
                            "createdAt": "2019-11-02T15:44:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nCopy on propagation: I am not a big fan of this point. It would bring a significant performance impact on the API - What is the main goal here?\n\nThe main goal is to isolate different nested resources from each other. As the most illustrative example, imagine an HTTP server where we need to assign unique id to each request. If the AsyncContext's store is shared (no copy-on-write) all request handlers will \"see\" the same value instead of seeing different value per each request. Moreover, in this case that value will be overwritten by each incoming request.\nThe test/async-hooks/test-context-propagation.js test shows an even more simple example where copy-on-write is a must have (the test is quite ugly, but it's enough for demonstration of the idea):\nasyncContext.run(() => {\n  asyncContext.set('root', 'value0');\n  \n  setTimeout(() => {\n    asyncContext.set('nested', 'value1');\n    setTimeout(() => {\n      assert.strictEqual(asyncContext.get('root'), 'value0');\n      assert.strictEqual(asyncContext.get('nested'), 'value1');\n    }, 200);\n  }, 200);\n\n  setTimeout(() => {\n    asyncContext.set('nested', 'value2');\n    setTimeout(() => {\n      assert.strictEqual(asyncContext.get('root'), 'value0');\n      // here we expect to see 'value2' which is local to this async chain\n      assert.strictEqual(asyncContext.get('nested'), 'value2');\n    }, 200);\n  }, 200);\n});\nSo, the copy-on-write semantics is required for proper isolation of nested async call/resource chains. Each of these chains will get it's own copy, which includes all key-value pairs from the root context and which is propagated to all downstream async calls/resources.\nHopefully, I've explained the idea well enough.",
                            "createdAt": "2019-11-02T16:42:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz Gotcha! Actually I was making the enter/exit methods synchronous and I realize that the API would be way harder to use without the object copy. I will probably need to bench the cost of that operation before merging.",
                            "createdAt": "2019-11-02T16:56:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "But this leads to another painful situation:\n'use strict';\nconst assert = require('assert');\nconst { AsyncStorage } = require('async_storage');\n\nconst asyncStorage = new AsyncStorage();\nasync function test() {\n  await Promise.resolve();\n  assert.strictEqual(asyncStorage.getStore().get('a'), 1);\n  assert.strictEqual(asyncStorage.getStore().get('b'), 10);\n}\n\nasync function main() {\n  asyncStorage.getStore().set('b', 10);\n  await test();\n  assert.strictEqual(asyncStorage.getStore().get('b'), 10);\n}\nasyncStorage.enter();\nasyncStorage.getStore().set('a', 1);\nmain()\n  .then(() => {\n    assert.strictEqual(asyncStorage.getStore().get('a'), 1);\n    assert.strictEqual(asyncStorage.getStore().get('b'), 10);\n  });\n\nwill fail because before and after the await call, we are in different contexts.",
                            "createdAt": "2019-11-02T17:10:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nI see no problem with the test above when re-written with the proposed AsyncContext API. Here how it looks in that case (this test passes successfully on my machine):\n'use strict';\nconst assert = require('assert');\nconst { AsyncContext } = require('async_hooks');\n\nconst asyncContext = new AsyncContext();\nasync function test() {\n  await Promise.resolve();\n  assert.strictEqual(asyncContext.get('a'), 1);\n  assert.strictEqual(asyncContext.get('b'), 10);\n}\n\nasync function main() {\n  asyncContext.set('b', 10);\n  await test();\n  assert.strictEqual(asyncContext.get('b'), 10);\n}\n\nasyncContext.run(() => {\n  asyncContext.set('a', 1);\n  main()\n    .then(() => {\n      assert.strictEqual(asyncContext.get('a'), 1);\n      assert.strictEqual(asyncContext.get('b'), 10);\n    });\n});",
                            "createdAt": "2019-11-02T17:38:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nIs there anything I could help you with? Like benchmarking the overhead of copy-on-write and/or CLS in general or something else.",
                            "createdAt": "2019-11-03T07:02:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Shahor",
                                "__typename": "User"
                            },
                            "bodyText": "Glad to see this move forward, this is really lacking in core and will provide a great unified way of dealing with that issue, effectivelly making the platform better.\nAlthough this might be a hard one to jump into to start with node, I'm happy to help if necessary/possible :)\n\ud83d\udcaa",
                            "createdAt": "2019-11-18T21:59:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "I just pushed a commit switchig the enter method as synnchronous.\ncc @addaleax  @jasnell @cjihrig @Qard @puzpuzpuz @Trott",
                            "createdAt": "2019-12-12T19:58:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nLooks like there might be problems with sync .enter() method + async/awaits. Here is an example:\n'use strict';\n\nconst async_hooks = require('async_hooks');\n\nfunction printHooked(msg) {\n    console.log(`${msg.padEnd(15)}, res id: ${async_hooks.executionAsyncId()}, trigger res id: ${async_hooks.triggerAsyncId()}`);\n}\n\nasync function test() {\n    printHooked('before nextTick');\n    process.nextTick(() => {\n        printHooked('inside nextTick');\n    });\n    printHooked('before await');\n    await new Promise((resolve) => {\n        setTimeout(resolve, 0);\n    });\n    printHooked('after await');\n}\n\ntest().then(() => printHooked('done'));\nThe output on v12.13.1, v13.2.0 and v13.3.1-nightly20191204355b48bd06 is the following:\nbefore nextTick, res id: 1, trigger res id: 0\nbefore await   , res id: 1, trigger res id: 0\ninside nextTick, res id: 5, trigger res id: 1\nafter await    , res id: 0, trigger res id: 0\ndone           , res id: 0, trigger res id: 0\n\nYou may notice the after await entry which has 0 resource as both current and trigger resource. My bet is that asyncStorage.getStore() placed after the await won't work because of that. That's because when this call is made the current resource is \"outer\" when compared with the resource captured in .enter().\nAnother thing to mention is that with sync API it would be nice to expose .exit() method as well.\nWDYT?",
                            "createdAt": "2019-12-13T08:16:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I am not sure I get it. isn't that one of the cases covered in the tests?\nCurrently there is no exit as of #26540 (comment). I was thinking about cases for it yesterday but could not see a good need for it so far. Do you have examples where it is needed?",
                            "createdAt": "2019-12-13T14:28:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I am not sure I get it. isn't that one of the cases covered in the tests?\nCurrently there is no exit as of #26540 (comment). I was thinking about cases for it yesterday but could not see a good need for it so far. Do you have examples where it is needed?\n\nIt might be helpful to free some resources. For example if we .unref() something we then might be able to collect the garbage after, therefore if we still sharing pointers somewhere, I suppose .exit() might be something like .emerge() for collected resources. Anyway I'm not an expert, only giving opinion: I'd like to free resouces auto-magicaly.",
                            "createdAt": "2019-12-13T15:23:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nI am not sure I get it. isn't that one of the cases covered in the tests?\n\nIf you mean test-async-functions-context.js test, then not exactly. Here is an updated version of this test (it reproduces the above sample) and it fails:\n'use strict';\nconst common = require('../common');\nconst assert = require('assert');\nconst { AsyncContext } = require('async_hooks');\nconst asyncContext = new AsyncContext();\n\nasync function testAwait() {\n  const store = asyncContext.enter();\n  store.set(\"key\", \"value\");\n  // the following two asserts pass\n  assert.notStrictEqual(asyncContext.getStore(), undefined);  // asserts\n  assert.strictEqual(asyncContext.getStore().get(\"key\"), \"value\");\n\n  await new Promise((resolve) => {\n    setTimeout(resolve, 0);\n  });\n\n  // the following two asserts fail\n  assert.notStrictEqual(asyncContext.getStore(), undefined);  // asserts\n  assert.strictEqual(asyncContext.getStore().get(\"key\"), \"value\");\n}\n\nassert.doesNotReject(testAwait);\n\nCurrently there is no exit as of #26540 (comment). I was thinking about cases for it yesterday but could not see a good need for it so far. Do you have examples where it is needed?\n\nI can't give concrete use cases, but I believe that some users may want to be able to exit CLS context explicitly.",
                            "createdAt": "2019-12-13T15:23:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nI am not sure I get it. isn't that one of the cases covered in the tests?\n\nIf you mean test-async-functions-context.js test, then not exactly. Here is an updated version of this test and it fails:\n'use strict';\nconst common = require('../common');\nconst assert = require('assert');\nconst { AsyncContext } = require('async_hooks');\nconst asyncContext = new AsyncContext();\n\nasync function testAwait() {\n  const store = asyncContext.enter();\n  store.set(\"key\", \"value\");\n  // the following two asserts pass\n  assert.notStrictEqual(asyncContext.getStore(), undefined);  // asserts\n  assert.strictEqual(asyncContext.getStore().get(\"key\"), \"value\");\n\n  await new Promise((resolve) => {\n    setTimeout(resolve, 0);\n  });\n\n  // the following two asserts fail\n  assert.notStrictEqual(asyncContext.getStore(), undefined);  // asserts\n  assert.strictEqual(asyncContext.getStore().get(\"key\"), \"value\");\n}\n\nassert.doesNotReject(testAwait);\n\nCurrently there is no exit as of #26540 (comment). I was thinking about cases for it yesterday but could not see a good need for it so far. Do you have examples where it is needed?\n\nI can't give concrete use cases, but I believe that some users may want to be able to exit CLS context explicitly.\n\nIndeed we might suppose the following scenario:\n\nhaving pointers for all my started execution paths throug variety of CLS vectors\nthen receiving uncaughtExceptions somewhere, or SIGINT or SIGUSR2\nwish to close resources properly, cause there are pointers to incoming HTTP Request, Open DB Connection, associated with that request, and there might be even open request to DB inside, and so on. And I wish to be able to share this between resources. That is why I store them inside of CLS vector, but not inside through arguments of methods of that Execution Path. And only thing I have is a fact that I'm inside of uncaughtException now, and have to grab all that stuff somehow.\n\nI know this is an example of bad architecture, but there might be code like this in wild world.",
                            "createdAt": "2019-12-13T15:28:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@wentout make sense. I'll fix @puzpuzpuz 's case then check how exit should work.",
                            "createdAt": "2019-12-13T15:33:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I can't find any good solution to cover your care and keep the API syncrhonous at the same time. Do you see anything?",
                            "createdAt": "2019-12-13T16:16:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I can't find any good solution to cover your care and keep the API syncrhonous at the same time. Do you see anything?\n\nI don't think of synchronous .exit(), I can wait on interrupt. Suppose there might be special note in the documentation, the same as for ReadLine and underlying streams...",
                            "createdAt": "2019-12-13T16:21:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@wentout I was more thinking about fixing #26540 (comment)",
                            "createdAt": "2019-12-13T16:24:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nI can't find any good solution to cover your care and keep the API syncrhonous at the same time. Do you see anything?\n\nUnfortunately, no. I can only think of fixing it with async API, e.g. such as was proposed here: #26540 (comment)",
                            "createdAt": "2019-12-13T16:27:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "@wentout I was more thinking about fixing #26540 (comment)\n\nIndeed, thank you!\nIf I only could, I'd be able to finish it. But somwhere there my are just not enough skills.\nAnyway the state of app on uncaughts~unhandleds is unpredictable, and my only hope is to collect some more data for logging and monitoring systems. Otherwise I will not be able to grab Open Tracing ID of the failed execution path. And after receiving exception I can wait some additional time to receive notification from resources about closing if I'd have Resource ID that is failed. I mean, I can collect it via some chaining, I know which callback were forbidden after error occures, but I'm unalle to predict the way where it fails. With this API all this becomes possible. And if .exit() is there, I don't even have to care of tracking all the resources, cause they will receive notification. I think of something like Atomics and Shared Array Buffer notification for CLS resources.",
                            "createdAt": "2019-12-13T16:28:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "So, it seems that there is no good solution for a synchronous (or even promise-friendly) API at the moment.\nI would recommend to fully go with the last version (asynchronous API with a run method). This does not prevent us from adding a runSync or any other syncrhonous API we can build in the future.",
                            "createdAt": "2019-12-13T18:49:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sam-github",
                                "__typename": "User"
                            },
                            "bodyText": "I don't have my head in this enough anymore to do a in-depth review, but I  think this solves a real problem, particularly for APM and for CLS users (like opentracing, jaeger, etc.) and would very much like to see it solved in core, so that ecosystem packages that lose context can have it reported as a bug, and fixed, leading to more robust CLS for everyone.",
                            "createdAt": "2019-12-13T19:53:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/27639/",
                            "createdAt": "2019-12-13T20:35:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/diagnostics @nodejs/async_hooks",
                            "createdAt": "2019-12-13T20:38:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@mscdex Can you confirm that you still oppose this in its current form or else clear your request for changes?",
                            "createdAt": "2019-12-13T20:39:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/27641/",
                            "createdAt": "2019-12-13T21:01:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr I just updated the doc. Is that what you had in mind? Thanks so much for reviewing this!",
                            "createdAt": "2019-12-13T21:20:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "I think the doc linter is unhappy but I have a hard time reading the output",
                            "createdAt": "2019-12-13T21:30:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "It would be good to get a profile measure of this.\n\nI would assume pretty slow given async hooks have a ~2-3x performance penalty on promises IIRC (right?). I think a benchmark vs. a userland solution would be nice. If it is up for core to provide this (rather than vendor a blessed module) I think it needs justification.\nIf the process for doing so wasn't so hard I would recommend a userland model that Node blesses and maintains - but given our current processes I am more +1 on this than -1.\n\nAs a side note I realised most of my comments were criticism or questions and I forgot to say thanks for working on this. I somehow missed this in the last few months when reviewing. So - thank you for working on this hard and important problem and for your effort \ud83d\ude4f",
                            "createdAt": "2019-12-13T21:33:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I still think that async enter/ exit is problematic as it requires to change the control flow for using CLS. This may be acceptable for users which have full control of their program logic but for tools like OpenTelemetry and APMs which hook calls in the middle between user code and libraries (e.g. mongodb) it's not possible to change control flow.\nTo my understanding the reason why a sync enter/exit is not possible is that propagation via the triggerId is used and not executionId.\nWhy is it that important to use the trigger path here? All CLS implementations I have seen till now use the execution path.",
                            "createdAt": "2019-12-13T21:36:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina @benjamingr I am not sure of the perf impact of WeakReference. I will try to benchmark this but I will have limited bandwidth. Maybe we can merge and optimize in another PR later?",
                            "createdAt": "2019-12-13T21:39:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna the main approach of this PR is to limit/remove the memory leak introduced when destroy is not called or called way later.\nI don't think megring this soon will prevent us from updating the API later (introduce a runSync or runAndReturn method for instannce) if we find good and safe solutions.",
                            "createdAt": "2019-12-13T21:41:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim thanks for the clarification!\nidResourcePairing still relies on delete hook to get elements removed even the linked resource is just referenced weak. I think it's worth to link #21313 here which targeted the removal of the destroy hook - at least for CLS use cases.\nThat time it was mostly for performance reasons but I'm quite sure that avoiding leaks because of missing calls to destroy is more important then performance.\nI thought about a followup on #21313 but unfortunatelly I found no time till now.",
                            "createdAt": "2019-12-13T22:28:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna agreed! I believe the weakref mitigates the leak enough for this to be acceptable. But indeed this is made with the idea that #21313 will eventually happen and we can rewrite the API over currentResource",
                            "createdAt": "2019-12-13T22:32:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "I'd like to re-iterate over a couple of ideas for potential enhancements.\nThe first one is copy-on-write semantics (see previous comments from @Flarna and #26540 (comment)). I believe that it will help users to avoid lots of issues: for example, some of them will wrap the whole app.listen() call of their Express app and write/read something into/from CLS on each request; if they use a different key for each request, with current design (a single Map) they'll get a mem leak; with copy-on-write it won't be a problem\nAnother problem mentioned by @Flarna is misbehaving resources that don't emit destroy events. In such situations there will be dangling entries in idResourcePairing map, thus a mem leak. Potentially that one could be solved without async_hooks.currentResource (i.e. support in native code), but with FinalizationGroup API. See #26540 (comment).",
                            "createdAt": "2019-12-14T06:31:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "I just finished a rebase of the current resource PR, so if that lands I can update this to use that and eliminate the risk of the missed destroy hook leak. #30959",
                            "createdAt": "2019-12-14T15:01:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "The first one is copy-on-write semantics (see previous comments from @Flarna and #26540 (comment)). I believe that it will help users to avoid lots of issues: for example, some of them will wrap the whole app.listen() call of their Express app and write/read something into/from CLS on each request; if they use a different key for each request, with current design (a single Map) they'll get a mem leak; with copy-on-write it won't be a problem\n\nI still think the performance impact of copyinng this would be too high.\n\nAnother problem mentioned by @Flarna is misbehaving resources that don't emit destroy events. In such situations there will be dangling entries in idResourcePairing map, thus a mem leak. Potentially that one could be solved without async_hooks.currentResource (i.e. support in native code), but with FinalizationGroup API. See #26540 (comment).\n\nThis will be fixed by #30959",
                            "createdAt": "2019-12-14T16:34:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@cjihrig Just applyes your comments. Thanks for the review!",
                            "createdAt": "2019-12-14T16:43:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard this is awesome! I'm good with holding this PR if #30959 is merged soon! (I will review it today)",
                            "createdAt": "2019-12-14T16:44:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim, @Qard\n\nI just finished a rebase of the current resource PR, so if that lands I can update this to use that and eliminate the risk of the missed destroy hook leak. #30959\n\nWow! With this new executionAsyncResource() function the standard CLS API can be greatly simplified, both internally and externally.\nNo need to deal with WeakRefs, WeakMap and, even Map anymore. It can be as simple as shown here: https://github.com/nodejs/node/pull/30959/files#diff-0fcb81ef709be21a5573a3aecbe5c204R26\nThus, its public API may contain only a constructor, .set(), .get() and, maybe, .close() methods and that's it. The only problem with this API may be in certain async/await scenarios, like the #26540 (comment) one. But even if this becomes the problem, the implementation still can be simplified a lot.",
                            "createdAt": "2019-12-14T17:32:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I thik that the #26540 (comment) case is still blocking to have an API siimpler than what's iin the PR right now.",
                            "createdAt": "2019-12-14T18:32:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I thik that the #26540 (comment) case is still blocking to have an API siimpler than what's iin the PR right now.\n\nThat might be the case and that's why I wrote the following:\n\nThe only problem with this API may be in certain async/await scenarios, like the #26540 (comment) one. But even if this becomes the problem, the implementation still can be simplified a lot.\n\nAs for that scenario, I think it's worth it to discuss it with node core/V8 teams. Maybe it's an edge case and it's possible to change the behavior of async/await.",
                            "createdAt": "2019-12-14T19:40:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I thik that the #26540 (comment) case is still blocking to have an API siimpler than what's iin the PR right now.\n\nI'm quite sure the reason why this test fails is that propagation via triggerID is used.\nSee https://github.com/nodejs/node/pull/27172/files?file-filters%5B%5D=.js#diff-1001eb2fa5d735649f8bb6f43eb961b7R63-R76 for a similar test using AsyncLocal I proposed a while ago which uses execution path. It passes without the need to have an async creation/enter.",
                            "createdAt": "2019-12-14T22:14:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna\n\nI'm quite sure the reason why this test fails is that propagation via triggerID is used.\nSee https://github.com/nodejs/node/pull/27172/files?file-filters%5B%5D=.js#diff-1001eb2fa5d735649f8bb6f43eb961b7R63-R76 for a similar test using AsyncLocal I proposed a while ago which uses execution path. It passes without the need to have an async creation/enter.\n\nThanks for the heads up!\nYour test is a little bit different: the hook is enabled in constructor, which is called outside of the async function under test. Because of that it's able to capture the root resource and the test passes.\nHere is how your test would look like:\nasync function asyncFunc() {}\n\n// the line from original test\n// const asyncLocal = new AsyncLocal();\n\nasync function testAwait() {\n  // the line from updated test\n  const asyncLocal = new AsyncLocal();\n\n  asyncLocal.value = 42;\n  await asyncFunc();\n  assert.strictEqual(asyncLocal.value, 42);\n}\ntestAwait().then(common.mustCall(() =>\n  // this one is not valid anymore\n  // assert.strictEqual(asyncLocal.value, 42)\n));\nBut in general, I'd say that it's safe to advice users to interact with the context like it's done in your test, not in #26540 (comment), and this should solve the problem.\nAPI of AsyncLocal from your PR is quite close to what was described in #26540 (comment). And what's even more important, standard CLS based on executionAsyncResource() would be much safer than any APIs based on the execution path (\u00e0 la cls-hooked).\nWDYT?",
                            "createdAt": "2019-12-15T07:17:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz Added a test as suggested by you (still passing).\n\nCLS based on executionAsyncResource() would be much safer than any APIs based on the execution path\n\nYour proposed cls is using execution path, see your init hook.\nIt sets the context from current executing resource (not the triggering resource) to the new, initializing resource.\nThe only difference between using executionAsyncId and executionAsyncResource is that latter avoids the need for a (potential leaking) Map<id, context>,  instead it allows to put the context as member into the resource or use a (leak free) WeakMap<resource, context>. This difference makes it saver (and hopefully more efficient) but it doesn't change the path how a context is propagated.",
                            "createdAt": "2019-12-16T08:02:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna\n\nYour proposed cls is using execution path, see your init hook.\nIt sets the context from current executing resource (not the triggering resource) to the new, initializing resource.\n\nIt's a matter of terminology, but I have nothing against calling it execution path.\nBTW I thought that executionAsyncResource(), when it's called in init(), will return the triggerAsyncId resource. The documentation update for executionAsyncResource() (for some reasons it's called currentResource() there - I guess it'll be fixed soon) in #30959 says the following:\n* Returns: {Object} The resource that triggered the current\n  execution context.\n  Useful to store data within the resource.\n\nDo you think there are cases when this description is wrong, i.e. current executing resource of init() is different from the triggering resource?\n\nThe only difference between using executionAsyncId and executionAsyncResource is that latter avoids the need for a (potential leaking) Map<id, context>, instead it allows to put the context as member into the resource or use a (leak free) WeakMap<resource, context>. This difference makes it saver (and hopefully more efficient) but it doesn't change the path how a context is propagated.\n\nYes, that was my point. It's safer and doesn't involve additional data structures, like WeakMap or Map, thus it should be more efficient.",
                            "createdAt": "2019-12-16T08:18:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I think we should not mix up the propagation of a context by a CLS system and the API added in #30959 to get the current executing resource.\nThe init hook is called when a new async operation is created (not yet executed!). It's called by another async resource - that one returned by the API in #30959 and this resource has id you get from executionAsyncId().\nThe triggerAsyncId passed as 3rd argument to init may be the same as executionAsyncId() but it may be a different one (see https://nodejs.org/dist/latest-v13.x/docs/api/async_hooks.html#async_hooks_triggerasyncid).\nA CLS system has to decide in the init hook to either propagate the CLS context from the executionAsyncId of from triggerAsyncId.",
                            "createdAt": "2019-12-16T10:08:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna\n\nThe triggerAsyncId passed as 3rd argument to init may be the same as executionAsyncId() but it may be a different one (see https://nodejs.org/dist/latest-v13.x/docs/api/async_hooks.html#async_hooks_triggerasyncid).\nA CLS system has to decide in the init hook to either propagate the CLS context from the executionAsyncId of from triggerAsyncId.\n\nThanks for the clarification! It now makes sense to me.\nDo you happen to know of any problems with CLS APIs based on the execution path context propagation? Like the implementation from #30959:\nconst hook = createHook({ init });\nhook.enable();\n\nconst clsSymbol = Symbol('cls');\nfunction init(asyncId, type, triggerAsyncId, resource) {\n  var cr = executionAsyncResource();\n  if (cr !== null) {\n    resource[cls] = cr[cls];\n  }\n}\nAs far as I understand, they should have some restrictions, like the one that was discussed here: #26540 (comment)",
                            "createdAt": "2019-12-16T11:38:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not aware of any restrictions. The main point is that two variants exist and both are \"correct\" - it depends on what a user wants/expects.\nconsider an incoming HTTP request: via triggerId you can track back to the HTTP server, via executionId it's something new.",
                            "createdAt": "2019-12-16T12:27:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not aware of any restrictions. The main point is that two variants exist and both are \"correct\" - it depends on what a user wants/expects.\nconsider an incoming HTTP request: via triggerId you can track back to the HTTP server, via executionId it's something new.\n\nI'd wish we can track that incoming HTTP request forward to uncaughtException caused by this request. If it fits all the other prepositions. It would be nice to grab it via CLS. If this can be made, then that it would be nice to use CLS to store any additional data.",
                            "createdAt": "2019-12-16T13:20:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/27784/",
                            "createdAt": "2019-12-18T17:52:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/27805/",
                            "createdAt": "2019-12-19T06:22:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/27809/",
                            "createdAt": "2019-12-19T12:54:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott thanks for starting CI. Now it's all green. Do we have enough \ud83d\udc4d to merge?",
                            "createdAt": "2019-12-19T13:50:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "We need @mscdex to unblock or to go to a vote I believe if we want to merge this.",
                            "createdAt": "2019-12-20T13:27:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "How does this related to #31016 ?\nDo we have to choose between both, or they don't solve the same problem?",
                            "createdAt": "2019-12-20T15:44:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@targos this PR, #31016 and #27172 are solving the same problem.\nAs discussed with @Qard  the current code should be updated when #30959 but we can merge it first and update later.\n(edit) -> This means that there will eventually be no call to destroy when this update is done. Currently this PR mocks of #30959",
                            "createdAt": "2019-12-20T15:51:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@targos\n\nHow does this related to #31016 ?\nDo we have to choose between both, or they don't solve the same problem?\n\nYes, they solve the same problem. I've tried to compare #31016 with this PR here: nodejs/diagnostics#345 (comment)",
                            "createdAt": "2019-12-20T15:56:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/tsc There\u2019s an outstanding objection by @mscdex here (from March), and @vdeturckheim has indicated to me that he\u2019d like to move forward with this PR at this point despite that objection. I\u2019m adding the tsc-agenda label because of that.",
                            "createdAt": "2019-12-24T13:35:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "This is definitely a functionality that should be in core so I'm +1 on moving forward over the objection. But, I have not yet had the opportunity to review the PR in detail so can't yet sign off.",
                            "createdAt": "2020-01-08T15:33:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina If it lands as experimental, is it really necessary to block it for that? I agree that it should use that, when it's ready, but I think the two can be landed in isolation and just not stabilize until both are in.",
                            "createdAt": "2020-01-08T18:58:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sam-github",
                                "__typename": "User"
                            },
                            "bodyText": "Is the advantage to having this be in core instead of userland is it allows PRs to be made to update modules that don't track async resource pools to be described as \"doesn't work with core CLS\", as opposed to \"doesn't work with this thirdparty module?\". The latter is more likely to be treated with a shrug.",
                            "createdAt": "2020-01-08T20:36:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@sam-github this is one of the advantages of having this in core indeed.\nAnother one is that we can iterate on Async Hooks API (which is still debated) and have a stable higher level API handling most of the use cases.",
                            "createdAt": "2020-01-09T15:16:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "I'll also chime in that I see the value of having this in core due to the advantages mentioned.",
                            "createdAt": "2020-01-09T15:27:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@sam-github This topic was also discussed on Diagnostics Summit last march (recordings there).\nGetting async hooks out of experimental will not happen soon for serveral reasons. But this hinders useland modules to adapt using AsyncResource as it may change/go away at any time (at least in theory).\nIdea was to add a high level CLS API in core which covers the most wanted use case of async hooks. Getting this out of experimental should be easier because it e.g. doesn't expose internal objects.\nHaving AsyncResource and an CLS API non exerimental in core (even if they use experimental async hooks internally) would be a good basement for userland modules to use it.",
                            "createdAt": "2020-01-09T18:22:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/tsc having spent a bit of time looking at this I think the 2 separate questions the TSC is being asked to answer are as below and I think we should answer/discuss each of those separately:\n(Edited to add third point 10 Jan)\n\nShould and API like this this be in core or not (several people have already chimed on this)\nWhat should the API look like, we have 2 PRs which mostly differ by:\n\nNaming of what you create, AsyncContext versus AsyncLocal\nRoot datatype, any Object versus a (store/map)\nHaving to wrap in run() or not.\n\n\nDo we need to wait until  #30959  lands or can this land and then be updated to use  #30959  later.\nThis would allow experimentation to begin and we don't believe API changes would be needed\nonce  #30959  lands.",
                            "createdAt": "2020-01-09T20:59:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mhdawson regarding the three main differences between the PRs, my take would be:\n\nNaming: both names make sense and it's a minor choice\nRoot datatype: I am uncomfortable with having a method as get(): any which would return undefined until a call to set(x: any) is made. I usually prefer methods to have a stable signature. Also, this will prevent megamorphism that might make TurboFan unhappy.\nrun, this is mostly for me an outcome of the domain port-mortem where it is explained that possible the syncrhonous behavior was a source of issues. As I forsee people building light implementations of domain over this API (by keeping an HTTP context and adding a process exception handler), I believe that the call to run clearly limits the scope of the AsyncContext.\n\nAlso, even if this code is designed to be updated over #30959 when it lands, it can still be merged by itself and enable us to move forward and iterate on the concept.",
                            "createdAt": "2020-01-10T09:19:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim goog point about whether we need  to wait for #30959 or not, I'll edit my comment to list that as another question that should be answered.",
                            "createdAt": "2020-01-10T21:29:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "If we don't think the API would have to change after  #30959 lands, I'd be ok with this landing in advance so that people can start trying it out first.",
                            "createdAt": "2020-01-10T21:31:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wentout",
                                "__typename": "User"
                            },
                            "bodyText": "If we don't think the API would have to change after #30959 lands, I'd be ok with this landing in advance so that people can start trying it out first.\n\nAnd if then, they still can make their own Issue or PR if they would need to try to change something",
                            "createdAt": "2020-01-10T23:16:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "If we don't think the API would have to change after #30959 lands, I'd be ok with this landing in advance so that people can start trying it out first.\n\nMy two cents.\nOnce #30959 lands, it'll be possible to implement a sync API here (e.g. with sync .enter() method. AFAIK that was the original intention for this PR, but it's not possible to build such API without having executionAsyncResource().\nAnother reason to wait for executionAsyncResource() is memory safety (see https://github.com/nodejs/node/pull/26540/files#r349906661).",
                            "createdAt": "2020-01-11T06:44:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@targos suggested I published a userland implementation to make testing easier for reviewer:\nYou can find it on npm (https://www.npmjs.com/package/userland-async-context)\nand Github https://github.com/vdeturckheim/UserlandAsyncContext\nThe only code difference between this module and the PR is the use of the native WeakRef class (thanks to a smart hack I found in a response to an issue from @addaleax!)",
                            "createdAt": "2020-01-17T16:22:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim Is there any chance we could vendor that module into Node.js core, rather than adding its code, and moving it into the Node.js org? Would you be open to that suggestion?",
                            "createdAt": "2020-01-18T21:11:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax thanks a lot for this suggestion!\nif I understand, vendoring it into core means it would still be available with Node.js (not through npm). If so, this works perfectly for me!\nIt might also be easier to track user's feedback during it's experimental phase this way.",
                            "createdAt": "2020-01-20T14:30:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim It could be available through both, if you like.\n\nIt might also be easier to track user's feedback during it's experimental phase this way.\n\n\ud83d\udc4d",
                            "createdAt": "2020-01-20T15:43:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "The TSC reached consensus in nodejs/TSC#803 that we do want an Async storage API in core.  That means that from the questions:\n\nShould and API like this this be in core or not (several people have already chimed on this)\nWhat should the API look like, we have 2 PRs which mostly differ by:\nDo we need to wait until #30959 lands or can this land and then be updated to use #30959 later.\n\nWe have TSC agreement that we want an Async API in core despite the objections to that raised in this issue and it makes sense to move to to the next questions.\nThe next step is to agree on what the API should look like.  @vdeturckheim what you do think the next step is in terms of trying to get to an agreement between those involved in the 2 PRs as to what the API should look like?",
                            "createdAt": "2020-01-22T21:34:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mhdawson thanks for the update!\nAs you mentionned there are 3 main differences between the 2 PRs in term of design and 1 difference regarding the merge order. To summarize them and my position:\nMerging order\nAs @Qard said we can probably move forward with this current PR without waiting for #30959\nAPI differences:\nnaming\nI don't have any strong links to any naming here and I would be happy to change it to AsyncLocals or any other name that would make sense here (I think we need to settle on something and call it a day to avoid more bikeshedding on that topic).\nExposing a Map\nI find this to be a clean and predicatable way to do it. Having a method to fetch the store that might return undefined or any type based on what the end user did will definitly create confusion and issues (it might even make the TypeScript's users life easier).\nSync vs. async API\nAt the end of the day, I think we must have an asynchronous entering method. People will use this API to implement light-userland versions of domains and I would like to avoid falling back into the issues the domain API has.\nHowever, having an async API does not mean we can't have a synchronous one too. As long as the risks are documented and explained, I think there is room for both behaviors as they serve different goals (async being the \"strict\" way with no surprise, sync being less safe and more versatile). However, having a sync API only works after #30959 is merged.\nNext steps\nTbh, at the moment, I think we should move forward as we want the users to put their hands on the API as soon as possible to get field results on it.\n(edit) In the end my conclusion would be that appart from the debate on the name, I belive this PR can be merged and be a base to iterate upon.\nI have also messaged @puzpuzpuz and @Qard to see if we can get on a call together next week. Anyone is welcome to join, just let me know!",
                            "createdAt": "2020-01-23T13:59:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I'm interested - but not mandatory to add me.\n\nAt the end of the day, I think we must have an asynchronous entering method. People will use this API to implement light-userland versions of domains and I would like to avoid falling back into the issues the domain API has.\n\nAre you referring to d.run() as the safe variant for a paired d.enter()/d.exit() or something else?",
                            "createdAt": "2020-01-23T20:36:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna we did not find a solution to have a call so far. But if we discuss it again, I will make sure to have you in the loop.\nWe are currently working on a document summarizing the differences between the PR to give a good overview to anyone who want to take part in the final discussion.\n\nAre you referring to d.run() as the safe variant for a paired d.enter()/d.exit() or something else?\n\nI think so, my point is that I would like to psuh toward a solution where there is no doubt on wether a piece of code is running within the scope of an AsyncLocal/AsyncContext or not. Or in other terms, reduce the implicit behaviors to the minimal.",
                            "createdAt": "2020-01-23T20:40:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna I added a test to clarify how this works with async functions (for the case of promise-heavy cases) in 7c74ac3\nIt follow the design goal of providing a clear scope on where the store is available and where it is not.",
                            "createdAt": "2020-01-24T12:26:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Current next steps:\nIt seems that we won't merge this before #30959. I will rebase on it and add the synchronous methods later this week.",
                            "createdAt": "2020-01-27T14:10:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna , I have not found a case where a resource is used twice at the same time (i.e. reused while still creating children). In this case the current PR is safe from the reuse issue as I reference the resources by AsyncId in idResourcePairing. Wdyt?",
                            "createdAt": "2020-01-28T17:57:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I had no time yet to look into the code in more detail so can't tell yet if it is safe or not.\nThe reuse of resources happens not at the same time and the asyncId used differs.  It's like this:\n\ninit(id1, type, tid1, resource)\nbefore(id1)/after(id1) 0 to n times\ndestroy(id1)\ninit(id2, type, tid2, resource) <= new id/tid but same resource and type\nbefore(id2)/after(id2) 0 to n times\ndestroy(id2)\n\nIf you do something like resource[clsKey] = contextObj1 this context leaks from id1 to id2.\nIf I understand you correct you do something like resource[clsKey][id] = contextObj2.  So even if the clsKey entry leaks this results in no wrong use of contextObj. But the resource will hold more and more references to contextObjs.\ntest/async-hooks/test-http-agent-handle-reuse.js shows reuse of socket handle within http agent\ntest/async-hooks/test-httparser-reuse.js shows reuse of HTTPParser\nIn both cases the resource passed to init hook will differ as the native resource is wrapped but executionAsyncResource as it is now returns the native resource which is reused.",
                            "createdAt": "2020-01-28T19:07:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna this is not quite the same flow.\nWhat I do is:\nasyncId -> Weakref -> resource -> resource[clsKey] = contextObj\nWhen a resource is reused, the context that was attached to it is overwritten by the new context. But since I access the resource through the asyncId, I am always accessing the resource that make sense at one point.\nAlso, I use a destroy hook to cleanup the contextObj.\nIn the end, as long as the same resource is not used for two things at the same time (i.e. I do not have two active asyncId pointing to the same resource) my code works. You confirmed this weird case does not exist because destroy(id1) happens before init(id2)",
                            "createdAt": "2020-01-28T20:31:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I think the following could happen with a reused resource:\n\ninit(id1, type, tid, resource) => idResourcePairing.set(id1, weakref(resource)), store gets attached to resource\ndestroy(id1) => id1 get's removed from idResourcePairing, resource.store still present\ninit(id2, type, tid, resource) =>  idResourcePairing.set(id2, weakref(resource)), old store is still on resource and gets not overwritten if triggerResource == null or triggerResource has no store\nget(id2) => returns old store which means wrong propagation\n\nnot sure if this is really a realistic sequence.\nBesides that we should anyway aim to get unique resources soon so this will disapear then.",
                            "createdAt": "2020-01-28T22:26:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Seems that it can easely be mitigated by removing the store from the resource in destroy then :)",
                            "createdAt": "2020-01-28T22:37:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Done in 66a8d3c\nI think I can probably introduce a sync interface here with enough warnings regarding its safety/edge cases and clarifying that some of them will be resolved eventually by #30959",
                            "createdAt": "2020-01-29T10:51:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard I could not listen to the diagnostic meeting today. Do you think #30959 will still be merged soon?\n@mcollina if we can't move forward with #30959 before a while, would you still be against merging this current PR now and use it as a base to iterate upon in ter of performances and of API?\nThe resource re-use problem will block us with a destroy hook until Async Hooks don't see the resources being reused at all (otherwise, it will attach context to a never garbage-collected resource).",
                            "createdAt": "2020-01-29T20:46:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for the review @Flarna",
                            "createdAt": "2020-01-30T18:42:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard I could not listen to the diagnostic meeting today. Do you think #30959 will still be merged soon?\n\nI will be getting back to it hopefully Sunday. I'm in New York at the moment and haven't had time to work on this all week.",
                            "createdAt": "2020-02-01T02:35:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "It's been very difficult to keep up with the state of this PR. Are there still a couple of competing approaches being looked at? It would be extremely helpful if someone closely following this could post a comment updating on the general status :-)",
                            "createdAt": "2020-02-03T18:45:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell I tried to do so in nodejs/TSC#807 (the first messages), at least to state the difference between the approaches. Let me know if you have any questions or pieces I could clarify to help you make your mind :)",
                            "createdAt": "2020-02-03T18:47:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Missed that one! Thank you :-)",
                            "createdAt": "2020-02-03T18:53:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard\n\nI'm not a fan of exposing enterSync() and exitSync(). That same pattern created a ton of bugs with domains and I suspect the same would be the case here. \ud83e\udd14\n\nThat's a concern I share. So, sometimes there is a need for it but it should be marginal. Currently, documentation highlights why it is dangerous..  Do you think runAndReturn and run are enough for all use cases? @Flarna, @Qard, wdyt? I'd be happy to make the Sync methods private.",
                            "createdAt": "2020-02-04T06:05:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "I think it's fine to expose only the a sync run for now. If it turns out that people have need for dedicated enter/exit this is easy to add later on.",
                            "createdAt": "2020-02-04T06:42:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "My 2 cents about recent changes in the proposed API.\nLooks like the current API is inspired by continuation-local-storage/cls-hooked user-land modules. If that's correct, the naming is misleading. For instance, ns.run() method in these APIs is sync, just like ns.runAndReturn(). Also, ns.exit() stands for a counterpart of ns.enter() method, not ns.run(). There are also a bunch of other methods in these APIs (in general, I personally find these libraries over-bloated and not intuitive), but that's another story. My point is that all of this may lead to user confusion.",
                            "createdAt": "2020-02-04T07:06:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz that's a very valid concern.\nIndeed this inheritates from CLS but also, from the domain post mortem document.\nRegarding the run/exit couples, I remember there has been a fair share of bikeshedding on that last spring and I am a bit scared to dive into this again :/",
                            "createdAt": "2020-02-04T08:22:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna @Qard I removed the non-scoped. I think this is for the best. The main counter-example I have for them is the event-emitter one:\nemitter.on('x', () => { enterSync() });\nemitter.on('x', => { /* this code is within context */ });\nemitter.on('x', () => { exitSync() });\nemitter.on('x', => { /* this code is outside context */ });\n\nWhich would definitly cause major issues regarding error management (or even understandability).",
                            "createdAt": "2020-02-04T08:27:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna @puzpuzpuz\n@Qard and I discussed the potential following changes to the API:\n\nintroduce a bind method that could add up to existing ones or replace them. It would basically return a function running in the context. It would still cover the need for scoping but make the API less opinionated. We would, in any way, keep an exit method with a callback (is unbind a word ;p)\nchange the constructor signature to accept a (optional) factory method as argument that would be used to create the store. This is something I like too. One of my main concern with setting the store each time entering the context is that it drives the user toward instanciating multiple AsyncContext/Local to track different things (for instance in a large shared codebase, each concern would have their own instance). The factory strategy sounds like a good compromise between \"let's make it behave consistently\" and \"let's give freedom to the users. In that case, the signature of bindwould be bind(fn, ...args) and args would be passed to the factory method. A default factory could be () => new Map(), or even () => ({}).\n\nWdyt?\n@Flarna would such an API still cover your use cases?",
                            "createdAt": "2020-02-04T22:36:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nIn my experience ns.bind() method is quite opinionated. You need to have a function that is returned from your module to be later called by other modules that you don't control. As a good illustration, you may refer to my library, which implements request tracing middlewares/plugins for popular web frameworks on top of cls-hooked:\nhttps://github.com/puzpuzpuz/cls-rtracer/blob/master/index.js\nI had to use a lot of different methods from cls-hooked there.\nIn general, I feel that this PR ends up in porting continuation-local-storage/cls-hooked into core.",
                            "createdAt": "2020-02-05T04:43:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim I'm sorry but I don't think I understood how bind should actually work. Is it a replacement for run or runAndExit or both?\nIn nodejs/TSC#807 (comment) I described the use case I have in mind.",
                            "createdAt": "2020-02-05T07:57:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Flarna bind could replace at least runAndReturn, it would be equivalent to:\nbind(fn) {\n    return function(...args) {\n        return context.runAndReturn(fn, ...args);\n    }\n}\n\nBut after a good night sleep, it might be opening the Pandora box by introducing function wrapping which could lead to issues.\n@puzpuzpuz\n\nIn general, I feel that this PR ends up in porting continuation-local-storage/cls-hooked into core.\n\nThat's partially true indeed, at least that the goal that has been discussed for several years now.\nRegarding the store update, it would change the following:\nconst storeFactory = (a, b, c) => somehting;\nconst context = new AsyncContext(storeFactory);\n\ncontext.runAndReturn(() => {\n    context.getStore() // => returns storeFactory(x,y,z)\n}, x, y, z)\n@Flarna the main downside here is that we lose the change we did with arguments passed to the callback but this still introduces an API that limits the user's mistake in store instanciation.",
                            "createdAt": "2020-02-05T09:06:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "As #31016 is now closed, I don't think there is a need to have this on TSC's agenda.",
                            "createdAt": "2020-02-06T09:11:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "I've noticed the recent AsyncContext -> AsyncLocal rename in this PR.\nAsyncLocal name doesn't meet with current API. In .NET it means a single variable available through async calls flow with analogy to ThreadLocal. Thus, it'll lead to users confusion.\nSo, I propose to call it AsyncLocalStorage, which seems to be a good fit for the API. WDYT?",
                            "createdAt": "2020-02-06T11:24:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I really like it! I will make this change!",
                            "createdAt": "2020-02-06T14:04:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "I've seen recent comments and would like to leave some feedback on the current API, which is inspired by continuation-local-storage/cls-hooked (I'll refer to it as cls-hooked for brevity).\nI can see the following problems:\n\nIn cls-hooked all .run*() methods are synchronous and aimed to provide an async context/scope that doesn't leave bounds of the method.\nThere are no .exit*() counterparts of .run*() methods in cls-hooked as those methods have scope guarantees.\nEven with all specialized methods available in cls-hooked, e.g. .bind(), .runPromise(), .bindEmitter() (all of them are not present in this PR), the library still has .enter()/.exit() methods, as there are some situations when they're required to avoid context loss or leaks (see #26540 (comment) thread or this library).\n\nAll of these will probably lead to user confusion and bug reports.\nSo, I propose the following in order to improve the API and mitigate some problems:\n\nRemove existing .exit*() methods.\nRename .runAndReturn() into .runSyncAndReturn().\nIntroduce synchronous .enter()/.exit() methods for advanced use cases.",
                            "createdAt": "2020-02-07T09:59:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I am reaching the exact same conclusions currently (thanks for the very clear overview).  I removed enterSync/exitSync after a couple iterations we had earlier, but the totally make sense for some use cases.\n\n.runPromise()\n\nI did not think of introducing this. That would actually create a path of least confusion for users who want to interact with async/await. Does anyone see a strong reason why we could not have it?\n\nRemove existing .exit*() methods.\n\nI would still want to keep an exclude method or something like that to exclude a certain scope path from context propagation while keeping it somewhere else. Wdyt?\n\nRename .runAndReturn() into .runSyncAndReturn().\n\nagreed\n\nIntroduce synchronous .enter()/.exit() methods for advanced use cases.\n\nagreed",
                            "createdAt": "2020-02-07T10:10:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nI did not think of introducing this. That would actually create a path of least confusion for users who want to interact with async/await. Does anyone see a strong reason why we could not have it?\n\nI didn't propose to introduce .runPromise() method. I agree that it'll only confuse users.\n\nI would still want to keep an exclude method or something like that to exclude a certain scope path from context propagation while keeping it somewhere else. Wdyt?\n\nI've never heard of use cases for such methods and never had them myself. So, I think it's better to release the first version without them and introduce them later, when (and if) there will be some user feedback.",
                            "createdAt": "2020-02-07T10:16:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "I didn't propose to introduce .runPromise() method. I agree that it'll only confuse users.\n\nNo, I was proposing to introduce it ;)\n\nI've never heard of use cases for such methods and never had them myself. So, I think it's better to release the first version without them and introduce them later, when (and if) there will be some user feedback.\n\nSounds fair!\nI have a meeting day - I'll make the changes tonight",
                            "createdAt": "2020-02-07T10:19:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@bajtos I just updated the API and the doc based on @puzpuzpuz 's feedback. I especially added guidance on how to do with async/await in the guidance on how to use the API. Can you check if that makes sense to you?\n@puzpuzpuz let me know what you think so far.",
                            "createdAt": "2020-02-07T21:29:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "Rather than exposing the enter() and exit() again, why not just have the run* function look something like this:\nrun (fn, ...args) {\n  this._enter();\n  try {\n    const result = fn.apply(null, args);\n    if (result && typeof result.then === 'function') {\n      return result.then(value => {\n        this._exit();\n        return value;\n      });\n    }\n  } catch (err) {\n    this._exit();\n  }\n  return result;\n}\nIf you give it a promise-returning function it will have context within the entire async scope of it's own execution, but async continuation after that function, such as following await the result, will be exited automatically. It's a lot less error-prone that way.",
                            "createdAt": "2020-02-07T22:23:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard right now, this would fail:\n'use strict';\nrequire('../common');\nconst assert = require('assert');\nconst { AsyncLocalStorage } = require('async_hooks');\n\nconst asyncLocalStorage = new AsyncLocalStorage();\n\nasyncLocalStorage.runProm = function (fn, ...args) {\n  this.enter();\n  try {\n    const result = fn.apply(null, args);\n    if (result && typeof result.then === 'function') {\n      return result.then(value => {\n        this.exit();\n        return value;\n      });\n    }\n  } finally {\n    this.exit();\n  }\n  return result;\n};\n\nasync function test() {\n  asyncLocalStorage.getStore().set('foo', 'bar');\n  await Promise.resolve();\n  assert.strictEqual(asyncLocalStorage.getStore().get('foo'), 'bar');\n}\n\nasync function main() {\n  asyncLocalStorage.enter();\n  await asyncLocalStorage.runProm(test);\n  assert.strictEqual(asyncLocalStorage.getStore(), undefined);\n}\n\nmain();\nfails on line 33 as the store is still available there. I am not clear yet on wether rebasing on executionAsyncResource will clear this. I planned to test that tomorrow.",
                            "createdAt": "2020-02-07T22:37:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard I just made a test after a rebase on your branch. Indeed, it fixes this case.\n@bajtos the recommendation for async/await calls will end up being:\nawait asyncLocalStorage.runSyncAndReturn(test);\nwhich will guarantee scope safety (you won't have to handle any exit case.\nSo I guess this will remove the need for the enter/exit pair and then re-introduce the need for the exit(cb)/existSyncAndReturn pair.",
                            "createdAt": "2020-02-10T12:22:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bajtos",
                                "__typename": "User"
                            },
                            "bodyText": "@bajtos the recommendation for async/await calls will end up being:\nawait asyncLocalStorage.runSyncAndReturn(test);\nwhich will guarantee scope safety (you won't have to handle any exit case.\n\nThanks, @vdeturckheim. I assume that in your example code, test is an async function executed in the new scope, is that correct? Such recommendation looks sensible to me \ud83d\udc4d\nSubjectively, I wish there was a way how to do this without any callback function, but I see how the design you describes is better because it enforces scope safety \ud83d\udc4f\nI have one last question - is this style supported by V8 async stack traces? If test calls out to several other functions and awaits their return, and one of those function returns a rejected promise, will the error stack trace include frames for the outer function which called asyncLocaStorage.runSyncAndReturn? I think it's ok if async stack traces are not supported, but it would be nice to mention such fact in the documentation.",
                            "createdAt": "2020-02-10T15:16:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks, @vdeturckheim. I assume that in your example code, test is an async function executed in the new scope, is that correct? Such recommendation looks sensible to me \ud83d\udc4d\n\nBasically, from an asynchronous resource stack perspective, this code will not change anything to the original code -> the user is just adding 1 synchronous function to the call stack. But the method getStore will return undefined outside of the callback and its children asynchronous operations. This function call is the scoping itself.\n\nSubjectively, I wish there was a way how to do this without any callback function, but I see how the design you describes is better because it enforces scope safety \ud83d\udc4f\n\nThat's its main goal, I agree with @Qard that callback-less functions are dangerous (it is one of the main issues with domains) - his PR makes it possible to do things without callbacks.\n@Flarna helped making the use of the callback easier (with the [,...args] capability on the runs methods). If we eventually need to re-expose the unsafe functions for some edge use-cases, we will do it but with severe documentation warnings (see, the current state of the doc before I rebase on #30959)\n\nI have one last question - is this style supported by V8 async stack traces? If test calls out to several other functions and awaits their return, and one of those function returns a rejected promise, will the error stack trace include frames for the outer function which called asyncLocaStorage.runSyncAndReturn? I think it's ok if async stack traces are not supported, but it would be nice to mention such fact in the documentation.\n\nSo runSyncAndReturn being synchronous by itself, it will only add a line to the stacktrace but no async break. So the default v8 behavior is kept here. This will not be the case with run.\nI will add \"that runSyncAndReturn will not alter the stacktrace while run will\" in the doc, would that cover your question? I don't want to spare any effort on the doc on this PR (also, let me know if I am not clear enough in my answers, I will try to answer your questions as much as possible in the doc :) ).",
                            "createdAt": "2020-02-10T15:33:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Updated the doc and the API code - still not mergeable until #30959 lands.",
                            "createdAt": "2020-02-10T21:53:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bajtos",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim Thank you for explaining the details to me, I really appreciate that!\n\nI will add \"that runSyncAndReturn will not alter the stacktrace while run will\" in the doc, would that cover your question?\n\nSounds good \ud83d\udc4d\n\nlet me know if I am not clear enough in my answers, I will try to answer your questions as much as possible in the doc :)\n\nAll is clear now \ud83d\udc4f",
                            "createdAt": "2020-02-11T08:25:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29084/",
                            "createdAt": "2020-02-12T08:34:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29085/",
                            "createdAt": "2020-02-12T09:18:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Side idea/note/RFC, I know that a lot of people are skeptical about the store being always a Map.\nIt could be possible (and not event a breaking change), to do the following:\n\nintroduce setStore(any), setStore would overwrite the store with anything\nif when calling getStore the store contains undefined (which is an arbitrary choice I don't like that much), it would create a Map then.\n\nDepending on how the review cycle go from here, this does not need to happen in this PR and can be added later on without breaking anything.",
                            "createdAt": "2020-02-12T21:17:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell would you have time to check this PR/the doc one last time? I revamped it based on your feedback and @bajtos 's questions.\nThe change requested by @mcollina has been applied yesterday so I have good hopes we can move forward pretty soon :)",
                            "createdAt": "2020-02-13T08:27:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29102/",
                            "createdAt": "2020-02-13T16:32:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29103/",
                            "createdAt": "2020-02-13T17:41:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks a lot for the review @targos !",
                            "createdAt": "2020-02-15T13:31:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29155/",
                            "createdAt": "2020-02-15T13:32:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29156/",
                            "createdAt": "2020-02-15T17:01:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29157/",
                            "createdAt": "2020-02-15T17:36:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29159/",
                            "createdAt": "2020-02-15T19:35:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29161/",
                            "createdAt": "2020-02-15T20:20:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "I've noticed recent addition of .enable()/.disable() methods and with current implementation they may lead to users confusion. The main problem that I can see now is the fact that _enter() method implicitly enables AsyncLocalStorage even if it was disabled before. See https://github.com/nodejs/node/pull/26540/files#diff-0bb01a51b135a5f68d93540808bac801R276\nThe simplest illustration of the problem might look like this:\nconst storage = new AsyncLocalStorage();\n// normal interaction\nstorage.run(() => {\n  // ...\n});\n\n// after a while the storage is disabled\nstorage.disable();\nstorage.run(() => {\n  // storage is enabled again\n});\nConsidering that in web service use case .run()/.runSyncAndReturn() has to be called for each HTTP request, this implicit behavior kills the whole idea of .disable() method. Even if the storage is disabled, it'll be re-enabled when another request comes in.",
                            "createdAt": "2020-02-16T18:20:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz do you think enable/disable should just leave the instance as is and make getStore always return undefined ?",
                            "createdAt": "2020-02-16T18:24:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz do you think enable/disable should just leave the instance as is and make getStore always return undefined ?\n\nThat might as well create some confusion, as users might have to write defensive code even inside of .run()/.runSyncAndReturn() and check is the store is still available. So, both options aren't ideal. \ud83e\udd14\nIn case of AsyncLocal (#31016) it's simpler. Once it's created, it's immediately enabled. And when it's destroyed with the .destroy() call (and that's a terminal operation), all subsequent .get()/.set() are silently ignored. But it doesn't have scoped methods, like .run(), so I'm not sure if such approach makes sense for AsyncLocalStorage.",
                            "createdAt": "2020-02-16T18:34:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29173/",
                            "createdAt": "2020-02-17T08:49:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim your PR seems to lack benchmarks. So, I have extended benchmark/async_hooks/async-resource-vs-destroy.js with AsyncLocalStorage. See this PR for more details: https://github.com/vdeturckheim/node/pull/1",
                            "createdAt": "2020-02-17T12:59:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29174/",
                            "createdAt": "2020-02-17T13:59:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29178/",
                            "createdAt": "2020-02-17T16:02:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks a lot @puzpuzpuz , I added you as a co-author of the PR.",
                            "createdAt": "2020-02-18T16:42:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29212/",
                            "createdAt": "2020-02-18T16:51:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nI'd like to share some thoughts on enable/disable API. After some thinking, I came to conclusion that such methods work well for passive calls, like AsyncHook, where a set of hook functions is being called (or not) based on the enabled status. But AsyncLocalStorage is a different story: you call it\nwith .run*() and .getStore() methods, thus it's about active calls. So, enable/disable methods don't sound like a good fit for AsyncLocalStorage, at least that's how I see it.\nFor certain use cases, it totally makes sense to have a terminal method, say .destroy(), that would remove the storage instance from being used in the underlying async hook and disable the hook if there was only a single active storage. Main problem here is to define a convenient and intuitive behavior for .run*() and .getStore() methods for a terminated instance. For instance, it may be as minimal as always returning undefined from .getStore() for a terminated instance, or, in addition, .run*() could be totally ignored (i.e. no callback execution).\nWDYT?",
                            "createdAt": "2020-02-19T13:23:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz it's a very good point. I think @mcollina 's concern here are:\n\ncan we disable the instance (for perf reason)\ncan we remove the instance from the global store (to let it get it garbage collected)\n\nI can imagine a case where you only use a storage for a dedicated task once in the lifetime of the process and you want it to be GCed. Would you see another solution to answer this case?",
                            "createdAt": "2020-02-19T18:18:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nI can imagine a case where you only use a storage for a dedicated task once in the lifetime of the process and you want it to be GCed. Would you see another solution to answer this case?\n\nI was thinking of this problem recently and here are options that I see now:\n\nHave a global array of WeakRefs to AsyncLocalStorages instead of an array of strong references. Then the underlying hook will have to do deref while iterating over the array and remove elements for GCed AsyncLocalStorages. The hook could even disable itself when there are no elements in the array. A somehow similar approach is used in Java's ThreadLocal (instances are stored in Thread object through weak refs).\n\n\nThis approach will allow us to get rid of manual memory management on user-land side, i.e. there will be no need for .disable()/.destroy() method. Once there are no user-land references to a AsyncLocalStorage, it'll be eventually GCed (yet, values may remain as they're stored via symbol properties in async resources).\nSuch change may impact performance, but I'm not sure how critical the impact will be. That needs to be measured once the change is ready.\n\n\nKeep a global array of strong references and a .disable()/.destroy() method. In this case, users will have to be warned in docs that they should delete references to AsyncLocalStorages only after they destroy them.\n\n\nThat's the simplest approach, however it may lead to issues when the API is not used in the intended way.\n\n\nHave a global \"registry\" of AsyncLocalStorages (<string, instance> pairs) and expose them via new functions in async_hooks module. A similar thing is done in continuation-local-storage/cls-hooked: these libraries have .getNamespace() method which allows obtaining previously created instance at any time. On the other hand, instances have to be explicitly destroyed via .destroyNamespace().\n\n\nI'm afraid that this option is a no-go for a core API, as it doesn't isolate user modules from each other, i.e. it's possible to obtain somebody else's instance.\n\nI think that option 1 is worth spending some time on it and measuring the performance impact. And if the impact is low enough, that option could be kept in the final API. WDYT?",
                            "createdAt": "2020-02-19T19:45:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz that's great ideas. If I understand well, solution (2) is pretty much what's in the PR right now.\nI will try to benchmark WeakRefs but after giving it a night, I think solution (2) without enable is actually good enough:\n\ndisable can be used to unreference an instance from the hook and left ready for GC\nif the user still has a reference to the instance, calling run or runSyncAndReturn will re-enable it under the hood.\n\nThis would actually reach our goals I believe. wdyt?",
                            "createdAt": "2020-02-20T05:24:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nIf we go with option 2, I think it's better to rename .disable() into .remove() or .destroy(). That's because once an AsyncLocalStorage is disabled (removed/destroyed), there will be no way to enable it.\nI also did a quick experiment for option 1 (memory safe implementation based on an array of weak refs) and saw no performance degradation in the benchmark. Could you take a look?\nhttps://github.com/vdeturckheim/node/pull/2",
                            "createdAt": "2020-02-20T07:34:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz I was more thinking of a documentation-warned case with something like\n\nYou should only call disable when you plan not to use the instance of AsyncLocalStorage anymore. When calling disable, all current contexts linked to the instance will be exited. Calling run or runSyncAndReturn will create and enter a new context.\n\nwdyt?",
                            "createdAt": "2020-02-20T14:56:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\nSo, you're thinking of keeping implicit enable logic in .run*() methods? That could probably work.\nHowever, I still suggest to remove local lists located in symbol properties inside resources and move back to a global list, as this approach leads to weird issues like this one. And with that global list users will have to be warned that they need to disable AsyncLocalStorage and make sure that it's not used anymore (i.e. no further .run*() calls) when they want to get it GCed.",
                            "createdAt": "2020-02-20T15:13:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Indeed, I missed #26540 (comment), good catch. If that works for you I will do as describbed in #26540 (comment) and #26540 (comment)",
                            "createdAt": "2020-02-20T15:15:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mcollina after a couple iterations with @puzpuzpuz, having local store on resources introduces too much edge cases. However, we introduced a disable method that removes the instance from the global array and disable the hook if no instance is alive.",
                            "createdAt": "2020-02-20T15:49:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29254/",
                            "createdAt": "2020-02-20T16:32:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim\n\nIndeed, I missed #26540 (comment), good catch. If that works for you I will do as describbed in #26540 (comment) and #26540 (comment)\n\nI also like the idea of starting with the simplest possible approach: a .disable() method + a global list, so I'm more than fine with the approach. And if there will be any issues related with this part of the API, we could reiterate over option 1 from #26540 (comment).",
                            "createdAt": "2020-02-20T16:47:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz so it should be good (I ninja pushed this 20 minutes ago)",
                            "createdAt": "2020-02-20T16:50:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "@vdeturckheim, @puzpuzpuz thanks for all of the hard work on this.  Seeing @mcollina LGTM I'm wondering if you think it's now ready and a good time for me to take another look?",
                            "createdAt": "2020-02-20T22:13:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29257/",
                            "createdAt": "2020-02-20T23:08:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "@mhdawson I just merged https://github.com/vdeturckheim/node/pull/3 so I think you can safely give it a look. Thanks a lot \ud83d\ude04\n(I am not sure why the test-commit-arm-fanned fails on CI - but that seems to be one of the last technical issue before we can merge \ud83c\udf86 )",
                            "createdAt": "2020-02-20T23:09:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29258/",
                            "createdAt": "2020-02-21T06:00:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/29293/",
                            "createdAt": "2020-02-23T07:56:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Landed in 9c70292",
                            "createdAt": "2020-02-23T19:25:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "Should wait for #31930 before this is backported to v13.x",
                            "createdAt": "2020-02-24T14:00:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vdeturckheim",
                                "__typename": "User"
                            },
                            "bodyText": "Should wait for #31930 before this is backported to v13.x\n\n#31930 landed, good to go to v13.x",
                            "createdAt": "2020-02-27T20:23:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Sytten",
                                "__typename": "User"
                            },
                            "bodyText": "Any chance this will be backported to v12?",
                            "createdAt": "2020-03-06T07:28:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "Any chance this will be backported to v12?\n\nIt would be great to have AsyncLocalStorage in v12, so I'm all for backporting it.\nNote: executionAsyncResource (#30959) has to be backported first.\ncc @Qard @vdeturckheim",
                            "createdAt": "2020-03-06T09:04:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "As far as I know, backporting executionAsyncResource to v12 should not be a problem, but I haven't tested it myself.",
                            "createdAt": "2020-03-06T09:07:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Flarna",
                                "__typename": "User"
                            },
                            "bodyText": "Care must be taken to include also the followup PRs fixing various bugs found afterwards.",
                            "createdAt": "2020-03-06T09:26:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "I've created a backport PR for executionAsyncResource: #32131. Hopefully, it includes all bugfixes.",
                            "createdAt": "2020-03-06T19:04:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "codebytere",
                                "__typename": "User"
                            },
                            "bodyText": "@puzpuzpuz thanks! this next release is a patch so it'll go out in the subsequent minor.",
                            "createdAt": "2020-03-16T01:16:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "puzpuzpuz",
                                "__typename": "User"
                            },
                            "bodyText": "v12 backport: #32318",
                            "createdAt": "2020-03-17T06:31:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "indutny",
                                "__typename": "User"
                            },
                            "bodyText": "Providing a reference to another issue here because most interested parties are subscribed to this issue.",
                            "createdAt": "2020-07-16T18:33:18Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 4765,
            "title": "Enable Node.js to run with Microsoft's ChakraCore engine",
            "author": {
                "login": "kunalspathak"
            },
            "state": "CLOSED",
            "closedAt": "2016-02-19T16:58:51Z",
            "comments": {
                "totalCount": 194,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak Thanks for the PR! This has a very large impact so please expect review to take a considerable amount of time. :)",
                            "createdAt": "2016-01-19T17:29:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "defnorep",
                                "__typename": "User"
                            },
                            "bodyText": "VERY cool! Don't envy the code reviewers here though!",
                            "createdAt": "2016-01-19T17:30:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshmanders",
                                "__typename": "User"
                            },
                            "bodyText": "This is by far one of the coolest things I've seen happen to Node.js since the convergence of io.js and Node.js.",
                            "createdAt": "2016-01-19T17:33:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MikeFielden",
                                "__typename": "User"
                            },
                            "bodyText": "Legit. Thanks, cant wait until this happens \ud83d\udc4d",
                            "createdAt": "2016-01-19T17:34:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "unicodeveloper",
                                "__typename": "User"
                            },
                            "bodyText": "The review will really take a lot of time and scrutiny! \ud83c\udf74",
                            "createdAt": "2016-01-19T17:39:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "SilverIgniter",
                                "__typename": "User"
                            },
                            "bodyText": "+1\ufe0f\u20e3 guys, really good job! \ud83d\udca5",
                            "createdAt": "2016-01-19T17:50:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ingIor",
                                "__typename": "User"
                            },
                            "bodyText": "This is incredibly cool, I have a request.\nPlease do not post comments on the GH issue unless you have something important to add. These issues gain a lot of attention and it makes it incredibly hard for collaborators to communicate.\nLocking the issue to collaborators means other people from the outside who have a significant ***** contribution or want to help can't do that.\nComments like +1 -1 and such create a significant amount of noise.\nSupport open source, keep the discussion clean.\nEDIT(@trevnorris): Possible accidental use of inappropriate word? Has been removed.",
                            "createdAt": "2016-01-19T17:57:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak What happens when v8 needs to be updated and the API doesn't match the Chakra shim? Will we need to hold off until the shim also has an update?",
                            "createdAt": "2016-01-19T18:01:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak ... thank you for submitting this. As you can imagine, it's going to be a big review and could take some time to settle out.\n@trevnorris ... I have separately reached out to each of the V8 and Chakra teams and invited both to sit down face to face to work through the API/ABI impact of this change and figure out how we can make the ABI layer more robust. I'm working out the logistics for that face to face now and want to make sure to extend the invite to all the @nodejs/ctc members as well. There are a ton of questions this brings up and I think sitting down for an afternoon to hash things out would be quite productive.",
                            "createdAt": "2016-01-19T18:05:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Marking it as semver-major for now (just to be safe), although semver-minor might be appropriate once we get further along in the review. Very happy to see this tho.",
                            "createdAt": "2016-01-19T18:07:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe this is a stupid question, but what is the advantage to this PR? To use Chakra instead of V8, right? Is that a runtime specification or a build specification?",
                            "createdAt": "2016-01-19T18:11:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "Am I correct that this currently works only on Windows platform? Initial Linux support is still on the roadmap of ChakraCore: https://github.com/Microsoft/ChakraCore/wiki/Roadmap. And that is decribed as \u00abmake it link, make it run, no JIT\u00bb.",
                            "createdAt": "2016-01-19T18:17:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sethgaurav",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, its currently Windows only. For cross-platform support, the key target for next six months on the roadmap is to get the interpreter & runtime working. JIT would come after that (don't read it as no JIT forever - it was just a breakdown of what we need enable and its ordering for next 6 mos).",
                            "createdAt": "2016-01-19T18:27:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "Will ChakraCore be treated as a first-class citizen? That is:\n\nWill there be binary builds with ChakraCore for each Node.js release provided from the nodejs.org site?\nWould it be guaranteed that ChakraCore must work with every next Node.js version, or would it be ok if v6.2.0 builds with ChakraCore, v7.0.0 breaks with ChakraCore (let's say the shim update didn't get in in due time), and v7.1.0 works again with ChakraCore?\nWhat if v7.3.0 breaks again with ChakraCore in a semver-minor version, because of some additive change that didn't get yet ported to the shim?",
                            "createdAt": "2016-01-19T18:28:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I think those questions can't be answered until after this PR lands. We have support in Node.js for architectures that we don't have in CI and pretty much all the ones we do have were added some time after support for the architecture was landed. I don't think anyone wants to add another vector to CI until we know there is some stability here and we're only going to figure that out after it lands.",
                            "createdAt": "2016-01-19T18:34:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR ... at least in my opinion, it depends on what is meant by \"first-class citizen\"\n\nFor the very near term, likely not. Having officially supported builds of Node+ChakraCore is likely quite some time off and wouldn't be able to happen at least until the cross-platform work is done. Similar to how we (IBM) handled our Node-on-PPC and Node-on-AIX builds, it would be more likely that Msft would host their own downloads with builds of Node+ChakraCore (please correct me if I'm wrong @orangemocha or @kunalspathak), at least until a decision is made to officially provide Chakra support.\n\n2 and 3: I think it's too early to determine that. Given the dependency on the V8 APIs currently, and given how quickly those could change, there will need to be dedicated effort by Microsoft and other interested collaborators to ensure that the Chakra shim continues to work. It is entirely possible that semver-major update of V8 could land that could break these. Until we're sure that the shim is stable, we likely won't want to commit to ensuring that things would continue to work.\n+1 to what @mikeal just said as I was typing this :-)\nWhat I'd personally like to see is getting this landed but clearly indicating that it is experimental and unsupported for the time being.",
                            "createdAt": "2016-01-19T18:36:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal @jasnell You mean that the initial answer is \u00abno\u00bb to all questions (i.e.: no guarantees at all for the time being), with a possibility to change in the future? That seems legit.",
                            "createdAt": "2016-01-19T18:37:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Yup, this is sort of a classic \"let's put this behind a flag and see what happens\" situation :)",
                            "createdAt": "2016-01-19T18:39:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Yup, this is sort of a classic \"let's put this behind a flag and see what happens\" situation :)\n\nAs a note, this is not a runtime feature, so it is explicitly behind a build-time flag.",
                            "createdAt": "2016-01-19T18:42:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "It seems like a nightmare to support.\nImagine the following: someone make a PR that uses v8 API. CI breaks on Chakra build, because shim doesn't support said API. What we are going to do? wait until Chakra implements them? abandon the PR?\nWhat if next week someone PRs support for JSC or SpiderMonkey?",
                            "createdAt": "2016-01-19T18:44:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin If I read the answers above by @mikeal and @jasnell correctly \u2014 ignore the breakage and land, but mention the people who will support ChakraCore and give them a chance to fix this.",
                            "createdAt": "2016-01-19T18:47:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin ... initially, we would not gate acceptance of any V8 changes based on whether or not it breaks Chakra. The responsibility would be on those collaborators who are supporting the experimental Chakra support to update that code to work again.",
                            "createdAt": "2016-01-19T18:48:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Imagine the following: someone make a PR that uses v8 API.\n\nThe general direction the project wants to go in is to become more vm agnostic, which means using less of the API, not more, and moving towards a neutral API that all vm's can support natively. That's a long way off, we have a lot of work to do, but this is the first step in that direction.",
                            "createdAt": "2016-01-19T18:48:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR well, the goal is to make it officially supported one day, obviously. Otherwise committing this code doesn't make anything. So, when we decide that it is supported, what would be the answer then?",
                            "createdAt": "2016-01-19T18:51:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "The general direction the project wants to go in is to become more vm agnostic, which means using less of the API, not more, and moving towards a neutral API that all vm's can support natively. That's a long way off, we have a lot of work to do, but this is the first step in that direction.\n\nThis seems to be a step in the opposite direction, really. I mean, it implements v8 API, not neutral API. Also, adding another vm into source tree seems like a step in the opposite direction as well.",
                            "createdAt": "2016-01-19T18:53:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell\n\nWhat I'd personally like to see is getting this landed but clearly indicating that it is experimental and unsupported for the time being.\n\nThen it should go on a dedicated branch, not master.",
                            "createdAt": "2016-01-19T18:54:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Then it should go on a dedicated branch, not master.\n\nThat's just not in line with how we've added any experimental features before. Branches might be used from time to time to develop a feature but it's never used by the public until it lands in master. For instance, AsyncWrap has been experimental and in master for quite a while.",
                            "createdAt": "2016-01-19T18:56:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jbergstroem",
                                "__typename": "User"
                            },
                            "bodyText": "Before we start running this on our CI -- @kunalspathak do you have output of vcbuild.bat test somewhere?",
                            "createdAt": "2016-01-19T18:58:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal Sounds exactly like what a change like this deserves.",
                            "createdAt": "2016-01-19T19:10:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@Qix- Note: this does not replace V8, it only gives a built-time option to.\nEdit @joshmanders, nope, sorry!",
                            "createdAt": "2016-01-19T19:21:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshmanders",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 was that meant to be directed at me?",
                            "createdAt": "2016-01-19T19:33:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jianchun",
                                "__typename": "User"
                            },
                            "bodyText": "@jbergstroem  vcbuild.bat test output",
                            "createdAt": "2016-01-19T19:33:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "indutny",
                                "__typename": "User"
                            },
                            "bodyText": "I'm slightly concerned about download size of our repository. Having a big chunk of code living there and not being used in 99% of cases seems to be a huge waste of bandwidth. (I know many people clone the repo, or get the source from tarballs)",
                            "createdAt": "2016-01-19T19:33:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin ... it's a step in the right direction, it's not the only step :-) The next step is to begin moving towards a more abstracted ABI between Node core and the VM layer, which is something that ought to make a LOT of things in core easier... for one, we'd be able to take V8 updates faster than we currently do, even potentially landing new V8 majors within stable branches. It's a long road, however, and there are many steps along the way that still need to be figured out.",
                            "createdAt": "2016-01-19T19:38:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@indutny ... I do share the concern over download size. One possible approach is to handle this similar to how we handle the ICU dependency. IF the config option is set to use this, then the build goes out and grabs the tar file and drops it into the deps folder, then and only then is this large chunk of optional code downloaded.",
                            "createdAt": "2016-01-19T19:39:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "If we're considering pulling in stuff during build time we need to ping @nodejs/build :)",
                            "createdAt": "2016-01-19T19:39:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "naholyr",
                                "__typename": "User"
                            },
                            "bodyText": "Many APIs and/or options didn't come to exist for the sake of platform equality (thinking about sendfile for example), is this about to change or are you going to wait for Linux/Mac compatibility of Chakra?",
                            "createdAt": "2016-01-19T19:45:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell I'm really trying to see how it makes transitioning to abstract VM API easier, but I can't. I clearly see how it will make maintaining node much more difficult in short term, though.",
                            "createdAt": "2016-01-19T19:54:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not seeing how it makes maintaining node more difficult in the short term as maintaining support for the Chakra shim would not be in the critical path of any other changes. For the majority of collaborators, in the short term, they could simply ignore the Chakra stuff and would be perfectly fine. There would be zero impact. If we made it a download-on-build option then it would be even less of an impact.\nIn the long term, it helps making the transition to an abstract VM API easier because the Chakra team has had to go through this exercise of getting Chakra to transparently act like V8. That means they've gathered a significant amount of experience about what it would take to create that abstraction. By combining their experience and bringing the various teams together for discussion, we can begin to identify how that abstraction needs to be defined.",
                            "createdAt": "2016-01-19T20:05:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "davidmurdoch",
                                "__typename": "User"
                            },
                            "bodyText": "I haven't seen anyone answer why this should be added.\nWhy should node support the ChakraCore engine? What are the benefits of doing so?",
                            "createdAt": "2016-01-19T20:08:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mscdex",
                                "__typename": "User"
                            },
                            "bodyText": "+1 to making this downloadable on demand at build time like the intl data.",
                            "createdAt": "2016-01-19T20:11:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "+1 to what @jasnell said:\n\ninitially, we would not gate acceptance of any V8 changes based on whether or not it breaks Chakra. The responsibility would be on those collaborators who are supporting the experimental Chakra support to update that code to work again.\n\n... but hopefully when and if the Chakra team has proven their ability to keep up with those breaks, we'll be able to include support in stable releases. I guess we will cross that bridge when we get there, and it's a good idea to deem this as 'experimental' for now.\nWe can still add support for ChakraCore in CI, so that at least we know when things break, even though it wouldn't prevent acceptance of PRs. I will get working on that.\nIn terms of reviewing this change, I am tempted to say that we could treat the stuff under deps/ as a black box. The remaining delta is actually fairly small.\n@kunalspathak it might make sense to maintain ChakraShim in its own repo, and update it here as a whole.",
                            "createdAt": "2016-01-19T20:19:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not seeing how it makes maintaining node more difficult in the short term as maintaining support for the Chakra shim would not be in the critical path of any other changes. For the majority of collaborators, in the short term, they could simply ignore the Chakra stuff and would be perfectly fine.\n\nI'm talking about period after that.\n\nIn the long term, it helps making the transition to an abstract VM API easier because the Chakra team has had to go through this exercise of getting Chakra to transparently act like V8. That means they've gathered a significant amount of experience about what it would take to create that abstraction.\n\nSo, they've already done that. If this code remains in a separate repo, their experience is not going to become any less useful.",
                            "createdAt": "2016-01-19T20:19:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jbergstroem",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not very comfortable landing anything that has 51 test fails on the currently only supported OS, be it optional or not. I'll look at running the PR against our own CI shortly.",
                            "createdAt": "2016-01-19T20:27:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "@jbergstroem - We are aware of these test failures and most of the unit test failures are because of unimplemented features in chakrashim. We are working on getting them to 0 failures. We will keep this thread posted on our status.",
                            "createdAt": "2016-01-19T20:47:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "loopmode",
                                "__typename": "User"
                            },
                            "bodyText": "@davidmurdoch chakra currently has a more complete es6/es7 implementation. Of course once v8 catches up it'll be a different story.",
                            "createdAt": "2016-01-19T21:06:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kevva",
                                "__typename": "User"
                            },
                            "bodyText": "As a package maintainer, I'm afraid that I'll have to make sure that stuff works across two engines, in addition to all node versions. While having another engine has its upsides, it's most likely going to cause compatibility issues.",
                            "createdAt": "2016-01-19T21:12:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@kevva I think many of us have similar concerns. We'll be trying to make sure everything is as compatible as possible.",
                            "createdAt": "2016-01-19T21:20:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kevva",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123, yeah, but it's almost out of nodes scope in a way. Even though everything in the node API works across both engines, we still have to account for JS features that will differ between them. Not to mention all the native abstractions.",
                            "createdAt": "2016-01-19T21:23:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe @obastemur (jxcore) can contribute to the discussion?\nI would like to see something like zero overhead Neutral API that can target more JS engines, I would myself contribute to such effort. I even started developing mine called JSNI (js native interface) after V8 broke several times my own addon, but I was never able to support more than V8 and it is based on macros.",
                            "createdAt": "2016-01-19T21:53:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123\n\nNote: this does not replace V8, it only gives a built-time option to.\n\nI understand that. What I'm saying is this is a major change that not many people will need/use but many, many will have to support and maintain. I don't see this as a plus for Node at this time, personally.",
                            "createdAt": "2016-01-19T22:00:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jagtesh",
                                "__typename": "User"
                            },
                            "bodyText": "As much as I'd like to see this feature in, I'm afraid that some of the finer differences between V8 and Chakra fragment the community. Packages supporting Chakra only may emerge, while some other existing packages may not work on Chakra. Their use together will create a mess on both engines.\nWe could mitigate this (somewhat) the Ruby gems way by allowing packages to specify what engines they support. Still feel some thought needs to go into this from the more experienced members of our community.",
                            "createdAt": "2016-01-19T22:10:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "@jagtesh I think the question is about how to support more engines transparently. V8 doesn't have stable API, maybe introducing a stable and neutral API can take less time than continuing using V8 in long term. Also, having neutral API would mean that all engines are considered equal.",
                            "createdAt": "2016-01-19T22:16:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Fragmentation.\n\nThe differences between Chakra and V8 in terms of ES-NEXT support are roughly the same as the differences in V8 we have been shipping in different major releases so there's no reason to think that Chakra is going to cause fragmentation on the JS layer and because they are shimming the V8 API they won't be fragmenting native API users either.",
                            "createdAt": "2016-01-19T23:51:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "megastef",
                                "__typename": "User"
                            },
                            "bodyText": "Question: does it mean that v8 specific native modules like gc-stats or memwatch-next would run on Chakra? Are Chakras gc metrics correct and useful for monitoring ?",
                            "createdAt": "2016-01-20T00:47:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "lightningtgc",
                                "__typename": "User"
                            },
                            "bodyText": "Any performance comparison between V8 and Chakra in Node?",
                            "createdAt": "2016-01-20T01:17:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "@lightningtgc  - Please refer to this blog that talks about performance comparison.",
                            "createdAt": "2016-01-20T01:20:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "yjhjstz",
                                "__typename": "User"
                            },
                            "bodyText": "Node.js addon like node-inspector can't be used anymore. :( @kunalspathak\nHow to handle this?",
                            "createdAt": "2016-01-20T01:31:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "@yjhjstz  - Yes, we have not implemented debugger support for node+chakracore yet. You can follow its development at JsRTDebugging.",
                            "createdAt": "2016-01-20T01:40:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "denghongcai",
                                "__typename": "User"
                            },
                            "bodyText": "JavaScript Engines like V8, Chakra, may be best to unify the ABI layer.",
                            "createdAt": "2016-01-20T03:06:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "irfn",
                                "__typename": "User"
                            },
                            "bodyText": "What would this mean with respect to ES6 features. Would one expect the same level as Edge.\nWould this mean that node will be built with both engines and one can select on runtime(command line switch etc.) or would you have separate prebuilt binaries with node and v8",
                            "createdAt": "2016-01-20T03:33:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "obastemur",
                                "__typename": "User"
                            },
                            "bodyText": "What would this mean with respect to ES6 features. Would one expect the same level as Edge.\n\nYes. Looks like this PR comes with Async/Await feature is enabled. (nodejs/node-chakracore@77a5f8d#diff-7da8fe3a685013a34f9825ff00f2f343R64)\nDetails on async/await -> https://blogs.windows.com/msedgedev/2015/09/30/asynchronous-code-gets-easier-with-es2016-async-function-support-in-chakra-and-microsoft-edge/",
                            "createdAt": "2016-01-20T03:48:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "As far as ES features are concerned, until a decision was made to support Chakra officially, the baseline for supported features would have to be whatever is supported by V8. Anything supported by Chakra but not supported by V8 would be \"use at your own risk\" and would not be something could be supportable by core.",
                            "createdAt": "2016-01-20T04:08:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "shigeki",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak This PR includes two new features. One is adding ChakraCore as a new JS engine and the other is adding a new os and arch support where Node running Windows on arm. Is it difficult to separate this into two PRs? I'm not sure V8 can be built and run on the Windows arm.",
                            "createdAt": "2016-01-20T05:23:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "We have a github org just for nodejs stuff now, and public repos are free...maybe we should just start pulling stuff out of deps and use git submodules that point to our own forks we can maintain with whatever patches we need.\nAlso, I really hope we can get this merged if for nothing else than just to have a control sample in our attempts to formalize a consistent internal API. It's easy to overlook the rough edges in our internals when only interfacing with one VM that seems to work okay most of the time, even though its API is actually really weird compared to most other VMs.",
                            "createdAt": "2016-01-20T06:36:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "use git submodules\n\ngit submodules would be nice in principle but in practice git submodule implementation is more trouble that it's worth. Anyway, I opened nodejs/build#310 so that we can continue the discussion about optional dependencies there.",
                            "createdAt": "2016-01-20T10:26:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mazhlekov",
                                "__typename": "User"
                            },
                            "bodyText": "nice, next step - bundle app in .exe :D",
                            "createdAt": "2016-01-20T14:33:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@mazhlekov That's out of scope for this. :)",
                            "createdAt": "2016-01-20T17:12:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "@irfn, to answer your questions:\n\nWould one expect the same level as Edge.\n\nNot necessarily. ChakraCore might have ES6 features not yet present in Edge because ChakraCore binaries get ultimately merged to Edge and not vice-versa. So you will get latest ES6 features in node+chakracore that might not be released in Edge yet.\n\nWould this mean that node will be built with both engines and one can select on runtime(command line switch etc.) or would you have separate prebuilt binaries with node and v8\n\nNo. Currently, you can build node either with chakracore or v8 and not both. Command line to build with chakracore is\nvcbuild.bat ia32 chakracore",
                            "createdAt": "2016-01-20T17:59:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "Is it difficult to separate this into two PRs?\n\nThanks @shigeki for feedback. I could separate the PRs. From your comments, I suppose this has to be divided in 3 PRs however:\n\nNode-gyp changes that needs to go in node-gyp repo.\nMake node run on Windows for ARM a new PR.\nEnabling Node.js with Chakracore engine (the original PR).\n\nFor this to happen, I will have to overwrite commits (by taking it 1 and 2 off from some commits) and update my branch. Are you fine with that?",
                            "createdAt": "2016-01-20T18:18:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zchrykng",
                                "__typename": "User"
                            },
                            "bodyText": "I don't have much skin in this game, other can being a user of node, but really like the idea of moving toward a standardized API/ABI for the javascript engines. Node's dependence on V8 was always one of the things that made me most nervous about the platform.",
                            "createdAt": "2016-01-20T20:41:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "shigeki",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak Yes, I'm fine with it. Reading the minutes of ctc meeting today, this discussion will be continued in an issue. You should not be in a hurry to work on my requests.",
                            "createdAt": "2016-01-21T00:42:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@zchrykng The @nodejs/api group has done some preliminary research into an abstraction layer. Unfortunately since core relies on v8 specifics it's difficult to abstract at that layer. So as a more feasible goal I think we've decided to first tackle the native user exposed API. That unfortunately won't help this case.",
                            "createdAt": "2016-01-21T03:29:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "An interesting prospect that came out of discussion around nodejs/Release#62 (specifically how to enable non-ABI breaking V8 upgrades during Stable cycles) from @bnoordhuis was to start with a shim that reflects the V8 API at a point in time and let V8 evolve behind that shim while keeping it stable for Node's purposes. The idea here was that we could do this at the start of a Stable cycle, V8 could do it's ABI-breaking dance but we get to keep the same ABI (and API) as long as we can manage those changes behind a shim of their earlier API.\nOne could take that approach a bit further and suggest that we it with a longer-term in mind and evolve the shim to something resembling a slightly more engine-agnostic layer that can be backed with V8, ChakraCore or another engine. That way we would have a concrete starting point (the V8 API at the time we started) and take an evolutionary approach to making it more ideal. IMO this would work a lot better than the revolutionary approach of defining an entire API from scratch and doing the implementation work as this is almost begging to be a dead-in-the-water project unless there are serious and dedicated resources applied to such an effort.",
                            "createdAt": "2016-01-21T06:02:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "One could take that approach a bit further and suggest that we it with a longer-term in mind and evolve the shim to something resembling a slightly more engine-agnostic layer that can be backed with V8, ChakraCore or another engine. That way we would have a concrete starting point (the V8 API at the time we started) and take an evolutionary approach to making it more ideal. IMO this would work a lot better than the revolutionary approach of defining an entire API from scratch and doing the implementation work as this is almost begging to be a dead-in-the-water project unless there are serious and dedicated resources applied to such an effort.\n\nAny reason we wouldn't use this to start developing our own more agnostic public-facing API? It seems  like a good starting point where we can feel engine differences and similarities.",
                            "createdAt": "2016-01-21T17:16:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "Any reason we wouldn't use this to start developing our own more agnostic public-facing API? It seems like a good starting point where we can feel engine differences and similarities.\n\nV8 is a terrible choice for that. JSC, Chakra and SpiderMonkey API have a lot in common and V8 is very different.",
                            "createdAt": "2016-01-21T19:02:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "I also think V8 shouldn't dictate how the neutral API should look like. It's overcomplicated without any benefits compared to others. I think the main problem is that V8 API really reflects its internals, when internals change, public V8 API changes as well. The worst addition was all of these Maybe<> maybes.\nI was thinking on how the neutral API should look like, and I think that it should just not use typedefs (aka NAN), but it should just wrap everything and provide really thin layer on top of JS engines. If designed right it would be zero overhead abstraction. If this goes well then JS engine writers may even enhance their engines to allow even more seamless integration with the neutral API.",
                            "createdAt": "2016-01-21T19:25:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "macalinao",
                                "__typename": "User"
                            },
                            "bodyText": "Is there really a benefit in supporting engines other than v8? There are\nquite a few native modules, so I'm not sure officially creating a shim is\nthe best approach. Furthermore, this would only work on Windows. Maybe Node\nshould be forked with only Chakra as the backend.\nOn Thu, Jan 21, 2016 at 11:27 Petr Kobalicek notifications@github.com\nwrote:\n\nI also think V8 shouldn't dictate how the neutral API should look like.\nIt's overcomplicated without any benefits compared to others. I think the\nmain problem is that V8 API really reflects its internals, when internals\nchange, public V8 API changes as well. The worst addition was all of these\nMaybe<> maybes.\nI was thinking on how the neutral API should look like, and I think that\nit should just not use typedefs (aka NAN), but it should just wrap\neverything and provide really thin layer on top of JS engines. If designed\nright it would be zero overhead abstraction. If this goes well then JS\nengine writers may even enhance their engines to allow even more seamless\nintegration with the neutral API.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-01-21T20:00:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "LPGhatguy",
                                "__typename": "User"
                            },
                            "bodyText": "@simplyianm ChakraCore is in development for other platforms; a neutral API would also open up the possibility of using other engines like SpiderMonkey without breaking plugins.",
                            "createdAt": "2016-01-21T20:15:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "There is a large body of native modules out there. An evolutionary rather than a revolutionary approach, as @rvagg suggests is probably the best way to move forward. Examples from other ecosystems to consider would be ruby vs jruby, cpython vs. pypy (not exactly the same beasts, but still relevant): a revolutionary break in compatibility with native modules has meant jruby still cannot run rails compatibly. An evolutionary approach gives as a way to get to a VM api without causing wide-spread churn in the ecosystem.",
                            "createdAt": "2016-01-21T21:00:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "aruneshchandra",
                                "__typename": "User"
                            },
                            "bodyText": "Node.js addon like node-inspector can't be used anymore. :( @kunalspathak\nHow to handle this?\n\n@yjhjstz, as @kunalspathak pointed out - our debugging support is a work in progres. Currently, we are in the process of replacing Windows specific COM based debugging APIs with JSON based Modern Diagnostic APIs, which can be used inside any host by writing a simple adapter for that host. The goal is to make ChakraCore interoperable with existing debugging tools for Node.js. I showed a brief demo of this early work at NodeInteractive using VS Code for now. So, please stay tuned!\n:)",
                            "createdAt": "2016-01-21T21:54:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hiddentao",
                                "__typename": "User"
                            },
                            "bodyText": "As a package maintainer I'm also concerned. Even if we go with a fixed ABI/API layer and allow the engine(s) underneath to grow and/or be swapped out, there's still the risk that different engines may exhibit different behaviour (especially thinking about bugs) for the same API - meaning your package runs fine on V8 but not on Chakra, or vice versa. This can be mitigated through extensive and thorough tests but there's always a probability.",
                            "createdAt": "2016-01-22T06:59:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Agreed and acknowledged. This is precisely why we would want to be very\ncareful about if, how and when we accepted chakra as an officially\nsupported first class citizen in core. There are many issues such as this\nto work out.\nOn Jan 21, 2016 11:00 PM, \"Ramesh Nair\" notifications@github.com wrote:\n\nAs a package maintainer I'm also concerned. Even if we go with a fixed\nABI/API layer and allow the engine(s) underneath to grow and/or be swapped\nout, there's still the risk that different engines may exhibit different\nbehaviour (especially thinking about bugs) for the same API - meaning your\npackage runs fine on V8 but not on Chakra, or vice versa. This can be\nmitigated through extensive and thorough tests but there's always a\nprobability.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-01-22T07:10:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "This might be obvious, but it hasn't been said...\nJavaScript developers are by no means strangers to having to deal with multiple engines. Not to say minimizing, or nullifying, the differences wouldn't be greatly appreciated.\nHow would we document these differences?",
                            "createdAt": "2016-01-22T14:23:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "megastef",
                                "__typename": "User"
                            },
                            "bodyText": "I suggest to keep separate projects/binaries and submitting in PR to https://github.com/coreybutler/nvm-windows - to support switching between Node and Chakra. Like io.js was separated from node.  But users are then aware that they switch to something 'different'.",
                            "createdAt": "2016-01-22T15:19:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "shouldn't there be a separate discussion about the neutral API? Was this discussed before?",
                            "createdAt": "2016-01-22T15:28:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "190n",
                                "__typename": "User"
                            },
                            "bodyText": "Why don't we make this easier by developing a universal interface for JS engines?",
                            "createdAt": "2016-01-22T15:51:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Started a thread to discuss Node.js moving toward VM neutrality :) nodejs/roadmap#54",
                            "createdAt": "2016-01-22T19:54:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "runvnc",
                                "__typename": "User"
                            },
                            "bodyText": "VM neutrality is great, but embrace, extend, extinguish is a real Microsoft policy.  Their documented track record of interfering with de facto/real standards must be part of the conversation.  Accepting something like this could very easily lead to the end of Node a few years down the line.\nI assume this comment will be censored.  Therefore I will record it for later reference in the aftermath down the line.",
                            "createdAt": "2016-01-22T21:18:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tanaydin",
                                "__typename": "User"
                            },
                            "bodyText": "In some day we will write codes like that...\nif (engine === 'v8') {\n    do_stuff_for_v8();\n} else if (engine === 'chakra') {\n    do_stuff_for_chakra();\n}\nand we all gonna hate about it.",
                            "createdAt": "2016-01-22T23:59:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "multics",
                                "__typename": "User"
                            },
                            "bodyText": "\u5728 2016\u5e741\u670823\u65e5\uff0c\u4e0a\u53488:00\uff0ctanaydin sirin notifications@github.com \u5199\u9053\uff1a\nIn some day we will write codes like that...\nif (engine === 'v8') {\ndo_stuff_for_v8();\n} else if (engine === 'chakra') {\ndo_stuff_for_chakra();\n}\nand we all gonna hate about it.\n\u2014\nReply to this email directly or view it on GitHub.\n\nHate this, +1",
                            "createdAt": "2016-01-23T00:58:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bterlson",
                                "__typename": "User"
                            },
                            "bodyText": "if (engine === 'v8') {\n    do_stuff_for_v8();\n} else if (engine === 'chakra') {\n    do_stuff_for_chakra();\n}\n\n\nI would suggest handing different script engine similarly to web best practices - feature detect what you need. Also similar to what is done when you want to support multiple versions of Node with differing language feature support. Doing a script engine check like this is a bad idea as it will likely break when the script engines' capabilities change.",
                            "createdAt": "2016-01-23T01:17:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MrRio",
                                "__typename": "User"
                            },
                            "bodyText": "This is a very different Microsoft submitting this PR. It literally shims\nthe same API rather than extending it.\nOn Fri, 22 Jan 2016 at 21:18, Jason Livesay notifications@github.com\nwrote:\n\nVM neutrality is great, but embrace, extend, extinguish is a real\nMicrosoft policy. Their documented track record of interfering with de\nfacto/real standards must be part of the conversation. Accepting something\nlike this could very easily lead to the end of Node a few years down the\nline.\nI assume this comment will be censored. Therefore I will record it for\nlater reference in the aftermath down the line.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).\n\nJames Hall\nDirector\nParallax Agency Ltd\nM. 07894950320",
                            "createdAt": "2016-01-23T01:30:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MrRio",
                                "__typename": "User"
                            },
                            "bodyText": "Just land it and see what gives. It's adding so many features and doesn't\nbreak anything else.\nIt can be refined once in and think about different engines later.\nOn Fri, 22 Jan 2016 at 19:55, Mikeal Rogers notifications@github.com\nwrote:\n\nStarted a thread to discuss Node.js moving toward VM neutrality :)\nnodejs/roadmap#54 nodejs/roadmap#54\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).\n\nJames Hall\nDirector\nParallax Agency Ltd\nM. 07894950320",
                            "createdAt": "2016-01-23T01:34:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Please refrain from telling us to \"just land it\". That would be very irresponsible of us.",
                            "createdAt": "2016-01-23T01:46:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MrRio",
                                "__typename": "User"
                            },
                            "bodyText": "Yeah fair point.\nThere's so many things we could um and ah over. It might be easier to take a more pragmatic approach. Getting it into the codebase while finer details are still up in the air would allow people to test it out and refine it. Especially as it doesn't break anything else.",
                            "createdAt": "2016-01-23T02:18:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@MrRio there is no guarantee it doesn't break stuff. As well, if the PR is rebased against master there is nothing to stop individuals from applying the patch if they want to try it out themselves. Simply merging into master is not humming and ha'ing... it imho is the pragmatic approach.",
                            "createdAt": "2016-01-23T02:28:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MrRio",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd I see your point. Are there particular tests we can write to ensure this? Happy to lend a hand.\nI worry the PR will remain open for a long time discussing without action.\nWho is responsible at Microsoft's end for helping this get merged in?",
                            "createdAt": "2016-01-23T02:38:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@MrRio the thread was started by a Microsoft employee, and there are others who have chimed in as well. This is going to take a while, the implications on the ecosystem should not be under estimated. Thank you for your patience.",
                            "createdAt": "2016-01-23T02:48:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "Landing a PR without checking the code for any language that allows direct modification of memory (which is basically every major language out there right now - definitely C/C++) is begging for problems.\n#include <limits.h>\n#include <string.h>\n\nmemset(0, 0, LONG_MAX);\nNothing in the above code removes anything, but will definitely cause you hard to debug problems. Crude example, but it gets the point across.",
                            "createdAt": "2016-01-23T03:08:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "@MrRio , you could try out this by cloning nodejs-chakracore branch. As @thealphanerd  mentioned, there are certain things that are unimplemented in chakrashim and we are working on it.\nRegarding testing, you can check out the unit test results which will give you an idea of stability.",
                            "createdAt": "2016-01-23T03:22:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "waynebloss",
                                "__typename": "User"
                            },
                            "bodyText": "I hope you reject this PR and also the idea that Node.js needs to support multiple engines. Please don't make Node.js a battleground of competing Javascript engines like the Browser has become. We want a runtime that works the same everywhere, not another problem-vector to consider.\nThis PR is not useful to anybody but Microsoft and I doubt it will even be useful to them because I feel like next to nobody is going to target the Chakra version of Node.js. Node.js can run on any OS already. If they can't get it running as-is on their OS, then they should fork it or fix their OS.\nI say this as a Windows user, an MSDN subscriber and a person who uses Visual Studio to write all of my Node.js code...I have nothing against Microsoft.",
                            "createdAt": "2016-01-23T15:40:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "deathtrip",
                                "__typename": "User"
                            },
                            "bodyText": "I think the PR should be rejected. It only benefits microsoft, and works only on windows. If this gets accepted it will give microsoft a way to create incompatibilities between the two engines, and disrupt the ecosystem. As they've done so many times in the past.\nBasically they want to use the community to help them push their W10 IoT.\nAnd no, it's not \"a different microsoft\", just look how they use their market position to push Win10 down everyone's throat.",
                            "createdAt": "2016-01-23T22:23:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zchrykng",
                                "__typename": "User"
                            },
                            "bodyText": "I do find it slightly ironic that people assume bad faith from Microsoft, while being complete beholden to another tech giant (Google). I am not a big fan of either company and don't particularly trust either one. So would like to expand the number of different engines node can run on so no one company can seriously disrupt the project's viability.\n\nOn Jan 23, 2016, at 5:24 PM, deathtrip notifications@github.com wrote:\nI think the PR should be rejected. It only benefits microsoft, and works only on windows. If this gets accepted it will give microsoft a way to create incompatibilities between the two engines, and disrupt the ecosystem. As they've done so many times in the past.\nBasically they want to use the community to help them push their W10 IoT.\nAnd no, it's not \"a different microsoft\", just look how they use their market position to push Win10 down everyone's throat.\n\u2014\nReply to this email directly or view it on GitHub.",
                            "createdAt": "2016-01-23T22:44:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "waynebloss",
                                "__typename": "User"
                            },
                            "bodyText": "I don't think Node.js is completely beholden to Google since v8 is open source, but the real disruption here is this pull request IMO. It's asking the project to expend effort now (and continually in the future) to do something that I'm sure the vast majority of Node.js users do not care about.\nIf we can brush politics aside, I think that's what it boils down to. If not too many people care about this feature, then why do it at all?",
                            "createdAt": "2016-01-23T23:44:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakesays-old",
                                "__typename": "User"
                            },
                            "bodyText": "@waynebloss Microsoft has committed to porting Chakra.\nFor those who say this PR only benefits Microsoft, you're being a bit myopic. Having multiple engines adds many benefits, and node will be the better for it.\n@runvnc Can you explain how, in this situation, Microsoft could in any way cause node to fail?",
                            "createdAt": "2016-01-23T23:51:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zchrykng",
                                "__typename": "User"
                            },
                            "bodyText": "@waynebloss Yeah I was being a little melodramatic with that. I have no disagreement with the \"this will be a lot of work and it is not needed or is not the time\" argument. I just felt the need to comment on the paranoia that appeared to be going around.",
                            "createdAt": "2016-01-23T23:53:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Please keep the conversation civil and focused.\nThe process we follow here is well defined. Whether or not this PR or some\nvariation of it lands will be determined by consensus of the collaborators.\nWhile discussion of the technical merits of the proposed change are\nwelcome, personal arguments are not. We all have opinions, let's please be\nrespectful of them.\nOn Jan 23, 2016 6:02 PM, \"Yonas Yanfa\" notifications@github.com wrote:\n\n@gufi https://github.com/gufi Who are you to lecture me about what will\nkill an open source project? What are your credentials?\nJust because someone dumps a bunch of code at your doorstep doesn't mean\nyou owe it to them to accept it into your codebase.\nMicrosoft can fork nodejs and keep this PR to themselves, since that's who\nit benefits. This PR is not for our benefit, it's for theirs.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-01-24T02:10:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "thedark1337",
                                "__typename": "User"
                            },
                            "bodyText": "This doesn't strictly benefit Microsoft though. It's the beginning towards a future Node.js where its not coupled to V8 and you're allowed a choice of either Chakra or any other engine. I get that Microsoft in the past has had a bad reputation for many many things, but that doesn't mean that all they do is bad. I for one welcome this change to Node.js and would love to see it progress further.",
                            "createdAt": "2016-01-24T02:22:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "obastemur",
                                "__typename": "User"
                            },
                            "bodyText": "I don't know if it's already mentioned on this thread or not. ChakraCore is actively being ported to Linux/OSX (guess it's for Node.JS? what else it could be..). (see https://github.com/Microsoft/ChakraCore/tree/linux)\n@jasnell\n\nPlease keep the conversation civil and focused.\n\nDefinitely agree. Politics and personal issues aside, all the hard work and commitment done should deserve at least this much..",
                            "createdAt": "2016-01-24T04:31:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "Some people here have really no clue what API neutrality could provide in the future. It's a good direction and I think it's not even related to chakracore, MS started this discussion by submitting the PR, but the problem was here before.\nImagine that you use node to build desktop apps, or mobile apps, and everything you need to ship is your own code + node that uses native JS engine the target OS provides. Or, if the OS has already node installed, you can just ship the package :) This is a huge step forward and it's not really MS related.",
                            "createdAt": "2016-01-24T04:36:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MartinJohns",
                                "__typename": "User"
                            },
                            "bodyText": "@obastemur:\n\nChakraCore is actively being ported to Linux/OSX (guess it's for Node.JS? what else it could be..).\n\nIt is very easy to integrate ChakraCore into your .NET Core applications. .NET Core is already working across platforms, including Linux and OSX.  By porting ChakraCore to Linux and OSX you can now easily embed a JavaScript engine into your .NET Core applications, working across all major platforms.",
                            "createdAt": "2016-01-24T08:45:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Codelica",
                                "__typename": "User"
                            },
                            "bodyText": "I think the idea of API neutrality is noble, but that's not really what this specific PR is about -- at least not in its current form. (Unless you consider the current Node/V8 interface that abstraction.)\nAs a Node user, I'm concerned about the confusion and fragmentation that would certainly come with this being part of the \"main\" branch without careful consideration.  After finally being clear of the IO.js / Node split, I'd hate to see the community reaction to engine specific (Windows only) NPM packages or handling engine specific package issues which maintainers may not even have the ability to investigate (as Windows currently only accounts for about 1/3 of Node downloads).\nI understand what MS has to gain here.  Increased visibility in the Node community, an inferred approval of their JS engine, a PR opportunity, more eyes and use of their code, etc.  What I'm not sure about is what Node really gains right now.  As far as I can tell it would just be a second JS engine option for Windows and access to a handful of Windows supported IoT devices (which can't run the current V8 Node?).  Language features like async/await are already possible via Babel, and performance doesn't seem like a differentiator at the moment.\nI'm definitely not saying that Node should only be married to V8, but I do think a few things should be in place before opening the doors to other engines.  Like a defined abstraction layer (even if that's initially based on the V8 implementation, assuming that's an option, i have no idea :) ) and some minimal set of \"requirements\" for engines to be considered for core Node inclusion.  Personally, I think any JS engine that's a core option should be required to support Linux, OS X, and Windows.  IMO broad platform support is one of Node's biggest strengths currently, and it keeps the playing field level.\nSo why not take some time to define the abstraction layer, think about what might need to happen on the NPM front, and let MS produce their Linux (and OS X ?) version(s).  At that point I think it would be better received by the community.  If somehow MS could also increase Windows' MAX_PATH size while they're at it, people might even cheer. ;)",
                            "createdAt": "2016-01-24T09:56:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nook-scheel",
                                "__typename": "User"
                            },
                            "bodyText": "-1 http://www.viva64.com/en/b/0370/\nMod edit: This links to a post discussing static analysis of Chakra's C++ Source .",
                            "createdAt": "2016-01-24T14:33:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trendzetter",
                                "__typename": "User"
                            },
                            "bodyText": "-1\nother platforms are not first class. windows centric is not open.",
                            "createdAt": "2016-01-24T16:32:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MartinJohns",
                                "__typename": "User"
                            },
                            "bodyText": "@Nooks How is this an argument against the PR? Every software has bugs, NodeJS or the V8 engine are no exception in this regard. I'm sure if you let a static analyzer run over those projects there will be plenty of mistakes too. Besides that, these mistakes are surely already fixed (or will be shortly).\n@trendzetter Microsoft is committed to bring ChakraCore support for the Linux and OSX platform as well. This is nothing Windows centric. This was mentioned several times already.",
                            "createdAt": "2016-01-24T16:52:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "I don't really get the argument that Microsoft doing this for their own benefit is somehow bad. The same could be said about everyone contributing to node. We work on node because it benefits our careers. Is that bad too?\nThe fork people have suggested is what Microsoft would've done if they didn't care about us. They absolutely have the capacity to be able to maintain their own fork, if they felt that served their interests best. But recently, Microsoft has been discovering the power of open source and realizing how much more they benefit by enabling the use of their tech, rather than enforcing it.\nWhile I'm still a bit cautious about how that will all play out long-term, for now, I trust them to do what's best for the community because that is also what's best for them.",
                            "createdAt": "2016-01-24T17:15:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I'm fairly certain these Microsoft points are moot. We already have had Microsoft helping us for years in the form of @orangemocha.\nThe larger question is already being discussed in nodejs/roadmap#54 -- that is, are we a V8-centric platform, or are we engine agnostic?\n(If you comment about that here, I will remove your comment. Move it to that thread.)",
                            "createdAt": "2016-01-24T17:45:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "seishun",
                                "__typename": "User"
                            },
                            "bodyText": "Can someone name any disadvantage of this being maintained in a separate fork?",
                            "createdAt": "2016-01-24T19:23:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakesays-old",
                                "__typename": "User"
                            },
                            "bodyText": "@trendzetter How is windows centered not open? That makes no sense whatsoever.",
                            "createdAt": "2016-01-24T20:48:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "macalinao",
                                "__typename": "User"
                            },
                            "bodyText": "fragmentation\nOn Sun, Jan 24, 2016 at 11:24 AM Nikolai Vavilov notifications@github.com\nwrote:\n\nCan someone name any disadvantage of this being maintained in a separated\nfork?\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-01-24T20:49:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakesays-old",
                                "__typename": "User"
                            },
                            "bodyText": "@seishun Yes - it is always best for a project to maintain one fork. It keeps the community focused and limits fragmentation and compatibility issues.",
                            "createdAt": "2016-01-24T20:49:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakesays-old",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard I agree. I'll bet a paycheck that Google developed V8 with their own interests in mind.",
                            "createdAt": "2016-01-24T20:50:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "abdulhannanali",
                                "__typename": "User"
                            },
                            "bodyText": "",
                            "createdAt": "2016-01-25T08:00:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trendzetter",
                                "__typename": "User"
                            },
                            "bodyText": "@MartinJohns the point is microsoft trying to make windows first class, linux second class (windows works now, linux will work but cannot now if ever equally, no guaranties. end game; fix it yourself). Also their bringing in of their pushers doesn't help much to their reputation for astroturfing.\nMicrosoft is only out to promote its closed source products. we don't need a closed source oriented \"open sauce\" to burden the community of open source projects.",
                            "createdAt": "2016-01-25T08:03:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "JureUrsic",
                                "__typename": "User"
                            },
                            "bodyText": "http://www.ecis.eu/documents/Finalversion_Consumerchoicepaper.pdf\nRead this document carefully... Do you see the pattern? Please don't give me that \"Microsoft being a whole new company\" bullshit...\nBefore merging the PR, I think Microsoft should first make Chakra fully Open Source and cross platform supported...",
                            "createdAt": "2016-01-25T08:06:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "deathtrip",
                                "__typename": "User"
                            },
                            "bodyText": "It should be decided first whether node will be VM neutral or not. Without that decision, even considering this PR makes no sense. And as was said before, they should make the whole thing work equally on all platforms, not make systems other than their own second class citizens.",
                            "createdAt": "2016-01-25T11:35:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "abdulhannanali",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak i support you this merge should happen. don't worry about the trolls here \ud83d\udc4d",
                            "createdAt": "2016-01-25T12:09:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "@trendzetter Microsoft runs Linux on Azure, which would be a popular place to use node, so I'm sure they'll be actively supporting it. They have already begun work on Linux support themselves. The only reason it's not available at the time of open sourcing is because the primary function of Chakra is in the Edge browser, so they focused on getting it working there first, then open sourced it as soon as possible.\nAlso, looking to the community for help with expanding platform compatibility is totally fine and something node and V8 also do. Several platforms node is available on are provided by IBM, and the same has happened with fixes to V8 to support those platforms.\nLarge scale open source does not exist in a vacuum. There's always corporations in the background supporting it in one way or another, whether it be paying wages of contributors or donating directly to a foundation for it. An open source project does not get big without a business need for it.",
                            "createdAt": "2016-01-25T16:28:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alexsaves",
                                "__typename": "User"
                            },
                            "bodyText": "Very cool. I think its really meaningful to test the extensibility of Node by integrating third party interpreters like this. Super enthusiastic about this.",
                            "createdAt": "2016-01-25T19:51:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rumkin",
                                "__typename": "User"
                            },
                            "bodyText": "So we should to decide several separated questions:\n\nDoes we need ABI? And what is it's goal to isolate v8 or to isolate abstract javascript engine?\nWhat does Nodejs wins with ChakraCore and is it so important?\nWhat does Nodejs loose without ChakraCore and is it critical for now?\nWhich engine is primary and which is fully dependant until we got ABI?\nWhy do we need ChakraShim in node.js repo instead of separated fork if it only a shim?\nHow does one permanent breaking API would be fixed with another for another engine?\nAnd rhetorical question. Why does not Microsoft release working project forked from node at first and commit not fully supported and a half working shim? And why some node foundation members support that out of standard and logic decision?",
                            "createdAt": "2016-01-25T23:08:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jakesays-old",
                                "__typename": "User"
                            },
                            "bodyText": "@JureUrsic Exactly how is chakra core NOT open source? The full source code is available. It is licensed under MIT. It doesn't get more open than that.\n@trendzetter Microsoft is a Windows shop (obviously) - they develop on windows. Why do you expect them to release anything else?\nHonestly all the complaints/rants about the motivation of Microsoft with respect to Chakra are irrelevant, full of subjective and poorly thought out opinions.",
                            "createdAt": "2016-01-25T23:10:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "waynebloss",
                                "__typename": "User"
                            },
                            "bodyText": "@rumkin Good summary of the points here but I'm having trouble parsing or confirming some of your English. Specifically:\n\n\nHow does one permanent breaking API would be fixed with another for another engine?\n\n\nI believe you're referring to @trevnorris ' question (\"What happens when v8 needs to be updated and the API doesn't match the Chakra shim? Will we need to hold off until the shim also has an update?\") Correct?\n\n\n...And why some node foundation members support that out of standard and logic decision?\n\n\nI feel that we should probably focus on the technical and avoid this, but just to be thorough - I want to let you know that the above was unclear. Are you asking why some members of the CTC support the shim against \"standard decision logic\"? I'm not aware of any such thing, but I'm sure that I do not know what your last sentence means.\nThank you.",
                            "createdAt": "2016-01-26T00:14:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kobalicek",
                                "__typename": "User"
                            },
                            "bodyText": "Why some people don't understand \"Please keep the conversation civil and focused\"?",
                            "createdAt": "2016-01-26T06:49:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rumkin",
                                "__typename": "User"
                            },
                            "bodyText": "@waynebloss, thank for attention and sorry for bad english )\n\nYep, that's mean the same.\nI mean that we probably should not include semi-working code in repository. There is no any reason to use new engine right now. MS should make a fork (maybe call it like MS Node.NET) and support it. This is a standard way of extension which will not freeze nodejs development at some time and make clear all differences betweem the projects. Other part of the question is why some users are trying to call Chakra shim an ABI? And if we want to get Unified Javascript Engine API than we should discuss this but not a shim. And we should to discuss this with several engine developers to get the working draft or scratch of what it should looks like to avoid breaking changes in near future.\n\nHope it's now clear to understand.",
                            "createdAt": "2016-01-26T07:36:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MartinJohns",
                                "__typename": "User"
                            },
                            "bodyText": "@trendzetter Would you please mind to stop with this irrational Microsoft hate and be factual instead? You are just repeating your points with no additional information, points that have been pointed out to be moot already.",
                            "createdAt": "2016-01-26T08:57:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MartinJohns",
                                "__typename": "User"
                            },
                            "bodyText": "I would suggest to close further discussions on this PR until nodejs/roadmap#54 brought up results.",
                            "createdAt": "2016-01-26T08:58:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rumkin",
                                "__typename": "User"
                            },
                            "bodyText": "@MartinJohns But how does nodejs/roadmap#54 actually relate to discussion. ChakraShim is not an ABI. And if we talking about Chakra than it should sounds like \"Do we need a zoo of engines\".",
                            "createdAt": "2016-01-26T09:03:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "You're not really adding value here @trendzetter and your comments are starting to get insulting. If you have trouble moderating yourself then we can help you with that.\nSame goes for anyone else having trouble being constructive in this thread; this is not your personal blog and there are people trying to get things done and make objective decisions around here and we could do without the silly ranting.",
                            "createdAt": "2016-01-26T10:25:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@trendzetter thankyou, your concerns are noted, along with others who have been expressing similar and opposing views on this particular topic. There is obviously a lot of complex context that feeds into any decision around this pull request.\nHowever, please, let's draw a line under discussion regarding Microsoft, many of us have heard most of these arguments and are aware of both extreme points of view. Continuing to repeat them here will only contribute to you being further marginalised from the only debate that actually matters here and will have no impact on the end decision. It's all been said already.\nThankyou for your input, however.",
                            "createdAt": "2016-01-26T11:28:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "We've decided to lock this thread, for a few days at least, to put a damper on the unproductive chatter before it gets fully out of control.\nIf you'd actually like to engage in productive discussion regarding Node.js being tied to V8 or becoming something closer to VM neutral, then please head over to nodejs/roadmap#54. Please try and stay civil and if you don't have anything helpful to add, just observe (there's a Subscribe button on the side).",
                            "createdAt": "2016-01-26T13:12:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "I have updated the changes in the PR to incorporate as much feedback as possible and restructured the commits. I have also updated the PR description to reflect the new commit ordering. Thanks!",
                            "createdAt": "2016-01-28T23:56:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@kunalspathak +1, it may take a bit of time to review but I'll try to get some comments in by next week. Thank you for being patient!",
                            "createdAt": "2016-01-29T06:51:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "Deleted comment by @runvnc. Please take it to your blog, this PR is for technical discussion at the PR at hand. Discussion about whether Node.js should even head down a multi-VM route are taking place at nodejs/roadmap#54. Off-topic rants should be taken to tumblr, wordpress, or some other forum where you can engage in focused discussion rather than this PR. Please have a bit of respect for the collaborators of this project.",
                            "createdAt": "2016-01-30T09:18:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg I thought it was a pretty valid point, though it does belong in the roadmap discussion. Suggesting legitimate concerns be taken to Tumblr is a bit crass, though.\n\n/ontopic is there a reason this isn't being run against the automated tests in CI?",
                            "createdAt": "2016-01-30T09:26:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MrRio",
                                "__typename": "User"
                            },
                            "bodyText": "I haven't be paid by Microsoft for the record. \ud83d\ude02\nOn Sat, 30 Jan 2016 at 09:27, Josh Junon notifications@github.com wrote:\n\n@rvagg https://github.com/rvagg I thought it was a pretty valid point,\nthough it does belong in the roadmap discussion. Suggesting legitimate\nconcerns be taken to Tumblr is a bit crass, though.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).\n\nJames Hall\nDirector\nParallax Agency Ltd\nM. 07894950320",
                            "createdAt": "2016-01-30T09:34:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jbergstroem",
                                "__typename": "User"
                            },
                            "bodyText": "@Qix-: Collaborators (inc me) have already run tests (see above). We're counting 50+ fails on Windows, Linux being worse and SmartOS, FreeBSD not working at all. I treat this PR as a door opener for nodejs/roadmap#54.",
                            "createdAt": "2016-01-30T11:21:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hansdunk",
                                "__typename": "User"
                            },
                            "bodyText": "@jbergstroem\n\nWe're counting 50+ fails on Windows, Linux being worse and SmartOS, FreeBSD not working at all.\nCollaborators (inc me) have already run tests (see above).\n\nThis must be a joke. ChakraCore does not even compile on Linux yet...\n@rvagg You have a bigger responsibility than deleting peoples' messages here. Starting with answering 'How come this PR can be considered seriously at this very point' ?\nForget about Microsoft is this or that. There are very good managers at Microsoft, and the bad ones. Like in any other place. The 'project management' behind this PR Has clearly failed. They supposed to wait, fix their issues and start the discussion first.\nNode.js was supposed to be governed by community. Sadly, this PR shows otherwise.",
                            "createdAt": "2016-01-30T16:31:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "waynebloss",
                                "__typename": "User"
                            },
                            "bodyText": "@hansdunk Deleting comments that are doing nothing more than speculating on Microsoft's motives is a pretty important job to do. We already have a good, objective, drama-free summary of the basic technical considerations that need to be made here (with some points clarified a few comments down) and discussion on those points has begun in other threads already.\n\nForget about Microsoft is this or that.\n\nExactly. I read the deleted comments if I in fact received them all in my email...they were both walls of text containing nothing more than rumors and pure speculation about Microsoft's business and marketing practices.\n\nThe 'project management' behind this PR Has clearly failed. They supposed to wait, fix their issues and start the discussion first. Node.js was supposed to be governed by community. Sadly, this PR shows otherwise.\n\nDon't you think that's a bit dramatic? It's a Pull Request which has led to a discussion. It's not the end of Node.js being governed by its community. I'm not even sure how it's a failure on anybody at Microsoft's part other than the fact that it might be a bad idea to have a Chakra-specific shim in Node.js (for the record - I think it's a bad idea and that a non-Chakra specific ABI would be a better idea).",
                            "createdAt": "2016-01-30T17:18:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MartinJohns",
                                "__typename": "User"
                            },
                            "bodyText": "It's always hilarious when people claim some is bought by Microsoft or they're working against the community, just because their own opinion is not reflected. The community is large and this is a sensitive subject, there are people on both sides and on middle ground.",
                            "createdAt": "2016-01-30T17:24:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "waynebloss",
                                "__typename": "User"
                            },
                            "bodyText": "@hansdunk Here's the discussion. We're in it. Sorry it didn't happen according to the exact timeline that you were expecting. :( Yes, it's still dramatic that you think Node.js community governance is over because one pull request (from a community member) happened before you thought it should.\nHere's one of the technical bits that has been discussed here (among others): Do you think that it's a good idea for Node.js to have an ABI/facade for it's Javascript engine or should it be v8 only?\nThe core technical committee is having a discussion about this PR. Did you read the notes from their last meeting?\nAll you're doing is flinging accusations about and not really contributing anything at all. Please stop doing that.",
                            "createdAt": "2016-01-30T18:31:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "Seeing as how not one collaborator has appeared to consider the negatives of this PR, it's understandable that people are a little uncomfortable.\n\n@jbergstroem okay, but is there not a CI integration added to Github to be checking PRs automatically where test results can be viewed by the public?",
                            "createdAt": "2016-01-30T20:01:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@Qix- have you read the TC meeting notes or the issue and discussion about accepting a second engine? That discussion is held and a lot of people are expressing their opinion - they're just not doing it on the pull request itself.",
                            "createdAt": "2016-01-30T20:03:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jokeyrhyme",
                                "__typename": "User"
                            },
                            "bodyText": "Fun self-censorship exercise: swap \"Microsoft\" for \"Google\", and \"Chakra\" for \"v8\". If your sentence is still true then don't bother posting it.",
                            "createdAt": "2016-01-30T22:53:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "We'd like to not have to re-lock this thread but will do so if necessary. Comments from a user who appears to have created a throw-away account simply for the purpose of posting derailing comments here have been removed.\nI personally really hate deleting comments and I'm not even going to argue that there aren't legitimate discussion-worthy points being made in the comments being deleted. However, discussion that deviates significantly from technical discussion on this PR and that are intended to continue tangential argumentation will be removed. Please find a new forum for these posts, nobody wants to deny you your opinions, this just isn't the place for them and you're hurting Node.js in general by serving as a distraction from all of the productive things we could otherwise be doing.",
                            "createdAt": "2016-01-31T02:20:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jbergstroem",
                                "__typename": "User"
                            },
                            "bodyText": "@Qix- not yet since I'd have to fork this PR and add commits since it doesn't change vm by default. I opted for opening one of our windows slaves and testing it there instead.",
                            "createdAt": "2016-02-01T21:56:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "darth10",
                                "__typename": "User"
                            },
                            "bodyText": "A fork sounds like a much better option IMHO.\nOn 02-Feb-2016 3:27 am, \"Johan Bergstr\u00f6m\" notifications@github.com wrote:\n\n@Qix- https://github.com/Qix- not yet since I'd have to fork this PR\nand add commits since it doesn't change vm by default. I opted for opening\none of our windows slaves and testing it there instead.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-02-02T02:42:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matthiasg",
                                "__typename": "User"
                            },
                            "bodyText": "If Node were more open to other engines the auto build process could be configured to automatically produce more builds with different engines. As a totally independent fork would likely stay behind quickly and thus there would be no incentive to use it even.\nAs chakra being windows only. If some microprocessor comes out which were to require a modified version of v8 (e.g stripped down etc) I would consider this the same thing. Developers could use node everywhere, but there might be an alternative js engine under the hood which might work better on their platform. Whether they could use native modules is of course not necessarily guaranteed for all platforms. That is sadly already the case anyway.\nActually having chakra or any other engine in node would not be helpful. Fork with automated build seem more logical to me.",
                            "createdAt": "2016-02-02T05:23:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@matthiasg The tone I drew from this (and some discussion elsewhere) is that this is yet another attempt to abstract Node from the runtime it uses. It's not unheard of, and it's even being done for Chrome extensions and the Java Runtime with Nashorn. I think it being an option in core (even if it means full vm module support is limited to one or more specific platforms) would just further legitimatize these efforts, as well as making future work far easier.",
                            "createdAt": "2016-02-02T15:13:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "At yesterday's CTC meeting, it was resolved to let these changes live in a separate repository under the nodejs/ organization. The rationale behind this decision (or at least my interpretation of it) is that we want to encourage experimentation with this project, yet at this time we don't want to put any additional burden on the collaborators of the main Node.js project to maintain the chakracore version. In particular, issues about the chakracore version should be directed to the new repo (name TBD). Of course, people interested in contributing are more than welcome to do so in the new repo. There is also a @nodejs/chakra team that can be mentioned within the nodejs org.\nI suggest that we keep this PR open to continue providing feedback to the actual code changes, which I think would be welcome by the authors. Then instead of merging the changes into this repo, we can push them to the new repo.\n@kunalspathak , can you add two changes to the README:\n\nHow to build node with chakracore. This can be a part of nodejs/node-chakracore@b6e81a2\nA visible notice that tells users to file node-chakracore specific issues into the node-chakracore repo rather than nodejs/node. I would keep this as a separate commit.\n\nAs usual, please keep the discussion constructive.\ncc: @nodejs/ctc",
                            "createdAt": "2016-02-04T14:25:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I would also point out that it's possible that we could include the chakra\nbuilds in CI and regular nightlies.\nOn Feb 4, 2016 6:25 AM, \"Alexis Campailla\" notifications@github.com wrote:\n\nAt yesterday's CTC meeting #5058,\nit was resolved to let these changes live in a separate repository under\nthe nodejs/ organization. The rationale behind this decision (or at least\nmy interpretation of it) is that we want to encourage experimentation with\nthis project, yet at this time we don't want to put any additional burden\non the collaborators of the main Node.js project to maintain the chakracore\nversion. In particular, issues about the chakracore version should be\ndirected to the new repo (name TBD). Of course, people interested in\ncontributing are more than welcome to do so in the new repo. There is also\na @nodejs/chakra https://github.com/orgs/nodejs/teams/chakra team that\ncan be mentioned within the nodejs or g.\nI suggest that we keep this PR open to continue providing feedback to the\nactual code changes, which I think would be welcome by the authors. Then\ninstead of merging the changes into this repo, we can push them to the new\nrepo.\n@kunalspathak https://github.com/kunalspathak , can you add two changes\nto the README:\n\nHow to build node with chakracore. This can be a part of Microsoft@\nb6e81a2\nnodejs/node-chakracore@b6e81a2\nA visible notice that tells users to file node-chakracore specific\nissues into the node-chakracore repo rather than nodejs/node. I would keep\nthis as a separate commit.\n\nAs usual, please keep the discussion constructive.\ncc: @nodejs/ctc https://github.com/orgs/nodejs/teams/ctc\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-02-04T14:32:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "thefourtheye",
                                "__typename": "User"
                            },
                            "bodyText": "it was resolved to let these changes live in a separate repository under the nodejs/ organization\n\nWill that repo also adhere to our Node.js CoC, Contribution, Moderation and other procedures we follow?",
                            "createdAt": "2016-02-04T14:44:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, it would fall under the same policies as the main repo. I imagine a\nchakra team would be created and eventually a WG would emerge.\nOn Feb 4, 2016 6:44 AM, \"thefourtheye\" notifications@github.com wrote:\n\nit was resolved to let these changes live in a separate repository under\nthe nodejs/ organization\nWill that repo also adhere to our Node.js CoC, Contribution, Moderation\nand other procedures we follow?\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-02-04T15:00:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "+1 for a WG to be formed around this, and keeping the policies in line with the main repo as much as possible. In the interest of relieving Node's collaborators from additional duties, we might want to make some slight modifications to the collaborator guide to replace \"collaborators\" with \"WG members\".",
                            "createdAt": "2016-02-04T15:17:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "Forming a WG\n\nFor organizational purposes this may make sense but there's one thing that troubles me about it. The goal of the WG will be to get this eventually merged into Core, if contentious issues come up in that repo it would be best to escalate those to the CTC, not just to the WG membership. This would avoid decisions that are controversial being made in that repo that will make it difficult to eventually merge the work into core.",
                            "createdAt": "2016-02-04T18:48:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Agreed. Couldn't that be put into the WG charter tho? :-)\nOn Thu, Feb 4, 2016 at 10:48 AM, Mikeal Rogers notifications@github.com\nwrote:\n\nForming a WG\nFor organizational purposes this may make sense but there's one thing that\ntroubles me about it. The goal of the WG will be to get this eventually\nmerged into Core, if contentious issues come up in that repo it would be\nbest to escalate those to the CTC, not just to the WG membership. This\nwould avoid decisions that are controversial being made in that repo that\nwill make it difficult to eventually merge the work into core.\n\u2014\nReply to this email directly or view it on GitHub\n#4765 (comment).",
                            "createdAt": "2016-02-04T18:50:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "Agreed. I was suggesting that we replace collaborators with WG members but still allow for CTC escalation for controversial issues. We should probably also promote some level diversity in the WG membership so that controversy can be had \ud83d\ude04",
                            "createdAt": "2016-02-04T18:55:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I'd also suggest that changes in the repo be limited to only those directly impacting the implementation of the chakra support. Anything that can be upstreamed into the main repo should be.",
                            "createdAt": "2016-02-04T18:59:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qix-",
                                "__typename": "User"
                            },
                            "bodyText": "The rationale behind this decision (or at least my interpretation of it) is that we want to encourage experimentation with this project, yet at this time we don't want to put any additional burden on the collaborators of the main Node.js project to maintain the chakracore version.\n\n\n\nI would also point out that it's possible that we could include the chakra builds in CI and regular nightlies.\n\nPerfect. This is what should be happening. Happy this is how it turned out \ud83d\udc4d",
                            "createdAt": "2016-02-05T04:58:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "FezVrasta",
                                "__typename": "User"
                            },
                            "bodyText": "Is it just me, or till ChakraCore is not ported to all the platforms supported by V8, all this stuff is completely useless?\nI can't see how you could release a ChakraCore version of Node that works only on Windows, it would mean an hell of fragmentation...",
                            "createdAt": "2016-02-05T14:16:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "Update: we are in the process of transferring https://github.com/microsoft/node to nodejs/node-chakracore. Once that's done, I'll create an issue in that repo inviting collaborators to a newly formed node-chakracore WG, which will act as the repo collaborators.\nIn the meantime, if reviewers of this PR are comfortable giving it a 'LGTM as a starting point for the new repo', we can make the changes of this PR the head of the chakracore-master branch. Otherwise, we can resume the review process in the new repo.",
                            "createdAt": "2016-02-09T16:52:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "thefourtheye",
                                "__typename": "User"
                            },
                            "bodyText": "LGTM as a starting point for the new repo\n\nI think I would be a little confident if we had a green CI run.",
                            "createdAt": "2016-02-09T17:05:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "@thefourtheye assuming you mean on the regular CI, which doesn't test the chakracore build. Green status on the chakracore build is still work in progress.\nhttps://ci.nodejs.org/job/node-test-pull-request/1606/ shows a merge conflict. @kunalspathak can you rebase the PR onto the current master?",
                            "createdAt": "2016-02-09T17:19:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "BTW, I don't think a straightforward \"repo transfer\" will work in GitHub because that repo is in the same fork network as one already in this repo. That means you'll have to essentially pull down the repo and all branches and push it to a brand new repo in this org. It's annoying, and you'll lose the issues, but I don't know of a way around it.",
                            "createdAt": "2016-02-09T17:47:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "@mikeal, thanks for the suggestion. We were actually able to work around it but removing the fork link first (had to contact GH support for it).",
                            "createdAt": "2016-02-09T17:48:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "@orangemocha awesome! good to know that is an option, this will probably come in useful again in the future :)",
                            "createdAt": "2016-02-09T17:50:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "On second thought, rebasing here is not necessary, as we can push to the new repo the master that this PR is up-to-date with, and deal with the conflict in the next master -> chakracore-master integration.\nHere's a CI run with no rebasing: https://ci.nodejs.org/job/node-test-commit/2175/. It shows 2 failures on ARM (linux). Investigating whether these could be legit or flaky. /cc @nodejs/testing",
                            "createdAt": "2016-02-09T18:02:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@orangemocha Those are both known flaky tests that are marked as flaky in current master. One of them has a fix ready to go in a PR that might land in another day or three. The other one is probably Flaky Test Public Enemy Number One once that PR lands.",
                            "createdAt": "2016-02-09T18:38:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for clarifying that @Trott ! I guess that means that the CI run looks good for this PR.",
                            "createdAt": "2016-02-09T18:40:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@orangemocha Yes. The TL;DR of my comment is: Those are known flaky tests. The CI run looks good.",
                            "createdAt": "2016-02-09T18:49:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "The CI run looks good.\n\nCan someone sign off on this PR then, so we can go ahead and move the repo?\n// cc: @thefourtheye, @silverwind, @jepler, @Fishrock123, @benjamingr , @TooTallNate, @jasnell",
                            "createdAt": "2016-02-09T20:31:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@orangemocha I think we're good to go and you should have the right access level to pull it off.\nI'd like to suggest a couple of things:\n\nKeep it in sync with nodejs/node as much as possible so it can be compared at any time by anyone who adds it as a remote to their local clone. Either keep this PR open with the changes (which I think you were suggesting) or keep an equivalent PR open there with the changes. The aim is to get it to a point where we can actually make a decision about merging it or not rather than pursuing it as a separate project indefinitely (at least that's the aim right now).\nPlace a notice at the top of the README on the default branch of the new repo that clearly states that it is a work in progress, not an officially endorsed branch of Node.js and maybe link back to this issue. We need to follow a process that doesn't presume that decisions have been made that have actually not, so far all that the CTC has offered is a way to make progress and I imagine we'd get a lot of upset people commenting if it looked like we'd already pulled the trigger on this.",
                            "createdAt": "2016-02-10T12:00:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for the suggestions, @rvagg.\n\nYep, I had a chat with @kunalspathak and the current plan is to have a master branch which is the same as nodejs/node:master and a chakracore-master branch that would be master + the chakracore changes, so the diff would be easily visible, and to keep syncing master from nodejs/node and integrating changes into chakracore-master, ~weekly. Let me know if you have any additional input.\nWill do.",
                            "createdAt": "2016-02-10T14:32:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "silverwind",
                                "__typename": "User"
                            },
                            "bodyText": "Sorry to bikeshed, but I'm still not totally happy with the name of process.jsEngine. I'd rather have it be process.engine for simplicity and it's more neutral towards the es vs js naming debacle.",
                            "createdAt": "2016-02-11T14:18:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@silverwind \ud83d\udc4d, but more so for API consistency than that particular reason. Most of the other Node APIs use that convention. It's version, not nodeVersion, for example. Trying not to derail the topic, though.",
                            "createdAt": "2016-02-11T16:20:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "I am on the opposite camp, I think that engine could be ambiguous. There could be different types of engines in this thing (e.g. libuv could be seen as the I/O engine).\nAnyway, since the new repo is already live, at this point I think it would be better to open an issue in the new repo and discuss it there. I will follow up.\nEDIT: opened issue nodejs/node-chakracore#19",
                            "createdAt": "2016-02-11T17:54:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "And here is node-chakracore: https://github.com/nodejs/node-chakracore ! Hoping to get lots of contributions \ud83d\ude04",
                            "createdAt": "2016-02-11T18:12:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kunalspathak",
                                "__typename": "User"
                            },
                            "bodyText": "As @orangemocha mentioned these changes are ported to new repo https://github.com/nodejs/node-chakracore chakracore-master branch. Weekly merge from nodejs.node master and chakrashim changes will happen in this branch of new repo. Feel free to contribute and providing feedback. Thanks everyone for the support!",
                            "createdAt": "2016-02-19T16:58:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@orangemocha Does this still need ctc-agenda?",
                            "createdAt": "2016-02-19T17:03:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "orangemocha",
                                "__typename": "User"
                            },
                            "bodyText": "Removed ctc-agenda. We'll ping the CTC periodically to provide updates and get feedback on the direction of the project. Thank you.",
                            "createdAt": "2016-02-19T17:59:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "itsjavi",
                                "__typename": "User"
                            },
                            "bodyText": "Abstracting Node from the underlying engine sounds good, but we should avoid incompatibilities, otherwise we may start to see packages only working for a specific engine that will not be reusable in the other, so here comes the potential fragmentation.\nPlease, let's not bring cross-platform headache to Node, make the differences minimal, defining a clear and common API, that's all I would ask.\nGreat job btw.",
                            "createdAt": "2016-03-23T19:32:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@mjolnic I agree, but I will note that Browserify/Webpack isn't helping that too much. I do feel that NAN might help alleviate much of that concern, though, but it'll have to go through a major version change to account for all the additional abstraction boilerplate it'll need.\nI'm also staring intently on WebAssembly, which will also be runnable on future versions of Node, with Chakra and V8 both supporting it, and that may have an even more significant impact on native addons (more than even supporting Chakra IMHO, because of the language difference).",
                            "createdAt": "2016-03-26T07:10:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jfbastien",
                                "__typename": "User"
                            },
                            "bodyText": "From Node's POV WebAssembly will look like an opaque blob of JS. You can call into it from JS, it can call out to JS, but the API surface is the same as an opaque JS blob.\nEventually WebAssembly may gain access to extra APIs, but the MVP won't have anything special. If / when WebAssembly gains new APIs I think they should be designed with Node in mind, not just browsers.",
                            "createdAt": "2016-03-26T18:17:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "omeid",
                                "__typename": "User"
                            },
                            "bodyText": "Just echoing @davidmurdoch,\nWhat are the benefits of adding this? this question is specially important when you consider the complexity that is introduced not only to the core of node.js but also the code that will be written against node, having to worry about the version of node.js is enough, don't need to compound that into a matrix of backends and versions.\n@kunalspathak Can you please give some context?",
                            "createdAt": "2017-10-21T01:04:16Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 6792,
            "title": "Add v8_inspector support",
            "author": {
                "login": "ofrobots"
            },
            "state": "CLOSED",
            "closedAt": "2016-05-30T16:12:40Z",
            "comments": {
                "totalCount": 163,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "mscdex",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome! Thanks everyone that helped put all this together and made it possible!",
                            "createdAt": "2016-05-16T20:46:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots I'm a bit late to the party so sorry if this has been covered in the other thread... Would this PR landing change anything in regards to the current debugger?",
                            "createdAt": "2016-05-16T20:49:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Great to see this come through. Looking forward to playing around with it.",
                            "createdAt": "2016-05-16T20:52:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd The old debugger is not affected, and still works as-is.  v8_inspector debugger gets enabled only when the --inspect option is provided.",
                            "createdAt": "2016-05-16T20:57:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cjihrig",
                                "__typename": "User"
                            },
                            "bodyText": "My initial reaction is that this is fantastic. Thank you.",
                            "createdAt": "2016-05-16T21:00:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sam-github",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots\n\nv8_inspector debugger gets enabled only when the --inspect option is provided.\n\nIt would be great if it could be enabled/disabled at runtime using a v8.debugOn/Off() js API call.",
                            "createdAt": "2016-05-16T21:11:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots Why import the entire inspector?",
                            "createdAt": "2016-05-16T21:52:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Why import the entire inspector?\n\nWas wondering that myself...",
                            "createdAt": "2016-05-16T22:05:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Why import the entire inspector?\n\nWhat do you mean by entire inspector?\n\nIt would be great if it could be enabled/disabled at runtime using a v8.debugOn/Off() js API call.\n\nDoes present debugger allow that? We were aiming at feature parity before we start adding features. Enabling dynamically means that we would bind port at runtime. Other than that, debugger can be enabled/disabled at any moment, no technical limitations there.",
                            "createdAt": "2016-05-16T22:26:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "Nice work!\nSo the intent is for this to get merged to v6 and then removed again at v7 when it's baked into V8? Why not just wait until v7 when it's built-in? Certainly it's valuable work and would benefit v6 greatly, but this is a rather large chunk of stuff to review only to remove it again in a few months.\nWhat does the plan look like for merging with V8? I assume the user-facing surface of it would stay the same when we reach v7? (Other than maybe not needing the build flag anymore?)",
                            "createdAt": "2016-05-16T22:32:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "What do you mean by entire inspector?\n\nThe second commit -> a7f339b",
                            "createdAt": "2016-05-16T22:36:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "This PR is not bringing in the DevTools inspector. It only brings in the v8_inspector part, which is an implementation of the DevTools debug protocol.\n\nIt would be great if it could be enabled/disabled at runtime using a v8.debugOn/Off() js API call.\n\nThis would be a good follow-on. Once this PR lands, it would be easier to work on the ergonomics & integration.\n\nbut this is a rather large chunk of stuff to review only to remove it again in a few months.\n\nThe review is needed on 0995140. This integrates the inspector protocol into Node-core. This code is is not going to be removed in a few months. Once this is reviewed and merged, it would be an independent question whether this should merge into v6.x. Part of the answer depends on whether this is a semver major change.\nThe other, larger, commit is a dependency that is needed until the dependency merges upstream into V8. Here's the upstream repository: https://chromium.googlesource.com/chromium/src/third_party/WebKit/Source/platform/v8_inspector/. This commit, like other dependency rolls, doesn't really need an in-depth review.\nEDIT: fix link.",
                            "createdAt": "2016-05-16T22:42:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks so much for all this work! Really looking forward to having a \"real\"/modern debugger protocol for node.\nI assume that since the --inspector flag already is disabled by default, it might be possible to enable --with-inspector by default during the lifetime of node 6? Getting a \"real\" debugger that is part of all the binary distributions of node as part of the next LTS would be great.\nThe above (\"what will become the next LTS\") is also, imo, a good reason for bringing it into node 6 and to not wait until all the inspector pieces landed in v8 itself.",
                            "createdAt": "2016-05-16T23:04:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Hmmm, when we were originally discussing this I was under the impression we'd only have the hooks for the v8 debugger but not actually ship the v8 debugger?\nIIRC the v8 (chrome?) debugger is very version agnostic so there wasn't any great need for it to ship in core, and shipping in core is pretty awkward as we see with npm. e.g. you're never quite on the version you want to be. Plus it's a ton of extra source code.\nThis is assuming the v8/chrome debugger doesn't need native compilation, if it does, that is probably going to be a whole other issue.\n\nAnother question: is this intending to replace the default node debugger?",
                            "createdAt": "2016-05-16T23:13:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Hmmm, when we were originally discussing this I was under the impression we'd only have the hooks for the v8 debugger but not actually ship the v8 debugger?\n\nThis PR does not include the Devtools debugger. It only includes the debugger protocol implementation. When you run with --inspect you see the following on the command line:\nchrome-devtools://devtools/remote/serve_file/@4604d24a75168768584760ba56d175507941852f/inspector.html?experiments=true&v8only=true&ws=localhost:5858/node\n\nChrome will load the version of inspector identified by the id, served from the DevTools web hosts. The only thing Node is doing, is implementing a debug server that 'talks' the protocol expected by the Devtools debugger.\n\nAnother question: is this intending to replace the default node debugger?\n\nNo.",
                            "createdAt": "2016-05-16T23:21:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Wow, I'm really surprised that it is this large given that it's just the hooks...",
                            "createdAt": "2016-05-16T23:27:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Ok, so it's the hooks + the protocol, that makes sense. Will have to spend some time digging into that second commit. The size is a bit concerning but not too bad.",
                            "createdAt": "2016-05-16T23:29:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "BTW, there are other debuggers that already talk the same protocol, for example: https://github.com/Microsoft/vscode-chrome-debug. It is conceivable that these debuggers could be extended to support Node.js debugging.",
                            "createdAt": "2016-05-16T23:29:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "Sorry, I was a bit vague. I meant to ask specifically about if the dependency would get removed in v7 (due to being integrated in V8).\nMerging 0995140 seems reasonable to me. It's just a7f339b that I'm a bit wary of, since it'd be a bunch of churn to add it and then remove it again. Am I understanding the plan right? The dep get added in v6, then hopefully merged into V8 and removed again for probably v7?",
                            "createdAt": "2016-05-16T23:30:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "FWIW, I'm leaning more toward just merging it for the sake of making debugging in v6 LTS much nicer. I'm just a bit unsure of the semver-minor-ness of this and the extra work to pull the dep in and maintain it, if we already know we're going to need to remove it again later and get it through the V8 dep.",
                            "createdAt": "2016-05-16T23:34:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots ... are the jinja and markupsafe dependencies really necessary? What are those being used for? (I could keep digging and find out but figured it would be easier to ask ;-) ..)",
                            "createdAt": "2016-05-16T23:36:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "If there is push back on a7f339b due to size, could it be brought in similar to the way we were handling icu before?",
                            "createdAt": "2016-05-16T23:41:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "are the jinja and markupsafe dependencies really necessary?\n\nthose are build-time dependencies, we are using jinja to generate native protocol dispatcher and protocol data structures off protocol.json.",
                            "createdAt": "2016-05-16T23:44:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd ... my concern is not so much about size but of complexity. I think I'm good with this, was just surprised a bit at about how much more code this brings in.",
                            "createdAt": "2016-05-16T23:47:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "evanlucas",
                                "__typename": "User"
                            },
                            "bodyText": "@repenaxa so I'm not sure how much of protocol.json is browser specific (and I am assuming it is just being pulled in from somewhere else), but how many items in protocol.json are not needed for node? (https://github.com/ofrobots/node/blob/v8-inspector/deps/v8_inspector/devtools/protocol.json#L557-L573)\nThis is awesome by the way!!! Thanks!",
                            "createdAt": "2016-05-17T00:26:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "how many items in protocol.json are not needed for node?\n\nv8_inspector only supports 4 of 30 domains (Runtime, Debugger, Profiler and HeapProfiler). It is likely to support 2 more later (Console and Tracing). Here is the Blink version of the protocol vs v8_inspector subset.\nAs we move v8_inspector into v8, we'll have to split the protocol definition and maintain the debugging subset along with v8.",
                            "createdAt": "2016-05-17T00:36:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "evanlucas",
                                "__typename": "User"
                            },
                            "bodyText": "@repenaxa thanks!",
                            "createdAt": "2016-05-17T00:40:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Quick reference on the file/folder structure of the change:\nv8_inspector\ndevtools/ - remote debugging protocol definition. protocol.json defines the protocol, Inspector-1.1.json contains baseline for backwards compatibility validation. Protocol can be extended with Node-specific domains for non-JS runtime inspection.\nplatform/inspector_protocol/ - generic remote debugging protocol harness. Generates native API interfaces, data structures and wired dispatcher implementation. Uses deps/jinja2 and deps/markupsafe to emit code at build time.\nplatform/v8_inspector/ - actual debugger implementation.\nAll these are single source with the chromium versions, on their way to V8 repo: protocol.json, inspector_protocol, v8_inspector.\nnode\ninspector_agent.* - similarly to debug-agent.*, wires debugger to Node\ninspector_socket.* - bare native WebSockets implementation sufficient to power remote debugging",
                            "createdAt": "2016-05-17T03:43:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "a7madgamal",
                                "__typename": "User"
                            },
                            "bodyText": "awesome! I'm already using node-inspector and can't live without it!\ncan I know what is the main difference?\nconsider this comment also as a 'tip' that might help the two projects work together or share knowledge :)",
                            "createdAt": "2016-05-17T13:41:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "I'm already using node-inspector and can't live without it! can I know what is the main difference?\n\nThese projects are somewhat related. Both have strong points and should converge later on.\nfeature set\nv8_inspector delivers more fresh features (es6 support, async stacks, integrated profiling, inline values, blackboxing, source maps, workspaces and many more). Its backend is going to be a part of V8 itself. Multiple front-ends including Chrome DevTools, Firefox Tools or Microsoft VS Code will attach to it and debug it (more on that later).\nnode-inspector has been in the Node space for a long time and captures important debugging ergonomics aspects that are native to Node environment. Things that we missed while developing tooling for the web browsers. We want them supported in the new toolchain as well.\nbackground\nChromium DevTools has client-server architecture where native backend is a part of Blink rendering engine and the front-end is implemented as a web app. There are non-chromium projects that reuse front-end to debug non-web targets (Stetho, node-inspector, etc). There are also non-DevTools clients that attach to the backend for debugging, performance and automation. We call this communication channel remote debugging protocol and it has been supported by Microsoft and Mozilla in their respective clients.\nfront-end\nBoth node-inspector and v8_inspector reuse Chrome DevTools front-end. node-inspector rolls the deps periodically (last roll was about a year ago), v8_inspector uses the tip of the tree (the version that matches the v8 release commit).\nbackend\nMore importantly, v8_inspector uses the tip of tree native Blink's (soon to be v8's) backend that exposes remote debugging protocol, while node_inspector uses a rudimentary v8-debug protocol that is no longer maintained. node-inspector has a bridge that converts v8-debug terms into remote debugging terms. While working on Web Inspector (origin of DevTools) some time in 2010, we realized the limitations of v8-debug and kicked off the remote debugging protocol. We've been exposing the new features there only since then.\nunder the hood\nv8_inspector brings in the standard infrastructure for exposing runtime capabilities and instrumentation. It enables scaleability via the extensible domain model that Node can use to debug aspects specific to Node or its modules. Here is how Chromium exposes its capabilities via its 30 domains.",
                            "createdAt": "2016-05-17T15:34:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "What all platforms/os's has this been tested for ?",
                            "createdAt": "2016-05-17T16:09:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "We have tested the integration on Linux and Mac. Other unices should work too, but they need independent verification. There isn't any architecture specific code that I am aware of, so this should also work on ARM, Power and zArch.\nWindows support should be easy to add (once I figure out how to get the Visual Studio environment on my windows box set up to allow me to build Node). Note however that this PR brings in v8_inspector support is behind a compile time flag, so Windows support can be added incrementally.",
                            "createdAt": "2016-05-17T16:42:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshgav",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots\n\nWindows support should be easy to add (once I figure out\n\nKeep us updated!\n/cc @orangemocha",
                            "createdAt": "2016-05-17T18:49:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for the review @bnoordhuis, we will get the issues addressed. We are also investigating the --stdlib=libc++ requirement on Mac.\nIn the meanwhile, I have updated the PR with a few fixes. Here's a CI: https://ci.nodejs.org/job/node-test-pull-request/2707/. Note that it is testing the default configuration after this PR (i.e. configure flag --with-inspector is not set.)",
                            "createdAt": "2016-05-20T00:08:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cjihrig",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots is the plan to keep the --inspector flag? If so, I think we'll need something like cjihrig@5890790 for cluster support.",
                            "createdAt": "2016-05-20T17:46:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@cjihrig Yes, the plan to have the --inspect flag in addition to the existing --debug[-brk] flags so that both the old debugger and inspector debug server are available to users. I've added your commit to this PR. Thanks!",
                            "createdAt": "2016-05-20T18:24:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I think there was an idea in #2546 about opening the inspector from chrome://inspect. Is it still planned?",
                            "createdAt": "2016-05-21T06:39:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@targos It looks like it already kind of works. If Chrome is started with --remote-debugging-targets=localhost:5858, the node process appears in chrome://inspect.",
                            "createdAt": "2016-05-21T19:16:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "lin7sh",
                                "__typename": "User"
                            },
                            "bodyText": "Can't wait, so good!",
                            "createdAt": "2016-05-22T04:04:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I'm pretty weary of the maintenance of this in the long term... :/",
                            "createdAt": "2016-05-23T16:35:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 This is comparable in the number of lines of code to the existing debug server in Node that uses the deprecated V8 debug API. The v8_inspector dependency doesn't need maintenance from Node-core; it is an upstream dependency that is en route to get merged into V8. Can you elaborate your exact concern?",
                            "createdAt": "2016-05-23T16:42:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Right, I'm not worried about the dependency itself, but the inspector.cc and inspector sockets seem like good amount of extra stuff to maintain. You compare it to the debugger, but consider that the debugger is barely maintained and has a good amount of issues related with it.\nAlso, if this is comparable to the debugger, I'm wondering why we would ship both? They are different in functionality, right?",
                            "createdAt": "2016-05-23T19:22:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I'd hope that this new debugger protocol can replace the existing debugger completely one day. E.g. it's likely that it would be possible to implement a better command line debugger against the new protocol, given that it has better support for inspecting remote objects etc.. Shipping both enables a graceful transition while a lot of tools still depend on the old protocol.",
                            "createdAt": "2016-05-23T19:50:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "the debugger is barely maintained and has a good amount of issues related with it.\n\nThe addition of the v8_inspector should actually help with this. It would be good to have a debugger written against a proper, documented Debug API as opposed to a long deprecated one.\nDestiny of the old debugger is a separate issue and as @jkrems mentions, it makes sense to keep the old debugger for now as it allows for a graceful transition. Let us not conflate these two discussions.",
                            "createdAt": "2016-05-23T20:56:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "yjhjstz",
                                "__typename": "User"
                            },
                            "bodyText": "node-8-inspector  ./node --inspect benchmark/http_simple.js\nDebugger listening on port 5858. To start debugging, open following URL in Chrome:\n    chrome-devtools://devtools/remote/serve_file/@521e5b7e2b7cc66b4006a8a54cb9c4e57494a5ef/inspector.html?experiments=true&v8only=true&ws=localhost:5858/node\nListening at http://127.0.0.1:8000/\nDebugger attached.\nAssertion failed: ((0) != (remaining)), function encode_frame_hybi17, file ../src/inspector_socket.cc, line 175.\n[1]    40138 abort      ./node --inspect benchmark/http_simple.js\nwhen I take snapshot , got assert error.",
                            "createdAt": "2016-05-24T06:44:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "auchenberg",
                                "__typename": "User"
                            },
                            "bodyText": "Concern: Is tiring the node core to the Chrome browser a good idea?\nI'm concerned about exposing a proprietary chrome-specific URL directly from Node Code, as it encourages developers to install and use Chrome DevTools as the default debugging tool for Node JS.\nToday there's already an ecosystem of tools that works with node, such as node-inspector, VSCode and others. By exposing a Chrome-only way to debug directly from Node Core, it's disencouraging for the existing community of node tools (node-inspector, VSCode, and others).\nAs a runtime Node shouldn't favor one debugging tool, but the --inspect flag should simply expose a debuggable endpoint that's discoverable by tools such as Chrome DevTools, Node-inspector, VSCode and others.\nI suggest adding a mechanism that would allow tools discover \"inspectable node processes\", just like Chrome and other tools are able to detect debuggable phones, browsers via chrome://inspect.\nA way could be to implement the HTTP-part of the Chrome Debugging Protocol, or look into MDNS discoverability.",
                            "createdAt": "2016-05-24T13:41:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "A way could be to implement the HTTP-part of the Chrome Debugging Protocol\n\n@auchenberg If you check the PR, you can see that that is exactly what it does.",
                            "createdAt": "2016-05-24T14:30:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@auchenberg\n\nToday there's already an ecosystem of tools that works with node, such as node-inspector, VSCode and others. By exposing a Chrome-only way to debug directly from Node Core, it's disencouraging for the existing community of node tools (node-inspector, VSCode, and others)\n\nTo be clear, this PR is not adding a Chrome-only way to debug. As discussed above, other debuggers can have have implemented support for this protocol to be able to work with the Chrome Remote Debug protocol: see https://github.com/Microsoft/vscode-chrome-debug. If anything this PR makes it easier to implement alternative debuggers for Node as adds a property documented debug protocol for V8.\nSee this comment from one of the maintainers of node-inspector for their take on it. Quote: \"this would be awesome\".\n\nI'm concerned about exposing a proprietary chrome-specific URL directly from Node Code, as it encourages developers to install and use Chrome DevTools as the default debugging tool for Node JS.\nAs a runtime Node shouldn't favor one debugging tool, but the --inspect flag should simply expose a debuggable endpoint that's discoverable by tools such as Chrome DevTools, Node-inspector, VSCode and others.\n\n--inspect does exactly that.\nI think your objection is that the URL printed on the console includes a chrome-devtools:// URL. I think it would be fine to make this more generic once the Visual Studio Code and other debugger teams have had the opportunity to add v8_inspector support, once this lands. For now, we opted to include the URL to make it easier for new users to get started.\n\nI suggest adding a mechanism that would allow tools discover \"inspectable node processes\", just like Chrome and other tools are able to detect debuggable phones, browsers via chrome://inspect.\n\nImproved auto discovery would be something that can be added as follow-on work. Pull requests are welcome ;).",
                            "createdAt": "2016-05-24T14:42:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Concern: Is tiring the node core to the Chrome browser a good idea?\n\nFor those who did not play with v8 inspector yet, here is the context of the question.\nWhen you start node --inspect, it dumps the following message:\nDebugger listening on port 5858. To start debugging, open following URL in Chrome:\n    chrome-devtools://devtools/remote/serve_file/@521e5b7e2b7cc66b4006a8a54cb9c4e57494a5ef/inspector.html?experiments=true&v8only=true&ws=localhost:5858/node\nQ: should we dump anything besides \"Debugger listening on port 5858\", anything that mentions Chrome. Kenneth represents Microsoft IE DevTools and I can see how it might look concerning to him.\nA: The string that is printed is for debugging ergonomics only, it is not a part of v8_inspector. It belongs to the embedder, node.cc and is defined by the Node community. It can be either changed or removed entirely.\n\nA way could be to implement the HTTP-part of the Chrome Debugging Protocol\n\nThis is implemented, so starting Chrome or Chromium with -- remote-debugging-targets=5858,9229,... makes node available at chrome://inspect as you are suggesting. It is also out-of-the box ready for VSCode consumption.",
                            "createdAt": "2016-05-24T14:56:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "auchenberg",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots\n\nIf anything this PR makes it easier to implement alternative debuggers for Node as adds a property documented debug protocol for V8.\n\nIndeed embracing the Chrome Debugging Protocol for Node it makes it easier for the existing tooling community to target Node. As the Microsoft PM of the vscode-chrome-debug and the initiator of RemoteDebug I'm in favor of adding Chrome compliant endpoints to Node Core, and I think this is great step forward for the Node tooling ecosystem.\n\nI think your objection is that the URL printed on the console includes a chrome-devtools:// URL\n\nMy objection is shipping Node Core with a Chrome specific URL. A URL that favors Chrome DevTools over other debugging tools, and requires Node developers to install Chrome on their computer.\nLaunching of specific debugging tools doesn't belong to the core, but something that for example could be implemented in a tool specific CLI like node-chrome-debug index.js -> node --inspect index.js + opens chrome-devtools://devtools/ in Chrome.\nI understand this message probably was added while v8-inspector as under development, as it super convenient, but I have the above concerns for keeping and shipping it in Node.",
                            "createdAt": "2016-05-24T15:08:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "front-end URL structure and semantics\nFor those interested in the structure of the URL node --inspect dumps.\nThe URL points to the revision of the open source Chromium DevTools front-end  (github mirror) that is compatible with Node under debug. We cache every revision (hash) of the front-end at the appspot server and here is the one matching the hash currently used:\nhttps://chrome-devtools-frontend.appspot.com/serve_file/@521e5b7e2b7cc66b4006a8a54cb9c4e57494a5ef/inspector.html?experiments=true&v8only=true\nGo ahead and try it out - it should open the front-end as a web app.\nThe prefix of the URL chrome-devtools://devtools/remote makes the above URL open in a Chromium container that has additional native bindings that allow establishing the non-secure WebSocket connection to localhost:5858, something the page served off HTTPS is not able to do per web standards. Chromium allows working around it with yet another command line flag though.\nSo this is a convenience link that makes debugging one click away for those running Chromium / Chrome / Blink. VSCode users don't need that, their IDE would establish connection out of the box as per comment above. But again, this is up to Node community to print or not print it.",
                            "createdAt": "2016-05-24T15:13:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "Just want to clarify, the HTTP API is only available over websockets. So it'd be impossible for me to open a dumb TCP socket and feed in strings. Correct? TBH I have a hard time reasoning how we should be allowed to ship its native debugger which uses a protocol that node doesn't natively support. Thus requiring a third-party module in order to simply interface with the debugger from another node process.",
                            "createdAt": "2016-05-24T17:09:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Just want to clarify, the HTTP API is only available over websockets. So it'd be impossible for me to open a dumb TCP socket and feed in strings. Correct?\n\nCorrect, but that's not fundamentally different from the current debugger protocol, that also requires a parser.\n\nTBH I have a hard time reasoning how we should be allowed to ship its native debugger which uses a protocol that node doesn't natively support.\n\nThe websockets subset that this PR implements is simple enough that I'm not bothered by that.  You can implement a basic client in < 50 lines of JS.",
                            "createdAt": "2016-05-24T17:28:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Just want to clarify, the HTTP API is only available over websockets. So it'd be impossible for me to open a dumb TCP socket and feed in strings. Correct?\n\nThat is correct. Since we want remote debugging to be truly remote, it needs to use HTTP to go through the proxies, etc.\n\nTBH I have a hard time reasoning how we should be allowed to ship its native debugger which uses a protocol that node doesn't natively support.\n\nI understand the concern. Sticking with the web-friendly transport allows us to quickly build the ecosystem around debugging. You get DevTools working out of the box, you get VSCode supporting the format already. WebSockets clients are available in all possible platforms and frameworks. Introducing a new TCP-based protocol with its handshake and message format effectively removes DevTools and other web-based solutions from the set of the available front-ends.\nHaving said that, v8_inspector is a transport-agnostic library and that is why sockets are introduced on the Node level. There is no reason to not expose multiple bidirectional wired / typed APIs.\n\nThus requiring a third-party module in order to simply interface with the debugger from another node process.\n\nWe could expose bindings hooks for the remote debugging protocol in Node and rely upon Node-friendly instance-to-instance transport to deliver the messages. It would be a simple messaging api with opaque message strings that goes over node-to-node messaging transport.\n[Added]\nIt would need to be native though since we should not execute JavaScript in the target Node instance while debugging / profiling.",
                            "createdAt": "2016-05-24T17:34:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@yjhjstz thanks for reporting that issue. We are working on a fix.\nThe original code review comments have been addressed, and this PR is ready for review (/cc @bnoordhuis). The PR has been rebased and libc++ dependency on Mac has been removed. We think this is getting pretty functional at this point.\nNote that the inspector functionality is behind a compile time flag that is disabled by default. This mitigates risk from merging this PR to master, if this is otherwise a reasonable direction for Node (I've added the ctc-agenda label to address that specific question). Merging this PR would make it easier to collaborate on the functionality and for users to test and report bugs.\nHere's a CI: https://ci.nodejs.org/job/node-test-pull-request/2772/. It looks green, modulo CI infrastructure issue on Windows.",
                            "createdAt": "2016-05-24T21:20:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@yjhjstz the issue you reported should be fixed now.",
                            "createdAt": "2016-05-24T23:44:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@auchenberg\n\nMy objection is shipping Node Core with a Chrome specific URL. A URL that favors Chrome DevTools over other debugging tools, and requires Node developers to install Chrome on their computer.\n\nFor the sake of argument, when I clone a repo on GitHub \"to my desktop\", my browser opens a URL with the github-mac:// scheme.  I don't have GitHub Desktop installed; my browser opens Atlassian's SourceTree instead.\nLikewise, the chrome-devtools:// scheme (and any other scheme!) can be configured to open any program.  It does not require Google Chrome to be installed.\nBecause of this, I assert the scheme doesn't really matter that much.\nGiven we're talking about the Chrome Debugging Protocol here, it's not wildly inappropriate that chrome is part of the scheme, but perhaps chrome-debugger:// would appear less application-specific.",
                            "createdAt": "2016-05-25T05:06:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Ali added a ctc-agenda label to the bug and I wanted to post a couple of fyi links: crbug.com/439376 and crbug.com/580337. Those are the bugs that DevTools team used to track v8_inspector-driven changes for the last 18 months.\nAs you can see, this has been quite a project for us and we remain committed to enriching all the v8 embedders with the best in class debugging tools. Although there is a lot of work ahead (landing into v8 repo, establishing per-domain protocol versioning, wiring asynchronous stacks in Node, surfacing network requests in the network panel, etc.), this PR marks an important milestone for us!",
                            "createdAt": "2016-05-25T06:16:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "Immediate questions that seem to arise from the discussion so far that we need to answer together:\n\nAre we comfortable with the v8_inspector dependency addition, given it's size (the patch for that commit alone is 2.4M) and the fact that it's slated to be removed in a few V8 versions?\nAre we comfortable with embracing a websockets-based protocol for debugging?\nIs --with-inspector the right approach for including this? What are we buying by using a compile-time flag, does it increase our comfort with including this in v6, how will users react to knowing this goodness is available but they can't get it from standard builds?\nIs this semver-minor or semver-major, does that even change if it were enabled by default?\nIs the chrome part of the URL a concern?\nHow do we move forward with this? What are the next steps toward landing? Are we OK just reviewing the second commit and not the first? (btw @ofrobots it's hard to do that with the additional squashable commits adding on top, we can't exclude the deps commit which is too big for GH).\n\nMore big-picture questions that we should be at least considering:\n\nDoes this in any way increase our dependence on Chromium, is this driving in a generic enough direction for us to be comfortable embracing (the assumption here is that we want to be less dependent, that's also up for discussion of course)? This question is probably best put to third-parties that may consume this, so far from this thread it seems OK.\nWhat do we do with the current debugger? We don't have an owner for it, it's cared for just enough to survive and will likely be even less loved after (if) this lands. I really wish we'd been able to spin up a @nodejs/debugging working group by now but we've not had any takers.",
                            "createdAt": "2016-05-25T12:36:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "How do we move forward with this? What are the next steps toward landing? Are we OK just reviewing the second commit and not the first? (btw @ofrobots it's hard to do that with the additional squashable commits adding on top, we can't exclude the deps commit which is too big for GH).\n\nApologies. I have squashed the commits so they should be easier to review now. Incremental work would be easier once we are able to land this.",
                            "createdAt": "2016-05-25T14:06:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg ...\n\nAre we comfortable with the v8_inspector dependency addition, given it's size (the patch for that commit alone is 2.4M) and the fact that it's slated to be removed in a few V8 versions?\n\nSo long as it is maintainable then I'm ok with this. What I would like to see from the Google team is some extensive documentation on how the v8_inspector is structured, how it works, and how it will be maintained, and I would like to see some effort put into bootstrapping some other developers in the community that can pick it up should Google decide to move in some other direction in the future. While it's a bonus that this is \"single source\" currently with the stuff in chrome, it would be best if it weren't \"single source\" in terms of contributors.\n\nAre we comfortable with embracing a websockets-based protocol for debugging?\n\nMy key concern here would be whether the websockets-based protocol introduces any new security risks. If the debug protocol is not locked down then we need to make sure we're stamping \"Do Not Enable This In A Production Environment\" in big bold letters in the documentation.\n\nIs --with-inspector the right approach for including this? What are we buying by using a compile-time flag, does it increase our comfort with including this in v6, how will users react to knowing this goodness is available but they can't get it from standard builds?\n\nI think putting this behind a compile time flag is the best approach for now. In fact, I think we should take a page from the standards playbook and require that this be kept behind a flag until it can be demonstrated that there are at least two or three independent implementations capable of using it (including chrome's inspector).\n\nIs this semver-minor or semver-major, does that even change if it were enabled by default?\n\nFor now I would treat this similarly to how we have handled async_wrap... that is, it's an unsupported feature that is considered to be experimental up until we decide that it's not. As long as there are no detrimental impacts to existing supported features, then landing changes here should be ok as semver-patch or semver-minor.\n\nIs the chrome part of the URL a concern?\n\nCurrently, it's ok. Long term, yes, this is a concern. The inspector protocol should be more implementation agnostic, including the URL.\n\nDoes this in any way increase our dependence on Chromium, is this driving in a generic enough direction for us to be comfortable embracing (the assumption here is that we want to be less dependent, that's also up for discussion of course)? This question is probably best put to third-parties that may consume this, so far from this thread it seems OK.\n\nSame answer as above: while landing this behind a compile time flag now is fine, in my opinion, it should not become a fully supported option or compiled in by default until there are at least two or three independent implementations available that can make use of it; and it must be something that can be supported and maintained by more than just the Google/chrome team.\n\nWhat do we do with the current debugger? We don't have an owner for it, it's cared for just enough to survive and will likely be even less loved after (if) this lands. I really wish we'd been able to spin up a @nodejs/debugging working group by now but we've not had any takers.\n\nEventually, I would argue that if we cannot get anyone to pick it up to maintain it, we should eventually deprecate it.",
                            "createdAt": "2016-05-25T15:19:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "My key concern here would be whether the websockets-based protocol introduces any new security risks.\n\nRunning node --inspect binds server socket on 0.0.0.0. Anything that attaches to that socket has complete access to node JS runtime (all the data available to the VM). Remote debugging security model relies upon the socket access control rather than anything specific to remote debugging protocol.\nJS runtime does not have access to the instrumentation, inspection is not JS-detectable anyhow other than by means of timing attacks while profiling / debugging. It is safe to run untrusted code with --inspect no matter whether client has attached to the port or not. Not sure how important it is for Node, but it is a big deal for the web.",
                            "createdAt": "2016-05-25T15:42:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "YurySolovyov",
                                "__typename": "User"
                            },
                            "bodyText": "I wonder if URL could be changed to node-inspect://... real quick. This might resolve most of the \"vendor-bounding\" perception",
                            "createdAt": "2016-05-25T15:48:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Running node --inspect binds server socket on 0.0.0.0.\n\nNote that the existing debugger (node --debug) works the same way.",
                            "createdAt": "2016-05-25T15:58:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "I wonder if URL could be changed to node-inspect://... real quick.\n\nAs was mentioned above, link is not the only way to engage with the debugging. Restarting the browser with the command line flag opens more ways:\nchrome --remote-debugging-targets=localhost:5858,9229\nThis makes Node targets appear under chrome://inspect.\nThis boils down to the debugging UX and ergonomics only. As of today, pasting a link significantly lowers the engagement friction. This is something we've learned in the early Chrome days - we decided that DevTools should be a part of the product and \"Inspect Element\" should be there in every web page's context menu by default, just for the sake of developers. Fast forward to today, most of the browsers followed the pattern. Necessity to restart the browser adds friction.\nbackground of what chrome-devtools:// is all about\nchrome:// and chrome-devtools:// are the schemes that Chromium uses to serve content from local resource bundles. Here is where they are defined. These schemes also have security-sensitive bindings that runtime injects into the runtime environment. In our case, chrome-devtools://devtools/remote is a simple proxy that points to the https://chrome-devtools-frontend.appspot.com, but as I mentioned above, we need some of these bindings in order to establish non-secure websocket connection.\nIt is unlikely that we can rename the scheme in Chromium since some of the security measures are bound to the chrome- scheme names.",
                            "createdAt": "2016-05-25T16:13:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "clarkbw",
                                "__typename": "User"
                            },
                            "bodyText": "Currently, it's ok. Long term, yes, this is a concern. The inspector protocol should be more implementation agnostic, including the URL.\n\nWanted to add my support to this, as the product manager for DevTools in Firefox.  I agree that this is fine in the short term, it works and finding a solution should not block this PR work.  I'd also like to be involved in the longer term solution.\nThe Firefox DevTools team is actively experimenting on a new standalone debugger project called debugger.html that can target Node, Firefox, and other web platforms so a more agnostic long term approach would be useful for us as I know it would be for @auchenberg",
                            "createdAt": "2016-05-25T16:34:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@pavelfeldman ... thank you for the clarification. I would ask that any docs that are generated for this within core include at least a short discussion of the security impact (even if there is none) just so that users are aware.",
                            "createdAt": "2016-05-25T16:53:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Currently, it's ok. Long term, yes, this is a concern. The inspector protocol should be more implementation agnostic, including the URL.\n\nNot sure I agree, I think we we can get stuck there quite easily.",
                            "createdAt": "2016-05-25T17:03:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 ... sorry, that's not entirely clear. Stuck where quite easily? Stuck using the chrome-specific URL?",
                            "createdAt": "2016-05-25T17:20:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "The inspector protocol should be more implementation agnostic, including the URL.\n\nI'm not sure I agree. There are already multiple implementations that work against this protocol (the Chrome Devtools just being one of them). Coming up with a new one would mean choosing a protocol nobody supports. The Chrome Debugger Protocol is a simple JSON RPC protocol, well documented (compared to the current protocol), and pretty easy to use. There are command line clients, editor integrations, proxies that can help inspect the traffic, ... There are downsides (like Google having 100% control over changes) but that's true for the current protocol as well.\nAs somebody who tried to make advanced Devtools-like features work nicely via the old protocol, I would hate for this opportunity to be dropped just because the new protocol isn't perfect. Unfortunately there is no universally accepted debugging protocol for JS platforms.\nP.S.: Just for clarity on \"what this replaces\" - you can spend days trying to understand how the undocumented inlineRefs parameter affects response object serialization in node's current debugger protocol.",
                            "createdAt": "2016-05-25T18:07:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshgav",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg\n\nI really wish we'd been able to spin up a @nodejs/debugging working group by now but we've not had any takers.\n\nI've been working on this here: nodejs/diagnostics#46 and have asked @ofrobots  to speak about the Chrome Debugging Protocol in next week's meeting: nodejs/diagnostics#49",
                            "createdAt": "2016-05-25T18:55:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "The points about vendor lock-in seem like non-issues to me.  We're currently using an undocumented and deprecated protocol, with virtually no clients except the builtin one.  This PR is strictly an improvement over the current state of affairs.",
                            "createdAt": "2016-05-25T19:19:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "Not sure I agree, I think we we can get stuck there quite easily.\n\nAgree.  Getting this PR merged > fussing over URLs",
                            "createdAt": "2016-05-25T19:21:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@SomeKittens The first URL is the safe option - it points to one specific revision of the devtools frontend that is definitely compatible and tested against the implementation of the agents included in node. The second URL uses whatever version of the frontend is shipped in your version of Chrome. It will work fine most of the time and is likely to contain more recent improvements but if you're running a version of node from 1 or 2 years ago, it's starting to become a bit tricky. It might very well still work, but linking to a static revision makes sure it's known to work.",
                            "createdAt": "2016-05-25T22:34:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "As requested in the CTC meeting:\n\n\u2728 Now working on Windows! \u2728\nThe --with-inspector configure flag has been dropped. v8-inspector support is built by default. You still need the --inspect flag at runtime. We have added a --without-inspector compile time flag that allows Node to be built without v8-inspector support.\n\nLet's get this reviewed and landed!\nI have squashed the commits to make it easy to review.",
                            "createdAt": "2016-05-25T23:57:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "auchenberg",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull\n\nFor the sake of argument, when I clone a repo on GitHub \"to my desktop\", my browser opens a URL with the github-mac:// scheme. I don't have GitHub Desktop installed; my browser opens Atlassian's SourceTree instead.\n\nIf the chrome-devtools:// were a well-defined scheme like github-mac://that defines the schema as github-mac://<action>/<repo url>, it wouldn't object against outputting it by default in the console. But the current schema is specific to the Chrome DevTools, as the URL contains a commit hash, and query strings that are chrome-specific, and a simple implementation detail of Chrome DevTools.\nAs @pavelfeldman has pointed out, this particular console message is a minor implementation detail and doesn't affect the core of v8inspector if changed. Chrome already have the ability to discover Node targets inside chrome://inspect, just like VS Code and JetBrains products can if the socket details (url+port) are passed to the relevant tool.\nLet me repeat my point: We see Node is a cross-plat runtime that shouldn't favor any specific vendor tooling over other vendors, but instead expose a generic debugging endpoint that's discoverable by external tools.\nIf the argument is the convenience, this could just be achieved by Google or any other vendor providing a CLI that starts node --inspect and launches the specific tool connecting to the specific node process.\nI can easy imagine the community or Google making a noded CLI package that provides the current convient experience for Chrome DevTools users, but I don't see it as something that belongs to the Node core.",
                            "createdAt": "2016-05-26T12:58:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Friendly ping that this PR is ready for review. Making incremental improvements is getting cumbersome/blocked while this PR is pending.",
                            "createdAt": "2016-05-27T15:12:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sidorares",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots is it easy to add console domain and console api ( \"inspect\" for example ) ?",
                            "createdAt": "2016-05-27T15:19:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "drcmda",
                                "__typename": "User"
                            },
                            "bodyText": "@auchenberg Node just happens to be in part driven by technology that originated from Chrome and V8. None of this makes Node less cross platform capable or favors a specific vendor, it just uses the respective and reasonable names. Not to mention that there are already scores of tools out there that use these URLs and name schemes as a living standard for their purposes. This PR shouldn't be blocked over this as it is such an important step for Node in general.",
                            "createdAt": "2016-05-27T15:32:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Folks, I would like to keep this issue focussed on landing the PR at the moment. The topic of the URL is not a blocker for this PR and can be discussed as a follow-on after this merges.",
                            "createdAt": "2016-05-27T15:59:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "is it easy to add console domain and console api ( \"inspect\" for example ) ?\n\nWe don't need console domain to support command line api. It should be easy to pull inspect into v8_inspector as a follow-up roll.\nWe use console domain for console object API: console.log, console.dir, console.assert, etc. But we are now thinking that it might make more sense to move those into runtime and leave console domain for general error reporting. It will not be too hard to upstream it into v8_inspector as well.",
                            "createdAt": "2016-05-27T16:03:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshgav",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots, could you discuss the V8 team's thoughts on stability of and future changes to the Chrome Debugging Protocol (CDP)? If and when it changes and Node's agents change with it, downstream tools such as VS Code and WebStorm will need to adjust as well. Chrome DevTools (CDT) is developed alongside the protocol and updated versions of CDT are served from the cloud; how do you anticipate other tools will adjust?\nAs a corollary, if other runtimes (Chakra, SpiderMonkey) or tools want to add new diagnostics functionality, will there be a way for them to extend CDP without breaking V8, CDT, or other tools?\nThanks!",
                            "createdAt": "2016-05-27T16:09:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots ... I haven't gone through the PR in detail just yet so I can only give a rubber-stamp LGTM on this with the caveat that it needs to be clear that this is not yet an officially supported feature (similar to how we handle async_wrap related stuff currently). I'm looking forward to being able to use this tho :-)",
                            "createdAt": "2016-05-27T16:18:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "btw, this breaks the build for me because file names are getting too long:\nmake[1]: stat: _home_xxxx_src_node_deps_v8_inspector_platform_inspector_protocol_protocol_gyp_protocol_sources_target_generateInspectorProtocolBackendSources.intermediate: File name too long\ntouch: cannot touch '_home_xxxx_src_node_deps_v8_inspector_platform_inspector_protocol_protocol_gyp_protocol_sources_target_generateInspectorProtocolBackendSources.intermediate': File name too long\ndeps/v8_inspector/platform/inspector_protocol/protocol_sources.target.mk:16: recipe for target '_home_xxxx_src_node_deps_v8_inspector_platform_inspector_protocol_protocol_gyp_protocol_sources_target_generateInspectorProtocolBackendSources.intermediate' failed\n\nIs that expected?",
                            "createdAt": "2016-05-27T16:33:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eugeneo",
                                "__typename": "User"
                            },
                            "bodyText": "On my system (Ubuntu), I have Node checked out to /usr/local/cccccc/home/xxxxxxxxxxx/Development/node and it builds fine...",
                            "createdAt": "2016-05-27T16:42:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@eugeneo eh, dug a bit and it seems it\u2019s failing because I\u2019m using ecryptfs, which apparently has a lower file name length limit\u2026 so don\u2019t let that stop this from being landed. :)",
                            "createdAt": "2016-05-27T16:49:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nojvek",
                                "__typename": "User"
                            },
                            "bodyText": "Shouldn't the  --inspect flag also appear in the help list when running 'node -h'. Thoughts?\nRelease\\node.exe -h\nUsage: node [options] [ -e script | script.js ] [arguments]\n       node debug script.js [arguments]\n\nOptions:\n  -v, --version         print Node.js version\n  -e, --eval script     evaluate script\n  -p, --print           evaluate script and print result\n  -c, --check           syntax check script without executing\n  -i, --interactive     always enter the REPL even if stdin\n                        does not appear to be a terminal\n  -r, --require         module to preload (option can be repeated)\n  ...",
                            "createdAt": "2016-05-27T21:27:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Shouldn't the --inspect flag also appear in the help list when running 'node -h'. Thoughts?\n\nYes. It would need to be in the node -h output, in doc/node.1, and in doc/api/cli.md.",
                            "createdAt": "2016-05-27T22:34:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Shouldn't the --inspect flag also appear in the help list when running 'node -h'. Thoughts?\n\n--debug doesn't show up in the 'node -h' output either. We should probably fix this as a follow-on.",
                            "createdAt": "2016-05-27T22:37:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "--debug doesn't exist in the sources I mentioned because I don't actually know how it works haha.",
                            "createdAt": "2016-05-27T22:41:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "Rubber-stamp LGTM from me too, anything else can Happen Later\u2122.",
                            "createdAt": "2016-05-27T23:09:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell / @addaleax Did you give it a try yet? I've been meaning to actually give it a try and understand some of what's going on, but haven't had the time yet..",
                            "createdAt": "2016-05-28T02:28:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 Just a very quick one to check that it can work, nothing too in-depth.",
                            "createdAt": "2016-05-28T02:49:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nojvek",
                                "__typename": "User"
                            },
                            "bodyText": "I just got it compiled on Windows. Running some sanity checks of the tools.\nOfficial node people should check it too.\nI'll file an issue for the help doco and submit my PR to node over the\nweekend. This is exciting stuff.\nOn Friday, May 27, 2016, Anna Henningsen notifications@github.com wrote:\n\n@Fishrock123 https://github.com/Fishrock123 Just a very quick one to\ncheck that it can work, nothing too in-depth.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\n#6792 (comment), or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AA-JVNsOGsD6qDx-swWiFZM2iX8BAGZzks5qF61qgaJpZM4IfrJC\n.",
                            "createdAt": "2016-05-28T02:53:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nojvek",
                                "__typename": "User"
                            },
                            "bodyText": "Tested source tree, breakpoints, console, intellisense, memory heap snapshots, cpu flame graphs. Chrome also happens to also show the my locally installed AngularJS extension tab so it seems node library specific extensions may work (not tested)\nSourcemaps didn't work unfortunately. It detects the source map but doesn't show the mapped file in the sources tab. I'm sure this can happen later \u2122.\nVSCode chrome debug plugin didn't quite work so that will need some fixing as well.\nWill this get merged over the weekend?",
                            "createdAt": "2016-05-28T03:38:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Sourcemaps didn't work unfortunately.\n\nLooked at it and found two issues:\n\nWe don't know how to fetch the map. Typically it would be resolved to the URL and fetched, but here we need to ask Node to fetch if for us. This is fixable and there is workaround: using workspaces.\n(function (exports, require, module, __filename, __dirname) { \"use strict\"; prefix in the scripts. We need to go through another position transform in order to account for it.\n\nWe'll get there.\n\nWill this get merged over the weekend?\n\nDeferring this to @ofrobots.",
                            "createdAt": "2016-05-28T05:05:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "CI (https://ci.nodejs.org/job/node-test-commit/3547/) is looking green but I want to make sure that the test failure on FreeBSD is indeed a flake. I will land later today if a second CI looks green (https://ci.nodejs.org/job/node-test-commit/3551/)",
                            "createdAt": "2016-05-28T15:30:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Left some comments, most are style issues.  LGTM if those are addressed.",
                            "createdAt": "2016-05-28T16:37:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cjihrig",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots there were some CI issues. Fingers crossed, they may be fixed now. Want to run this again?",
                            "createdAt": "2016-05-28T20:37:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "@cjihrig What's the behavior in cluster mode in terms of port assignment?",
                            "createdAt": "2016-05-29T15:24:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cjihrig",
                                "__typename": "User"
                            },
                            "bodyText": "What's the behavior in cluster mode in terms of port assignment?\n\nThe same as the existing behavior. The debug port of the cluster master is incremented for each worker. I found a possible edge case in the logic though (see #7050).",
                            "createdAt": "2016-05-29T18:08:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-commit/3574/ \u2013 the ARM buildbot ran out of memory during compilation. Relaunched an ARM build: https://ci.nodejs.org/job/node-test-commit-arm/3531/ after ARM config fixes from @rvagg.\nWill land later today.\nEDIT: arm-fanned CI job: https://ci.nodejs.org/job/node-test-binary-arm/2351/. All green.",
                            "createdAt": "2016-05-30T14:34:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks all. Landed as b83b363...894203d.",
                            "createdAt": "2016-05-30T16:12:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "what the hell?",
                            "createdAt": "2016-05-30T16:14:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Also my comments about the CLI options were not even addressed, the CTC agenda label remains, I think this has landed prematurely.",
                            "createdAt": "2016-05-30T16:17:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I'm going to skip this in this week's v6 release.\n(For the downvoters: You can always build it yourself it you really need it ASAP.)",
                            "createdAt": "2016-05-30T16:23:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "This was discussed at the ctc meeting last week. The decision at the ctc meeting was to proceed with code reviews. I forgot to remove the label after the meeting.\nWe have LGTMs on this issue hence the landing.",
                            "createdAt": "2016-05-30T16:28:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dignifiedquire",
                                "__typename": "User"
                            },
                            "bodyText": "I'm going to skip this in this week's v6 release.\n\nCould you explain as to why it is not landing in this weeks release, please?",
                            "createdAt": "2016-05-30T16:37:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots was there any decision regarding documentation? I just noticed that this landed without any references to --inspect or how to use the new debugger in the docs.\nI'm up for sending a quick PR if the lack of documentation was not intentional and isn't a duplicated effort",
                            "createdAt": "2016-05-30T16:39:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "See my above comments of it landing prematurely, not having correct documentation, etc.\nAlso we are trying to fix a number of pretty critical bugs right now and I'd prefer to not introduce anything that could slow that further.",
                            "createdAt": "2016-05-30T16:39:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nojvek",
                                "__typename": "User"
                            },
                            "bodyText": "I just filed an issue regarding the inspect and debug documentation in cli.\nI was thinking of sending it as my first node PR in the evening.\nIs that the documentation you are talking about?\nOn Monday, May 30, 2016, Jeremiah Senkpiel notifications@github.com wrote:\n\nSee my above comments of it landing prematurely, not having correct\ndocumentation, etc.\nAlso we are trying to fix a number of pretty critical bugs right now and\nI'd prefer to not introduce anything that could slow that further.\n\u2014\nYou are receiving this because you commented.\nReply to this email directly, view it on GitHub\n#6792 (comment), or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AA-JVIhs1nSggC-ta_hlJZlSvNGIqwzNks5qGxL_gaJpZM4IfrJC\n.",
                            "createdAt": "2016-05-30T16:43:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 by CLI options I am assuming that you're asking about the documentation in -h. Given that --debug is not documented either it is incongruous to add --inspect documentation as a prerequisite. See also the comment from @jasnell that this is analogous to AsyncWrap in that both should be considered experimental. Blocking this PR on minor CLI documentation requirements does not seem reasonable. AsyncWrap was landed without any documentation.\nComing up with this PR has been a lot of work for a lot of folks, and continuing to maintain it without landing is not fun.",
                            "createdAt": "2016-05-30T16:45:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "Documentation suggests some level of stability. I feel like it might be best to leave this undocumented until the inspector is included in V8. Until then, the feature exists but is considered unstable and therefore no promises made on support.",
                            "createdAt": "2016-05-30T16:57:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@Qard that seems reasonable to me. Perhaps this can be solved with some blogging",
                            "createdAt": "2016-05-30T17:03:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "This landing now seems perfectly appropriate given the ctc discussion, the LGTM's and the experimental stance. There's nothing here that should reasonably interfere with the other bugs that are being looked at and there has been other stuff (e.g. async wrap) that has been landed without complete documentation before. Holding off on including this in a release is perfectly reasonable but I do not see any problem with this landing now.",
                            "createdAt": "2016-05-30T17:30:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "cjihrig",
                                "__typename": "User"
                            },
                            "bodyText": "Holding off on including this in a release is perfectly reasonable but I do not see any problem with this landing now.\n\nIs there any precedent on keeping legitimate commits, which have already landed, out of releases because of one person's opinions? If the commits aren't going to be reverted, then they should go into the release.",
                            "createdAt": "2016-05-30T17:33:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "If I recall correctly it's happened a few times. Personally, I'm fine with\nit either way. It is an experimental feature that's not officially\nsupported or fully documented yet so there's little harm in it not going\ninto the next immediate release. However, There's also likely no harm in it\nbeing in the release but if there's someone (particularly a fellow ctc\nmember) who is unsure then it's worth not rushing.\nOn May 30, 2016 10:33 AM, \"Colin Ihrig\" notifications@github.com wrote:\n\nHolding off on including this in a release is perfectly reasonable but I\ndo not see any problem with this landing now.\nIs there any precedent on keeping legitimate commits, which have already\nlanded, out of releases because of one person's opinions. If the commits\naren't going to be reverted, then they should go into the release.\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n#6792 (comment), or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AAa2eWliYpII-Kwun4dWuLe2w0NkzhPIks5qGx9zgaJpZM4IfrJC\n.",
                            "createdAt": "2016-05-30T17:40:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Is there any precedent on keeping legitimate commits, which have already landed, out of releases because of one person's opinions?\n\nThere is a precedent set on doing a patch if the releaser feels that is the better option, but I think there have also been instances of specific commits here and there.\nI don't really see what the difference is between an objection before it has landed, or after but before it has been in a release.\n(Do not get me wrong, I don't actually object to this in that sort of way.)",
                            "createdAt": "2016-05-30T20:56:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "evanlucas",
                                "__typename": "User"
                            },
                            "bodyText": "Pulling in commits has more or less been at the releaser's discretion. He had already been planning to make this a semver-patch release since earlier last week though IIRC. I don't see any reason we this can't follow the normal process and just get pulled into the next semver-minor (which will probably follow this week's patch release)",
                            "createdAt": "2016-05-30T22:20:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "Agreed re release decisions, it's up to the releaser to establish their level of comfort with what they are releasing. If something were held back from a couple of consecutive releases even though there's no technical or agreed (by collabs) reason to do so then I think we should be concerned. In this case I agree with @Fishrock123, there's some critical stuff we're trying to sort out and it'd be good to try and get stability around those first.",
                            "createdAt": "2016-05-30T22:48:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@joshgav can we get a perspective from Microsoft and/or @nodejs/tracing regarding this functionality and whether this is a good starting point for a vendor neutral debugging API? Some of us would like some assurance that this isn't tying us even more closely to Chromium.\nI know @sidorares has already been messing around with it and seems to have been able to use it for his own tools: https://twitter.com/sidorares/status/736213204410335234",
                            "createdAt": "2016-05-30T23:17:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mscdex",
                                "__typename": "User"
                            },
                            "bodyText": "Is this supposed to work with just --inspect? I'm finding that I have to specify a port explicitly (e.g. --inspect=5959) for it to bind properly (otherwise the process dies with, 'Unable to open devtools socket: address already in use').\n.... and now that I try it again with an explicit port, that doesn't seem to work anymore either.... I get the same error message, no matter what the port number is.",
                            "createdAt": "2016-05-30T23:25:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sidorares",
                                "__typename": "User"
                            },
                            "bodyText": "@mscdex worked fine for me without port (defaulted to 5858 as expected). Maybe you have script with old debugger agent already running somewhere?",
                            "createdAt": "2016-05-30T23:49:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mscdex",
                                "__typename": "User"
                            },
                            "bodyText": "@sidorares Everytime I check with netstat -nlp,  there are no processes listening on whatever port I choose.\nEDIT: Ah ok I see now, I have to also add --debug-brk for it to work. The error message is very misleading in that case. If I don't set --debug-brk and I have no debugger; statement, it should just run through without an error right?",
                            "createdAt": "2016-05-31T00:48:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "FYI you can grab a nightly build of master (v7.0.0-nightly...) to try this out, testing would be greatly appreciated before we bring this in to v6: https://nodejs.org/download/nightly/ \u2014 right now v7.0.0-nightly20160530894203dae3 is the latest but there might be a new one by the time you're reading this, grab the latest, script the install if you like: https://gist.github.com/rvagg/742f811be491a49ba0b9",
                            "createdAt": "2016-05-31T03:01:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "I've opened #7072 to continue discussion and tied it to the 7.0.0 milestone so we have a decision point regarding continuing to ship this in v6 LTS. If there are outstanding concerns || discussion points I've not mentioned, please add them in there.",
                            "createdAt": "2016-05-31T03:53:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshgav",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg\n\n@joshgav can we get a perspective from Microsoft and/or @nodejs/tracing regarding this functionality and whether this is a good starting point for a vendor neutral debugging API?\n\n@auchenberg has started updating vscode-chrome-debug-core to support Node+CDP and gain insight, see microsoft/vscode-chrome-debug-core#17.\nBefore complete integration and official support, I think we all should understand CDP's stability, compatibility, extensibility, and governance model. That is:\n\nStability - frequency and effect of significant changes;\nCompatibility - support for various permutations of tools and runtime versions;\nExtensibility - how to add functionality new to specific tools and runtimes;\nGovernance model - how changes to the protocol are proposed and integrated.\n\nWe'll begin discussion in tomorrow's Tracing/Diag WG Meeting.\nWill post something similar to #7072. Thanks!",
                            "createdAt": "2016-05-31T16:50:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Chris911",
                                "__typename": "User"
                            },
                            "bodyText": "Reading the latest comments I'm guessing this won't make it to v4? I'm not really familiar with the release life cycle in terms of backporting functionality like this but this is tremendous for debugging and it should be available to as many people as possible. Perhaps when it's no longer an experimental feature?",
                            "createdAt": "2016-06-02T02:42:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "slikts",
                                "__typename": "User"
                            },
                            "bodyText": "Sorry, just to clarify, has this landed in v6? The label says \"dont-land-on-v6.x\".",
                            "createdAt": "2016-06-08T20:48:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@slikts that is correct. It will likely land in a future release of v6.x, but we are currently still working out some of the kinks",
                            "createdAt": "2016-06-08T20:52:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "develar",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks to all involved. It is great. No more old slow inconvenient V8 debugger protocol (so, we can get rid of our own v8 debugger protocol extension). After some fixes on the JetBrains IDE side and nodejs (#7248) it works in the IntelliJ IDEs. I haven't yet check sourcemap support but in general it works.",
                            "createdAt": "2016-06-10T14:54:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zcbenz",
                                "__typename": "User"
                            },
                            "bodyText": "@ofrobots Does the v8_inspector shipped in Node have any difference from the one in blink? I would like to bring this to Electron.",
                            "createdAt": "2016-06-14T03:10:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "@zcbenz it should be in sync once @ofrobots lands his PR. Are you going to install it on the isolates that are not serving web contents?",
                            "createdAt": "2016-06-15T16:08:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "joshgav",
                                "__typename": "User"
                            },
                            "bodyText": "Started a PR to track support across tools and runtimes here: nodejs/diagnostics#59",
                            "createdAt": "2016-06-15T19:52:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "Is there a reason why this PR forces an openssl build even with --shared-openssl --without-inspector? See #7478.",
                            "createdAt": "2016-06-29T14:21:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I think it is an oversight. I'm looking into it.",
                            "createdAt": "2016-06-29T14:55:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "avesus",
                                "__typename": "User"
                            },
                            "bodyText": "So what about source maps / workspaces support? Chrome said ''Workspace mapping mismatch\" because of the wrapper code.",
                            "createdAt": "2016-07-06T20:02:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pavelfeldman",
                                "__typename": "User"
                            },
                            "bodyText": "Chrome said ''Workspace mapping mismatch\" because of the wrapper code.\n\nThis is fixed upstream, we need to roll v8_inspector to pick it up.",
                            "createdAt": "2016-07-06T20:51:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "RohovDmytro",
                                "__typename": "User"
                            },
                            "bodyText": "node 6.3.0\nnode server --inspect\ndoes not work :|",
                            "createdAt": "2016-07-11T09:51:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sidorares",
                                "__typename": "User"
                            },
                            "bodyText": "@rogovdm you are passing argument to script, do node --inspect server instead",
                            "createdAt": "2016-07-11T10:12:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "leofab86",
                                "__typename": "User"
                            },
                            "bodyText": "I cant print to chrome console on Windows. Macbook works fine. Anyone else having this issue?",
                            "createdAt": "2016-11-17T14:00:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "uMaxmaxmaximus",
                                "__typename": "User"
                            },
                            "bodyText": "how to autostart chrome devtool when i write node --inspect app.js ?",
                            "createdAt": "2016-11-18T03:50:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danielkcz",
                                "__typename": "User"
                            },
                            "bodyText": "@uMaxmaxmaximus I use this Chrome extension: https://chrome.google.com/webstore/detail/nodejs-v8-inspector/lfnddfpljnhbneopljflpombpnkfhggl",
                            "createdAt": "2016-11-18T06:45:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "uMaxmaxmaximus",
                                "__typename": "User"
                            },
                            "bodyText": "@FredyC\nExtention throw error:\nCould not launch debugger\nInvalid devtools URL in\n[ { \"description\": \"node.js instance\", \"devtoolsFrontendUrl\": \"chrome-devtools://devtools/bundled/inspector.html?experiments=true&v8only=true&ws=127.0.0.1:9229/74dec2d8-aca4-4725-85af-f292cb39ad13\", \"faviconUrl\": \"https://nodejs.org/static/favicon.ico\", \"id\": \"74dec2d8-aca4-4725-85af-f292cb39ad13\", \"title\": \"./build/server\", \"type\": \"node\", \"url\": \"file://C:_localhost_taxi_build_server\", \"webSocketDebuggerUrl\": \"ws://127.0.0.1:9229/74dec2d8-aca4-4725-85af-f292cb39ad13\" } ]",
                            "createdAt": "2016-11-18T16:15:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danielkcz",
                                "__typename": "User"
                            },
                            "bodyText": "@uMaxmaxmaximus Sorry, I am not the author of that extension and I don't think this is a right place to try to solve the issue ... https://github.com/continuationlabs/node-v8-inspector",
                            "createdAt": "2016-11-18T16:23:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "uMaxmaxmaximus",
                                "__typename": "User"
                            },
                            "bodyText": "@FredyC\nI've tried it, it does not work unfortunately. Maybe there is some way to intercept the link of std.output using node.js? Then I would have written a module that automatically opens a browser to this link.\nMaybe link active debugger put to global.__inspectorUrl__ ?\nOr create debugger object like this, to control debug from runtime script:\nglobal.debug = {\n  url: 'bla bla',\n  port: 'bla bla',\n  next: function(){ [native code] },\n  stepInto: function(){ [native code] },\n  e.t.c\n}",
                            "createdAt": "2016-11-18T16:24:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danielkcz",
                                "__typename": "User"
                            },
                            "bodyText": "@uMaxmaxmaximus I don't know, it works for me (on Windows as well). There is another alternative you might try ... https://github.com/jaridmargolin/inspect-process",
                            "createdAt": "2016-11-18T16:54:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "june07",
                                "__typename": "User"
                            },
                            "bodyText": "@uMaxmaxmaximus http://june07.com/nim will manage DevTools (including auto launch).",
                            "createdAt": "2016-12-20T18:23:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alysson-pina",
                                "__typename": "User"
                            },
                            "bodyText": "Hi @ofrobots and team. Can we debug Node.js code written in TypeScript (.ts file) rather than regular JS?",
                            "createdAt": "2017-03-29T20:17:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eugeneo",
                                "__typename": "User"
                            },
                            "bodyText": "@alysson-pina it should not matter as long as V8 can run the code. One thing you may need is to generate in-line source maps.",
                            "createdAt": "2017-03-29T20:31:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alysson-pina",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks Eugene.\n\nI'm asking it because when I'm running it to debug a .ts file, it errors\nout with a SyntaxError saying \"SyntaxError: Unexpected token import\".\n\nSeems that it doesn't support TypeScript, as my app runs fine normally.\n\u2026\nOn Wed, Mar 29, 2017 at 5:31 PM, Eugene Ostroukhov ***@***.*** > wrote:\n @alysson-pina <https://github.com/alysson-pina> it should not matter as\n long as V8 can run the code. One thing you may need is to generate in-line\n source maps.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AEGIeRqZrDZLVMY11md771nvbh34-b66ks5rqr-wgaJpZM4IfrJC>\n .",
                            "createdAt": "2017-03-29T22:25:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eugeneo",
                                "__typename": "User"
                            },
                            "bodyText": "Where do you see the error? How do you run the Node to debug TypeScript?",
                            "createdAt": "2017-03-29T22:31:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alysson-pina",
                                "__typename": "User"
                            },
                            "bodyText": "I see it on command line when running it via: \"node --inspect server.ts\"\n\nError:\n\n\"Debugger listening on port 9229.\nWarning: This is an experimental feature and could change at any time.\nTo start debugging, open the following URL in Chrome:\n\nchrome-devtools://devtools/remote/serve_file/@60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?experiments=true&v8only=true&ws=\n127.0.0.1:9229/d1ae07ab-70fc-48bc-a39b-39e8fd0c4af0\n.../src/server/server.ts:1\n(function (exports, require, module, __filename, __dirname) { import * as\nhttp from \"http\";\n                                                              ^^^^^^\nSyntaxError: Unexpected token import\n    at Object.exports.runInThisContext (vm.js:76:16)\n    at Module._compile (module.js:542:28)\n    at Object.Module._extensions..js (module.js:579:10)\n    at Module.load (module.js:487:32)\n    at tryModuleLoad (module.js:446:12)\n    at Function.Module._load (module.js:438:3)\n    at Module.runMain (module.js:604:10)\n    at run (bootstrap_node.js:394:7)\n    at startup (bootstrap_node.js:149:9)\n    at bootstrap_node.js:509:3\nWaiting for the debugger to disconnect...\nDebugger attached.\"\n\u2026\nOn Wed, Mar 29, 2017 at 7:31 PM, Eugene Ostroukhov ***@***.*** > wrote:\n Where do you see the error? How do you run the Node to debug TypeScript?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AEGIeaUQagjZBBVOuDcAf9oCW7cFzDFIks5rqtvVgaJpZM4IfrJC>\n .",
                            "createdAt": "2017-03-29T22:37:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eugeneo",
                                "__typename": "User"
                            },
                            "bodyText": "Node cannot run TypeScript directly - e.g. \"node server.ts\" will fail just\nthe same. You need to debug compiled code.\n\u2026\nOn Wed, Mar 29, 2017 at 3:37 PM Alysson ***@***.***> wrote:\n I see it on command line when running it via: \"node --inspect server.ts\"\n\n Error:\n\n \"Debugger listening on port 9229.\n Warning: This is an experimental feature and could change at any time.\n To start debugging, open the following URL in Chrome:\n\n\n ***@***.***/inspector.html?experiments=true&v8only=true&ws=\n 127.0.0.1:9229/d1ae07ab-70fc-48bc-a39b-39e8fd0c4af0\n /Users/alysson/repo/AC/spyglass/spyglass-server/src/server/server.ts:1\n (function (exports, require, module, __filename, __dirname) { import * as\n http from \"http\";\n ^^^^^^\n SyntaxError: Unexpected token import\n at Object.exports.runInThisContext (vm.js:76:16)\n at Module._compile (module.js:542:28)\n at Object.Module._extensions..js (module.js:579:10)\n at Module.load (module.js:487:32)\n at tryModuleLoad (module.js:446:12)\n at Function.Module._load (module.js:438:3)\n at Module.runMain (module.js:604:10)\n at run (bootstrap_node.js:394:7)\n at startup (bootstrap_node.js:149:9)\n at bootstrap_node.js:509:3\n Waiting for the debugger to disconnect...\n Debugger attached.\"\n\n On Wed, Mar 29, 2017 at 7:31 PM, Eugene Ostroukhov <\n ***@***.***\n > wrote:\n\n > Where do you see the error? How do you run the Node to debug TypeScript?\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#6792 (comment)>, or\n mute\n > the thread\n > <\n https://github.com/notifications/unsubscribe-auth/AEGIeaUQagjZBBVOuDcAf9oCW7cFzDFIks5rqtvVgaJpZM4IfrJC\n >\n > .\n >\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AARkrdEFqMy5gPrXdHS3KegpNgzfM01lks5rqt0sgaJpZM4IfrJC>\n .",
                            "createdAt": "2017-03-29T22:40:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alysson-pina",
                                "__typename": "User"
                            },
                            "bodyText": "Good call. Definitely must be it then. Thanks a bunch Eugene =)\n\nOn Wed, Mar 29, 2017 at 7:41 PM, Eugene Ostroukhov <notifications@github.com\n\u2026\n wrote:\n Node cannot run TypeScript directly - e.g. \"node server.ts\" will fail just\n the same. You need to debug compiled code.\n\n\n On Wed, Mar 29, 2017 at 3:37 PM Alysson ***@***.***> wrote:\n\n > I see it on command line when running it via: \"node --inspect server.ts\"\n >\n > Error:\n >\n > \"Debugger listening on port 9229.\n > Warning: This is an experimental feature and could change at any time.\n > To start debugging, open the following URL in Chrome:\n >\n >\n > chrome-devtools://devtools/remote/serve_file/@\n 60cd6e859b9f557d2312f5bf532f6aec5f284980/inspector.html?\n experiments=true&v8only=true&ws=\n > 127.0.0.1:9229/d1ae07ab-70fc-48bc-a39b-39e8fd0c4af0\n > /Users/alysson/repo/AC/spyglass/spyglass-server/src/server/server.ts:1\n > (function (exports, require, module, __filename, __dirname) { import * as\n > http from \"http\";\n > ^^^^^^\n > SyntaxError: Unexpected token import\n > at Object.exports.runInThisContext (vm.js:76:16)\n > at Module._compile (module.js:542:28)\n > at Object.Module._extensions..js (module.js:579:10)\n > at Module.load (module.js:487:32)\n > at tryModuleLoad (module.js:446:12)\n > at Function.Module._load (module.js:438:3)\n > at Module.runMain (module.js:604:10)\n > at run (bootstrap_node.js:394:7)\n > at startup (bootstrap_node.js:149:9)\n > at bootstrap_node.js:509:3\n > Waiting for the debugger to disconnect...\n > Debugger attached.\"\n >\n > On Wed, Mar 29, 2017 at 7:31 PM, Eugene Ostroukhov <\n > ***@***.***\n > > wrote:\n >\n > > Where do you see the error? How do you run the Node to debug\n TypeScript?\n > >\n > > \u2014\n > > You are receiving this because you were mentioned.\n > > Reply to this email directly, view it on GitHub\n > > <#6792 (comment)>, or\n > mute\n > > the thread\n > > <\n > https://github.com/notifications/unsubscribe-auth/\n AEGIeaUQagjZBBVOuDcAf9oCW7cFzDFIks5rqtvVgaJpZM4IfrJC\n > >\n > > .\n > >\n >\n > \u2014\n > You are receiving this because you were mentioned.\n > Reply to this email directly, view it on GitHub\n > <#6792 (comment)>, or\n mute\n > the thread\n > <https://github.com/notifications/unsubscribe-auth/\n AARkrdEFqMy5gPrXdHS3KegpNgzfM01lks5rqt0sgaJpZM4IfrJC>\n > .\n\n >\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AEGIefZo7WYHNwpcWnbx0XIyQrQFR2Uwks5rqt4bgaJpZM4IfrJC>\n .",
                            "createdAt": "2017-03-29T22:47:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rafraph",
                                "__typename": "User"
                            },
                            "bodyText": "So the final conclusion is that there is no way to debug node written in TypeScript?",
                            "createdAt": "2017-04-27T09:40:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "styfle",
                                "__typename": "User"
                            },
                            "bodyText": "@rafraph This is probably not the place to ask how to debug TypeScript. Lookup Debugging with Source Maps, I'm sure there are lots of tutorials. If you get stuck, ask on https://StackOverflow.com",
                            "createdAt": "2017-04-27T11:16:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rafraph",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not asking how to debug typescript. From reading this thread it seems that debugging node written in TypeScript is not supported in Chrome. After @alysson-pina asked his question, it seems from the answers that this is not supported, so I just want to know if this is the final conclusion.\nBTW, I asked it in StackOverflow.com and someone send me to here, so this is an infinite loop :-)",
                            "createdAt": "2017-04-27T11:47:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alysson-pina",
                                "__typename": "User"
                            },
                            "bodyText": "Hey Refael,\n\nso my answer would be yes and no. You can't directly debug node code\nwritten in Typescript.\n\nHowever you can debug the transpiled JS code just the same. =)\n\u2026\nOn Thu, Apr 27, 2017 at 8:48 AM, Refael Jan ***@***.***> wrote:\n I'm not asking how to debug typescript. From reading this thread it seems\n that debugging node written in TypeScript is not supported in Chrome. After\n @alysson-pina <https://github.com/alysson-pina> asked his question, it\n seems from the answers that this is not supported, so I just want to know\n if this is the final conclusion.\n BTW, I asked it in StackOverflow.com and someone send me to here, so this\n is an infinite loop :-)\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AEGIefcGdcHfZoYvm-nJs-sTQdjKOioMks5r0IB8gaJpZM4IfrJC>\n .",
                            "createdAt": "2017-04-27T14:12:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rafraph",
                                "__typename": "User"
                            },
                            "bodyText": "What do you mean by \"the same\"? the traspiled code is totaly different and not really readable.",
                            "createdAt": "2017-04-27T14:29:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "danielkcz",
                                "__typename": "User"
                            },
                            "bodyText": "@rafraph And that's where source maps comes in :) #6792 (comment)",
                            "createdAt": "2017-04-27T14:44:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "wzup",
                                "__typename": "User"
                            },
                            "bodyText": "Is it true that live debug is impossible with this feature? I mean, debug an app with nodemon, for example, when nodemon restarts the server on every save Ctrl + S?\nCurrently Chrome Devtools breaks down when I save changes in my app:\n\nHow to deal with it? How to make Devtools reconnect automatically?",
                            "createdAt": "2018-01-15T19:20:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "eugeneo",
                                "__typename": "User"
                            },
                            "bodyText": "Open chrome://inspect. There click \"Open dedicated DevTools for Node\" -\nthat instance should be able to reconnect (and it will also connect\nautomatically when you start Node)\n\u2026\nOn Mon, Jan 15, 2018 at 11:20 AM wzup ***@***.***> wrote:\n Is it true that live debug is impossible with this feature? I mean, debug\n an app with nodemon, for example, when nodemon restarts the server on\n every save Ctrl + S?\n\n Currently Chrome Devtools breaks down when I save changes in my app:\n\n [image: dev tools]\n <https://user-images.githubusercontent.com/3880497/34958260-be061126-fa39-11e7-8f82-11f71015e361.png>\n\n How to deal with it? How to make Devtools reconnect automatically?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#6792 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AARkreQIXQrbUKCyE5_hGD4ApNBccKaYks5tK6URgaJpZM4IfrJC>\n .",
                            "createdAt": "2018-01-18T17:18:17Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 2133,
            "title": "workers: initial implementation",
            "author": {
                "login": "petkaantonov"
            },
            "state": "CLOSED",
            "closedAt": "2016-12-11T14:25:53Z",
            "comments": {
                "totalCount": 151,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "alubbe",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome, thank you for picking this up!",
                            "createdAt": "2015-07-08T12:34:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Implemented process.threadId which is always 0 for the main thread and > 0 for workers.\nImplemented data option where you can pass initial data to the worker (process.env cannot be used since it's process wide). The passed data is available in process.workerData inside a worker. This is needed for running fs and network tests in parallel when using workers.\nImplemented eval option, a boolean that you can set to true if you want the first argument to be evaluated as code rather than loading it as a file.",
                            "createdAt": "2015-07-08T15:29:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov \"io.js master merged the required libuv fix regarding to closing stdio handles on Windows\"\nCould you provide a link to the libuv issue up there? :)",
                            "createdAt": "2015-07-08T18:08:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piscisaureus",
                                "__typename": "User"
                            },
                            "bodyText": "io.js master merged the required libuv fix regarding to closing stdio handles on Windows\n\nThat happened: libuv/libuv@60e515d...c619f37. I believe a libuv release is also imminent.",
                            "createdAt": "2015-07-08T22:32:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@piscisaureus yeah the task means that current deps/uv in master doesn't contain the changes",
                            "createdAt": "2015-07-08T22:37:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@kzc The issue you reported was actually known all along in this comment:\n// Deleting WorkerContexts in response to their notification signals\n// will cause use-after-free inside libuv. So the final `delete this`\n// call must be made somewhere else\n\n\"somewhere else\" means queuing the delete this call asynchronously on the main thread event loop. And of course this fails when the owner thread == main thread.\nA significantly simpler solution (without this problem) now occurs to me where WorkerContexts to be deleted would be pushed to a global cleanup queue which is looped through in-between event loop iterations on the main event loop.",
                            "createdAt": "2015-07-10T14:40:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov - it's been some time since I looked at your thread worker code but I vaguely recall it already had a cleanup queue that was intended be called asynchronously. The problem was a nested event loop handler within a dispose function. Nesting event loops is something that really should be avoided - it creates complexity and it is difficult to reason about the ordering of events and the correctness of a solution.",
                            "createdAt": "2015-07-10T15:05:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@kzc btw did you want to know the worker's threadId from the worker object on its owner thread as well? As in worker.threadId?\nAnd yeah I'll change process.threadId to process.tid for better symmetry with process.pid :)",
                            "createdAt": "2015-07-10T15:28:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "For my needs just having process.threadId is sufficient.\nThis brings up a good point - in your implementation can a given worker instance potentially be scheduled on different threads during its lifetime, or are workers always pinned to a specific thread?  If not pinned, the worker instance could benefit from having a unique worker id (never reused for the lifetime of the process across all workers), which is different than a threadId.",
                            "createdAt": "2015-07-10T15:54:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Worker is exclusively tied to a thread. I am not sure what benefit there would be from being able to schedule it on different threads, it would be very complex to implement as you need to facilitate the ownership transfer of a v8 isolate and so on.\nHowever tying a worker to a specific CPU core will be possible if/when libuv merges libuv/libuv#280.",
                            "createdAt": "2015-07-10T15:59:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The use-after-free and nested event loops should be fixed now",
                            "createdAt": "2015-07-10T16:01:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov - Just curious... instead of posting delete tasks to the main thread with QueueWorkerContextCleanup() and CleanupWorkerContexts(), why don't you delete the WorkerContext at the end of WorkerContext::RunWorkerThread() when the worker thread's event loop is guaranteed to have finished?\nvoid WorkerContext::RunWorkerThread(void* arg) {\n  WorkerContext* worker = static_cast<WorkerContext*>(arg);\n  worker->Run();\n  delete worker;\n}",
                            "createdAt": "2015-07-10T18:35:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "After Run() completes only the stuff belonging to the worker thread has been disposed. It is still pending owner disposal at that point.",
                            "createdAt": "2015-07-10T19:21:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "Very cool stuff, but is this not going to be solved/replaced by Vats \"some day\"? I'm probably missing something, but hope this isn't overlooked.",
                            "createdAt": "2015-07-11T06:51:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "You seem to imply that all strawman proposals will eventually be implemented but that is not the case.",
                            "createdAt": "2015-07-11T14:29:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "I just assume a lot, out of ignorance :)",
                            "createdAt": "2015-07-11T14:57:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov - I tested your \"Fix use-after-free\" patch on Linux with valgrind as per the instructions here. It appears to work correctly.\nYou may consider getting rid of the async WorkerContext reaper on the main thread and adopting something like this instead which I think is easier to understand and should put less of a burden on the main thread since it would no longer have to poll the WorkerContext queue:\nvoid WorkerContext::RunWorkerThread(void* arg) {\n  WorkerContext* worker = static_cast<WorkerContext*>(arg);\n  worker->Run();\n  ...wait on a libuv condition variable signalled by \n     owner thread at end of WorkerContext::Dispose()...\n  delete worker;\n}\n\nUnfortunately the Mac OSX BADF/select problem mentioned in the last PR still exists. I think it's a libuv issue. There's also an unrelated linux issue outlined below.\nUsing the latest workers implementation as of 1e0b6b1fd5fc93986d056798f47804d0a15a9bec and this patch:\n--- a/test/workers/test-crypto.js\n+++ b/test/workers/test-crypto.js\n@@ -33,3 +33,3 @@ var tests = [\n\n-var parallelism = 4;\n+var parallelism = 8;\n var testsPerThread = Math.ceil(tests.length / parallelism);\n\nrunning this command repeatedly:\n./iojs --experimental-workers test/workers/test-crypto.js\n\non a 4 core Linux VM it experiences this error roughly once per 50 runs:\n/opt/iojs-workers-implementation/test/common.js:484\n  throw e;\n        ^\nError: Running test/parallel/test-crypto-stream.js inside worker failed:\nAssertionError: false == true\n    at Decipheriv.end (/opt/iojs-workers-implementation/test/parallel/test-crypto-stream.js:52:5)\n    at Decipheriv.<anonymous> (/opt/iojs-workers-implementation/test/common.js:371:15)\n    at emitOne (events.js:82:20)\n    at Decipheriv.emit (events.js:169:7)\n    at done (_stream_transform.js:178:19)\n    at _stream_transform.js:119:9\n    at Decipheriv.Cipher._flush (crypto.js:160:5)\n    at Decipheriv.<anonymous> (_stream_transform.js:118:12)\n    at Decipheriv.g (events.js:260:16)\n    at emitNone (events.js:67:13)\n    at Worker.<anonymous> (/opt/iojs-workers-implementation/test/common.js:477:14)\n    at emitOne (events.js:77:13)\n    at Worker.emit (events.js:169:7)\n    at onerror (worker.js:61:18)\n    at WorkerBinding.workerContext._onmessage (worker.js:75:16)\n\non a 4 core Mac it experiences these errors roughly once per 20 runs:\n /opt/iojs-workers-implementation/test/common.js:484\n   throw e;\n         ^\n Error: Running test/parallel/test-crypto-hmac.js inside worker failed:\n Error: EBADF: bad file descriptor, close\n     at Error (native)\n     at Object.fs.closeSync (fs.js:518:18)\n     at Object.fs.readFileSync (fs.js:445:21)\n     at Object.Module._extensions..js (module.js:447:20)\n     at Module.load (module.js:355:32)\n     at Function.Module._load (module.js:310:12)\n     at Function.Module.runMain (module.js:471:10)\n     at process._runMain (node.js:68:18)\n     at Worker.<anonymous> (/opt/iojs-workers-implementation/test/common.js:477:14)\n     at emitOne (events.js:77:13)\n     at Worker.emit (events.js:169:7)\n     at onerror (worker.js:61:18)\n     at WorkerBinding.workerContext._onmessage (worker.js:75:16)\n (node) crypto.createCredentials is deprecated. Use tls.createSecureContext instead.\n <Buffer 0c 1e e9 6b 67 d3 29 f7 94 26 87 51 bb 05 53 3f>\n Assertion failed: (r == 1), function uv__stream_osx_interrupt_select, file ../deps/uv/src/unix/stream.c, line 127.\n Abort trap: 6\n\nIgnore the deprecation lines - they are of no consequence to this issue.",
                            "createdAt": "2015-07-11T19:52:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "evanlucas",
                                "__typename": "User"
                            },
                            "bodyText": "With it being behind a flag, I'm guessing we are punting on the docs for now?",
                            "createdAt": "2015-07-11T22:00:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov This is more of a meta question - What's your sense of the number of (not lock protected) global/static variables in native modules and methods in the worker threads source tree? Something like that could account for the spurious failures in the worker thread tests. Just scanning the sources in src/*.cc I see a few mutable not lock protected globals. And any third party native module used on a worker thread would have to be thread safe as well. The code in this ecosystem was originally developed without regard to thread safety by design. Should a mechanism or policy be developed to say which node modules are thread safe and as such could be used on a worker thread?",
                            "createdAt": "2015-07-12T13:50:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "I made a thread on v8-users yesterday about this, in case you all are interested.",
                            "createdAt": "2015-07-15T03:50:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "You may consider getting rid of the async WorkerContext reaper on the main thread and adopting something like this instead which I think is easier to understand and should put less of a burden on the main thread since it would no longer have to poll the WorkerContext queue:\nvoid WorkerContext::RunWorkerThread(void* arg) {\n  WorkerContext* worker = static_cast<WorkerContext*>(arg);\n  worker->Run();\n  ...wait on a libuv condition variable signalled by \n     owner thread at end of WorkerContext::Dispose()...\n  delete worker;\n}\n\nThis doesn't help. Consider that after signaling the condition variable, the owner thread is suspended. Meanwhile the worker thread continues and deletes the WorkerContext as the condition was signaled. After this the owner thread is again scheduled and it continues at end of Dispose returns to back inside libuv where the use-after-free now happens because the WorkerContext has been deleted.\nThere should be nothing like a \"burden on main thread\" from the cleanup queue as It's virtually always empty and only checked in-between fully executed event loop \"turns\".\n\nThis is more of a meta question - What's your sense of the number of (not lock protected) global/static variables in native modules and methods in the worker threads source tree? Something like that could account for the spurious failures in the worker thread tests. Just scanning the sources in src/*.cc I see a few mutable not lock protected globals.\n\nFor this PR I have only checked all dependencies (./deps) and some critical global statics like those in node.cc",
                            "createdAt": "2015-07-15T13:14:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "When the crypto test fails the message is \"Error: error:1006706B:elliptic curve routines:ec_GFp_simple_oct2point:point is not on curve\"",
                            "createdAt": "2015-07-15T13:43:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "After this the owner thread is again scheduled and it continues at end of Dispose returns to back inside libuv where the use-after-free now happens because the WorkerContext has been deleted\n\nThat's not the case. If the signal is the last action in Dispose on the owner thread as proposed, there are no more actions to perform on the owner thread - just a return. Just like the owner thread cannot do anything with the WorkerContext at this point in the current implementation after the WorkerThread instance is passed via node::QueueWorkerContextCleanup(this) to the reaper on the main thread.\n\nThere should be nothing like a \"burden on main thread\" from the cleanup queue as It's virtually always empty and only checked in-between fully executed event loop \"turns\".\n\nThe queue may be empty the majority of the time but the mutex is continually being locked/unlocked on the main thread after every uv_run(env->event_loop(), UV_RUN_ONCE) which can have adverse effects on the CPU cache lines and stall a CPU core. Polling is generally something that should be avoided. The signal proposal avoids this polling.\nBut it's not a showstopper. It's just an efficiency issue.\n\nFor this PR I have only checked all dependencies (./deps) and some critical global statics like those in node.cc\n\nI wonder if package.json should have a field to mark whether a given module is thread-safe or not and only the modules deemed to be thread-safe could be used on a worker thread.",
                            "createdAt": "2015-07-15T13:54:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "That's not the case. If the signal is the last action in Dispose on the owner thread as proposed, there are no more actions to perform on the owner thread - just a return.\n\nDispose is the last action yes, but it is called from libuv. And after the control returns to libuv where libuv will still use the worker context object. That's why direct delete this inside Dispose won't work. Signaling inside Dispose for some other thread to do delete this is exactly the same as doing delete this directly and won't work.\n\nThe queue may be empty the majority of the time but the mutex is continually being locked/unlocked on the main thread after every uv_run(env->event_loop(), UV_RUN_ONCE) which can have adverse effects on the CPU cache lines and stall a CPU core. Polling is generally something that should be avoided. The signal proposal avoids this polling.\n\nThe mutex is also virtually always uncontested.",
                            "createdAt": "2015-07-15T14:04:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "I wonder if package.json should have a field to mark whether a given module is thread-safe or not and only the modules deemed to be thread-safe could be used on a worker thread.\n\nThis could only be an issue for compiled modules, not for pure Javascript ones. I think this is something somewhat more related to node-gyp...",
                            "createdAt": "2015-07-15T14:18:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Third party native modules cannot be loaded inside worker. Later a NODE_THREAD_SAFE_MODULE macro could be introduced.",
                            "createdAt": "2015-07-15T14:19:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@kzc the crypto issue appears to be fixed by petkaantonov@0d10ae6\nThe issue seemed to be that ECDH routines did not clear errors on return which caused stale error to pop up in the wrong place. I speculate this only appears with workers because the normal parallel runner always creates a fresh process to run each test in (so openssl error stack is always clean for each test).\nNormally when I ran this asd=0; while ./out/Release/iojs --experimental-workers ./test/workers/test-crypto.js > /dev/null 2>&1; do let \"asd++\"; echo $asd; done; with parallelism=8 the loop stops almost always at < 50 iterations and highest was 84. With the fix I got to 200 iterations so I am assuming it works based on that.",
                            "createdAt": "2015-07-15T15:19:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Signaling inside Dispose for some other thread to do delete this is exactly the same as doing delete this directly and won't work\n\nGetting the worker thread to delete the WorkerContext after its uv_run loop is done and after waiting for the signal from the owner thread guarantees that there will not be an issue. In fact, your present implementation is making the exact same assumption once you call QueueWorkerContextCleanup() - that another thread will delete it - immediately or some time in the future.\nThe original delete this crash happened because the WorkerContext class has a NotificationChannel data member that has a uv_async_t that initiated the callback and it was trying to delete the rug out from under itself. That is not the case with the proposal. The worker thread run loop would be over at that point and that async struct is not being used any longer by any thread and can safely be deleted.\nSince we both think we're right there's no point debating this. Later when the workers branch is merged to master I'll put together a patch to demonstrate it.\n\nThe mutex is also virtually always uncontested\n\nEven so, polling is not desirable, nor necessary here.\n\nThird party native modules cannot be loaded inside worker.\n\nWhat about indirectly via require?",
                            "createdAt": "2015-07-15T15:27:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "The issue seemed to be that ECDH routines did not clear errors on return which caused stale error to pop up in the wrong place\n\n@petkaantonov - well done.\nI guess the worker threads implementation will have a number of similar issues and single threaded assumptions to sort out once it's merged into master. Will probably have to keep the --experimental-workers flag in place for a year or so to shake these things out.\nJust the spurious Mac OSX BADF and select assert failures to deal with now.",
                            "createdAt": "2015-07-15T15:42:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The original delete this crash happened because the WorkerContext class has a NotificationChannel data member that has a uv_async_t that initiated the callback and it was trying to delete the rug out from under itself. That is not the case with the proposal. The worker thread run loop would be over at that point and that async struct is not being used any longer by any thread and can safely be deleted.\n\nThere is a wrong assumption there - the uv_async_t for owner notifications is on the owner's event loop, not on the worker's. Especially in the case where owner thread is the main thread, the loop is never over.",
                            "createdAt": "2015-07-15T15:44:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "What about indirectly via require?\n\nOne ultimately needs to call process.dlopen to load 3rd party native modules but it's not defined inside workers.\n\nJust the spurious Mac OSX BADF and select assert failures to deal with now.\n\nAt least the assertion failure seems to be a libuv bug",
                            "createdAt": "2015-07-15T15:59:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "There is a wrong assumption there - the uv_async_t for owner notifications is on the owner's event loop, not on the worker's. Especially in the case where owner thread is the main thread, the loop is never over.\n\nOkay, I didn't realize that. I see what you mean now.",
                            "createdAt": "2015-07-15T16:00:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "With parallelism = 8 here's the last two valgrind errors on Linux in our favorite test: test/workers/test-crypto.js.  These simple mismatched free/delete errors may not be specific to the workers work but would be nice to see this test run cleanly.\nvalgrind --freelist-vol=250000000 --malloc-fill=0xda --free-fill=0xde \\\n    ./iojs --experimental-workers test/workers/test-crypto.js\n\n(1)\n==13566== Thread 8:\n==13566== Mismatched free() / delete / delete []\n==13566==    at 0x4C2BDEC: free (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==13566==    by 0xA8FD9F: node::smalloc::CallbackInfo::DisposeNoAllocation(v8::Isolate*) (smalloc.cc:97)\n==13566==    by 0xA8D8C1: node::PersistentHandleCleanup::VisitPersistentHandle(v8::Persistent<v8::Value, v8::NonCopyablePersistentTraits<v8::Value> >*, unsigned short) (persistent-handle-cleanup.cc:26)\n==13566==    by 0x7D94BA: v8::VisitorAdapter::VisitEmbedderReference(v8::internal::Object**, unsigned short) (api.cc:6900)\n==13566==    by 0x8A8A1B: v8::internal::GlobalHandles::IterateAllRootsWithClassIds(v8::internal::ObjectVisitor*) (global-handles.cc:910)\n==13566==    by 0x7E2E1F: v8::Isolate::VisitHandlesWithClassIds(v8::PersistentHandleVisitor*) (api.cc:6912)\n==13566==    by 0xA69E38: node::Environment::~Environment() (env-inl.h:217)\n==13566==    by 0xA9D1DA: node::WorkerContext::DisposeWorker(node::WorkerContext::TerminationKind) (env-inl.h:260)\n==13566==    by 0xA9D2C4: node::WorkerContext::LoopEnded() (worker.cc:326)\n==13566==    by 0xA9D574: node::WorkerContext::Run() (worker.cc:654)\n==13566==    by 0xACBC67: uv__thread_start (thread.c:49)\n==13566==    by 0x5A6B181: start_thread (pthread_create.c:312)\n==13566==  Address 0x10671360 is 0 bytes inside a block of size 16 alloc'd\n==13566==    at 0x4C2B800: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==13566==    by 0xA9FD24: node::crypto::CipherBase::GetAuthTag(char**, unsigned int*) const (node_crypto.cc:2879)\n==13566==    by 0xAA81A2: node::crypto::CipherBase::GetAuthTag(v8::FunctionCallbackInfo<v8::Value> const&) (node_crypto.cc:2892)\n==13566==    by 0x7EEB4E: v8::internal::FunctionCallbackArguments::Call(void (*)(v8::FunctionCallbackInfo<v8::Value> const&)) (arguments.cc:33)\n==13566==    by 0x80416B: v8::internal::MaybeHandle<v8::internal::Object> v8::internal::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::(anonymous namespace)::BuiltinArguments<(v8::internal::BuiltinExtraArguments)1>&) (builtins.cc:1077)\n==13566==    by 0x8043B4: v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) (builtins.cc:1100)\n\n(2)\n==13566== Thread 18:\n==13566== Mismatched free() / delete / delete []\n==13566==    at 0x4C2C83C: operator delete[](void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==13566==    by 0xAAAB4F: node::crypto::Certificate::ExportChallenge(v8::FunctionCallbackInfo<v8::Value> const&) (node_crypto.cc:5187)\n==13566==    by 0x7EEB4E: v8::internal::FunctionCallbackArguments::Call(void (*)(v8::FunctionCallbackInfo<v8::Value> const&)) (arguments.cc:33)\n==13566==    by 0x80416B: v8::internal::MaybeHandle<v8::internal::Object> v8::internal::HandleApiCallHelper<false>(v8::internal::Isolate*, v8::internal::(anonymous namespace)::BuiltinArguments<(v8::internal::BuiltinExtraArguments)1>&) (builtins.cc:1077)\n==13566==    by 0x8043B4: v8::internal::Builtin_HandleApiCall(int, v8::internal::Object**, v8::internal::Isolate*) (builtins.cc:1100)\n==13566==  Address 0x15aefe70 is 0 bytes inside a block of size 37 alloc'd\n==13566==    at 0x4C2AB80: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)\n==13566==    by 0x741EAF: CRYPTO_malloc (mem.c:342)\n==13566==    by 0x6E27AF: ASN1_STRING_set (asn1_lib.c:376)\n==13566==    by 0x6E9D60: asn1_ex_c2i (tasn_dec.c:960)\n==13566==    by 0x6EA150: asn1_d2i_ex_primitive (tasn_dec.c:831)\n==13566==    by 0x6EA331: ASN1_item_ex_d2i (tasn_dec.c:237)\n==13566==    by 0x6EABAC: asn1_template_noexp_d2i (tasn_dec.c:691)\n==13566==    by 0x6EAD45: asn1_template_ex_d2i (tasn_dec.c:579)\n==13566==    by 0x6EA784: ASN1_item_ex_d2i (tasn_dec.c:443)\n==13566==    by 0x6EABAC: asn1_template_noexp_d2i (tasn_dec.c:691)\n==13566==    by 0x6EAD45: asn1_template_ex_d2i (tasn_dec.c:579)\n==13566==    by 0x6EA784: ASN1_item_ex_d2i (tasn_dec.c:443)",
                            "createdAt": "2015-07-15T19:13:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "There's also a well over thousand memory leaks if you run with valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./out/Release/iojs --experimental-workers test/workers/test-crypto.js",
                            "createdAt": "2015-07-15T19:20:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Workers aside, no doubt Node itself could benefit from extensive valgrind testing. Of the thousand leaks only the \"definitely leaked\" ones are interesting, and even then most tend to be secondary leaks stemming from a few true leaks.",
                            "createdAt": "2015-07-15T19:35:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pashoo2",
                                "__typename": "User"
                            },
                            "bodyText": "Does it is support the structured clone algorithm instead of JSON parsing, when passing an objects between processes?",
                            "createdAt": "2015-07-22T05:55:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pashoo2",
                                "__typename": "User"
                            },
                            "bodyText": "Or it is still not supported, as you have said before",
                            "createdAt": "2015-07-22T06:12:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Globegitter",
                                "__typename": "User"
                            },
                            "bodyText": "This is exciting, looking forward to play around with this behind an experimental flag.",
                            "createdAt": "2015-07-30T23:34:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "This is exciting, looking forward to play around with this behind an experimental flag.\n\nPseudo-offtopic: is there any way to enable by default at compile time some experimental flags? I would like to test this on ]NodeOS](https://github.com/NodeOS/NodeOS), but I don't have there any way to pass flags to the node.js command... :-/",
                            "createdAt": "2015-07-31T07:55:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "heavyk",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna just change this to true\nhttps://github.com/nodejs/io.js/pull/2133/files#diff-cd53544f44aab2c697bcd7b6a57f23ccR142",
                            "createdAt": "2015-07-31T12:41:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna just change this to true\nhttps://github.com/nodejs/io.js/pull/2133/files#diff-cd53544f44aab2c697bcd7b6a57f23ccR142\n\nOh cool, thank you! :-D Maybe this can be set as compile time options too? If not, would be easy to add an #ifdef :-)",
                            "createdAt": "2015-07-31T12:45:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Morgul",
                                "__typename": "User"
                            },
                            "bodyText": "Is there any documentation on this new API? I couldn't find any in the PR.\nI'm highly interested in the ability to use workers, and was curious about getting a feel for how this will work (other than attempting to read the unit tests.)",
                            "createdAt": "2015-08-31T20:04:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Is there any documentation on this new API? I couldn't find any in the PR.\n\nIt would initially land behind a flag, so there wouldn't be until it becomes fully public api.",
                            "createdAt": "2015-08-31T20:18:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mikeal",
                                "__typename": "User"
                            },
                            "bodyText": "It would initially land behind a flag, so there wouldn't be until it becomes fully public api.\n\nWe should still document it, just not in the main API docs. We have a whole new docs project for this kinda stuff.",
                            "createdAt": "2015-09-05T14:49:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alubbe",
                                "__typename": "User"
                            },
                            "bodyText": "Since 4.0 is just around the corner, is there anything besides docs that's\nkeeping us from merging this to give this some production usage?\nAm 05.09.2015 2:50 nachm. schrieb \"Mikeal Rogers\" <notifications@github.com\n\n:\nIt would initially land behind a flag, so there wouldn't be until it\nbecomes fully public api.\nWe should still document it, just not in the main API docs. We have a\nwhole new docs project for this kinda stuff.\n\u2014\nReply to this email directly or view it on GitHub\n#2133 (comment).",
                            "createdAt": "2015-09-05T18:29:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@alubbe due to how this touches large parts of the code base dealing with handling V8 Isolates, we're being very cautious about this.",
                            "createdAt": "2015-09-05T19:21:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "alubbe",
                                "__typename": "User"
                            },
                            "bodyText": "Right, my question is more geared towards how we can help - what's left to tackle? I've lost track of the status.",
                            "createdAt": "2015-09-05T22:44:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Status?",
                            "createdAt": "2015-09-06T06:30:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 What do you mean? This code has minimal effect unless you enable the flag.\n@IMPinball Waiting for node to use the libuv where the windows stdio closing bug is fixed, this is in the OP",
                            "createdAt": "2015-09-06T09:48:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Rebased and noticed the libuv windows fix has been integrated so this is good to go.",
                            "createdAt": "2015-09-06T11:30:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "this is good to go.\n\nThe spurious Mac test assert failure and EBADF exceptions are not a concern?  If Mac is a tier 2 node platform, I get it.",
                            "createdAt": "2015-09-06T17:09:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Yeah I forgot about that but it's an assertion error inside libuv's async emulation code so it is probably a libuv bug and should be fixed there. Is it reported to libuv yet?",
                            "createdAt": "2015-09-06T17:25:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Morgul",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not speaking for anyone but myself here, but I'd rather see this go in with the spurious Mac assert (since landing this increases the potential user base of people who will help debug it, as well as just getting it out there to see what the community does with this new feature) than to  hold it back at this point.",
                            "createdAt": "2015-09-06T17:31:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Reduced test cases for Mac failure(s) is problematic given their spurious nature and requirement of this web worker branch.",
                            "createdAt": "2015-09-06T17:43:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Is libuv thread safe and free of race conditions with respect to file descriptors in the presence of threads?",
                            "createdAt": "2015-09-06T18:16:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Is libuv thread safe and free of race conditions with respect to file descriptors in the presence of threads?\n\n@kzc I'm not quite sure how to parse the \"with respect to file descriptors\" part.  Libuv is fork-safe on platforms that let you atomically set the close-on-exec flag on file descriptors.  It's thread-safe in the sense that you can call most libuv functions from different threads but not for the same event loop (with the sole exception of uv_async_send().)\nFile operations that run inside the thread pool are not innately ordered.  Two write requests for the same file descriptor can run in either order or even concurrently.",
                            "createdAt": "2015-09-06T21:14:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ericmdantas",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome!",
                            "createdAt": "2015-09-08T14:03:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "Extremely keen to see this merged now, it's been a long time coming and since it's exposed behind a flag it certainly seems ready. What's holding up the merge at this point?",
                            "createdAt": "2015-09-17T10:58:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov How is fork() handled or its use constrained in the web worker threads implementation? (main thread or other).\nhttp://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them\nAny of the issues in this article applicable to this PR?",
                            "createdAt": "2015-09-17T12:44:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "heavyk",
                                "__typename": "User"
                            },
                            "bodyText": "a node fork isn't a real fork(). all \"fork\" means, is to spawn the same script as a child process, maintaining process.args, execArgs, PATH, etc. it just spawns another node instance with all of that and an ipc channel open for communication. you can emulate the behaviour using cp.spawn actually.\nwhat happens with workers is just what you would expect: node will spawn() itself (same script and everything) with an ipc channel opened to the child. from the \"forked\" process' point of view, process.parent will be a reference to the parent process. no memory is copied or anything (unlike a real fork). it behaves just like a spawn. either parent or child processes may spawn workers.\nhttps://iojs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options\n\nThis is a special case of the spawn() functionality for spawning io.js processes. In addition to having all the methods in a normal ChildProcess instance, the returned object has a communication channel built-in. See child.send(message, [sendHandle]) for details.\nThese child io.js processes are still whole new instances of V8. Assume at least 30ms startup and 10mb memory for each new io.js. That is, you cannot create many thousands of them.",
                            "createdAt": "2015-09-17T19:59:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "Note: Unlike the fork() POSIX system call, child_process.fork() does not clone the current process.\n\nI think doing this can be useful, since the .text section and other things could be shared and some memory earned since they would not be duplicated in memory like how it happens when spawning full new processes... By not preserving the heap and the stack (and maybe file descriptors), real forks could safely done and memory would not be wasted, that's one of the biggest problems of NodeOS...\n(Disclaimer: I'm lead developer of NodeOS).",
                            "createdAt": "2015-09-17T20:17:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@heavyk - Thanks for the explanation! That makes perfect sense now.",
                            "createdAt": "2015-09-17T20:21:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna Perhaps some pre-fork()ing technique before v8 is initialized or any threads are created could work.",
                            "createdAt": "2015-09-17T20:34:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "heavyk",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna - don't wanna thread hijack so I made an issue on nodeOS repo to discuss this. NodeOS/NodeOS#170\nthis issue is already really long as it is. cheers",
                            "createdAt": "2015-09-17T21:02:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna - don't wanna thread hijack so I made an issue on nodeOS repo to discuss this. NodeOS/NodeOS#170\n\n\ud83d\udc4d good idea :-)",
                            "createdAt": "2015-09-17T21:06:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "Afaik the OS should already limit the copies of text to 1. It's a simple optimisation that I think kernels have been doing for years. Someone please correct me if I'm wrong.",
                            "createdAt": "2015-09-18T00:03:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rektide",
                                "__typename": "User"
                            },
                            "bodyText": "Original PR is all check marks now. Any chance this can get in before 4.2.0?",
                            "createdAt": "2015-10-02T20:04:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "unlikely in the extreme that this'll make it in to v4, sorry, too big and needs time to bake before we could have confidence to support it in lts",
                            "createdAt": "2015-10-03T01:39:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "This branch has conflicts that must be resolved\n\nI'm guessing that's part of it?",
                            "createdAt": "2015-10-05T10:04:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@IMPinball well that's a consequence of it hanging around for so long. There's no point anyone doing the work to bring the branch up to date if it's not going to be merged any time soon, because the same thing will just happen again.",
                            "createdAt": "2015-10-05T10:07:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "There's that as well.\nOn Mon, Oct 5, 2015 at 6:08 AM, Charles Pick notifications@github.com\nwrote:\n\n@IMPinball https://github.com/impinball well that's a consequence of it\nhanging around for so long. There's no point anyone doing the work to bring\nthe branch up to date if it's not going to be merged any time soon, because\nthe same thing will just happen again.\n\u2014\nReply to this email directly or view it on GitHub\n#2133 (comment).\n\n\nIsiah Meadows",
                            "createdAt": "2015-10-05T10:13:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Morgul",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg Does LTS have to support experimental features, behind flags, with no documentation? That seems a little much to expect, imho.\nWhile I understand the 'needs time to bake', there's not a lot of baking that will go on without it being available somewhere in a release. I'd love to experiment with this, but not quite enough to take the time to mess with building a special version of node for my experiments.\nDisclaimer: I really want to see this feature adopted in node, so I might be a little over zealous to see it merged in. XD",
                            "createdAt": "2015-10-05T16:07:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg Could you please clarify whether official Node releases from the upcoming 5.x branch will be considered to be Stable or Experimental?",
                            "createdAt": "2015-10-05T17:03:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "@kzc v5 is stable.  We can land experimental features behind flags but the issue with this PR is that it's large (which makes thorough reviews difficult) and touches just about everything (which means the risk of subtle bugs is not insignificant.)\nIn hindsight, it would have been better to approach this through a series of smaller PRs.",
                            "createdAt": "2015-10-05T17:23:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis What criteria will be used to judge whether this PR is ready for primetime? Reviews can only go so far to catch errors. It won't be seriously tested unless officially released.\nSome open source projects have an even/odd minor version number release strategy for stable/development releases. I don't suppose that's in the cards for Node?",
                            "createdAt": "2015-10-05T18:22:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "What criteria will be used to judge whether this PR is ready for primetime?\n\nWhen enough reviewers feel confident it's ready.\n\nSome open source projects have an even/odd minor version number release strategy for stable/development releases. I don't suppose that's in the cards for Node?\n\nYou could say that, yes.",
                            "createdAt": "2015-10-05T18:28:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Fwiw, the basic status of this is that because of\n\n(...) but the issue with this PR is that it's large (which makes thorough reviews difficult) and touches just about everything (which means the risk of subtle bugs is not insignificant.)\nIn hindsight, it would have been better to approach this through a series of smaller PRs.\n\nNo-one is super interested in taking responsibility for this, which should be quite understandable.\nAlso, as I understand from @trevnorris, this means we will have to be more careful when dealing with isolates in future changes, which adds a fairly large long-term debt to this.",
                            "createdAt": "2015-10-05T19:09:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe we should consider reusing the code that the V8 team did for d8 Workers ?\nThey implemented interesting things like Object serialization (instead of JSON.stringify) and support of Transferable objects.",
                            "createdAt": "2015-10-05T19:18:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "The serializer/deserializer in d8 is not hugely sophisticated (which is to be expected, d8 is not production-quality software.)  For example, it happily overruns the stack when the object graph is deep.\nI've been investigating reusing the serializer/deserializer from Blink (see also #3145 (comment)) but it pulls in a lot of additional code.  The 200-something files in https://chromium.googlesource.com/chromium/src/+/dba5fc9/third_party/WebKit/Source/bindings/core/v8 are just the tip of the iceberg.",
                            "createdAt": "2015-10-05T19:58:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mlogan",
                                "__typename": "User"
                            },
                            "bodyText": "I have a working fork of this that does serialization/deserialization + transferables using a modified version of the BSON code from https://github.com/audreyt/node-webworker-threads. I also had to fix a few data races in this code that I pointed out earlier.\nIt's not remotely suitable to be merged into node, and I don't have the time to invest into getting it ready, but I'd be happy to share it if someone wanted to use it as a starting point.",
                            "createdAt": "2015-10-05T20:09:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "heavyk",
                                "__typename": "User"
                            },
                            "bodyText": "put it up bro. I'll be glad to use it.",
                            "createdAt": "2015-10-05T20:19:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "The complexity of these other serialization schemes seem counter to the goal of getting web worker threads released in a timely manner. JSON provides a simple API and a clean separation of concerns between threads. When this PR is folded into a release, it can be optimized then if the need arises.",
                            "createdAt": "2015-10-05T21:24:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nathansobo",
                                "__typename": "User"
                            },
                            "bodyText": "The complexity of these other serialization schemes seem counter to the goal of getting web worker threads released in a timely manner. JSON provides a simple API and a clean separation of concerns between threads. When this PR is folded into a release, it can be optimized then if the need arises.\n\n\ud83d\udc4d Cut scope.",
                            "createdAt": "2015-10-05T21:46:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Morgul",
                                "__typename": "User"
                            },
                            "bodyText": "\ud83d\udc4d Cut scope.\n\nI agree with this completely.",
                            "createdAt": "2015-10-06T14:17:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "In case it wasn't clear from context, faster serialization is relevant beyond just this PR.  Let's move that discussion to #3145.",
                            "createdAt": "2015-10-06T14:51:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "spion",
                                "__typename": "User"
                            },
                            "bodyText": "Regarding the size, @bnoordhuis @Fishrock123 does this mean this particular pull request wont get merged unless its split up into separate smaller ones?\nNote that I don't really understand how is node supposed to get any significant new features if large PRs wont get merged. Is it even possible to split this one up?",
                            "createdAt": "2015-10-07T12:53:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "And if that's the case, please could you suggest some logical boundaries for those PRs so that other people could pick this up, given that Petka is busy with other things at the moment?",
                            "createdAt": "2015-10-07T12:57:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "does this mean this particular pull request wont get merged unless its split up into separate smaller ones?\n\nI wouldn't put it that strongly but it's unlikely to get enough review the way it is now.  A good first step would be breaking out the environment cleanup code into its own PR (i.e. the RegisterHandleCleanup() and VisitHandlesWithClassIds() logic.)",
                            "createdAt": "2015-10-07T15:19:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "listepo",
                                "__typename": "User"
                            },
                            "bodyText": "+1 \ud83d\udc4d",
                            "createdAt": "2015-10-07T20:45:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "I'd be more than willing to do the grunt work.",
                            "createdAt": "2015-10-16T13:44:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@tflanagan I think we'd probably accept a PR with the stun @bnoordhuis mentioned if you're up for it. :)",
                            "createdAt": "2015-10-19T13:35:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 I am more than up for it, this feature definitely needs to keep moving. I'll get started either tonight or tomorrow. :)",
                            "createdAt": "2015-10-19T14:32:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "19h",
                                "__typename": "User"
                            },
                            "bodyText": "What is the current progress and state of this PR?",
                            "createdAt": "2015-10-24T13:55:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zxc122333",
                                "__typename": "User"
                            },
                            "bodyText": "What is the current progress and state of this PR?",
                            "createdAt": "2015-11-20T05:31:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@zxc122333 Someone with the means and knowledge will need to break up this PR into discrete parts. This PR is simply too large for proper review.",
                            "createdAt": "2015-11-20T20:48:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "I'm interested in trying to pick this up if possible. I spent a bit of time last night trying to get things to rebase against master and compile, there was a bit of weirdness though (looks like some changes in v8)\nIf someone was willing to pair with me a bit on irc I'm sure we could work through the errors.\n@trevnorris would you have time to collaborate on this a bit next week perhaps?",
                            "createdAt": "2015-11-20T21:07:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tflanagan",
                                "__typename": "User"
                            },
                            "bodyText": "I'm half way through the rebase myself. Haven't had much time to reconcile since I first attempted to.",
                            "createdAt": "2015-11-20T21:13:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd i'm willing to give feedback/advice on the direction changes should go, but not sure how much time i'll have to help code the change.",
                            "createdAt": "2015-11-20T22:57:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd +1",
                            "createdAt": "2015-11-21T00:14:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "Been going at this for a bit today.\nWorked out the conflicts to the best of my ability, but am dealing with some compilation errors.\n../src/env.h:589:20: error: use of undeclared identifier 'HandleWrap'\n  typedef ListHead<HandleWrap, &HandleWrap::handle_wrap_queue_> HandleWrapQueue;\n                   ^\n../src/handle_wrap.cc:71:27: error: member reference base type 'HandleWrapQueue' (aka 'int') is not a structure or union\n  env->handle_wrap_queue()->PushBack(this);\nedit:\nBranch --> https://github.com/TheAlphaNerd/node/tree/worker\nPatch --> https://github.com/TheAlphaNerd/node/commit/42d1385ecc49c26f73373304d693b1b177149067.patch",
                            "createdAt": "2015-11-24T21:47:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd Being that one of the reasons this wasn't accepted is because it's too large a change on its own, could it be helpful to you to break up the changes into more discrete commits while rebasing?",
                            "createdAt": "2015-11-24T23:30:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "JamesMGreene",
                                "__typename": "User"
                            },
                            "bodyText": "WebWorkers, yes please. \ud83d\udc4d",
                            "createdAt": "2016-01-04T14:28:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I believe there is 2 separate parts. First part is all the stuff outside WorkerContext.cc/h/js and the new tests. Those have been reviewed. Second part is WorkerContext.cc/h/js and the new tests, which have not been reviewed much at all (except for the internal worker.js file). The second part cannot really be broken down.",
                            "createdAt": "2016-02-09T09:58:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "In the first part there is also a ton of changes that are not any change at all but extraction of some class to a header file and implementation file. Those should be easy to separate to different commits. The meat of the PR isn't actually very large.",
                            "createdAt": "2016-02-09T10:00:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Is it acceptable to separate the commits in the PR rather than making separate PRs?",
                            "createdAt": "2016-02-09T10:06:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov That will help, but it would be more helpful to have them in separate PRs since discussion will be more focused and if there is any concerns about part of the implementation that won't prevent other parts from landing.",
                            "createdAt": "2016-02-09T10:53:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@thealphanerd I have successfully rebased now.",
                            "createdAt": "2016-02-09T16:11:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dherman",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Sorry if I'm intruding but I wanted to ask if this PR supports (or, if not, if it could support) a per-worker variant of node::AtExit? I am working on a codebase that needs the ability to allocate some data associated with an isolate and then delete that data when the isolate is torn down.\nHope this isn't the wrong place to ask, but feel free to send me elsewhere if so!",
                            "createdAt": "2016-02-12T02:23:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "fbender",
                                "__typename": "User"
                            },
                            "bodyText": "@dave: It does not seem to be in the Web Worker spec, so in the interest of consistency, I'd vote against it. However, you may want to talk to the WHATWG since this seems to be an interesting idea.\nWorkaround: send your own shutdown event for nominal shutdown and listen for error events for off-nominal shutdowns. Also, use polling messages and clean up after the worker has not responded for X polls after Y seconds.\nVon meinem Mobilger\u00e4t gesendet\n\nAm 12.02.2016 um 03:24 schrieb Dave Herman notifications@github.com:\n@petkaantonov Sorry if I'm intruding but I wanted to ask if this PR supports (or, if not, if it could support) a per-worker variant of node::AtExit? I am working on a codebase that needs the ability to allocate some data associated with an isolate and then delete that data when the isolate is torn down.\nHope this isn't the wrong place to ask, but feel free to send me elsewhere if so!\n\u2014\nReply to this email directly or view it on GitHub.",
                            "createdAt": "2016-02-12T07:39:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@dherman Yes I dont see why not\n@fbender this already has several features not in the ww spec. it is just ww api inspired not the same spec.",
                            "createdAt": "2016-02-12T07:50:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dherman",
                                "__typename": "User"
                            },
                            "bodyText": "@fbender Sorry if I wasn't clear -- I'm talking about a C++ API for addons, not a JS API.",
                            "createdAt": "2016-02-12T19:50:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dherman",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Thanks for being open to this -- I've written up a proposed API for per-isolate exit hooks. Not sure if that's the best place to propose this API but I'll see what feedback I get.",
                            "createdAt": "2016-02-12T20:55:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Changes are now in separate commits",
                            "createdAt": "2016-02-13T14:59:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for the clarification on that part, but even in a 1:1 producer/consumer scenario with a single child worker what prevents the race I described above from occurring executing events out of order in the parent/owner? (pardon my accidental non-inline response).",
                            "createdAt": "2016-02-14T19:17:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "If the last slot in the primary is refilled in the course of processing the primary PopFront while loop\n\nThe primary queue is atomic, either the producer sees full queue and puts it in secondary queue or the consumer will see the inserted item in its next loop",
                            "createdAt": "2016-02-14T20:55:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "The primary queue is atomic\n\n\nEach individual primary queue PushBack and PopFront is atomic. But that doesn't prevent the race condition outlined above involving the backup queue.",
                            "createdAt": "2016-02-14T21:09:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "You are right but it's not a race condition or synchronization problem, it's just everyday faulty program logic.\nFor instance if the primary queue is full and secondary queue has some items and only now consumer processing starts. Now the primary queue slots are being freed by the processing and further messages from producer will be placed on primary queue even though they should only come after secondary queue.",
                            "createdAt": "2016-02-14T21:24:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Perhaps it should just be the primary queue with larger size and making producer postMessage block until the consumer can consume. With the queue size configurable by applications they can optimize it best.",
                            "createdAt": "2016-02-14T21:39:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Damn, this appears to be a thing https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem",
                            "createdAt": "2016-02-14T21:42:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "kzc",
                                "__typename": "User"
                            },
                            "bodyText": "Synchronizing two things without a mutual lock is a very difficult problem. I only examined your code to see how you tried to solve it.\n\nPerhaps it should just be the primary queue with larger size and making producer postMessage block until the consumer can consume\n\nThat can work. The devil is in the details.",
                            "createdAt": "2016-02-14T22:40:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matheusmoreira",
                                "__typename": "User"
                            },
                            "bodyText": "Hello,\nI'd like to know the current status of this feature. I'm confused by the pull request's comment history.\nFrom what I understood, it is a complex implementation, and thus should be split into smaller change sets. I'm not sure about where all the work is happening, if it is happening, or if and how I can help. All references I know of a Node.js worker implementation take me to this discussion.",
                            "createdAt": "2016-05-31T15:37:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "spion",
                                "__typename": "User"
                            },
                            "bodyText": "Based on the tempo, I'd estimate its safe to say its \"not going to happen\"\nedit: Apparently it is. I remain sceptical for now.",
                            "createdAt": "2016-05-31T16:36:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "piranna",
                                "__typename": "User"
                            },
                            "bodyText": "It's a shame, the concept was really beautiful... :'-(\nEl 31/5/2016 6:37 PM, \"Gorgi Kosev\" notifications@github.com escribi\u00f3:\n\nBased on the tempo, I'd estimate its safe to say its \"not going to happen\"\n\u2014\nYou are receiving this because you were mentioned.\nReply to this email directly, view it on GitHub\n#2133 (comment), or mute\nthe thread\nhttps://github.com/notifications/unsubscribe/AAgfvg67sqTmFwAeVKYkOHjYWooBgR5Kks5qHGPLgaJpZM4FUYS9\n.",
                            "createdAt": "2016-05-31T16:59:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mitar",
                                "__typename": "User"
                            },
                            "bodyText": "@piranna: Check out: https://github.com/audreyt/node-webworker-threads",
                            "createdAt": "2016-05-31T17:03:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Getting this merged in one shape or another is on my todo list for v7.  In fact, I hope to have the first patches ready for review later this week.\nCaveat emptor: \"this\" should be understood as \"this feature\", not necessarily \"this exact pull request\".",
                            "createdAt": "2016-05-31T17:06:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matheusmoreira",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis: I'm happy to hear that! When the new patches are ready, where shall we head for updates on the feature's progress? Will there be a new pull request or issue?",
                            "createdAt": "2016-05-31T20:40:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis could you make a meta-tracking issue for these like I have done with the stdio things? e.g. #6980",
                            "createdAt": "2016-06-01T18:13:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matheusmoreira",
                                "__typename": "User"
                            },
                            "bodyText": "Any updates on the patches or the meta-tracking issue?\nI'm also wondering if there will be any limitations placed on code executing in a worker thread.\n\nWhat kinds of objects can or can't be communicated through the event loop messaging system?\nAre there any functions or operations which can't be used?",
                            "createdAt": "2016-06-17T07:20:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "basarat",
                                "__typename": "User"
                            },
                            "bodyText": "What kinds of objects can or can't be communicated through the event loop messaging system\n\nonly JSON serializable can be communicated.\n\nAre there any functions or operations which can't be used?\n\nNo functions can be passed around. At least not reliably (.toString is not the right solution).",
                            "createdAt": "2016-06-18T07:35:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "matheusmoreira",
                                "__typename": "User"
                            },
                            "bodyText": "@basarat commented:\n\nNo functions can be passed around. At least not reliably (.toString is not the right solution).\n\nI realize that using JSON as the underlying serialization method prevents passing functions as data. Issue #6300 is relevant.\nWhat I meant to ask is whether there will be anything you can do in Node's event loop thread that you can't do in a worker thread. I'm wondering what subset of Node.js functionality will be usable within a worker.\nFor example, will worker threads:\n\nHave their own event loops?\nBe able to start other workers?\nBe able to spawn a child process?\nBe able to require modules and native addons?\n\nWith child_process it is clear what will happen. It is a full, independent Node.js instance and works just like one; the only real limitation is in the process communications mechanism. The semantics of threads in Node.js don't seem so clear to me.",
                            "createdAt": "2016-06-18T14:10:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "For example, will worker threads:\nHave their own event loops?\nBe able to start other workers?\nBe able to spawn a child process?\nBe able to require modules\n\nYes.\n\nand native addons?\n\nMaybe, it's complicated.  Add-ons would have to opt-in.   The mechanism already kind of exists (NODE_MODULE_CONTEXT_AWARE) but no existing add-ons (to my knowledge) use it.",
                            "createdAt": "2016-06-18T17:26:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis I'd suspect that if worker (or any kind of threading) support makes it into core, several add-ons will start using it.",
                            "createdAt": "2016-06-18T19:22:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hax",
                                "__typename": "User"
                            },
                            "bodyText": "@isiahmeadows Workers should be in core to support transfer ArrayBuffer or other resources in Node. But I'm not sure whether this PR implement these features.",
                            "createdAt": "2016-06-19T05:33:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "siriux",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis Is there any place to follow your work on integrating webworkers for v7?",
                            "createdAt": "2016-07-25T11:35:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "HyeonuPark",
                                "__typename": "User"
                            },
                            "bodyText": "As Atomics and SharedArrayBuffer api landed in stage 2 of tc39 process and v8 is implementing it, I think nodejs should have thread apis in any form as it's core module, to support shared memory correctly.\n#bnoordhuis have you checked that sharedmem api? Can it be possible with your implementation?",
                            "createdAt": "2016-08-22T15:37:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "HyeonuPark",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis have you checked that sharedmem api? Can it be possible with your implementation?\nI' just wonder why i used # instead @ :P",
                            "createdAt": "2016-08-22T15:39:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "I'll point out that this is a really old PR, and it would be easiest to\nrewrite it from scratch again.\n\u2026\nOn Tue, Dec 6, 2016, 04:25 Cogery bot ***@***.***> wrote:\n [image: review status] <http://127.0.0.1:7000/review/nodejs/node/2133/>\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#2133 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AERrBFy1afzdViBRi8x8E-DgUUVsBAklks5rFSn8gaJpZM4FUYS9>\n .",
                            "createdAt": "2016-12-11T12:42:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "I've been working on and off on a rewrite of this pull request but after discussion with other collaborators I've come to the conclusion that multi-threading support adds too many new failure modes for not enough benefit.\nThe primary motivation for the rewrite was improved IPC performance but I'm fairly confident by now that we can also accomplish that using more traditional means like shared memory and more efficient serialization.\nI'll go ahead and close this.  Thanks for your hard work, Petka.",
                            "createdAt": "2016-12-11T14:25:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GnorTech",
                                "__typename": "User"
                            },
                            "bodyText": "For those who want to write Node.js code in multithread program: NW.js implemented this by enabling Node.js in Web Workers:  https://nwjs.io/blog/v0.18.4/",
                            "createdAt": "2016-12-13T02:34:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pemrouz",
                                "__typename": "User"
                            },
                            "bodyText": "The primary motivation for the rewrite was improved IPC performance but I'm fairly confident by now that we can also accomplish that using more traditional means like shared memory and more efficient serialization.\n\nHi @bnoordhuis. Can I ask what the latest plan/thinking is for shared memory in Node (i.e. implement workers, or somehow allow transferring SharedArrayBuffers with cluster, or different API altogether)? The latest version seems to have SharedArrayBuffer (and Atomics), but there is no way to currently use this iiuc? Also, what would be the best the way to help out with this?",
                            "createdAt": "2017-01-10T21:42:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "I've come to the conclusion that multi-threading support adds too many new failure modes for not enough benefit.\n\nAlso\u2026 could you mention what exactly it is that you have discarded? Multi-threading with the full Node API available in each thread, or something more lightweight like a WebWorkers-style API?",
                            "createdAt": "2017-01-12T19:49:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rsp",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax I tried to summarize the state of this issue as well as the different types of concurrency and their pros and cons in the context of Node, and I also kept posting updates about this pull request (mostly thanks to comments from @matheusmoreira - thanks for that) in this answer on Stack Oveflow:\nWhich would be better for concurrent tasks on node.js? Fibers? Web-workers? or Threads?\nIf anything is incorrect or outdated please let me know.",
                            "createdAt": "2017-01-12T22:57:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Can I ask what the latest plan/thinking is for shared memory in Node (i.e. implement workers, or somehow allow transferring SharedArrayBuffers with cluster, or different API altogether)?\n\nShared memory is not my primary focus right now, reducing the overhead of serializing/deserializing is.  I ran a lot of benchmarks and in most non-contrived cases the overhead of converting to and from JSON is significantly greater (as in 70/30 or 80/20 splits) than sending it to another process.\nOnce I get the overhead of serdes down, I'm going to look into shared memory support.  It's a minefield of platform-specific quirks and limitations so it's probably going to take a while to get it merged in libuv and iron out the bugs.  If you want to help out, this is probably a good place to start.\nV8 5.5 or 5.6 will make it a lot easier to do efficient serdes so that's what I'm currently waiting for.\n\ncould you mention what exactly it is that you have discarded? Multi-threading with the full Node API available in each thread, or something more lightweight like a WebWorkers-style API?\n\nThe former, the node-with-threads approach.  WebWorkers-style parallelism is still an option and not terribly hard to implement but I didn't see a point in pursuing that in core, there are already add-ons that do.",
                            "createdAt": "2017-01-13T10:44:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis\n\nThe former, the node-with-threads approach. WebWorkers-style parallelism is still an option and not terribly hard to implement but I didn't see a point in pursuing that in core, there are already add-ons that do.\n\nThat'd be useful except none of the modules I've seen using true threads (instead of processes) actually support require in any way, which makes it way harder to scale. (More specifically, they currently can't, because there's no way to atomically modify the require-related caches via different threads. It has to be moved into C++ land for that to be possible, thanks to V8's lack of thread safety.)",
                            "createdAt": "2017-01-15T10:23:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis\n\nV8 5.5 or 5.6 will make it a lot easier to do efficient serdes so that's what I'm currently waiting for.\n\nOut of curiosity, could you elaborate as to why this is?",
                            "createdAt": "2017-01-16T02:50:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "V8 5.5 or 5.6 will make it a lot easier to do efficient serdes so that's what I'm currently waiting for.\n\n\n\nOut of curiosity, could you elaborate as to why this is?\n\nI\u2019m pretty sure Ben is referring to the added ValueSerializer and ValueDeserializer classes",
                            "createdAt": "2017-01-16T02:54:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ronkorving",
                                "__typename": "User"
                            },
                            "bodyText": "@addaleax Ah nice, a serializer that doesn't use JSON strings?\nSidenote: Something cluster's messaging could make use of too I imagine (would be nice as it's quite slow now imho).",
                            "createdAt": "2017-01-16T04:05:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "Ah nice, a serializer that doesn't use JSON strings?\n\nI mean, I haven\u2019t used it myself yet, but that\u2019s sure what it sounds like. \ud83d\ude04\n\nSomething cluster's messaging could make use of too I imagine (would be nice as it's quite slow now imho).\n\nYeah, I had that thought, too. But as far as the current slowness is concerned: #10557 seems to fix quite a bit of that. :)",
                            "createdAt": "2017-01-16T04:07:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "NawarA",
                                "__typename": "User"
                            },
                            "bodyText": "Is this still being worked on?",
                            "createdAt": "2017-05-12T05:41:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "@NawarA ... not at this time. If someone wanted to volunteer to pick it up, I think that would be welcome, but it's quite a task and there would be much to do.",
                            "createdAt": "2017-05-12T12:58:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "pemrouz",
                                "__typename": "User"
                            },
                            "bodyText": "@jasnell it would be useful if someone could setup a meta-tracking issue like #6980 to just break down the problem on what is required in order to get this done - then volunteers can start picking them up.\nBased on the above, it's not even clear what the desired end state is. It would be good to clarify how Node users will eventually be able to use SharedArrayBuffer (e.g: shared memory between workers? shared memory between processes? using cluster module?).",
                            "createdAt": "2017-05-21T17:53:55Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 29327,
            "title": "module: resolve self-references",
            "author": {
                "login": "jkrems"
            },
            "state": "CLOSED",
            "closedAt": "2019-10-24T22:15:02Z",
            "comments": {
                "totalCount": 149,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "I have to dig up the PR for introducing a scope / namespace... but ~ could potentially be a scope e.g. ~:some-module",
                            "createdAt": "2019-08-26T22:06:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins Unfortunately basically anything but \\0 is a valid Unix directory name. So namespaces etc. won't remove the need for making it resolve last for backwards compat. But it could help make it more obvious that it's \"special\"!",
                            "createdAt": "2019-08-26T22:10:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "It isn't a valid path on Windows though. With it being a tier 1 platform do\nwe have to worry about breaking it?\n\u2026\nOn Mon, Aug 26, 2019, 6:11 PM Jan Olaf Krems ***@***.***> wrote:\n @MylesBorins <https://github.com/MylesBorins> Unfortunately basically\n anything but \\0 is a valid Unix directory name. So namespaces etc. won't\n remove the need for making it resolve last for backwards compat. But it\n could help make it more obvious that it's \"special\"!\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#29327?email_source=notifications&email_token=AADZYV32XQHZW7LTXBBAYO3QGRIHLA5CNFSM4IPWVHE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD5F22IQ#issuecomment-525053218>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AADZYV3IZODLSGGRX5UJKF3QGRIHLANCNFSM4IPWVHEQ>\n .",
                            "createdAt": "2019-08-26T22:34:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "This dovetails with the concept of package scope we\u2019re introducing in ESM, as ~ would always refer to the root of the current package scope. It feels like there should be opportunities there for sharing code.\nOf course I assume you plan on making this work in ESM too; we should make sure it doesn\u2019t conflict with potentially eventually supporting browser import maps, if they have any plans for ~.",
                            "createdAt": "2019-08-26T22:35:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "It isn\u2019t a valid path on Windows though. With it being a tier 1 platform do\nwe have to worry about breaking it?\n\nIsn\u2019t it the opposite? On Windows we know that ~ isn\u2019t referring to a file path, so we could skip those checks.",
                            "createdAt": "2019-08-26T22:37:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "It isn't a valid path on Windows though. With it being a tier 1 platform do we have to worry about breaking it?\n\nWe may have to check that trying to stat on Windows won\u2019t throw (so we actually get to our logic). The specifier not working as-is across platforms would be a good thing because it reduces the risk that somebody used it already for other purposes.",
                            "createdAt": "2019-08-26T22:45:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "cc @nodejs/modules",
                            "createdAt": "2019-08-27T00:07:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "~ is a valid path on all general FS these days, see wikipedia for actual characters allowed in files.\nOn *nix:\ndate > '~' ; cat < '~'\nOr on win32:\ndate > '~' ; type < '~'\nHowever, the fact that it is valid doesn't necessarily mean it is portable. Lack of portability in particular on the myriad of package registries means that it is probably safe I would think, a quick search of require on gzemnid shows usage that we could comb through, but a cursory glance looks to be people altering resolution already.\n\ngzemnid naive findings\nModuleBinder-0.0.1.tgz/tests/constructorinjection_test.js:9:var ConstructorInjection = require('~/'),\nadfc-t30-paten-map-0.3.6.tgz/lib/index.js:22:\"use strict\";var e=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};exports.__esModule=!0,require(\"~/index.css\"),require(\"~/node_modules/leaflet/dist/leaflet.css\");var r=require(\"leaflet\"),a=e(require(\"./layer/osm-layer\")),t=e(require(\"./layer/soz-einrichtung\")),l=new r.Map(\"map\");l.setView(new r.LatLng(53.55,9.98),9),l.addLayer(a.default),l.addLayer(t.default);var u={OpenStreetMap:a.default},i={\"Soziale Einrichtungen\":t.default};r.control.layers(u,i).addTo(l);\nastroman-1.3.0.tgz/lib/commands/create/react-native/__tests__/reduxAction.js:44:  const saveASTtoFile = require('~/utils/js/saveASTtoFile')\nastroman-1.3.0.tgz/lib/commands/plug/react-native/utils/__tests__/wireUp.js:74:  const appendImport = require('~/utils/js/appendImport')\nastroman-1.3.0.tgz/lib/commands/plug/react-native/utils/__tests__/wireUp.js:84:  const appendReducer = require('~/utils/js/appendReducer')\nastroman-1.3.0.tgz/lib/commands/plug/react-native/utils/__tests__/wireUp.js:92:  const appendImport = require('~/utils/js/appendImport')\nastroman-1.3.0.tgz/lib/commands/plug/react-native/utils/__tests__/wireUp.js:102:  const appendLogic = require('~/utils/js/appendLogic')\nbabel-plugin-root-require-1.3.0.tgz/test/does-not-transform.js:55:  const code = 'require(\"~foo\");'\nbabel-plugin-root-require-1.3.0.tgz/test/does-not-transform.js:83:  const code = 'const require = () => {};\\nrequire(\"~/foo\");'\nbabel-plugin-root-require-1.3.0.tgz/test/fixtures/a/req-a.js:1:module.exports = require('~/a')\nbabel-plugin-root-require-1.3.0.tgz/test/fixtures/c/index.js:1:module.exports = require('~/' + 'c')\nbabel-plugin-root-require-1.3.0.tgz/test/fixtures/d/index.js:2:module.exports = require('~/' + myVar + '/d')\nbabel-plugin-root-require-1.3.0.tgz/test/fixtures/e/index.js:2:module.exports = require('~/ne' + myVar + '/e')\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:25:  const result = transform('require(\"~/a/b/c\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:34:  const result = transform('require(\"~/a/b/c\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:103:  const result = transform('require(\"~/foo\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:112:  const result = transform('require(\"~/foo\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:121:  const result = transform('require(\"~/foo\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:130:  const result = transform('require(\"~/foo\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:171:  const result = transform('require(\"~/q/w/e/r/t/y\");', {\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:191:    return require(\"~/a\");\nbabel-plugin-root-require-1.3.0.tgz/test/index.js:204:  const result = transform('require(\"~/foo/\" + bar);', {\nbabel-plugin-sfcc-modules-1.0.3.tgz/lib/index.js:46:        // require('~/cartridge/scripts/foo')\nbael-cms-template-0.1.2.tgz/store/index.js:99:        const info = require('~/content/setup/info.json');\nbael-cms-template-0.1.2.tgz/store/index.js:100:        const connect = require('~/content/setup/connect.json');\nbenben-frontend-generator-1.0.23.tgz/template/src/css.js:1:require('~/css/style.scss');\nbest-require-1.1.4.tgz/test/test.js:9:assert.strictEqual(require('~/test/bar/d1/a'), 1);\nbest-require-1.1.4.tgz/test/test.js:11:assert.strictEqual(require('~/test/bar/d2/b.js'), 2);\nbest-require-1.1.4.tgz/test/test.js:12:assert.strictEqual(require('~/test/foo/d3/c.js'), 3);\nbest-require-1.1.4.tgz/test/time-test.js:11:    require('~/test/bar/d1/a');\nbest-require-1.1.4.tgz/test/time-test.js:13:    require('~/test/bar/d2/b.js');\nbest-require-1.1.4.tgz/test/time-test.js:14:    require('~/test/foo/d3/c.js');\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:11:          src: require('~/assets/images/dev-resources/blockstack.js-documentation.png'),\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:15:          src: require('~/assets/images/dev-resources/blockstack-tutorials.png'),\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:19:          src: require('~/assets/images/dev-resources/blockstack-meetups.png'),\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:23:          src: require('~/assets/images/dev-resources/blockstack-github.png'),\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:27:          src: require('~/assets/images/dev-resources/app.co.png'),\nblockstack-react-scripts-1.0.4.tgz/template/src/components/Resources/index.js:31:          src: require('~/assets/images/dev-resources/blockstack-blog.png'),\ncontacts_client-0.0.1.tgz/lib/api.js:7:\tthis.client = units.require('~');\ncontacts_client-0.0.1.tgz/lib/client/api.js:21:\tthis.client = units.require('~');\ncontacts_client-0.0.1.tgz/lib/client/auth.js:7:\tthis.client = units.require('~');\ncontacts_client-0.0.1.tgz/lib/contract.js:22:\tvar client = units.require('~');\ncontainer-store-3.0.1.tgz/__tests__/Container.spec.js:1:const Container = require('~/Container')\nctail-1.5.6.tgz/lib/config.js:5:    config = require(\"~/.ctail.json\");\ndockular-0.0.1.tgz/tests/example-test.js:16:const login = require('~/util/login');\ndorc-0.0.1.tgz/src/cmd.js:11:const pad = require('~/lib/pad')\ndorc-0.0.1.tgz/src/cmd.js:12:const Help = require('~/lib/help')\ndorc-0.0.1.tgz/src/cmd.js:16:const zipObjRest = R.curry(require('~/lib/zip-obj-rest'))\ndorc-0.0.1.tgz/src/cmd.js:17:const parseArgs = require('~/lib/parse-args')\ndorc-0.0.1.tgz/src/handler/down/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/down/cmd.test.js:8:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/exec/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/exec/cmd.test.js:8:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/follow/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/follow/cmd.test.js:8:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/restart/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/restart/cmd.test.js:8:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/restart/index.js:1:const down = require('~/handler/down')\ndorc-0.0.1.tgz/src/handler/restart/index.js:2:const up = require('~/handler/up')\ndorc-0.0.1.tgz/src/handler/rmi/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/rmi/cmd.js:5:const needsBuild = require('~/lib/service/needs-build')\ndorc-0.0.1.tgz/src/handler/rmi/cmd.test.js:8:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/rmi/index.js:2:const getTags = require('~/lib/service/get-tags')\ndorc-0.0.1.tgz/src/handler/run/cmd.js:1:const sharedOptions = require('~/lib/shared-options')\ndorc-0.0.1.tgz/src/handler/run/cmd.test.js:3:const docker = require('~/lib/docker-api')\ndorc-0.0.1.tgz/src/handler/run/cmd.test.js:12:} = require('~/test')\ndorc-0.0.1.tgz/src/handler/run/command.js:3:const zipObjRest = R.curry(require('~/lib/zip-obj-rest'))\ndorc-0.0.1.tgz/src/handler/run/make-run-args.js:8:const moveProps = require('~/lib/move-props')\ndorc-0.0.1.tgz/src/handler/run/make-run-args.js:9:const mergeProps = require('~/lib/merge-props')\ndorc-0.0.1.tgz/src/handler/run/make-run-args.js:10:const transformDockerOptions = require('~/lib/transform-docker-options')\ndorc-0.0.1.tgz/src/handler/run/make-run-args.js:12:const getMainTag = require('~/lib/get-main-tag')\ndorc-0.0.1.tgz/src/handler/run/parse.js:4:const keysMatching = require('~/lib/keys-matching')\ndorc-0.0.1.tgz/src/handler/run/parse.js:5:const mapKeys = require('~/lib/map-keys')\ndorc-0.0.1.tgz/src/handler/run/parse.js:6:const zipObjRest = R.curry(require('~/lib/zip-obj-rest'))\ndorc-0.0.1.tgz/src/handler/run/parse.js:7:const prepOptionsForMinimist = require('~/lib/prep-options-for-minimist')\ndorc-0.0.1.tgz/src/handler/up/cmd.js:3:const sharedOptions = require('~/lib/shared-options')\ndorc-0.0.1.tgz/src/handler/up/cmd.js:4:const pickIfAnySpecified = require('~/lib/pick-if-any-specified')\ndorc-0.0.1.tgz/src/handler/up/index.js:1:const build = require('~/handler/build')\ndorc-0.0.1.tgz/src/handler/up/index.js:2:const run = require('~/handler/run')\ndorc-0.0.1.tgz/src/handler/up/index.js:3:const follow = require('~/handler/follow')\ndorc-0.0.1.tgz/src/handler/up/index.js:4:const needsBuild = require('~/lib/service/needs-build')\ndorc-0.0.1.tgz/src/lib/get-config.js:12:const configSchema = require('~/schema/config')\ndorc-0.0.1.tgz/src/lib/help.js:4:const prefixLines = curry(require('~/lib/prefix-lines'))\ndorc-0.0.1.tgz/src/lib/help.js:5:const toArrayAssignKeys = curry(require('~/lib/to-array-assign-keys'))\ndorc-0.0.1.tgz/src/lib/parse-args.test.js:3:const run = require('~/handler/run')\ndorc-0.0.1.tgz/src/lib/parse-args.test.js:4:const options = require('~/options')\ndorc-0.0.1.tgz/src/lib/parse-args.test.js:5:const commands = require('~/commands')\ndorc-0.0.1.tgz/src/scripts/save-run-options.js:5:const getRunOptions = require('~/lib/get-docker-run-options')\neasy-require-1.0.1.tgz/perf/local.js:11:  app.require('~/inc/absolute');\neasy-require-1.0.1.tgz/perf/nestedDirectory.js:11:  app.require('~/inc', true);\neasy-require-1.0.1.tgz/perf/temp.js:6:var test = app.require('~/inc', true);\neasy-require-1.0.1.tgz/tests/test.js:8:var test_local_dir = _require('~/local', true);\neasy-require-1.0.1.tgz/tests/test.js:9:var test_empty_dir = _require('~/empty_dir', true);\neasy-require-1.0.1.tgz/tests/test.js:10:var test_nested_dir = _require('~/nested_dir', true);\neasy-require-1.0.1.tgz/tests/test.js:11:var test_no_dir = _require('~/no_dir');\neasy-require-1.0.1.tgz/tests/test.js:12:var test_local = _require('~/local');\nelectron-ts-ipc-1.0.1.tgz/lib/index.js:6:var sub_1 = __importDefault(require(\"~/sub\"));\nember-fastboot-server-0.7.3.tgz/lib/ember-app.js:57:    return ctx.require('~fastboot/app-factory');\neos-framework-0.4.0.tgz/src/app/actions/__tests__/affiliateActions.spec.js:6:const dataProvider = require('~/app/providers/BaseDataProvider');\neos-framework-0.4.0.tgz/src/app/actions/__tests__/episodeListActions.spec.js:7:const dataProvider = require('~/app/providers/BaseDataProvider');\neos-framework-0.4.0.tgz/src/app/actions/__tests__/searchActions.spec.js:6:const dataProvider = require('~/app/providers/BaseDataProvider');\neos-framework-0.4.0.tgz/src/app/helpers/headers.js:5:const getNSProcessEnvVar = require('~/app/helpers/environment').setNamespace();\neslint-plugin-no-require-self-ref-1.0.3.tgz/test.js:27:      code: 'require(\"~/hello\")',\nethical-server-middleware-react-redux-0.0.6.tgz/test/specs/index.js:39:        .then(() => setTimeout(() => window.require('~'), 0))\nethical-utility-require-browser-0.0.1.tgz/test/specs/index.js:42:        expect(global.window.require('~/test/files/dist/a.js'))\nethical-utility-require-browser-0.0.1.tgz/test/specs/index.js:95:            global.window.require('~/app.js')\nexpress-api-starter-kit-1.0.0.tgz/src/__tests__/helper.js:17:  require('~/server'); // eslint-disable-line global-require\nfastboot-2.0.1.tgz/src/ember-app.js:203:      return ctx.require('~fastboot/app-factory');\nfastboot-ryanone-1.0.0-rc.2.tgz/src/ember-app.js:158:      return ctx.require('~fastboot/app-factory');\nfengyu-cli-1.0.9.tgz/template/framework/core/ws-plugin.js:9:    this.src = require('~/src/assets/img/src/common/default_load.png')\nfsbx-2.1.0-beta.4.tgz/src/tests/fixtures/cases/case1/index.js:1://require(\"~/sub/hello.js\");\nfsbx-2.1.0-beta.4.tgz/src/tests/fixtures/cases/case1/index.js:44:// require(\"~/sub/hello.js\");\nfsbx-2.1.0-beta.4.tgz/src/tests/fixtures/cases/case1/sub/hello.js:1:console.log(require(\"~/bar.js\"));\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:30:            \"hello.js\": `module.exports = require(\"~/stuff/boo.js\");`,\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:41:            \"hello.js\": `module.exports = require(\"~/stuff/boo\");`,\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:79:            FuseBox.dynamic(\"hello/world.js\", \"module.exports = require('~/foo')\")`,\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:92:            FuseBox.dynamic(\"hello/world.js\", \"module.exports = require('~/foo.js')\")`,\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:105:            FuseBox.dynamic(\"hello/world.js\", \"module.exports = require('~/foo.js')\")`,\nfusebox-cli-1.3.135.tgz/test/dynamic_modules.js:119:            FuseBox.dynamic(\"hello/world.js\", \"module.exports = require('~/foo.js')\")`,\nfusebox-cli-1.3.135.tgz/test/fixtures/cases/case1/index.js:1://require(\"~/sub/hello.js\");\nfusebox-cli-1.3.135.tgz/test/fixtures/cases/case1/index.js:44:// require(\"~/sub/hello.js\");\nfusebox-cli-1.3.135.tgz/test/fixtures/cases/case1/sub/hello.js:1:console.log(require(\"~/bar.js\"));\nfusebox-cli-1.3.135.tgz/test/generic_require.js:56:            \"foo/bar.js\": \"module.exports = require('~/foo/hello.js')\",\nfusebox-cli-1.3.135.tgz/test/generic_require.js:68:            \"foo/bar.js\": \"module.exports = require('~/foo/hello.js')\",\nfusebox-cli-1.3.135.tgz/test/generic_require.js:104:            \"foo/index.js\": `module.exports = require(\"~/bar\")`,\nfusebox-cli-1.3.135.tgz/test/generic_require.js:116:            \"foo/index.js\": `module.exports = require(\"~/bar/index\")`,\nfusebox-cli-1.3.135.tgz/test/generic_require.js:128:            \"foo/index.js\": `module.exports = require(\"~/bar/index.js\")`,\nganesh-api-1.0.2.tgz/lib/firestore/models/Category.js:7:var _Enum = require('~/models/Enum');\nganesh-api-1.0.2.tgz/lib/firestore/models/Meat.js:7:var _Enum = require('~/models/Enum');\nganesh-api-1.0.2.tgz/lib/firestore/models/NanAndRice.js:7:var _Enum = require('~/models/Enum');\nganesh-api-1.0.2.tgz/lib/firestore/models/OrderStatus.js:7:var _Enum = require('~/models/Enum');\nganesh-api-1.0.2.tgz/lib/firestore/models/Payment.js:7:var _Enum = require('~/models/Enum');\nganesh-api-1.0.2.tgz/lib/firestore/models/Store.js:7:var _Enum = require('~/models/Enum');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/app/healthz/tests/index.test.js:1:const { createTestServer } = require('~infra/test');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/index.js:1:const Configuration = require('~infra/configuration');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/index.js:2:const { createServer } = require('~infra/fastify');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/index.js:3:const Logger = require('~infra/logger');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/infra/test/index.js:1:const Configuration = require('~infra/configuration');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/infra/test/index.js:2:const { createServer } = require('~infra/fastify');\ngenerator-furious-0.0.2.tgz/generators/app/templates/src/infra/test/index.js:3:const Logger = require('~infra/logger');\ngoman-0.0.4.tgz/src/g.js:20:  generatorConfig = require('~/.g/.g.config.json');\ngpms_permission-0.0.1.tgz/playground/playground.js:2://const GPValidObject = require('~/development.api/gplib_validobject/dist/index');\ngridsome-0.6.3.tgz/app/main.js:4:  main = require('~/main').default\ngrunt-init-react-0.1.8.tgz/root/src/app/pages/About.js:11:      readmeHtml = require('~/README.md');\nhmls-2.2.0.tgz/bin/scaffold/routes/slash/index.js:8:      const page = require('~/pages/slash/index.marko')\nhmls-2.2.0.tgz/index.js:12:const config = require('~/config')\nhmls-2.2.0.tgz/test/index.js:7:const HMLS = require('~/index')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:24:  const dir1ModuleA = require('~/module-a')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:47:  const module = require('~/inner-require')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:62:  const randomC = require('~/../random')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:82:  const circle1 = require('~/circle1')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:106:  const circle1 = require('~/circle1')\nhook-require-path-1.1.0.tgz/test/install.manual-test.js:110:    const tmp = require('~/circle1')\nhook-require-path-1.1.0.tgz/test/test-modules/dir2/circle2.js:2:module.exports.other = require('~/circle1')\nignite-matt-oakes-react-native-boilerplate-2.0.0.tgz/boilerplate/src/navigation/rootNavigationStack.js:9:    getScreen: () => require(\"~/src/screens/Welcome\").default\nignite-matt-oakes-react-native-boilerplate-2.0.0.tgz/boilerplate/src/theme/images.js:4:  // logo: require(\"~/src/images/logo.png\")\nimpacter-0.0.8.tgz/ig.js:37:        const assets = require('~/../assets/assets.json');\nizi-3.1.0.tgz/fuzzy-time.js:6:} = require('~/i18n')\nlsk-mobx-0.1.0.tgz/src/App/App.server.js:22:      ...require('~/modules/server').default(this),\nlsk-mobx-0.1.0.tgz/src/Uapp/Uapp.js:29:      ...require('~/modules/uapp').default(this), // eslint-disable-line\nlvx-cli-1.0.6.tgz/template/framework/core/lvx-plugin.js:9:  this.src = require('~/src/assets/img/src/common/default_load.png')\nmarko-starter-2.0.4.tgz/index.js:5:require('~/src');\nmarko-starter-2.0.4.tgz/index.js:24:const logging = require('~/src/logging');\nmarko-starter-2.0.4.tgz/index.js:25:const pluginManager = require('~/src/plugin-manager');\nmarko-starter-2.0.4.tgz/index.js:28:const _createProject = require('~/src/util/createProject');\nmarko-starter-2.0.4.tgz/index.js:29:const _runProjectTasks = require('~/src/util/runProjectTasks');\nmarko-starter-2.0.4.tgz/index.js:30:const _triggerProjectHook = require('~/src/util/triggerProjectHook');\nmarko-starter-2.0.4.tgz/index.js:125:          const _buildAllRoutes = require('~/src/util/buildAllRoutes');\nmarko-starter-2.0.4.tgz/src/models/BuildResult.js:15:    project: require('~/src/models/Project'),\nmarko-starter-2.0.4.tgz/src/models/Project.js:3:const Raw = require('~/src/models/Raw');\nmarko-starter-2.0.4.tgz/src/models/Project.js:4:const logging = require('~/src/logging');\nmarko-starter-2.0.4.tgz/src/models/Project.js:5:const routeHandlerUtil = require('~/src/route-handler-util');\nmarko-starter-2.0.4.tgz/src/models/Project.js:86:      default: require('~/src/util/isProduction')\nmarko-starter-2.0.4.tgz/src/plugin-manager.js:3:const logging = require('~/src/logging');\nmarko-starter-2.0.4.tgz/src/plugin-manager.js:4:const Project = require('~/src/models/Project');\nmarko-starter-2.0.4.tgz/src/plugin-manager.js:27:      Raw: require('~/src/models/Raw'),\nmarko-starter-2.0.4.tgz/src/util/buildAllRoutes.js:7:const BuildResult = require('~/src/models/BuildResult');\nmarko-starter-2.0.4.tgz/src/util/createProject.js:4:const logging = require('~/src/logging');\nmarko-starter-2.0.4.tgz/src/util/createProject.js:6:const ProjectSchema = require('~/src/models/Project');\nmarko-starter-2.0.4.tgz/src/util/createProject.js:81:    require('~/src/project-tasks/print-configuration')\nmarko-starter-2.0.4.tgz/src/util/triggerProjectHook.js:3:const pluginManager = require('~/src/plugin-manager');\nmeta-client-0.0.0-c32.tgz/lib/Space/Meta/Graphics/Model/Model.js:1:'use strict';Object.defineProperty(exports,'__esModule',{value:true});var _src=require('~/src');function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var Model=function Model(file){_classCallCheck(this,Model);return new _src.Meta({graphics:new _src.Graphics({model:file},true)})};exports.default=Model;\nmongo-purge-1.0.1.tgz/index.js:4:const options = require('~/lib/cli')\nmongo-purge-1.0.1.tgz/index.js:9:const log = require('~/lib/logger')\nmongo-purge-1.0.1.tgz/lib/cli.js:4:const log = require('~/lib/logger')\nmongo-purge-1.0.1.tgz/lib/cli.js:8:  .version(require('~/package.json').version)\nnativescript-dev-webpack-0.24.0.tgz/load-application-css-angular.js:5:        global.registerModule(\"./app.css\", () => require(\"~/app\"));\nnativescript-download-progress-1.1.0.tgz/android-worker.js:4:      global.require('~/../internal/ts_helpers.js');\nnativescript-download-progress-1.1.0.tgz/android-worker.js:6:    global.require('~/vendor');\nnativescript-tus-upload-1.0.5.tgz/android-worker.js:5:    global.require('~/../internal/ts_helpers.js');\nnativescript-tus-upload-1.0.5.tgz/android-worker.js:7:  global.require('~/vendor');\nned-transpile-1.0.6.tgz/test/fixtures/root-import/bars/bar/bool.js:1:module.exports = require('~/result')\nned-transpile-1.0.6.tgz/test/fixtures/root-require/bars/bar/bool.js:1:module.exports = require('~/result')\nned-transpile-1.0.6.tgz/test/fixtures/root-require/foos/fool.js:1:module.exports = require('~/bars/bar/bool')\nned-transpile-1.0.6.tgz/test/fixtures/root-require/index.js:1:var x = require('~/')\nned-transpile-1.0.6.tgz/test/fixtures/root-require/index.js:2:var y = require('~')\nned-transpile-1.0.6.tgz/test/fixtures/root-require/index.js:3:module.exports = require('~/foos/fool')\nnexus-repo-0.0.16.tgz/nexusRepoCli.js:4://var config = require('~/.nexusRepo.json')\nnodecopter-0.0.2.tgz/nodecopter.js:50:            config = require('~/nodecopter.json')\nnuxt-feathers-vuex-0.0.7.tgz/lib/templates/plugin.js:47:    let { store, hooks, options } = require('~/store/services/' + name)\nnuxt-feathers-vuex-0.0.7.tgz/lib/templates/plugin.js:80:  allNames.includes('auth') ? require('~/store/services/auth').store : {}\nnuxt-i18n-module-0.2.7.tgz/src/templates/plugin.js:33:    messages[lang] = require('~/assets/locale/' + lang + '.json')\nnuxt.js-0.0.1.tgz/examples/i18n/plugins/i18n.js:13:      'en': require('~/locales/en.json'),\nnuxt.js-0.0.1.tgz/examples/i18n/plugins/i18n.js:14:      'fr': require('~/locales/fr.json')\nopen_castings_components-1.0.1.tgz/lib/Buttons/stories/Button.js:17:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Generic/stories/oc_editable_hoc.js:15:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Generic/stories/oc_editable_hoc.js:17:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_basic_stats.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_basic_stats.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_edit_jobs.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_edit_jobs.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_education_training.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_education_training.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_education_training_item.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_education_training_item.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_image.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_jobs.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_jobs.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_overview.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_overview.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_skills.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_skills.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_title.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Profile/stories/profile_title.js:11:var _load_mui_theme = require('~/.storybook/load_mui_theme');\nopen_castings_components-1.0.1.tgz/lib/Social/stories/facebook_followers.js:9:var _ = require('~/');\nopen_castings_components-1.0.1.tgz/lib/Social/stories/twitter_followers.js:9:var _ = require('~/');\noyod-0.1.1.tgz/server/test/apis/pv.test.js:4:var router = require('~/server/apis/pv/pv.api')\noyod-0.1.1.tgz/server/test/apis/pv.test.js:5:var PV = require('~/server/apis/pv/pv.model')\noyod-0.1.1.tgz/server/test/apis/pv.test.js:6:var db = require('~/server/lib/db-driver')\noyod-0.1.1.tgz/server/test/integration/basic-app-installation.test.js:6:var User = require('~/server/models/user')\noyod-0.1.1.tgz/server/test/integration/basic-app-installation.test.js:7:var AccessToken = require('~/server/models/access-token')\noyod-0.1.1.tgz/server/test/integration/basic-app-installation.test.js:8:var appRouter = require('~/server/index.js')\noyod-0.1.1.tgz/server/test/routes/oauth.test.js:6:var User = require('~/server/models/user')\noyod-0.1.1.tgz/server/test/routes/oauth.test.js:7:var appRouter = require('~/server/index.js')\npanela-0.2.0.tgz/lib/builder.js:16:const { isFunction } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/core.js:24:const logger = onepath.require('~/logger');\npanela-0.2.0.tgz/lib/core.js:25:const { isFunction, isArray, isObject } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/database.js:15:const util = onepath.require('~/util');\npanela-0.2.0.tgz/lib/endpoint.js:12:const Core = onepath.require('~/core');\npanela-0.2.0.tgz/lib/endpoint.js:13:const { isString, isFunction, slice } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/engine.js:15:const util = onepath.require('~/util');\npanela-0.2.0.tgz/lib/host.js:15:const Middleware = onepath.require('~/middleware');\npanela-0.2.0.tgz/lib/host.js:16:const NginxConfig = onepath.require('~/nginxc');\npanela-0.2.0.tgz/lib/host.js:17:const Route = onepath.require('~/route');\npanela-0.2.0.tgz/lib/host.js:18:const { isString, slice } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/hosts.js:24:const { isString } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/middleware.js:14:const Endpoint = onepath.require('~/endpoint');\npanela-0.2.0.tgz/lib/middleware.js:15:const { isString, slice } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/nginxc.js:22:const { isString } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/panela.js:16:const Builder = onepath.require('~/builder');\npanela-0.2.0.tgz/lib/panela.js:17:const Core = onepath.require('~/core');\npanela-0.2.0.tgz/lib/panela.js:18:const Database = onepath.require('~/database');\npanela-0.2.0.tgz/lib/panela.js:19:const Engine = onepath.require('~/engine');\npanela-0.2.0.tgz/lib/panela.js:20:const Host = onepath.require('~/host');\npanela-0.2.0.tgz/lib/panela.js:21:const Route = onepath.require('~/route');\npanela-0.2.0.tgz/lib/panela.js:22:const hosts = onepath.require('~/hosts');\npanela-0.2.0.tgz/lib/panela.js:23:const logger = onepath.require('~/logger');\npanela-0.2.0.tgz/lib/panela.js:24:const NginxConfig = onepath.require('~/nginxc');\npanela-0.2.0.tgz/lib/panela.js:25:const { isObject, isString, isFunction } = onepath.require('~/util');\npanela-0.2.0.tgz/lib/route.js:14:const Endpoint = onepath.require('~/endpoint');\npanela-0.2.0.tgz/lib/route.js:15:const { isString, slice } = onepath.require('~/util');\nplayland-2.1.1.tgz/src/components/App.js:10:const Home = () => \nplex-vr-0.9.0.tgz/lib/api/index.js:21:var _request = require('~api/request');\nplex-vr-0.9.0.tgz/lib/api/index.js:23:var _headers = require('~api/headers');\nplex-vr-0.9.0.tgz/lib/api/request.js:8:var _xml2json = require('~util/xml2json');\npostjss-0.1.0.tgz/src/webpack/tests/report-loader.spec.js:8:  const loader = require('~/webpack/report-loader').default\nprism-cli-0.3.1.tgz/prism.js:11:        ansi_mapping = require('~/.prismrc');\npult-cli-0.5.0.tgz/base-template/test/server/index_test.js:4:var routes = require('~/server/index')\nquasar-application-0.0.4.tgz/lib/templates/entry.js:29:require('~/css/<%= asset %>')\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:23:        let fileContent = 'Some text or code require(\"~/someLib\"); plus some other stuff';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:28:        let fileContent = 'Some text or code require(\"~/someLib\"); plus some other stuff';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:36:        let expectedOutput = 'require(\"~/some/directory/deep/lib\");';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:42:        let expectedOutput = 'require(\"~/some/directory/deep/child/lib\");';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:48:        let expectedOutput = 'require(\"~/some/directory/lib\");';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:54:        let expectedOutput = 'require(\"~/some/directory/deep/lib\"); require(\"~/some/directory/deep/lib\");';\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:70:                require(\"~/some/directory/deep/lib\");\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:71:                require(\"~/some/directory/otherdirectory/lib\");\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:72:                require(\"~/some/directory/lib\");\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:87:                require(\"~/some/directory/lib-dir/lib.lib_lib/lib\");\nrachnerd-test-plugin-0.0.34.tgz/test/utils.spec.js:88:                require(\"~/some/directory/deep/lib-dir/lib.lib_lib/lib\");\nreact-native-template-allmax-1.3.0.tgz/src/global/strings.js:11:    privateStrings = require('~/localization/ru-RU').strings;\nreact-native-template-allmax-1.3.0.tgz/src/global/strings.js:14:    privateStrings = require('~/localization/en-US').strings;\nreact-native-template-csorlandi-advanced-1.0.1.tgz/src/pages/main/index.js:40:      source={require('~/images/rocketseat_logo.png')}\nreact-native-template-csorlandi-basic-2.0.3.tgz/src/pages/Main/index.js:40:      source={require('~/images/rocketseat_logo.png')}\nreact-native-template-feature-based-basic-0.2.0.tgz/src/themes/images.js:4:\t//logo: require('~/assets/images/react.png'),\nreact-native-template-feature-based-redux-0.4.0.tgz/src/store/ducks/index.js:5:\t// product: require('~/common/state/product/ProductDuck').reducer,\nreact-native-template-feature-based-redux-0.4.0.tgz/src/store/ducks/index.js:6:\t// user: require('~/user/state/UserDuck').reducer,\nreact-native-template-feature-based-redux-0.4.0.tgz/src/themes/images.js:4:\t//logo: require('~/assets/images/react.png'),\nreact-native-template-scalable-0.3.0.tgz/src/themes/Images.js:4:  //logo: require('~/assets/images/lego.png'),\nreact-native-template-scalable-redux-0.4.0.tgz/src/store/Ducks.js:5:\t// product: require('~/common/state/product/ProductDuck').reducer,\nreact-native-template-scalable-redux-0.4.0.tgz/src/store/Ducks.js:6:\t// user: require('~/user/state/UserDuck').reducer,\nreact-native-template-scalable-redux-0.4.0.tgz/src/themes/Images.js:4:  //logo: require('~/assets/images/lego.png'),\nreacteum-1.2.1.tgz/src/store/index.js:19:const history = isBrowser ? require('~/store/history') : null;\nreaction-build-1.0.0-rc.104.tgz/lib/server.js:58:  var app = require('~/../web/server').default.app;\nreaction-build-1.0.0-rc.104.tgz/lib/storiesOf/StorybookView/index.js:47:      var rootStyle = require('~/../web/styles/root.scss?root=./web/styles/');\nrequire-app-root-1.0.0-a.tgz/test/main.js:16:\t\tt.ok(require(\"~/library/a.js\"), \"a\");\nrequire-app-root-1.0.0-a.tgz/test/main.js:17:\t\tt.ok(require(\"~/b.js\"), \"b\");\nrequiro-1.8.0.tgz/test/fixtures/package_root/a/1.js:2:module.exports = require(\"~/b\");\nrequiroify-1.2.1.tgz/test.js:6:var content = \"require('~/dummy')\";\nroot_require-0.0.0.tgz/test/index.js:6:  t.equal(require('~/a'), 123, 'prefix refers to project root')\nroot_require-0.0.0.tgz/test/index.js:7:  t.equal(require('~/a.js'), 123, 'file extension does not break things')\nroot_require-0.0.0.tgz/test/index.js:11:    require('~/a')\nroot_require-0.0.0.tgz/test/index.js:18:  t.equal(require('~/test/a'), 123, 'setRoot() uses package.json to determine root by default')\nroot_require-0.0.0.tgz/test/index.js:21:  t.equal(require('~/a'), 123, 'setRoot changes the root')\nroot_require-0.0.0.tgz/test/index.js:28:    require('~/a')\nsalesforce-storelocator-1.0.5.tgz/store_locator/cartridge/controllers/Stores.js:19:var dsStyles        = require('~/cartridge/scripts/modules/util/Styles.ds');\nslack-rx-event-1.0.0.tgz/examples/eventRouter/index.js:4:const slackRx = require('~/index.js')\nslack-rx-event-1.0.0.tgz/test/index.spec.js:5:const slackRx = require('~/index.js')\nstart-deepsweet-react-component-preset-0.0.6.tgz/lib/webpack/demo/index.js:11:var _demo = require('~/demo/');\nstart-deepsweet-react-component-preset-0.0.6.tgz/lib/webpack/demo/index.js:29:    renderDemo(require('~/demo/').default);\nstart-deepsweet-react-components-monorepo-preset-0.0.14.tgz/lib/webpack/demo/index.js:11:var _demo = require('~/demo/');\nstart-deepsweet-react-components-monorepo-preset-0.0.14.tgz/lib/webpack/demo/index.js:29:    renderDemo(require('~/demo/').default);\nsteal-conditional-1.1.3.tgz/test/relative-conditions/main.js:1:var foo = require(\"~/polyfill#?./some/deep/folder/dont-load-it\");\nsteal-conditional-1.1.3.tgz/test/relative-conditions/main.js:2:var bar = require(\"~/some/deep/#{./some/deep/folder/which}\");\nsteal-conditional-1.1.3.tgz/test/relative-conditions/main.js:11:require(\"~/some/deep/folder/test\");\nsteal-conditional-1.1.3.tgz/test/relative-conditions/some/deep/folder/test.js:1:var dotdotSlashX3 = require(\"~/some/deep/#{../../../some/deep/folder/which}\");\nsteal-conditional-1.1.3.tgz/test/relative-conditions/some/deep/folder/test.js:2:var dotdotSlashX3AndExport = require(\"~/some/deep/#{../../../some/deep/folder/which.foo}\");\nsteal-npm-1.0.11.tgz/test/import_test.js:302:\tvar app = \"var foobar = require('~/foo/foobar');\" +\nsteal-npm-1.0.11.tgz/test/import_test.js:303:\t\t\t\t\t\t\"var barfoo = require('~/./bar/barfoo');\" +\nsteal-npm-1.0.11.tgz/test/import_test.js:336:\tvar app = \"var foobar = require('~/foo/foobar');\" +\nszuprefix_crm-0.1.0.tgz/src/router/index.js:11:            component: require('~/views/index.vue')\nszuprefix_crm-0.1.0.tgz/src/store/index.js:6:require('~/configs/axios')\ntarantul-0.8.148.tgz/lib/server/app/api/registration.js:13:        return require('~/user/main').default;\ntarantul-0.8.148.tgz/lib/server/app/game.js:81:            result.push([key, require('~/user/main').default.create(user)]);\ntns-core-modules-5.4.1.tgz/profiling/profiling.js:132:    var appConfig = require(\"~/package.json\");\ntns-core-modules-5.4.1.tgz/ui/styling/style-scope.js:24:    var appConfig = require(\"~/package.json\");\ntns-i18n-0.0.10.tgz/index.js:9:  var defaults = require('~/i18n/' + defaultLang);\ntns-i18n-0.0.10.tgz/index.js:12:    strings = require('~/i18n/' + lang);\ntns-i18n-deep-0.0.13.tgz/index.js:8:  var defaults = require(\"~/i18n/\" + defaultLang);\ntns-i18n-deep-0.0.13.tgz/index.js:11:    strings = require(\"~/i18n/\" + lang);\ntoolkit-ui-0.12.1.tgz/src/plugins/i18n.js:20:      'en': require('~/locales/en.json'),\ntoolkit-ui-0.12.1.tgz/src/plugins/i18n.js:21:      'fr': require('~/locales/fr.json')\nuniversal-alias-loader-1.2.2.tgz/tests/alias-resolve.spec.js:84:    .toEqual(`require('~/pages/home/story.js')`)\nvalid8r-0.0.5.tgz/__test__/Validator.spec.js:1:const Validator = require('~/Validator')\nvcf-rntemplate-0.0.1.tgz/src/pages/Home/index.js:19:    \nvues-0.5.20.tgz/lib/__tests__/server.js:52:        require(\"~/test.css\")\nzhiwang-cli-1.0.1.tgz/framework/core/lvx-plugin.js:9:  this.src = require('~/src/assets/img/src/common/default_load.png')\n\n\n\nThat comes out to 92 modules in the public registry using this pattern.\nModuleBinder\nadfc-t30-paten-map\nastroman\nbabel-plugin-root-require\nbabel-plugin-sfcc-modules\nbael-cms-template\nbenben-frontend-generator\nbest-require\nblockstack-react-scripts\ncontacts_client\ncontainer-store\nctail\ndockular\ndorc\neasy-require\nelectron-ts-ipc\nember-fastboot-server\neos-framework\neslint-plugin-no-require-self-ref\nethical-server-middleware-react-redux\nethical-utility-require-browser\nexpress-api-starter-kit\nfastboot\nfastboot-ryanone-1.0.0\nfengyu-cli\nfsbx-2.1.0\nfusebox-cli\nganesh-api\ngenerator-furious\ngoman\ngpms_permission\ngridsome\ngrunt-init-react\nhmls\nhook-require-path\nignite-matt-oakes-react-native-boilerplate\nimpacter\nizi\nlsk-mobx\nlvx-cli\nmarko-starter\nmeta-client-0.0.0\nmongo-purge\nnativescript-dev-webpack\nnativescript-download-progress\nnativescript-tus-upload\nned-transpile\nnexus-repo\nnodecopter\nnuxt-feathers-vuex\nnuxt-i18n-module\nnuxt.js\nopen_castings_components\noyod\npanela\nplayland\nplex-vr\npostjss\nprism-cli\npult-cli\nquasar-application\nrachnerd-test-plugin\nreact-native-template-allmax\nreact-native-template-csorlandi-advanced\nreact-native-template-csorlandi-basic\nreact-native-template-feature-based-basic\nreact-native-template-feature-based-redux\nreact-native-template-scalable\nreact-native-template-scalable-redux\nreacteum\nreaction-build-1.0.0\nrequire-app-root-1.0.0\nrequiro\nrequiroify\nroot_require\nsalesforce-storelocator\nslack-rx-event\nstart-deepsweet-react-component-preset\nstart-deepsweet-react-components-monorepo-preset\nsteal-conditional\nsteal-npm\nszuprefix_crm\ntarantul\ntns-core-modules\ntns-i18n\ntns-i18n-deep\ntoolkit-ui\nuniversal-alias-loader\nvalid8r\nvcf-rntemplate\nvues\nzhiwang-cli\n\n\nFrom github it is harder to perform the search since ~ is stubbed out. 92 isn't terrible to audit by hand to see what is going on but a fair number of these seem to actually be using require dynamically with expressions or import which is harder to grep for. A small look into these, it looks like most are expecting ~ to be at some concept of a \"root\" but the root differs from application root vs package root. I think identifying packages that are mutating resolution to ensure we don't break them might be prudent. Packages not found naively sometimes are sizable enough to make me think a more thorough search is necessary babel-plugin-root-import.",
                            "createdAt": "2019-08-27T02:27:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Would it be more reasonable to add a separate api for this rather than relying on figuring out a new specifier?",
                            "createdAt": "2019-08-27T02:34:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 that would be much more confusing and complex for the massive ecosystem that handles resolution; and it wouldn\u2019t work as nicely with ESM. It\u2019s far cleaner to do it via specifier imo.",
                            "createdAt": "2019-08-27T03:04:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek tilde is the most commonly used alias in my experience (babel/webpack/TS) for this exact feature, package root. Do you have an alternative suggestion?",
                            "createdAt": "2019-08-27T03:05:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "# and & come to mind. Anything that isn't already widely used with a different meaning.",
                            "createdAt": "2019-08-27T03:36:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Since # is now the official symbol for \"private\" in Javascript, using it for \"public interface\" would be really confusing I think. ~ as a shorthand for \"the current package\" is following the ecosystem precedent but other symbols would be possible. For example @ or ^ or even a more complex prefix like <pkg> would be possible alternatives.",
                            "createdAt": "2019-08-27T16:24:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "Wouldn't the namespace approach make it different enough from home directory?",
                            "createdAt": "2019-08-27T16:42:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins Ah, gotcha. Right, if the issue is \"~/ could be confused with the home directory\", then we may be able to compromise on ~: even though the main may look weird (just ~:?). Or is the idea that we'd require a package name in addition to ~:, so ~:@foo/bar and checking against the name in package.json?",
                            "createdAt": "2019-08-27T16:52:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "My issue with the tilde is more of the fact that it's the first character in the string, which for the last 30 years has meant \"expand to $HOME\" in unix, and however long powershell has existed. If we're trying to make paths less confusing, I don't think using tilde at the start is the best approach.\nPerhaps :~ or @~?",
                            "createdAt": "2019-08-27T17:05:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "My 2c is over at nodejs/modules#306 (comment)\n\nI feel like if it is necessary Node.js can add some separate API for this, but if it for some reason needs to be within import statements then I strongly feel this should go to TC39, not us. (Although we may be able to make a recommendation.)",
                            "createdAt": "2019-08-27T17:09:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Requiring the package name defeats one of the benefits of having the alias, which is \u201cnot repeating the package name\u201d.",
                            "createdAt": "2019-08-27T17:11:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 TC39 is irrelevant here; there\u2019s no concept of a \u201cpackage\u201d and the spec intentionally avoids imposing any restrictions on specifier contents.",
                            "createdAt": "2019-08-27T17:11:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "my idea would be that ~: would refer to the root of the package so you could do\n~:named-export",
                            "createdAt": "2019-08-27T18:10:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "by \"named-export\" you mean, any specifier that's reachable from the package root, filtered through exports?",
                            "createdAt": "2019-08-27T18:14:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "FWIW, Parcel and other tools already implement tilde resolution as it is being proposed here. https://parceljs.org/module_resolution.html\nI don't think anyone would expect ~ to resolve to the home directory in the context of module resolution since this has never been true in node. It would also be pretty weird if it did resolve to the home dir since the resolution would change depending on the system it runs on, and thus would be non-portable.",
                            "createdAt": "2019-08-27T18:16:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "I don\u2019t think anyone would expect ~ to resolve to the home directory in the context of module resolution since this has never been true in node.\n\nI agree with this. Non-portable code is uncommon, and we shouldn\u2019t assume that that\u2019s the default or the user expectation. The only use case I can think of is the Node equivalent of shell scripts, but even those would probably usually use relative references.\nI think there\u2019s an advantage to reusing the ~ symbol, as users are already familiar with it meaning \u201chome.\u201d In the Node context, per this proposal, \u201chome\u201d would just mean the root of the package/project. I think that\u2019s what most users would expect, as evidenced by https://github.com/entwicklerstube/babel-plugin-root-import.",
                            "createdAt": "2019-08-27T18:46:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "Userland code can do whatever it wants, people opt into it. We don't plan to let this be overridden and I know at least three people I've talked to who would want avoid using tilde as an expansion.",
                            "createdAt": "2019-08-27T18:54:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek Asking explicitly: Would Myles' proposal change things (using ~: as the prefix) or is it a 100% if the first character is tilde, it's a no?",
                            "createdAt": "2019-08-27T19:54:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jkrems my critera above was \"what happens if i put it in bash\". For example on my computer ~snek expands to /home/snek, and ~: expands to ~/home/snek:.\nHowever, thinking about this further, I'm curious about whether this feature in general goes against our \"browser compatibility\" goals.",
                            "createdAt": "2019-08-27T20:24:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "However, thinking about this further, I'm curious about whether this feature in general goes against our \"browser compatibility\" goals.\n\nIt's just like any other bare specifier, in general. It's compatible with what can be expressed in the browser by generating the appropriate import map. The only difference is that this puts the main/exports entries within the scope of the package itself instead of into the scope of its dependents.",
                            "createdAt": "2019-08-27T20:31:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "My understanding from previous discussions was that \"supported by import maps\" wasn't good enough, did I miss something? And to be transparent, I don't dislike this feature, I just want to make sure we're being consistent with our design.",
                            "createdAt": "2019-08-27T20:36:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek There's a finer distinction between \"can be realistically done with import maps\" and \"could be done if you generate multiple entries for every single file\". The latter was the issue last time around. See the discussion above for why this may be falling on either side of that line. Maybe we would want some sort of opt-in signal so it doesn't require these entries for every single package.json file in the tree, even if it's never used.",
                            "createdAt": "2019-08-27T20:42:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Switched to @ as the new suggested sigil given that there were objections to ~. Anything but # works for me personally and it's a quick change if we end somewhere else after the bikeshed. :)",
                            "createdAt": "2019-08-27T20:44:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jkrems wouldn't you have to define an entry for each separate import? Maybe I'm misreading the import map proposal but I think if you don't it would pollute whatever our sigil is globally.",
                            "createdAt": "2019-08-27T20:45:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "I get the objections, but given that tilde is already implemented by many tools in this way, wouldn't node choosing a different symbol be creating unnecessary churn in the ecosystem?",
                            "createdAt": "2019-08-27T20:49:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@ can be a filesystem path so i don\u2019t think it\u2019s an option either.",
                            "createdAt": "2019-08-27T20:50:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek no, just one for the scope/dir",
                            "createdAt": "2019-08-27T20:51:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "anything easily typeable is a valid filesystem path on at least one platform, so i don't think its worth blocking on that.\n\njust one for the scope/dir\n\nthanks. would you mind posting an example for reference?",
                            "createdAt": "2019-08-27T20:52:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb It shouldn't matter that this is a valid file system char. That's true for anything but the null byte. We only look at this after all file system options have been exhausted so it shouldn't be breaking, no matter which prefix we choose.\nExample:\n// file:///foo/node_modules/bar/package.json\n{\n  \"main\": \"./bar.js\"\n}\n// file:///foo/node_modules/single/package.json\n{\n  \"main\": \"./single.js\",\n  \"exports\": {}\n}\n// file:///foo/node_modules/zapp/package.json\n{\n  \"main\": \"./zapp.js\",\n  \"exports\": {\n    \"./zapps/\": \"./dist/all/\",\n    \"./fav\": \"./dist/all/fav.js\"\n  }\n}\n// Resulting import map:\n{\n  \"imports\": {},\n  \"scopes\": {\n    \"file:///foo\": {\n      \"bar\": \"file:///foo/node_modules/bar/bar.js\",\n      \"bar/\": \"file:///foo/node_modules/bar/\",\n\n      \"single\": \"file:///foo/node_modules/single/single.js\",\n\n      \"zapp\": \"file:///foo/node_modules/zapp/zapp.js\",\n      \"zapp/zapps/\": \"file:///foo/node_modules/zapp/dist/all/\",\n      \"zapp/fav\": \"file:///foo/node_modules/zapp/dist/all/fav.js\"\n    },\n    \"file:///foo/node_modules/bar\": {\n      \"@\": \"file:///foo/node_modules/bar/x.js\"\n      \"@/\": \"file:///foo/node_modules/bar/\"\n    },\n    \"file:///foo/node_modules/single\": {\n      \"@\": \"file:///foo/node_modules/single/single.js\"\n    },\n    \"file:///foo/node_modules/zapp\": {\n      \"@\": \"file:///foo/node_modules/zapp/y.js\",\n      \"@/zapps/\": \"file:///foo/node_modules/zapp/dist/all/\",\n      \"@/fav\": \"file:///foo/node_modules/zapp/dist/all/fav.js\"\n    }\n  }\n}",
                            "createdAt": "2019-08-27T20:58:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@jkrems the import map you've provided seems to match the @ with a specific file. How would this expand to a local namespace or being self referential?",
                            "createdAt": "2019-08-27T21:57:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "One other thought. Would it make sense to limit self-references to exports found in the export map? if that were the case then it should solve the concern about browser compat as tooling would be able to statically determine all of the routes. although this would double the length of an export map :S",
                            "createdAt": "2019-08-27T22:02:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, i think it would.",
                            "createdAt": "2019-08-27T22:05:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins Updated the example to be more realistic about the entries. Originally I was just trying to show the existence of scopes, it wasn't meant to show the exact entries in each scope.\nThe short answer is: Yes, this would create one entry for each export rule, with main and the implicit default directory export counting as rules as well.\n\nWould it make sense to limit self-references to exports found in the export map?\n\nI'm not sure I follow this suggestion. I think it would be super confusing if it wouldn't work for main or for the default-dir export since that is the public interface of the package in that scenario.",
                            "createdAt": "2019-08-27T22:14:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "robpalme",
                                "__typename": "User"
                            },
                            "bodyText": "Would it make sense to limit self-references to exports found in the export map?\n\nWhilst it might be nice for self-references to be able to index into \"exports\", the main use-case I am aware for the existing ~ usage is to have clear absolute references to far-flung files inside the package, avoiding the long ../.. relative specifiers. So I think direct internal referencing is more valuable than exports-only referencing, if it came to a choice.",
                            "createdAt": "2019-08-28T07:59:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "If it\u2019s going to provide access to files that exports doesn\u2019t permit, then the # might be more appropriate, a la private fields?",
                            "createdAt": "2019-08-28T14:51:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "\"Access any file from the root of the project\" is a different feature with different use cases (and additional concerns). This is specifically trying to close a gap where it's currently impossible to reference the public interface of a package. So it's not just a convenience feature, it's a new capability.",
                            "createdAt": "2019-08-28T15:27:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "SMotaal",
                                "__typename": "User"
                            },
                            "bodyText": "Can I recommend staying away from special URL characters, even if it is not ambiguous in specifier form. It complicates debugging loader aspects needlessly at the very least.",
                            "createdAt": "2019-08-28T17:42:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "if this isn\u2019t pointing to os.homedir() i don\u2019t think tilde should be used. Just too surprising/confusing.\n\n@devsnek Tilde is no longer being used, do you mind dismissing your review?",
                            "createdAt": "2019-09-09T01:51:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Added ESM implementation and docs, removed WIP notice.",
                            "createdAt": "2019-09-12T20:26:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Rebased and delayed calculating exts until after we know that we need it for the self reference.",
                            "createdAt": "2019-09-19T22:57:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "I believe I just discovered a serious problem related to this \"@\" approach... quoting my tweets here about it:\n\nJust discovered a fairly serious \"bug\" with npm.\nI have a symlink in my node_modules directory like this:\n@ -> ../modules\nIn my app code, this lets me:\nrequire(\"@/whatever.js\")\nMy app's modules are stored in modules/, and this has worked fine for months.\nBut then...\nI did an npm install for a package, which failed (I believe unrelated), and I subsequently discovered that all my app's code inside modules/ had been deleted!\nLooking through the npm debug log, I notice that npm does this \"currentTree\" / \"idealTree\" comparison.\nApparently, npm's algorithm for managing the flattened node_modules/ tree structure sees this @ symlink as extraneous code inside node_modules/, code that it thinks it should auto-remove!\n:(",
                            "createdAt": "2019-09-20T14:05:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "I tried putting this in my package.json dependencies:\n\"@\": \"0.0.1\"\nThen I put a package.json in that modules/ directory that had the name \"@\" and the version \"0.0.1\".\nnpm still deleted everything in that directory, incl package.json.\nStrangely, it leaves the @ symlink.",
                            "createdAt": "2019-09-20T14:23:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@getify Isn't that good news for this approach? It means that using @ as a literal directory in node_modules doesn't work properly today, so for most people this shouldn't conflict with existing usage patterns.\nJust to clarify: If the npm problem is worked out, this PR shouldn't stop you from using node_modules/@. The logic here only applies if resolving from node_modules/@ failed. :)",
                            "createdAt": "2019-09-20T14:51:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@jkrems yes, but this means that given:\n/app/node_modules/@ -> /app/modules\n/app/node_modules/foo/index.js: require('@')\n\nwould have foo/index.js resolve that to /app/modules. This should probably have a stop gap at the nearest package to prevent apps from breaking containment of children?",
                            "createdAt": "2019-09-20T15:28:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck I'd like to err on the side of backwards compat. If that package is today resolving to a valid target using @, I don't think we should stop that.\nThe https://github.com/Rush/link-module-alias package does use package.json files to redirect file imports and also uses @ as a possible alias. So there's two scenarios:\n\nThe user of that package knows that using @ in node_modules isn't safe and may lead to data loss already. Your example doesn't apply because there is no @ in node_modules.\nThe user likes to live dangerously and is actively using @ to jump through different parts of the project, some of which may have unrelated local package.json files that should not stop propagation a search for node_modules/@. We'd break those existing projects when they upgrade node.\n\nI personally believe that (2) will go away because of the risks involved (as experienced by @getify) but it is something that is possible today. Also the problem you're talking about only applies if there is a path within @ that happens to match exactly the internal import of the package.\nI personally lean towards \"yes, this will not work for apps that choose to use @ as something meaningful in node_modules today\". But saying \"if you're depending on @ resolving to something across package.json boundaries, we don't consider it breaking\" would also work for me. But I do believe quite strongly that adding this feature shouldn't be a semver-major change.",
                            "createdAt": "2019-09-20T15:46:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "Also the problem you're talking about only applies if there is a path within @ that happens to match exactly the internal import of the package.\n\nThat is due to fall-through in CJS, that isn't true in our current ESM if I remember correctly.",
                            "createdAt": "2019-09-20T15:50:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck Good point, in ESM things get more complicated. There @ isn't a valid package name (which it actually verifies to some degree). But @/foo may be, so as long as node_modules/@/foo/package.json is a file, any self-reference starting with @/foo would resolve there even if the full specifier doesn't resolve. I think that's still acceptable?",
                            "createdAt": "2019-09-20T15:57:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "I'm neutral as long as it is known/put somewhere for people to reference when they encounter it. Even if it is just in this issue.",
                            "createdAt": "2019-09-20T16:01:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Is the argument for allowing @ in node_modules for backwards compatibility?",
                            "createdAt": "2019-09-20T16:05:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford It's the same argument that would apply to any character but \\0 - right now you can put them into node_modules/${x} and have them work. If self-reference takes precedent, it may shadow existing behavior a user depends on.",
                            "createdAt": "2019-09-20T16:13:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "It seems a highly unstable pattern, especially given the issues @getify describes with the severe usability problems. But caution may make sense I suppose.\nI would suggest though that in the ESM implementation we explicitly ensure it does not do this lookup, as it seems highly error prone when considering the soundness of the resolver itself.",
                            "createdAt": "2019-09-20T16:18:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I would suggest though that in the ESM implementation we explicitly ensure it does not do this lookup, as it seems highly error prone when considering the soundness of the resolver itself.\n\nThat is possible. The downside is that we'd end up in a situation where - potentially - both require and import successfully resolve to a target but it's a different one. Which is something we wanted to prevent.\n/**\n * /node_modules/@/foo.js/package.json\n * /node_modules/@/foo.js/index.js\n * /package.json\n * /foo.js\n */\n// In /foo.js:\nconst specifier = '@/foo.js';\nPromise.all([\n  // resolves to /foo.js because `@` isn't looked up in /node_modules\n  import(specifier),\n  // resolves to /node_modules/@/foo.js/index.js\n  { default: require(specifier) }\n])",
                            "createdAt": "2019-09-20T16:26:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "That is possible. The downside is that we'd end up in a situation where - potentially - both require and import successfully resolve to a target but it's a different one. Which is something we wanted to prevent.\n\nThat is true, but a rare edge case I can live with given the instability discussed above.\nNote there is another place where this happens - for the package main not found CJS fallthrough Bradley mentioned above.",
                            "createdAt": "2019-09-20T16:30:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "I would be very surprised if someone had packages inside node_modules that required @ and relied on it being implicitly available in an ancestor node_modules. @getify\u2019s use case is the one I\u2019d expect (and, rare, since ~ is ime the most common choice here) - and wouldn\u2019t be broken by having @ resolution stop at package boundaries.",
                            "createdAt": "2019-09-20T16:35:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "That is true, but a rare edge case I can live with given the instability discussed above.\n\nI'm pretty sure that's just a good argument for not doing it (the check for a folder named @) in any resolver. If it's currently mostly broken, I think keeping it (or making it) completely non-functional in pursuit of this is fine.",
                            "createdAt": "2019-09-20T16:37:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb There are people that create \"virtual\" node_modules directories that are checked in. I don't have a link handy but I've seen people suggest patterns like:\nproj/node_modules # third party\nproj/src/node_modules # all your code! easy to require!\n\nSo code being in node_modules doesn't necessarily mean \"code distributed via npm\". It can also mean \"somebody knows too much about node resolution rules and is feeling adventurous\".",
                            "createdAt": "2019-09-20T16:46:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "True. So the people here who are adventurous experts, and the subset of those who chose \u201c@\u201c, are the ones who might need to change to a different token to retain the same semantics?\nSeems like a small price to pay for a feature that actually behaves as one would expect, and the same in both module systems \u00af\\_(\u30c4)_/\u00af",
                            "createdAt": "2019-09-20T16:56:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Okay, trying to distill the package boundary proposal:\n\nAt the beginning of the existing node_modules logic (\"for bare specifiers\"), check if the bare specifier is @. If it is, for each search path:\na. If node_modules/@ exists, use existing logic for this package named \"@\". Break.\nb. If there's a package.json, resolve as self reference. Break.\n\nIt feels a bit complicated to handle what I would consider a tiny edge case (especially the fact that it needs to replicate search paths and scope checks with minor variations). But maybe I'm either missing something or it is just worth it?",
                            "createdAt": "2019-09-20T16:56:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "It feels a bit complicated to handle what I would consider a tiny edge case\n\nI agree. I feel like some core folks might complain that step 1a is a performance hit all the time, for an edge case that should be practically nonexistent.",
                            "createdAt": "2019-09-20T19:55:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "The alternative being, just don\u2019t allow a folder of @ to be resolved any more?",
                            "createdAt": "2019-09-20T21:40:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb Possible but definitely breaking I assume..? Maybe:\n\nAdd this feature as-is without breaking changes. There's a sharp edge for adventurous devs who currently use node_modules/@.\nAdd a docs-only deprecation for @ in node_modules.\nAdd a runtime deprecation in node >12.\nRemove support for @ in node_modules, make self-reference more efficient in node >(12+n).",
                            "createdAt": "2019-09-20T21:59:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "I mean... it might technically be breaking, but in practice, it's probably a completely unused edgecase - there's no good reason to have a (custom, non-npm) package or namespace named @... You can probably rip it out faster than that.",
                            "createdAt": "2019-09-21T01:30:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I mean... it might technically be breaking, but in practice, it's probably a completely unused edgecase\n\nThis discussion was triggered by a user report of using node_modules/@. Calling it \"probably complete unused\" seems a bit weird. And there is an ecosystem module that until recently suggested @ as a way to manage internal project targets.\nWe can tell people to rip it out but it feels awkward to just release a node version where previously working programs stop working. At least if we never officially deprecated the previous behavior. There's nothing in node right now suggesting that putting something into node_modules/@ isn't 100% valid.\nI'm not getting the disadvantage of not breaking it without notice. We have a solution in this PR that isn't a breaking change. We have established deprecation mechanisms in node to smooth it out longer term.",
                            "createdAt": "2019-09-23T16:19:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@jkrems that sounds like an argument for also supporting it from ESM though then?\nIf there are established conventions for @ then this is a scenario where changing the symbol to something without established conventions might help as well.",
                            "createdAt": "2019-09-23T16:24:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Anything practical that we choose will have nonzero users who would be broken by it. We should be attempting to avoid breakage where possible, ofc, but when that\u2019s not possible (like here) we should fine the path that will be the most straightforward and avoid silent failures.\nI think the suggestion above - to make @ never hit the fs - is likely to be the best option regardless of which token we use.",
                            "createdAt": "2019-09-23T16:27:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "I suppose if users are using @ already both in this issue and by the Rich Harris suggestion, then both cases are relying on the same behaviour that would be provided anyway by this PR approach without it needing to check node_modules. So what is still gained by having @ hit the fs anyway apart from an edge case of an edge case which seems completely unnecessary...",
                            "createdAt": "2019-09-23T16:31:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "that sounds like an argument for also supporting it from ESM though then?\n\nThat is true. If @ can resolve to something else in CJS then we'd have to support in ESM if we don't want to break the \"same specifier, same resolution or error\" rule. Which opens up the box of \"should ESM resolution of @ treat it as a namespace or as a package\". At which point I may become convinced that removing support for node_modules/@ isn't such a breaking change after all...",
                            "createdAt": "2019-09-23T16:34:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "After discussing with @jkrems I've pushed a commit to this PR to include the esm spec as well as updating the semantics to skip the node_modules check as discussed. I've also updated the main PR copy to reflect this.\nMore review would be very welcome.",
                            "createdAt": "2019-09-27T17:10:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "/cc @nodejs/modules-active-members I think this is ready for a round of reviews from collaborators. With that and a fresh CI run it should be good to land!",
                            "createdAt": "2019-09-27T17:19:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/25735/",
                            "createdAt": "2019-09-27T17:20:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "It seems this is ready to land. It would be great to get more approvals / comments / feedback if people want to share opinions further.",
                            "createdAt": "2019-09-28T22:36:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "I would still very much like to see this use ~ instead of @ for compatibility with existing tools in the ecosystem. It seems entirely unnecessary to invent a new syntax and create incompatibility here. The decision to use @ seems to have been made quite quickly and arbitrarily.",
                            "createdAt": "2019-09-29T00:10:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i wouldn't consider userland having done something to be an inherent reason that node should do it too, we'd probably have a lot of unsavory things in core if that were the case.",
                            "createdAt": "2019-09-29T01:03:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "\"userland\" is not even close to an appropriate description for other tools that implement JS module resolution. It's not like the tools I'm referring to are a third party extensions of Node or something. In fact, most of them have nothing to do with Node. Module resolution is not the exclusive purview of Node. There are plenty of tools in the ecosystem that all need to be compatible: bundlers, type systems, linters, etc. If there is existing precedence in the JavaScript ecosystem for a feature that Node is considering, then I think Node should take that seriously and attempt to avoid creating unnecessary incompatibility.",
                            "createdAt": "2019-09-29T01:35:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "can you link me to any tools that default to ~ besides parcel?\ntbh everything needing to work together leads me to further believe that package shortcuts like this are an antipattern.",
                            "createdAt": "2019-09-29T01:47:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "FuseBox (another bundler)\nbabel-plugin-root-import seems pretty widely used for this and uses tilde by default.\nI know Vue came up as well in our original discussions about this feature in Parcel, but I can't find it now.",
                            "createdAt": "2019-09-29T02:16:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "babel-plugin-root-import allows you to configure the prefix, and it certainly is userland (it also has 0.9% of the downloads of @babel/core, so i wouldn't call it a good representation of users one way or another).\nto be very transparent, i think this feature is an antipattern, but it seems people want it so i am being positive about it. Given that a configuration option is apparently not available here, i think it would be irresponsible of node to clobber such a well known prefix as tilde.\n@jkrems i apologize if my memory is failing here, but did we ever determine if a loader was able to fulfill this feature in a reasonable way? I don't think a node-loader-root-import to go along with babel-plugin-root-import would be too crazy from a usability perspective. If we decide that both using and not using tilde is a problem, that might be the way to go.",
                            "createdAt": "2019-09-29T02:34:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "did we ever determine if a loader was able to fulfill this feature in a reasonable way?\n\nThere's two things to keep in mind here:\n\nbabel-plugin-root-import isn't doing the same thing as this feature. It's importing as if the referrer were at the root of the project. This PR is importing as if the package was imported using a bare specifier.\nThis feature allows packages that use exports to test their public interface. Right now exports cannot be tested which is - to me - pretty close to a dealbreaker. You can technically work around it with a lot of custom setup (e.g. creating symlinks in node_modules that may be destroyed by the package manager), but I wouldn't call that a realistic solution.",
                            "createdAt": "2019-09-29T22:56:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "In other words: Yes, we could move this and the rest of exports into a loader. But I think it would be a shame because it would mean that you either couldn't use exports in your package or each one of your consumers would need to add the custom loader.",
                            "createdAt": "2019-09-29T22:58:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "thanks for clarifying. hopefully not using tilde isn't a deal-breaker then.",
                            "createdAt": "2019-09-29T22:59:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@devongovett I definitely get the sentiment - there's a reason I started this PR out with a ~. :) But I can understand the concerns about signaling / teachability. If somebody is familiar with *nix conventions, they may guess that ~/foo is trying to load from the home directory.\nI personally am fine with either @ or ~. But in the end a feature going into node needs to find consensus among node collaborators. I'm still hopeful that this means that we can get this feature now across bundlers with consistent semantics, including in a usable state in distributed packages.",
                            "createdAt": "2019-09-29T23:13:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devongovett",
                                "__typename": "User"
                            },
                            "bodyText": "It's importing as if the referrer were at the root of the file system.\n\nI think it resolves using the cwd as the default root, but you can configure what the root is. Either way, it refers to some \"home\" just like the shell ~ does.\nTo me, ~ just means \"home\". The exact location of \"home\" depends on the context. In the shell context, it already resolves to different locations depending on the machine and the logged in user. Node has never resolved ~ in any way, not even in path.resolve. I think it makes sense for node to apply this same concept of \"home\" to packages.\nI'm not going to push this anymore if you've all made up your minds, but I think the two arguments of precedence in other tools and reusing familiar concepts are strong.",
                            "createdAt": "2019-09-29T23:36:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Oops, typo above on my part. \"root of the project\" was what I meant, not \"root of the file system\".",
                            "createdAt": "2019-09-29T23:48:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "Personally I still prefer ~, and I agree that it\u2019s not so strongly associated with the user\u2019s home folder that we can\u2019t reuse it. In Windows, in particular, tildes have other uses such as denoting longer-than-8.3 filenames (remember FILENA~1.TXT?) or temporary files (~$myfile.doc). The user\u2019s home folder is referenced via %userprofile%.\nI\u2019m also fine with @; in CoffeeScript it\u2019s an alias for JavaScript\u2019s this, and in Ruby it refers to the current class instance, which are both pretty similar meanings to the self-reference proposed here. In many other languages such as Java and Python (and potentially JavaScript someday) it denotes a decorator, which I guess is also somewhat related to the concept.\nI\u2019m not sure how we settle subjective questions like this. Vote among core members? \ud83c\udf89 for ~ and \ud83d\udc40 for @?",
                            "createdAt": "2019-10-02T05:54:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "To use ~ would require the core collaborator who objected to it, @devsnek, to withdraw the objection.",
                            "createdAt": "2019-10-02T12:57:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I\u2019m not sure how we settle subjective questions like this. Vote among core members?\n\nGenerally speaking: If another core member decides to represent the ~ preference, it could be decided by the TSC. Right now there are no objections by a core member to @.",
                            "createdAt": "2019-10-02T15:29:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I prefer ~, for the main reason that is the \"home\" folder in unix, I do not oppose to @ anyway.",
                            "createdAt": "2019-10-02T16:16:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "also will there be a way to disable this? I think it's an antipattern and i don't want it to be used in my code.",
                            "createdAt": "2019-10-02T16:26:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "The way to disable things you think are antipatterns is called a \"linter\" :-p",
                            "createdAt": "2019-10-02T16:33:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "also will there be a way to disable this? I think it's an antipattern and i don't want it to be used in my code.\n\nIt's pretty easy to detect in linters, so I assume that will be the solution. To me it's mostly targeted for use in libraries that want to reference their public interface in the implementation. I agree that using it in application code to randomly jump around in the directory structure is an anti-pattern just like excessive use of ../../../.",
                            "createdAt": "2019-10-02T16:33:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Happy to add something to eslint-plugin-import btw that can disable/require it.",
                            "createdAt": "2019-10-02T16:34:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Is there a way/plan/something to get consensus on what the character should be? Is that the only thing keeping this from landing at this time?",
                            "createdAt": "2019-10-04T05:38:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I'm now aware of two concerns about the current version:\n\nThere are concerns about using @ vs. ~. Mostly based on a similar but different feature in bundlers that uses ~ (there it usually refers to some sort of static project root, not to the closest package boundary relative to the importer).\nCurrently it applies unconditionally to each package boundary which means that it necessarily doubles the required import map entries when trying to run the same code in the browser. This could be addressed using an explicit opt-in signal in package.json so that it at least only applies to packages actually using the feature.\n\nThe second one is something I could see being worked out in the thread. The first has fairly strong lines drawn in the sand on each side afaict. One side believes that ~ in a specifier is associated with the unix/bash convention of resolving to $HOME and shouldn't be used. The other believes that the related ecosystem feature created precedent for ~ and it should be used because it's what users would expect.",
                            "createdAt": "2019-10-04T16:43:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "It\u2019s entirely possible that import maps could add a feature that could avoid the size gain by using this feature in the future; that seems like something that can be addressed when/if it becomes an actual problem.",
                            "createdAt": "2019-10-04T16:53:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "To update here - we agreed at the yesterday's modules meeting that we are happy with whatever symbol here the TSC would like to move forward with. @mcollina has the TSC had a chance to discuss this yet? Suggestions re getting that consensus here further welcome.",
                            "createdAt": "2019-10-10T16:55:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "To update here - we agreed at the yesterday's modules meeting that we are happy with whatever symbol here the TSC would like to move forward with. @mcollina has the TSC had a chance to discuss this yet? Suggestions re getting that consensus here further welcome.\n\n/ping @nodejs/tsc\nI'll also tag this tsc-agenda so it will be on the next meeting agenda if there's no obvious consensus based on discussion here.",
                            "createdAt": "2019-10-10T17:49:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "If I'm the tie-breaker on the TSC or whatever, I'll make a decision. But I'm content to defer to the folks on the TSC who are more invested in ES modules than I am, such as @MylesBorins and @targos.",
                            "createdAt": "2019-10-10T17:51:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "So a thought. There are still some semantics of import-maps being worked out, and I'd like us to be sure that whatever we do here is going to be compatible. Would folks be open to landing this behind a flag for now... that would give us the option to change semantics as well as the character without many problems.\nFrom an DX standpoint I prefer ~... thankfully if we put this behind a flag we can have so,e time to confirm that isn't an issue",
                            "createdAt": "2019-10-14T21:44:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "(Moved to issue description.)",
                            "createdAt": "2019-10-14T21:54:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "Can someone clarify for me....\nvar x = require(\"~/whatever\")\nWhat directory path will that resolve to? __dirname+\"/node_modules/\"?",
                            "createdAt": "2019-10-14T21:55:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@getify with the new exports feature you are able to explicitly define your modules exports via package.exports. See https://nodejs.org/dist/latest-v12.x/docs/api/esm.html#esm_package_exports for more details.\nMy understanding is the ~/* would reference the exports as defined in the map in your package.json\nPTAL at https://nodejs.org/dist/latest-v12.x/docs/api/esm.html#esm_package_exports for more details",
                            "createdAt": "2019-10-14T22:03:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "What directory path will that resolve to?\n\nThe intuition is \"relative to the current package\". It would start with the directory of the file (__dirname), check if it contains a package.json (\"is it a package\"), and continue with the parent directories until it finds a package.json (\"find the closest package\"). Then it will resolve relative to the package. You can see it in action in the test files of this PR.\nPlay-through with your example\n// in /path/to/lib/foo.js\nvar x = require(\"~/whatever.js\");\n\nCheck if /path/to/lib/package.json exists. We assume it doesn't. Switch to parent directory.\nCheck if /path/to/package.json exists. It does!\nResolve the remainder (./whatever.js) as a package subpath relative to the package in /path/to.",
                            "createdAt": "2019-10-14T22:05:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "getify",
                                "__typename": "User"
                            },
                            "bodyText": "OK, thanks for the clarifications... So if it's ultimately chosen to use \"@\" instead of \"~\", am I correct that it would break my current usage of require(\"@/whatever.js\"), which with my symlink currently treats that not as a \"relative\" include but like an absolute include rooted at the same level as \"node_modules/\" location.",
                            "createdAt": "2019-10-14T22:15:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Not necessarily. We are exploring an opt-in signal (like a package.json\nfield) that would have to be set for the self-reference logic to apply. In\nthat scenario, it would likely fail to find such a signal and fall back to\nstill searching the node_modules paths. Which will find your symlink. :)\n\u2026\nOn Mon, Oct 14, 2019 at 3:17 PM Kyle Simpson ***@***.***> wrote:\n OK, thanks for the clarifications... So if it's ultimately chosen to use\n \"@\" instead of \"~\", am I correct that it would break my current usage of\n require(\"@/whatever.js\"), which with my symlink currently treats that not\n as a \"relative\" include but like an absolute include rooted at the same\n level as \"node_modules/\" location.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#29327?email_source=notifications&email_token=AAEKR5AMUC24IOMRFA5WDHLQOTVX5A5CNFSM4IPWVHE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBGZACI#issuecomment-541954057>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AAEKR5F3CZAJPU4TXWVON63QOTVX5ANCNFSM4IPWVHEQ>\n .",
                            "createdAt": "2019-10-14T22:22:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/tsc to get the vote going here, please vote in this comment what your preference for package-relative loading would be and ideally we can come to a conclusion on this fairly swiftly by the meeting. The modules group has previously confirmed it will go with whatever symbol the TSC has consensus on.\n\ud83c\udf89 = \"@\" symbol for loading relative to a package's own root\n\ud83d\ude80 = \"~\" symbol for loading relative to a package's own root\n\ud83d\ude41 = would prefer neither option (ideally please provide further context)\n\ud83d\udc40 = abstaining\nNote: Please do not vote on this comment if you are not a @nodejs/tsc member.",
                            "createdAt": "2019-10-15T15:23:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "myles suggested putting this behind a flag, in which case i don't really care what it does.",
                            "createdAt": "2019-10-15T15:30:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sam-github",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not sure if you can get a meaningful vote from the TSC without a bit better description of what is being voted on. Or maybe the rest of the TSC is right up to speed on this... but I'm not! And after I spent 5 minutes trawling through the comment history here and in nodejs/modules#306, I'm still not sure I am.\nFrom what I gather ~/ makes some people think of $HOME/, @/ reminds me of @ for package scopes. For both, the scope is different, shell glob chars don't show up in require() statements, and package.json depspecs don't show up in require() statements, but if one is considered too close for comfort, maybe the other one is, too?\nWhat is the exact behaviour of the sigil going to be? Will it always be followed by /, or is ~name/sub and @name/sub also possible? What other options were considered? Is there any prior art/equivalent feature in ES6 modules, or do Webapps not have this problem?",
                            "createdAt": "2019-10-15T16:26:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@sam-github the ES spec says nothing about specifier contents. The community prior art is things like https://www.npmjs.com/package/babel-plugin-root-import, where the sigil is configurable but most defaults are ~.\nSubpaths are possible - it will read from \"exports\" if present, otherwise it will read from the package's filesystem, just like any deep require/import.",
                            "createdAt": "2019-10-15T17:12:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "What is the exact behaviour of the sigil going to be? Will it always be followed by /, or is ~name/sub and @name/sub also possible?\n\nI know it's easy to get lost in the flood of content - the logic is mentioned in the PR description. It only applies to the exact specifier @ (no other characters after it) or a specifier that starts with @/. So @name/sub wouldn't be recognized as a self-reference since it doesn't fit either condition.",
                            "createdAt": "2019-10-15T17:34:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "Suggestion from TSC is to land this PR behind a flag to allow more time to work out semantics. There were strong opinions regarding both existing sigil suggestions but overall sentiment was that this is something the modules team should work out not for the TSC to decide.\nI think we should keep bikeshedding on this a bit and we can bounce ideas off the TSC in the future if we want more feedback.",
                            "createdAt": "2019-10-16T15:47:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "sam-github",
                                "__typename": "User"
                            },
                            "bodyText": "Has anyone considered % or $, or maybe  -? Choosing a sigil that isn't used in file system interactions or package tooling would let this entire thing be bypassed. I don't have strong feelings about any of the sigils, either proposed sigil, or another one, seem fine to me.\nAnd wrt. not worrying too much, landing this behind an experimental flag, and hoping to change it later after more discussion... past experience on inertia is that once landed, it won't change, and while we \"can\" (according to policy on changing experimental behaviour) change it before the features is unflagged, current users of an experimental feature would find that pretty annoying! Better to agonize over it now, and then just be happy with whatever lands, IMO.",
                            "createdAt": "2019-10-16T15:52:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Just thinking about the sigil... I'm likely missing context so I'm sorry if I'm duplicating prior settled discussion... would any of the following work:\n\nrequire('$')\nrequire('${module_name}')\nrequire('{module_name}$')\n\nThe reason for the $ is that it is not @, which is used for scoped modules, and is not ~ which can be confused with tilde expansion semantics\n(jinx with @sam-github's comment above ;-) ...)",
                            "createdAt": "2019-10-16T15:52:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I think @ was partially chosen because of its association with \"scope\". I read it as \"the self scope\" or \"own scope\". But I do appreciate that this may not be most people's initial reading.\n\n%: On windows (for most people their primary OS) that's an environment variable. Since specifiers in modules can be URLs, it could also get confusing with URL encoding. Doesn't have to be a blocker but could be awkward for %/a%20b.js.\nimport '$': Not sure if I'm alone in thinking \"that's importing jQuery?\". We may be moving past that generation of developers though..?\n\nThere's also ^ (\"go to the beginning\") or !. I'm -0.5 on - because it feels like to common of an operator / token already used by people.\nrequire('${module_name}') looks a lot like a shell expansion and in most ESLint configurations would be highlighted as an error (\"accidental use of template string?\"). There was also strong pushback against anything containing the name of the package since it seemed too verbose.\nFor me personally I could also totally see import 'pkg-name'. In other words: Importing the current package by its literal name without any special characters (and assuming it hasn't been found as a dependency in node_modules). See above though for the \"too verbose\" objection raised by others.",
                            "createdAt": "2019-10-16T16:39:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "For me personally I could also totally see import 'pkg-name'. In other words: Importing the current package by its literal name without any special characters (and assuming it hasn't been found as a dependency in node_modules). See above though for the \"too verbose\" objection raised by others.\n\nPerhaps we can start with the verbose option and not worry about saving people keystrokes for now? Then a symbol can be added at a later date if one is standardized or consensus forms around one and only one symbol?",
                            "createdAt": "2019-10-16T17:42:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott it's not about keystrokes. It creates a refactoring hazard as packages - or merely folders containing package.json - have their name changed. Also, many apps don't have a name at all.\nIt doesn't make any sense to me for a not-guaranteed-to-exist-or-be-unchanged package name to be required here.",
                            "createdAt": "2019-10-16T17:47:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott it's not about keystrokes. It creates a refactoring hazard as packages - or merely folders containing package.json - have their name changed. Also, many apps don't have a name at all.\nIt doesn't make any sense to me for a not-guaranteed-to-exist-or-be-unchanged package name to be required here.\n\nI should have known better than to try to participate in a modules discussion without reading EVERYTHING carefully first. Thanks. That helps a lot. And I'll stop now until I'm caught up....",
                            "createdAt": "2019-10-16T17:54:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "It doesn't make any sense to me for a not-guaranteed-to-exist-or-be-unchanged package name to be required here.\n\nAt the risk of starting an off-topic discussion: This feature exposes a way to refer to the \"public interface\". I think it's reasonable to assume that it's not an unnamed package and also reasonable to assume that a fundamental change to the public interface (like renaming the package) would require updates to references to the public interface.",
                            "createdAt": "2019-10-16T17:56:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I find pretty much any of the other sigil suggestions preferable to ~ (which i am very against, as it is very confusing). @ seems reasonably suitable to me, unless something like (self) is on the table.",
                            "createdAt": "2019-10-16T17:59:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "Pending discussion with the import maps team I still think we may want to\nconsider using a scope for this `~:export-name`\n\nThis has the benefit of the signal that ~ carries while keeping it clear\nthat it isn't in the path of what you are referencing.\n\nIt would require import maps being able to polyfill arbitrary scopes, I'll\nfollow up on that.\n\u2026\nOn Wed, Oct 16, 2019, 1:59 PM Jeremiah Senkpiel ***@***.***> wrote:\n I find pretty much any of the other sigil suggestions preferable to ~\n (which i am very against, as it is very confusing). @ seems reasonably\n suitable to me, unless something like (self) is on the table.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#29327?email_source=notifications&email_token=AADZYV6FKWWWU5BRNO7O3MLQO5JAHA5CNFSM4IPWVHE2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEBNMS5Y#issuecomment-542820727>,\n or unsubscribe\n <https://github.com/notifications/unsubscribe-auth/AADZYV25THLFSMOKDCNDP3TQO5JAHANCNFSM4IPWVHEQ>\n .",
                            "createdAt": "2019-10-16T22:22:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mcollina",
                                "__typename": "User"
                            },
                            "bodyText": "I would be in strong support of the package name itself. This would solve an old problem for me: testing examples (as I have to change . with the name).",
                            "createdAt": "2019-10-16T23:07:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "I would be in strong support of the package name itself. This would solve an old problem for me: testing examples (as I have to change . with the name).\n\nThat was actually the original proposal.",
                            "createdAt": "2019-10-16T23:31:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I updated the TODO comment to \"use the package name\" instead of any special sigil. @mcollina's comment reminded me of all the times that I wished this was a feature in the past.",
                            "createdAt": "2019-10-17T14:51:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "I still very much do not want the package name to be used here. It\u2019s redundant, and verbose, and the feature will be used in non-published packages as a \u201cpackage root\u201d feature anyways (in an app, I\u2019d add the JS root to \u201cexports\u201d and use the sigil, even tho my package is never published and thus has no external interface).",
                            "createdAt": "2019-10-17T15:00:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I still very much do not want the package name to be used here.\n\nWe're explicitly landing behind a flag so we can iterate on details like this. I've come around to think that supporting the package name is very important, because it fixes a long-standing annoyance (\"you can't test examples by default\"). So a short-hand would be additive but is unlikely to replace support for the full name (since the short-hand couldn't work in that use case).\nSo far I don't think anybody has brought up reasons why the full name isn't a valid solution (with the potential for adding a shorter \"sugar\" specifier in the future). Which I think should also address @sam-github's concerns about not landing - even behind a flag - if we don't think it could ship in that form, at least initially.",
                            "createdAt": "2019-10-17T15:12:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "I\u2019ve been using evalmd to test examples for years; I\u2019m not sure what the annoyance is.\nDespite npm not allowing you to install a same-named package, what happens when that\u2019s a dir that exists?",
                            "createdAt": "2019-10-17T15:37:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "I\u2019ve been using evalmd to test examples for years; I\u2019m not sure what the annoyance is.\n\nThat may work for examples in markdown files. It doesn't work well for code copied from tests or checked into examples/ directories.\n\nDespite npm not allowing you to install a same-named package, what happens when that\u2019s a dir that exists?\n\nIf there's a \"real\" package of that name, it's required instead. Realistically this happens if a package is installed and a traditional node_modules tree is present. In which case the behavior would be functionally identical with a \"true\" self-reference.",
                            "createdAt": "2019-10-17T15:54:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "dead-claudia",
                                "__typename": "User"
                            },
                            "bodyText": "I have a question regarding the name variant, too: does this go based on pkg.name or the calling directory name? Yarn and npm both support \"alias\": \"npm:foo\", which installs foo to node_modules/alias.",
                            "createdAt": "2019-10-17T16:12:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@isiahmeadows The TODO comment is more precise than my summary of it: package.json#name. Since it's the package referencing itself, I don't think it could possible be based on where it happens to be on disk. E.g. a local checkout will \"never\" match the name of the package, especially for scoped packages. Aliases are the least of our problems there - it would break as soon as somebody checks out the repo under a different directory name.",
                            "createdAt": "2019-10-17T16:19:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "It still feels to me like it\u2019s violating DRY to force repetition of the package name within itself.",
                            "createdAt": "2019-10-17T17:17:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb That's fair. But as I said above - I do care about the examples use case. And a sigil cannot work in that use case (or at least nobody has brought up how it possibly could). That doesn't mean that we cannot add sugar in the future. But I believe the feature is valuable without it and I personally don't feel like the sugar is an important enough aspect to wait on it.\nThe implementation overhead of supporting some kind of sugar would likely be a few characters, so if somebody wants to add it (and get consensus on it), I won't stand in their way once the feature itself lands. :)",
                            "createdAt": "2019-10-17T17:48:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "I'd be happy to go with the package.json \"name\" again as I do prefer it.\nWhen one package imports from another it uses the package name. When a package imports from itself to use that same name does seem sensible to me. The approach is compatible with any sort of package aliasing exceptions as the internal name can still apply fine.\nThe original proposal was to use a name, and it makes any generated import maps much shorter as we don't have \"@\" symbols being created for every package, which quickly inflates the package map size in my implementations of this.",
                            "createdAt": "2019-10-17T18:35:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Created an issue to track open questions before unflagging: nodejs/modules#403",
                            "createdAt": "2019-10-18T18:50:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Discussed in the modules meeting (see nodejs/modules#407):\n\nThe team is okay with landing behind a flag in its current form.\nEnabling this feature isn't considered blocking for enabling modules or exports.",
                            "createdAt": "2019-10-23T20:39:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Also:\n3. we will iterate further (but not urgently) on adding a sigil as well as a name self-reference.",
                            "createdAt": "2019-10-23T23:11:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/26182/",
                            "createdAt": "2019-10-24T15:19:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/26183/",
                            "createdAt": "2019-10-24T15:41:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/26184/",
                            "createdAt": "2019-10-24T17:20:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Looks like two HTTP tests are timing out on Windows: https://ci.nodejs.org/job/node-test-binary-windows-2/3677/COMPILED_BY=vs2017-x86,RUNNER=win2012r2,RUN_SUBSET=1/testReport/",
                            "createdAt": "2019-10-24T17:44:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/26185/",
                            "createdAt": "2019-10-24T17:45:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "So much \u2764\ufe0f to the build team for making \"Resume Build\" happen.",
                            "createdAt": "2019-10-24T17:56:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "nodejs-github-bot",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/26188/",
                            "createdAt": "2019-10-24T21:27:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Landed in 71bcd05",
                            "createdAt": "2019-10-24T22:15:02Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 758,
            "title": "Implement unhandled rejection tracking",
            "author": {
                "login": "petkaantonov"
            },
            "state": "CLOSED",
            "closedAt": "2015-02-25T00:30:43Z",
            "comments": {
                "totalCount": 146,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome! I think this is the least argumentive way to go forward requiring the least changes to core.\n(cc @paulirish )",
                            "createdAt": "2015-02-08T17:46:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "We clearly have a misunderstanding about WeakMap. I think you can achieve the same behaviour with plain Map. Here is diff to illustrate (I was trying to do exactly what you are doing):\ndiff --git a/src/env-inl.h b/src/env-inl.h\nindex c5f2328..27e09cd 100644\n--- a/src/env-inl.h\n+++ b/src/env-inl.h\n@@ -331,6 +331,14 @@ inline Environment::IsolateData* Environment::isolate_data() const {\n   return isolate_data_;\n }\n\n+inline void Environment::RunAfterLoopCallback() {\n+  v8::Handle<v8::Function> callback = this->after_loop_callback();\n+\n+  if (!callback.IsEmpty()) {\n+    callback->Call(this->process_object(), 0, nullptr);\n+  }\n+}\n+\n // this would have been a template function were it not for the fact that g++\n // sometimes fails to resolve it...\n #define THROW_ERROR(fun)                                                      \\\ndiff --git a/src/env.h b/src/env.h\nindex 4a4eaa3..75f6703 100644\n--- a/src/env.h\n+++ b/src/env.h\n@@ -215,6 +215,7 @@ namespace node {\n   V(zero_return_string, \"ZERO_RETURN\")                                        \\\n\n #define ENVIRONMENT_STRONG_PERSISTENT_PROPERTIES(V)                           \\\n+  V(after_loop_callback, v8::Function)                                        \\\n   V(async_hooks_init_function, v8::Function)                                  \\\n   V(async_hooks_pre_function, v8::Function)                                   \\\n   V(async_hooks_post_function, v8::Function)                                  \\\n@@ -398,6 +399,8 @@ class Environment {\n   inline bool printed_error() const;\n   inline void set_printed_error(bool value);\n\n+  inline void RunAfterLoopCallback();\n+\n   inline void ThrowError(const char* errmsg);\n   inline void ThrowTypeError(const char* errmsg);\n   inline void ThrowRangeError(const char* errmsg);\ndiff --git a/src/node.cc b/src/node.cc\nindex 990feea..cf8298b 100644\n--- a/src/node.cc\n+++ b/src/node.cc\n@@ -1002,6 +1002,16 @@ void SetupPromises(const FunctionCallbackInfo<Value>& args) {\n       FIXED_ONE_BYTE_STRING(args.GetIsolate(), \"_setupPromises\"));\n }\n\n+void SetAfterLoopCallback(const FunctionCallbackInfo<Value>& args) {\n+  Environment* env = Environment::GetCurrent(args);\n+\n+  if (args[0]->IsFunction()) {\n+    env->set_after_loop_callback(args[0].As<Function>());\n+  }\n+\n+}\n+\n+\n\n Handle<Value> MakeCallback(Environment* env,\n                            Handle<Value> recv,\n@@ -2779,6 +2789,8 @@ void SetupProcessObject(Environment* env,\n   env->SetMethod(process, \"_setupPromises\", SetupPromises);\n   env->SetMethod(process, \"_setupDomainUse\", SetupDomainUse);\n\n+  env->SetMethod(process, \"_setAfterLoopCallback\", SetAfterLoopCallback);\n+\n   // pre-set _events object for faster emit checks\n   process->Set(env->events_string(), Object::New(env->isolate()));\n }\n@@ -3710,6 +3722,7 @@ int Start(int argc, char** argv) {\n     bool more;\n     do {\n       more = uv_run(env->event_loop(), UV_RUN_ONCE);\n+      env->RunAfterLoopCallback();\n       if (more == false) {\n         EmitBeforeExit(env);\n\n@@ -3718,6 +3731,7 @@ int Start(int argc, char** argv) {\n         more = uv_loop_alive(env->event_loop());\n         if (uv_run(env->event_loop(), UV_RUN_NOWAIT) != 0)\n           more = true;\n+        env->RunAfterLoopCallback();\n       }\n     } while (more == true);\n     code = EmitExit(env);\ndiff --git a/src/node.js b/src/node.js\nindex a8278c1..51b26b8 100644\n--- a/src/node.js\n+++ b/src/node.js\n@@ -395,6 +395,7 @@\n     // this should be kept in sync with PromiseRejectEvent in v8.h\n     var kPromiseRejectWithNoHandler = 0;\n     var kPromiseHandlerAddedAfterReject = 1;\n+    var pendingRejections = new Map();\n\n     function promiseRejectCallback(event, promise, value) {\n\n@@ -406,19 +407,43 @@\n\n     function promiseRejectWithNoHandlerCallback(promise, value) {\n       var rejection = new PromiseRejection(promise, value);\n-      process.emit('unhandledPromiseRejection', promise, rejection);\n-\n-      if (!rejection.isHandled()) {\n-        process.nextTick(function() {\n-          throw value;\n-        });\n-      }\n+      pendingRejections.set(promise, rejection);\n+\n+      // process.emit('unhandledPromiseRejection', promise, rejection);\n+      //\n+      // if (!rejection.isHandled()) {\n+      //   process.nextTick(function() {\n+      //     throw value;\n+      //   });\n+      // }\n     }\n\n     function promiseHandlerAddedAfterRejectCallback(promise) {\n-      process.emit('unhandledPromiseRejectionHandled', promise);\n+      var pendingRejection = pendingRejections.get(promise);\n+\n+      if (pendingRejection) {\n+        pendingRejections.delete(promise);\n+      } else {\n+        process.emit('unhandledPromiseRejectionHandled', promise);\n+      }\n+\n     }\n\n+    process._setAfterLoopCallback(function() {\n+\n+      for (let rejection of pendingRejections.values()) {\n+        process.emit('unhandledPromiseRejection', rejection.promise, rejection);\n+\n+        if (!rejection.isHandled()) {\n+          process.nextTick(function() {\n+            throw rejection.value;\n+          });\n+        }\n+      }\n+\n+      pendingRejections.clear();\n+    });\n+\n     function PromiseRejection(promise, value) {\n       this.promise = promise;\n       this.value = value;",
                            "createdAt": "2015-02-08T19:39:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "An example of nondeterministic behaviour:\nprocess.on('unhandledRejection', function() {\n  console.log('unhandledRejection');\n});\n\nvar p = Promise.reject();\n\nsetImmediate(function() {\n  var a = Promise.reject();\n\n  process.nextTick(function() {\n    a.catch(function(){});\n\n  });\n});\nLogs unhandledRejection 2 times. Comment out first rejection: logs 0 times",
                            "createdAt": "2015-02-08T19:59:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin good example - @petkaantonov  why is the wait not promise specific? Is firing one per promise expensive?",
                            "createdAt": "2015-02-08T20:11:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin the WeakMap and array are because there are two distinct collections here - one holding the promises to be reported at the next turn as unhandled - it's life duration is one turn and it should not hold references to promises for longer than that. The other is a map of all unhandled rejections so we can report them as handled - this has to retain a reference to these promises for all eternity but it must not hold a strong reference to the promises since that would interfere with GC (if something was GC'd it's impossible for it to be later handled).\nIf we use a regular map either we don't retain promises long enough or we leak because we keep a reference to them",
                            "createdAt": "2015-02-08T20:20:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "The other is a map of all unhandled rejections so we can report them as handled\n\nwe don't need this. We have a map, we emit events for every rejection in the map and clear it. After that, if we receive kPromiseHandlerAddedAfterReject and promise is not in the map, we know that the event was emitted already an we need another one (rejectionHandled). No need to store these promises at all",
                            "createdAt": "2015-02-08T20:25:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin using the afterLoopCallback these will have different behavior:\nvar p = Promise.reject()\nsetImmediate(function() {\n  p.catch(function(){});\n});\nsetImmediate(function() {\n  p.catch(function(){});\n});\nvar p = Promise.reject()\nIt also occasionally causes all the tests to fail.",
                            "createdAt": "2015-02-08T20:28:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "#758 (comment) is an interesting example. As far as I can tell @petkaantonov is basically following https://gist.github.com/domenic/9b40029f59f29b822f3b#promise-error-handling-hooks-rough-spec-algorithm (with setImmediate = notify-rejected task... not sure why it's setImmediate + process.nextTick though?). So if we want to eliminate that example, which we almost certainly do, then we should probably fix the spec in that case.",
                            "createdAt": "2015-02-08T21:06:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "That is only because I was using nextTick as a generic micro task scheduler, when I use Promise.resolve().then(fn) as microtask scheduler, it works",
                            "createdAt": "2015-02-08T21:16:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov can you help me undesrstand why you do setImmediate + schedule a microtask, instead of just doing the work directly inside setImmediate?",
                            "createdAt": "2015-02-08T21:18:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Also if it is necessary you may be able to use V8 natives to do the equivalent semantically without creating two promises: https://code.google.com/p/v8/source/browse/branches/bleeding_edge/src/promise.js#120",
                            "createdAt": "2015-02-08T21:20:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "So that\nvar p = Promise.reject()\nsetImmediate(function() {\n  p.catch(function(){});\n});\nsetImmediate(function() {\n  p.catch(function(){});\n});\nvar p = Promise.reject()\nGive the same result",
                            "createdAt": "2015-02-08T21:20:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Basically as soon as you write Promise.reject() v8 calls the rejection hook synchronously, so a setImmediate is synchronously called right as you call Promise.reject() - so this would cause those above snippets to have different result which is very undesirable I think.",
                            "createdAt": "2015-02-08T21:24:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "That makes sense. However it's kind of a losing game, right? E.g. now you've just pushed off the problem so that\nvar p = Promise.reject();\nsetImmediate(function() {\n  Promise.resolve().then(function () {\n    p.catch(function(){});\n  });\n});\nvs.\nsetImmediate(function() {\n  Promise.resolve().then(function () {\n    p.catch(function(){});\n  });\n});\nvar p = Promise.reject();\ngive different results.",
                            "createdAt": "2015-02-08T21:27:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Oh right. Well, what I want is basically scheduleMacroTaskAfterAllOtherMacroTasks",
                            "createdAt": "2015-02-08T21:31:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Yeah I see. I think we should either do that or we should give up and let it be order-dependent.",
                            "createdAt": "2015-02-08T21:33:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I should be able to add internal method that adds to setImmediate's \"late queue\". (it doesn't exist probably)",
                            "createdAt": "2015-02-08T21:34:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov what's so bad about a setTimeout with 0 like @vkurchatkin suggested?",
                            "createdAt": "2015-02-08T21:36:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr Even using setTimeout with 0 this fails:\ncommon.asyncTest(function(done) {\n  var e = new Error();\n  onUnhandledFail(done);\n  setImmediate(function() {\n    var a = Promise.reject();\n    process.nextTick(function() {\n      a.catch(function(){});\n    });\n  })\n});",
                            "createdAt": "2015-02-08T22:19:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Given that I never care about looking dumb.... @petkaantonov, what about setTimeout(fn, 1) :D? Wouldn't a non-zero value fix it?",
                            "createdAt": "2015-02-08T22:21:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "That causes this to fail\ncommon.asyncTest(function(done) {\n  var e = new Error();\n  onUnhandledFail(done);\n  var _reject;\n  var promise = new Promise(function(_, reject) {\n    _reject = reject;\n  });\n  setImmediate(function() {\n    promise.then(assert.fail, function(){});\n  });\n  _reject(e);\n});\nFWIW the best behavior I got was using setImmediate with V8 microtask from promise. Any other combination I tried fails in mythical ways, almost as if setImmediate, setTimeout and nextTick were coupled in some strange ways.",
                            "createdAt": "2015-02-08T22:22:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Right, so a quick recap on where this PR stands.\nOpen issues with the PR:\n\nAs @vkurchatkin said a WeakMap + array isn't needed - we can do this with an array or a map. @petkaantonov has already started working on implementing it this way.\nAs @domenic said, it's probably a good and the easiest thing thing to report after setImmediate (a macrotask). I believe that while this will not have awesome precision and might report false positives when async exception handlers are attached (which is itself very rare in my experience) the alternatives have proven to be inconsistent. So I suggest logging unhandled rejections this way - the added benefit is that we can always improve precision and recall of this at a later PR.\n\nThings that are interesting to talk about as a result of the PR but should not postpone it:\n\nA default handler to untracked rejections. There are a lot of strong opinions on this and it's a very big issue that can be a breaking change. In my opinion it should be postponed to a future PR\nDiscussing how to run the hook with a guarantee a whole macro+micro task has passed - as several people have noted this has proven to be very hard because of how setImmediate and other deferring mechanisms are implemented (namely - things like the fact a nested setImmediate does not act the same as a non-nested one).",
                            "createdAt": "2015-02-09T07:03:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Rebased, fixed issues and squashed all commits into one",
                            "createdAt": "2015-02-09T12:17:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin Fixed one-line block braces.",
                            "createdAt": "2015-02-09T16:05:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I see two problems:\n\nsetImmediate. We can do better. Right now implementation looks random and unjustified. If we want to flush notifications at the very end of event loop turn, we should do THAT. @domenic said that he probably needs to fix the spec. So there's clearly a lot to think about.\nThink about the following case. We want to throw by default (or whatever default action). Some module wants to suppress this behaviour for specific promises because it's ok for them to be in rejected state. How can you do that with current implementation?",
                            "createdAt": "2015-02-09T16:09:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The spec is fine, just that there is nothing in io.js that is called at the end of turn all the time. setImmediate is closest but if you are already in a setImmediate callback then any further setImmediate is called synchronously instead of being called at the end of the turn. The implementation you suggested using setAfterLoopCallback randomly drops out and simply doesn't call the callback.\nAs @domenic said, you can attach a .catch(functon(){}) if you want to suppress unhandled rejection for specific promises.",
                            "createdAt": "2015-02-09T16:15:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "setImmediate. We can do better. Right now implementation looks random and unjustified. If we want to flush notifications at the very end of event loop turn, we should do THAT. @domenic said that he probably needs to fix the spec. So there's clearly a lot to think about.\n\nIt's certainly not random after all the discussions we've had about it and different attempts. The time we defer to can and should be further finer grained in the future to a more precise estimation. In practice bluebird and when (existing userland implementations of this) don't wait even that long since synchronous adding of error handlers is a very very very rare thing to do anyway so I think we should go forward with this and improve the detection logic later - this in no way prevents further pull requests from waiting more time for the report.\n\nThink about the following case. We want to throw by default (or whatever default action). Some module wants to suppress this behaviour for specific promises because it's ok for them to be in rejected state. How can you do that with current implementation?\n\nThrowing by default is a big choice to make and it's very divisive (read Domenic's comments above) - it's also a breaking change. I think it should be deferred to a future PR and issue and not discussed here - these hooks are very useful even without a default active action and adding it at a later point will be just as easy.\nI think we should debate this elsewhere but a module can suppress this for a single promise by adding a .catch(function(){}) to it for ignoring rejections for example as Domenic said in the original issue.",
                            "createdAt": "2015-02-09T16:16:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov the spec is not exactly fine; it says to enqueue a task (equivalent to setImmediate), and not anything about the end of turn. I think either would be OK.",
                            "createdAt": "2015-02-09T16:17:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov\n\nthere is nothing in io.js that is called at the end of turn all the time\n\nWe can make it. There is no much value in this being in core if just use \"what we have\".\n\nyou can attach a .catch(functon(){})\n\nyeah, that works. I somehow missed it.\n@domenic what if we just use microtask instead? that would be so much easier",
                            "createdAt": "2015-02-09T16:24:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin  basically the point is to be able to say Promise.reject(...).catch(function(){}) and it should never cause any notification. If we can achieve that with microtask, that's fine  by me.",
                            "createdAt": "2015-02-09T16:25:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov we can! also I think it's safe to do this now and change later to setImmediate or something else.",
                            "createdAt": "2015-02-09T16:30:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin no, microtask is pretty bad, as you want to at least be able to delay deciding to catch by a microtask. Honestly I'd be more comfortable with e.g. 1 second, but that's too arbitrary, so a macrotask is better.",
                            "createdAt": "2015-02-09T16:30:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "as you want to at least be able to delay deciding to catch by a microtask\n\nso you want this to work:\nvar p = Promise.reject();\n\nprocess.nextTick(function() {\n  p.catch(...);\n});\nwe can do that, no need for setImmediate",
                            "createdAt": "2015-02-09T16:33:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "The point I'm trying to make here is that anything that defers to any later\nturn of the loop will catch the vast majority of unhandled rejections and\neither version will report back handled ones just fine - this can and\nshould be fine grained later. I'm like @petkaantonov - ok with any variant\nthat defers execution including nextTick, however if we're using one we\nmight as well use setImmediate like Domenic suggested since it has that\nadded benefit.\nOn Mon, Feb 9, 2015 at 4:31 PM, Domenic Denicola notifications@github.com\nwrote:\n\n@vkurchatkin https://github.com/vkurchatkin no, microtask is pretty\nbad, as you want to at least be able to delay deciding to catch by a\nmicrotask. Honestly I'd be more comfortable with e.g. 1 second, but that's\ntoo arbitrary, so a macrotask is better.\n\u2014\nReply to this email directly or view it on GitHub\n#758 (comment).",
                            "createdAt": "2015-02-09T16:33:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "setImmediate cause this: #758 (comment)\nTo avoid it you will have to call setImmediate for each rejection, not just once",
                            "createdAt": "2015-02-09T16:36:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin I also want that to work for any arbitrary nesting of process.nextTick and Promise.resolve().then(fn).\nI also want to do something that can work well in both browsers and Node.js. Right now setImmediate (including the test case you point out) is a good analogue, because it's equivalent to queueing a task. Maybe we could investigate an end-of-task thing as well.",
                            "createdAt": "2015-02-09T16:37:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin we can call setImmediate for each rejection that's fine with me - Petka?",
                            "createdAt": "2015-02-09T16:38:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic that's possible, we have full control of it\n\nMaybe we could investigate an end-of-task thing as well.\n\ncould you elaborate on that?",
                            "createdAt": "2015-02-09T16:42:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin I don't know if browsers and related specs have a similar notion to \"run this after all other macrotasks\". So we'd want to investigate if they do, or are willing to add one, before creating such a notion in io.js to use for this feature.",
                            "createdAt": "2015-02-09T16:44:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Using unique setImmediate per promise fixes this:\ncommon.asyncTest(function(done) {\n  var e = new Error();\n  onUnhandledFail(done);\n  var a = Promise.reject(e);\n\n  process.nextTick(function() {\n    Promise.resolve().then(function() {\n      process.nextTick(function() {\n        Promise.resolve().then(function() {\n          a.catch(function()\u00a0{});\n        })\n      })\n    })\n  });\n});\nSo that you can now interleave as many microtasks in between and there is no notification.\nHowever still same problem persist as before, when you are already inside setImmediate callback, the whole thing blows up.",
                            "createdAt": "2015-02-09T16:58:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Would a setTimeout(..., 0) fix that?\nOn Mon, Feb 9, 2015 at 4:59 PM, Petka Antonov notifications@github.com\nwrote:\n\nUsing unique setImmediate per promise fixes this:\ncommon.asyncTest(function(done) {\nvar e = new Error();\nonUnhandledFail(done);\nvar a = Promise.reject(e);\nprocess.nextTick(function() {\nPromise.resolve().then(function() {\nprocess.nextTick(function() {\nPromise.resolve().then(function() {\na.catch(function() {});\n})\n})\n})\n});\n});\nSo that you can now interleave as many microtasks in between and there is\nno notification.\nHowever still same problem persist as before, when you are already inside\nsetImmediate callback, the whole thing blows up.\n\u2014\nReply to this email directly or view it on GitHub\n#758 (comment).",
                            "createdAt": "2015-02-09T17:00:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "setTimeout sometimes fires before setImmediate and sometimes after... making some tests fail randomly",
                            "createdAt": "2015-02-09T17:05:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin how do you think we should go forward?",
                            "createdAt": "2015-02-09T17:23:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr Well I am doing _setLateImmediate which adds to a late queue which is only drained when the early immediate queue has been completely drained.",
                            "createdAt": "2015-02-09T17:24:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I think we should emit notifications after microtasks right now. It could be safely changed later",
                            "createdAt": "2015-02-09T17:42:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "I strongly disagree and would rather not this be merged if those are the semantics.",
                            "createdAt": "2015-02-09T17:46:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Well I have already implemented late immediates and late microtasks, timers._setLateImmediate will run the given callback after all other immediates are ran and after all other microtasks are ran.",
                            "createdAt": "2015-02-09T17:47:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic what's the problem? All nested nextTicks and microtasks would run before",
                            "createdAt": "2015-02-09T17:56:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I have now working implementation of lateTick which is basically run microtask after all microtasks have been completely drained. So this means you can do any combination of nested microtasks and no notification is caused:\n// Doesn't cause any notification\nvar a = Promise.reject();\nPromise.resolve().then(function() {\n    process.nextTick(function() {\n        Promise.resolve().then(function() {\n            process.nextTick(function() {\n                a.catch(function() {});\n            });\n        });\n    });\n});\nIsn't this what you wanted @domenic ?",
                            "createdAt": "2015-02-09T18:36:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "So this means you can do any combination of nested microtasks and no notification is caused:\n\nI guess this is OK. I am unsure it is as good, because sometimes you'd rather be able to enqueue a full task in between. (In general I am in favor of later, as noted above.) With that in mind can you explain\n\nHowever still same problem persist as before, when you are already inside setImmediate callback, the whole thing blows up.\n\n?",
                            "createdAt": "2015-02-10T01:38:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Also maybe we are going in circles but what goes wrong if you do lateImmediate? (= task that happens after all other tasks, right?)",
                            "createdAt": "2015-02-10T01:41:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Also maybe we are going in circles but what goes wrong if you do lateImmediate? (= task that happens after all other tasks, right?)\n\nit turned out to be unnecessary to get  the behavior you wanted (the ability to attach a catch handler after any amount of any type of microtask and not get notification). Youd need lateTick on top of lateImmediate anyway so it was just pointless additional code.",
                            "createdAt": "2015-02-10T01:50:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "However still same problem persist as before, when you are already inside setImmediate callback, the whole thing blows up.\n\nThis was just to say that simply queueing unique setImmediate per rejection wasnt enough to solve the problem with using setImmediate",
                            "createdAt": "2015-02-10T01:58:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov what are the implications for userland promises implementations here, are they able to hook into this functionality or do they generally already provide their own?",
                            "createdAt": "2015-02-10T02:22:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg several userland libraries provide the same functionality based on the specification of these two events. You can track their status here: https://gist.github.com/benjamingr/0237932cee84712951a2\nHow long an implementation must wait to report is implementation dependent so other methods can be explored in the future (like detection via GC for example).\nUserland promises will also greatly benefit from this hook since it will give people the ability to catch all promise rejections that were unhandled in a central location regardless of promise library or how many libraries your project and its dependencies are using.",
                            "createdAt": "2015-02-10T06:16:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr is it going to be simple for userland libraries to hook in to this and all end up behaving the same? Will they just have to do a process.emit('...') and handle the timing themselves or is there a better hook?\nAlso, like many others who aren't exercised about promises, I find it difficult to get my head into the details of this so if this discussion is coming down to needing answers on specific questions then it would be helpful for someone in here to distill that so that others like me can give some advice and perhaps help steer this towards landing. fwiw this feature actually makes me a bit more comfortable about Promises in general because it makes it more difficult to ignore error handling (which is one of the main gripes I have against Promises); so I'd lean towards a more aggressive failure policy like with uncaughtException but I understand that it's not quite that straightforward here.",
                            "createdAt": "2015-02-10T06:31:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I'd lean towards a more aggressive failure policy like with uncaughtException but I understand that it's not quite that straightforward here\n\nThis is what a lot of people expect, but there are use cases for promises where rejections should be completely ignored. So, throwing by default is a breaking change",
                            "createdAt": "2015-02-10T06:49:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg\n\nis it going to be simple for userland libraries to hook in to this and all end up behaving the same? Will they just have to do a process.emit('...') and handle the timing themselves or is there a better hook?\n\nDoing a process.emit and handling the timing themselves. It's worth mentioning that this is already implemented in several libraries. Being in charge of the promises and not just emitting the event gives promise libraries some interesting control - for example if you're creating a promise in a then chain and not returning it and it gets rejected - bluebird will not only report the rejection, it will also let you know that it happened because of that reason. This is impossible with the current hooks v8 promise offer.\nTo be fair we could opt to offering userland promise libraries a cleaner hook but I'm less than excited about exposing anything other than two events to the userland - I think anything involving this that can be implemented outside of core regarding this should.\n\nAlso, like many others who aren't exercised about promises, I find it difficult to get my head into the details of this so if this discussion is coming down to needing answers on specific questions then it would be helpful for someone in here to distill that so that others like me can give some advice and perhaps help steer this towards landing.\n\nLuckily we have @vkurchatkin here who has done a very good job so far helping us with this issue representing io.js interests that Petka or Domenic or I are not always aware of. I think that this PR is a lot nicer now and the new scheduling Petka implemented is very nice. I think that this PR is generally ready but there is still a lot more work to do about making promises more debuggable - like I said before there are still things to improve here but they can be improved in future PRs.\n\nfwiw this feature actually makes me a bit more comfortable about Promises in general because it makes it more difficult to ignore error handling (which is one of the main gripes I have against Promises); so I'd lean towards a more aggressive failure policy like with uncaughtException but I understand that it's not quite that straightforward here.\n\nFirst of all about debuggability and suppressed errors I completely agree - this is why I'm pushing for this so hard. Native promises are a nightmare to work with at the moment in terms of debuggability and will silently fail when an exception is thrown - this hook fixes this and lets users gain control of their code.\nAs for a more aggressive failure policy - I definitely agree that this is something that should be explored but it's a much much harder question since it can break existing code and makes assumptions on the way people use promises. It's a big decision to make in my opinion and it requires research on usage - people use these hooks in many different ways and making a decision here is going to take time and research.\nBecause choosing a default action and deciding on a more precise algorithm for scheduling are things that require research and discussion - I believe this PR should land and a future PR can address these. This PR makes the least changes possible: just exposing two events and not changing any existing behavior.",
                            "createdAt": "2015-02-10T07:17:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg\n\nwhat are the implications for userland promises implementations here, are they able to hook into this functionality or do they generally already provide their own\n\nUserland promise libraries cannot hook into this at all, they have to fire these events manually as they best see fit when the library sees its promises being rejected without them having a catch handler attached by the end of a turn. The io.js runtime has no knowledge of these promises as they are just custom user objects.\nThe userland libraries that provide the sufficient hooks needed to implement any error handling scheme, provide them through the same protocol as used in this PR.\n\nI'd lean towards a more aggressive failure policy like with uncaughtException but I understand that it's not quite that straightforward here\n\nThis is out of scope for this PR but FWIW according to the data, the majority, I (and it seems many io.js maintainers too) prefer to use synchronous catch handlers and the simpler and more aggressive error handling scheme that it enables. But it is indeed possible to attach catch handlers asynchronously and some people are strong proponents for that so the hooks should be able to support that as well, in fact that's the entire reason a second hook type is even needed. However we can all discuss that till the end of times in another PR, this PR doesn't take any stance to that and simply provides the hooks needed to accomplish both schemes (and some other alternative schemes too).",
                            "createdAt": "2015-02-10T08:41:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "In terms of being able to do any sort of continuation tracking (e.g. the work I've done on AsyncWrap), V8 still hasn't exposed enough API. Currently any call stack that enters a Promise will be broken, and there's nothing we can do about that. IOW, even if this is the best solution we could hypothetically manage right now, it's not the solution we want for the long term.",
                            "createdAt": "2015-02-10T19:18:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris these are independent issues, I think. Both are important, but this one is possible with API we already have",
                            "createdAt": "2015-02-10T19:22:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris yeah that's an interesting issue with the call stack and AsyncWrap but I agree with @vkurchatkin  that the issues are independent and unhandled rejection tracking - even without good call stacks is something that can be exposed now and is future compatible.",
                            "createdAt": "2015-02-10T19:22:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "I don't see why any of this should be enabled unless the user has explicitly set the 'unhandledPromiseRejection' event.",
                            "createdAt": "2015-02-10T19:25:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris I completely agree that for this PR no default event handler should be enabled. Deciding whether or not a default action should be enabled can, and should be deferred to a future PR. I think we've reached consensus on that.\nNote that what you suggest (not performing any default action) is what happens in this PR right now. There is interesting discussion between @domenic and @vkurchatkin about this in the outdated diffs if you care.",
                            "createdAt": "2015-02-10T19:27:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr I mean _setupPromises() should run until 'unhandledPromiseRejection' has been set.",
                            "createdAt": "2015-02-10T19:30:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris in the future we definitely want some default action on unhandled rejections, console.error most likely",
                            "createdAt": "2015-02-10T19:36:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin There's a lot of extra queue'ing going on for nextTick because of promises, and that will have a performance hit. Optimally we could detect whether a Promise has been used, and set it lazily, but that's probably not an option.",
                            "createdAt": "2015-02-10T19:42:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris I'm also wondering about _setupPromises - I agree it would be really nice to run it lazily but I have no idea how an implementation of that would look like - I was under the impression that it's relatively cheap to call.\nAlso - why is there extra queuing to nextTick if promises are not used?",
                            "createdAt": "2015-02-10T19:45:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr It's not about the call to _setupPromises() specifically. It's about all the extra code that's run while processing callbacks that were passed to nextTick().",
                            "createdAt": "2015-02-10T19:47:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris this could be solved by something like nodejs/node-v0.x-archive#8648 (comment)",
                            "createdAt": "2015-02-10T19:49:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris I'm sorry if I'm being daft but what extra code is run when processing callbacks that were passed to nextTick?",
                            "createdAt": "2015-02-10T19:49:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "There is no extra code running while processing next tick callbacks and no extra code in general runs at all. There is one .length check per every full drainage of the tick queue and that's it.",
                            "createdAt": "2015-02-10T19:59:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Just going to recap what's going on in case anyone else didn't see the code flow:\n\nstartup.processPromises() runs process._setupPromises().\nprocess._setupPromises() passes the callback PromiseRejectCallback() to SetPromiseRejectCallback().\nPromiseRejectCallback() is only called in the cases of kPromiseRejectWithNoHandler or kPromiseHandlerAddedAfterReject.\n\nWhen PromiseRejectCallback() is called a callback is pushed onto lateTickQueue.\n\n\nWhile the nextTickQueue is being processed, if lateTickQueue.length != 0 then the callback queued is executed.\n\nOkay, now I see what you're saying about no extra code being executed. Didn't see that at first.",
                            "createdAt": "2015-02-10T20:33:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris thanks for that. :)",
                            "createdAt": "2015-02-10T20:37:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "I think we might be missing the case where a callback in process.nextTick() throws. The stack is handled differently in that case, and how do we want to handle any unhandled rejection callbacks that have been queued but are still waiting for the potential exception from nextTick to be handled by a domain or such?",
                            "createdAt": "2015-02-10T21:14:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I am trying to create a test for that but the domain is not catching the error for some reason\ncommon.asyncTest(function(done) {\n  var d = domain.create();\n  var domainReceivedError;\n  d.on(\"error\", function(e) {\n    domainReceivedError = e;\n  });\n  d.run(function() {\n    var e = new Error(\"error\");\n    var domainError = new Error(\"domain error\");\n    onUnhandledSucceed(done, function(reason, promise) {\n      assert.strictEqual(reason, e);\n      assert.strictEqual(domainReceivedError, domainError);\n      d.dispose();\n    });\n    setImmediate(function() {\n      var a = Promise.reject(e);\n      process.nextTick(function() {\n        Promise.resolve().then(function() {\n          process.nextTick(function() {\n            throw domainError;\n          })\n        })\n      });\n    });\n  });\n});",
                            "createdAt": "2015-02-10T21:27:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov nodejs/node-v0.x-archive#8648",
                            "createdAt": "2015-02-10T21:30:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "This seems to work for me in latest io.js:\nvar domain = require('domain');\nvar d = domain.create();\nvar domainReceivedError;\nd.on(\"error\", function(e) {\n  console.log('hi');\n  domainReceivedError = e;\n});\nd.run(function() {\n  var e = new Error(\"error\");\n  var domainError = new Error(\"domain error\");\n  onUnhandledSucceed(done, function(reason, promise) {\n    assert.strictEqual(reason, e);\n    assert.strictEqual(domainReceivedError, domainError);\n    d.dispose();\n  });\n  setImmediate(function() {\n    var a = Promise.reject(e);\n    process.nextTick(function() {\n      Promise.resolve().then(function() {\n        process.nextTick(function() {\n          throw domainError;\n        })\n      })\n    });\n  });\n});\n\n// output:\n// hi",
                            "createdAt": "2015-02-10T21:32:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "It was probably the combination of asyncTest and promises, it works just fine now as :\ncommon.asyncTest(function(done) {\n  var d = domain.create();\n  var domainReceivedError;\n  d.on(\"error\", function(e) {\n    domainReceivedError = e;\n  });\n  d.run(function() {\n    var e = new Error(\"error\");\n    var domainError = new Error(\"domain error\");\n    onUnhandledSucceed(done, function(reason, promise) {\n      assert.strictEqual(reason, e);\n      assert.strictEqual(domainReceivedError, domainError);\n      d.dispose();\n    });\n    var a = Promise.reject(e);\n    process.nextTick(function() {\n      throw domainError;\n    });\n  });\n});",
                            "createdAt": "2015-02-10T21:40:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris it catches onUnhandledSucceed is not defined",
                            "createdAt": "2015-02-10T21:45:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin ah thanks. domain and promises. definitely not two of my strong areas...",
                            "createdAt": "2015-02-10T23:25:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Summarizing what's going on and progress. PR has been looked at by @vkurchatkin , @rvagg @Fishrock123 and @trevnorris  all left useful comments. (Especially thanks to @vkurchatkin for all the help and trev for all the useful comments yesterday).\nThe currently open issues are:\n\nAllocating a closure for every .reject called - @petkaantonov is this something that can be fixed easily here?\nPosition and calling of runMicrotasksCallback - this was already discussed and petka is rolling a fix tomorrow.\n\nClosed issues are:\n\nDefault behavior if no handler is attached - consensus is to decide this at a later PR/issue. Once this is merged I'll open such an issue.\nVarious code style convention issues (positions of braces etc).\nThe collection used to hold the rejections (started off as a WeakMap and an array, optimized thanks to a comment @vkurchatkin made).\nWhen to run the unhandled rejection check - it was decided and so far uncontended that the next time to run this is when all microtasks have finished running. Several other alternatives were suggested but as the tests indicate this is the version that works best given the (good) constraints @domenic  and @vkurchatkin raised.\n\nDiscussed and closed before the PR:\n\nInteroperability concerns with how this will be handled with browsers. Was discussed with Domenic and Paul Irish from Google. Domenic is working on\nInteroperability with userland promise libraries - Bluebird and When implement this. RSVP and es6-promise said they'll intergrate this soon. Other promise libraries said they'll likely go forward. I wrote a PR for Q (still need to fix some stuff there) - Kris said he'll likely merge it this weekend.\nNaming it and other bikeshed issues.\n\nJust adding - awesome work keeping up with all this @petkaantonov \ud83d\udc4d\nI'll write another update after the next round of updates.",
                            "createdAt": "2015-02-11T13:40:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "The collection used to hold the rejections (started off as a WeakMap and an array\n\nWeakMap is back in, as I can see",
                            "createdAt": "2015-02-11T13:57:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Yes the WeakMap is needed after it was changed to schedule unique task per promise. Another way is to add new field (symbol or string) to the promise object but this is less preferable than weakmap I think.\nClosure allocation is avoided trivially by making the lateTickQueue specialized for this case",
                            "createdAt": "2015-02-11T13:58:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "lateTickQueue specialized for this case\n\nyes, that's what I meant.\nAfter some thoughts, we probably still need an array of promises, because it is better to emit events in the same order as rejections actually happened",
                            "createdAt": "2015-02-11T14:04:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The WeakMap is not used a data structure but as a way to add expansion fields to the promise object without actually adding them. That cannot be replaced with an array.\nThe order of the events is based on the order of the lateQueue array which is in same order as the rejections.",
                            "createdAt": "2015-02-11T14:07:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "The WeakMap is not used a data structure but as a way to add expansion fields to the promise object without actually adding them.\n\nThat's a big part of why WeakMaps were added to ECMAScript in the first place - it's definitely a valid use case for WeakMaps.",
                            "createdAt": "2015-02-11T14:08:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I removed the closure but IMO since without closure it is necessary to share variables between next tick startup and promise startup it's not worth it as the optimization has no real benefits since rejections are meant to be used like exceptions.",
                            "createdAt": "2015-02-11T17:59:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "rejections are meant to be used like exceptions.\n\nAgreed.",
                            "createdAt": "2015-02-11T20:08:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Right, so the performance concerns have been addressed and the fix for the timing of calling runMicrotasksCallback has been fixed.\n@vkurchatkin in terms of code functionality are we good to go?",
                            "createdAt": "2015-02-12T12:22:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Qard",
                                "__typename": "User"
                            },
                            "bodyText": "To me, it makes the most sense that promise failure should be consistent with streams failure in that it throws unless there is an explicit event handler.",
                            "createdAt": "2015-02-12T18:25:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks @Qard but we have decided ( I think?) to defer choosing the default action to another PR - see the comments above.",
                            "createdAt": "2015-02-12T20:05:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Since you're going to discuss this in the TC meeting I'm wondering if you have any more questions/issues that you'd like to discuss before it - anything that can be clarified please let us know.",
                            "createdAt": "2015-02-17T07:01:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "I wrote a native module that does Isolate::SetPromiseRejectCallback() and simply fprintf's when it's called. Along with the PromiseRejectMessage passed. Here's the test script:\nvar p = new Promise(function(fulfill, reject) {\n  throw new Error('hey!');\n});\np.then(function() { }, function() { });\nHere's the output:\npromise_reject: 1  (kPromiseHandlerAddedAfterReject)\npromise_reject: 0  (kPromiseRejectWithNoHandler)\n\nSo it seems to be calling the callback more often than it should?",
                            "createdAt": "2015-02-18T19:31:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris I'm not sure I understand so correct me if I misunderstood your comment: v8 lets you know when any promise is rejected at any time (and not only unhandled ones) - it reports the rejections synchronously. That's why this PR needs the map for keeping track of rejections and waiting for all microtasks to run before calling the hook.\nLike you said yourself earlier - rejections are like errors (much more rare than fulfillements) so this shouldn't really be an issue anyway.",
                            "createdAt": "2015-02-18T19:34:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris Yeah, the v8 hooks are too eager, hence the need for additional code and this PR to implement the unhandled rejection spec",
                            "createdAt": "2015-02-18T19:54:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr It appears that V8 runs the Promise callback immediately, then reports what happens in the future. Instead of running the callback in the future and reporting the results immediately. Here's the code to demonstrate:\nvar p = new Promise(function(fulfill, reject) {\n  process._rawDebug('promise');\n});\np.then(function() { }, function() { });\nprocess.nextTick(function() {\n  process._rawDebug('nextTick');\n});\n// output:\n// promise\n// nextTick\nAnd since the promise throws an exception V8 saves the state of the call at that point in time. If V8 instead ran the callback in the future it would have already detected that a reject handler was added, and neither error would have been reported.",
                            "createdAt": "2015-02-18T20:11:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris unlike then there is no requirement in the specification that the promise constructor runs asynchronously. When you do new Promise the code you pass into it is run synchronously. This is for people to support \"deferred like\" APIs.",
                            "createdAt": "2015-02-18T20:14:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "It appears that V8 runs the Promise callback immediately\n\nhttps://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-executor",
                            "createdAt": "2015-02-18T20:14:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "Ah I was confused, I thought @trevnorris was talking about the callback he passed to SetPromiseRejectCallback()",
                            "createdAt": "2015-02-18T20:16:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr It's more about the impression of how Promises work. Never having looked at the spec, and knowing the fulfill/reject callbacks always run in the future, I assumed that the \"executor\" would have also been run asynchronously.",
                            "createdAt": "2015-02-18T20:34:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris that was not criticism, the topic of when it executes was a pretty long debate.\nWhen is this PR landing :D?",
                            "createdAt": "2015-02-18T21:28:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr no worries. wasn't taken as such.\nSo it seems there is no standard, or even near consensus, of when the Promise executor should be called?",
                            "createdAt": "2015-02-18T21:58:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "I think you have misunderstood, the executor function must be called synchronously and it's specified in es6",
                            "createdAt": "2015-02-18T22:07:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Thanks for clarifying. I can't see how that's specified by the link you posted, but I'll believe you. :)",
                            "createdAt": "2015-02-18T22:13:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris it's the 10th step\n\n\nLet completion be Call(executor, undefined, \u00abresolvingFunctions.[[Resolve]], resolvingFunctions.[[Reject]]\u00bb).",
                            "createdAt": "2015-02-18T22:17:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov Ah, okay. I didn't realize the steps had to be completed in synchronous execution order. Figured they'd just need to be executed in that order, but at possibly indeterministic times.",
                            "createdAt": "2015-02-18T23:51:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@trevnorris can we land this?",
                            "createdAt": "2015-02-20T14:22:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "trevnorris",
                                "__typename": "User"
                            },
                            "bodyText": "@iojs/collaborators As the person who dislikes Promises more than probably any other collaborator, I would really like another LGTM before this goes in.\nLGTM.",
                            "createdAt": "2015-02-20T17:45:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I have a few questions/requests:\n\nI would like @domenic to LGTM this explicitly before it goes in\nscheduleMicrotasks() usage addPendingUnhandledRejection requires a FIXME notice. It works and it's rather harmless, but still a hack. I can do this myself if I'm going to land this\nMaybe we can emit rejectionHandled event in a microtask? /cc @domenic\n@petkaantonov  can you add tests to check that throwing/nextTick/microtask from event handlers works as expected?",
                            "createdAt": "2015-02-21T16:38:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin There are tests for throwing (also includes domain usage) and microtask inside event handler at the end",
                            "createdAt": "2015-02-21T16:44:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "scheduleMicrotasks() usage addPendingUnhandledRejection requires a FIXME notice. It works and it's rather harmless, but still a hack. I can do this myself if I'm going to land this\n\nI need to schedule microtasks because they might not be scheduled and that will leave code hanging until they are scheduled next time, you really should rename the method if it's not the perfect usage for that...",
                            "createdAt": "2015-02-21T16:46:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "I only see the test which throws from nextTick. Am I missing something?\n\nI need to schedule microtasks because they might not be scheduled and that will leave code hanging until they are scheduled next time, you really should rename the method if it's not the perfect usage for that...\n\nWhat you actually need is to ensure that _tickCallback is called. It's called from C++ code only if we have at least on nextTick callback to run. So scheduleMicrotasks only fixes the issue because it schedule exactly one nextTick callback. It is not required to do anything though.",
                            "createdAt": "2015-02-21T16:55:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin yes the test is right here for microtask:\n+common.asyncTest(function(done) {\n+  clean();\n+  var e = new Error(\"error\");\n+  var expectedDiff;\n+  var now = Date.now();\n+  process.on(\"unhandledRejection\", function(reason, promise) {\n+    var now = Date.now();\n+    process.nextTick(function() {\n+      var diff = Date.now() - now;\n+      assert(diff <= 1);\n+      done();\n+    });\n+  });\n+  Promise.reject(e);\n+});\nThe difference is always 0 or 1 when I test on virtual machine, when it was bugged the difference was 5+ ms. But if you have a better way to test it, I am ears.",
                            "createdAt": "2015-02-21T17:01:17Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov if you are trying to test that nextTick callbacks are not deferred for a long time, you can call setTimeout and check that it's callback is executed after nextTick callback",
                            "createdAt": "2015-02-21T17:15:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Rebased and addressed all issues except the time limit for an async test: if there is a better way to fail a test that simply never calls done I am ears.",
                            "createdAt": "2015-02-21T19:52:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "LGTM with comments.",
                            "createdAt": "2015-02-22T06:10:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Addressed comments, rebased and squashed",
                            "createdAt": "2015-02-22T12:45:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Right, now that @bnoordhuis, @vkurchatkin and @trevnorris have all read the PR it sounds like we're good to go.\n@vkurchatkin - @domenic LGTM'd it in the last TC meeting: https://www.youtube.com/watch?v=jeBPYLJ2_Yc#t=2487 (starts a bit sooner)",
                            "createdAt": "2015-02-22T21:50:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr well, we can cross number 1 off my list, I guess. number 2 I can do myself. 3 and 4 are still pending, though",
                            "createdAt": "2015-02-22T22:01:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov anything about 3 and 4?\n\n3.. Maybe we can emit rejectionHandled event in a microtask? /cc @domenic\n4.. @petkaantonov can you add tests to check that throwing/nextTick/microtask from event handlers works as expected",
                            "createdAt": "2015-02-22T22:04:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "The tests are there, for the third time.\nWaiting until all microtasks have fired and then waiting another microtask seems pointless to me.",
                            "createdAt": "2015-02-22T22:06:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "Can you explain what is happening here then:\nprocess.on('rejectionHandled', function() {\n  throw new Error;\n});\n\nvar p = Promise.reject();\n\nsetTimeout(function() {\n  try{\n    console.log(1)\n    p.catch(function(){\n      console.log('caught async');\n    });\n    console.log(3)\n  } catch (e) {\n    console.log('caught sync')\n  }\n\n}, 0);\n\nsetTimeout(function() {\n  console.log('timeout');\n}, 1000);\nPrints:\n1\ncaught sync\ncaught async\ntimeout // after 1000ms\n\nIf you comment out (3):\n1\ntimeout // after 1000ms\ncaught async\n\nIf you comment out (1):\n    console.log('caught sync')\n            ^\nTypeError: undefined is not a function",
                            "createdAt": "2015-02-23T00:12:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Does that happen without the try catch?",
                            "createdAt": "2015-02-23T00:45:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "No, it doesn't. Though the stack trace inside uncaughtException is weird:\n    at process.<anonymous> (/Users/vkurchatkin/io.js/test.js:7:11)\n    at emitOne (events.js:77:13)\n    at process.emit (events.js:166:7)\n    at process._fatalException (node.js:219:26)\n    at Promise.chain (native)\n    at Promise.then (native)\n    at Promise.catch (native)\n    at null._onTimeout (/Users/vkurchatkin/io.js/test.js:16:12)\n    at Timer.listOnTimeout (timers.js:88:15)",
                            "createdAt": "2015-02-23T00:53:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin I added nextTick call and it appears to be fixed. I thought you wanted to microtask in all events before, now I realize what you meant.",
                            "createdAt": "2015-02-23T01:06:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin can you please confirm nothing more is open at this point of time?",
                            "createdAt": "2015-02-23T16:10:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "we need @domenic's confirmation. The latest change contradicts his spec",
                            "createdAt": "2015-02-23T16:51:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "ping @domenic",
                            "createdAt": "2015-02-24T19:19:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "LGTM if @petkaantonov can confirm my interpretation of the tests. I think it would be cool to have those line comments I left in the source code too so that future maintainers know what's going on.",
                            "createdAt": "2015-02-24T22:45:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@domenic I actually just made asyncTest support descriptions like mocha, hope that's ok too",
                            "createdAt": "2015-02-24T23:07:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "domenic",
                                "__typename": "User"
                            },
                            "bodyText": "LGTM although I imagine you may have angered the line-length gods",
                            "createdAt": "2015-02-24T23:09:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "Should be ok, many test files with such descriptions and messages go over 80 for those messages",
                            "createdAt": "2015-02-24T23:14:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin is this ready to be merged now?",
                            "createdAt": "2015-02-24T23:16:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "@petkaantonov can you rebase and squash into a single commit please?",
                            "createdAt": "2015-02-24T23:32:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "petkaantonov",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg done",
                            "createdAt": "2015-02-24T23:41:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "oookkaayy ... I might land this then eh?",
                            "createdAt": "2015-02-25T00:01:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "phpnode",
                                "__typename": "User"
                            },
                            "bodyText": "@rvagg \ud83d\udc4d a lot of hard work has gone into this, it'd be nice to see it finally land!",
                            "createdAt": "2015-02-25T00:02:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "https://jenkins-iojs.nodesource.com/job/iojs+any-pr+multi/193/",
                            "createdAt": "2015-02-25T00:03:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "LGTM although I imagine you may have angered the line-length gods\n\n@bnoordhuis would be really unhappy with long lines :)",
                            "createdAt": "2015-02-25T00:09:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome, great work everyone and especially @petkaantonov and @vkurchatkin - it was a long issue + spec + pr + 300 comment road to cross but I think we learned a lot in the process and the semantics formed quite nicely.",
                            "createdAt": "2015-02-25T00:09:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "landed in 872702d\npretty sure @petkaantonov earns a collaborator spot for persisting with this, thanks @petkaantonov and others who contributed!",
                            "createdAt": "2015-02-25T00:30:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "rvagg",
                                "__typename": "User"
                            },
                            "bodyText": "It's just occurred to me that this is missing docs, could someone qualified please write some up and submit a PR? would be really good to have that in prior to a release #932 (tomorrow?)",
                            "createdAt": "2015-02-25T00:33:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Awesome! If my opinion counts I definitely think @petkaantonov deserves a collaborator spot - this and other PRs show that he has a lot to offer to io.js in terms of APIhelp  and performance.\n@rvagg already made a docs PR :) (Whoops, I pulled against the wrong fork, here it is now #946 )",
                            "createdAt": "2015-02-25T00:33:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "tjconcept",
                                "__typename": "User"
                            },
                            "bodyText": "Amazing work being done. This is Open Source.",
                            "createdAt": "2015-02-25T14:51:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Politely pinging parties involved in this to invite them to participate in https://github.com/nodejs/promises",
                            "createdAt": "2016-02-15T18:35:34Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 18392,
            "title": "esm: Implement esm mode flag",
            "author": {
                "login": "guybedford"
            },
            "state": "CLOSED",
            "closedAt": "2019-03-19T02:02:47Z",
            "comments": {
                "totalCount": 145,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "I have a writeup from conversations in form of a pseudo design document.",
                            "createdAt": "2018-01-26T14:19:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "The mode effectively marks a directory as an \"esm mode\" directory, where all \".js\" files\n\nWhat about extensionless bin files that CLI's often use?\nUpdate\nThere's a mention in the writeup about --format related to extensionless but I'm not sure why a mode property couldn't cover it.\nThe writeup mentions a gotcha with require and extensionless files.\nDoes this mean require can load ESM?",
                            "createdAt": "2018-01-26T16:52:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "JacopKane",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks a lot for your work that might save us from a new javascript extension.\nI know this is an entirely minor detail to consider right now, but I would only argue using shorthand, esm, instead of something more descriptive like esModule, ecmaModule or maybe something else but just more apparent.",
                            "createdAt": "2018-01-26T17:08:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton --format is for entry points that don't have extensions at all / STDIN, it does not alter the default format of file extensions. If --mode affected those situations it would need to expand scope so that all extension-less files were treated in a specific way. This complication is why it was punted.",
                            "createdAt": "2018-01-26T17:16:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck\n\nThis complication is why it was punted.\n\nWhat about tackling it in the shebang of the bin file like\n#!/usr/bin/env node --mode esm",
                            "createdAt": "2018-01-26T17:19:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton punted and as describe in the design doc \"bin\" files can have extensions even if the command does not which is the common case for using command line wrappers, feel free to PR the --format flag as described if you feel strongly about needing that specific use case.",
                            "createdAt": "2018-01-26T17:22:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "punted and as describe in the design doc \"bin\" files can have extensions even if the\n\nThe bin file is opting in to esm with the --mode in the shebang. It's not executing the command. Node would parse it out. How you handle conflicting signals is a separate issue.",
                            "createdAt": "2018-01-26T17:25:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton --mode is setting up file extension mapping similar to a MIME DB, --format is a very different idea which overrides something that doesn't have a well known intention already. We absolutely should not conflate these flags in my opinion.",
                            "createdAt": "2018-01-26T17:27:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "We absolutely should not conflate these flags in my opinion.\n\nHaving it specified in the shebang is a nice descriptive and natural way to tackle extensionless bins.",
                            "createdAt": "2018-01-26T17:29:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton PR up the --format flag :)",
                            "createdAt": "2018-01-26T17:30:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Naw. It doesn't have to be --format or bust.",
                            "createdAt": "2018-01-26T17:30:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton One problem with putting arguments into the shebang is that it's not super portable. :( https://unix.stackexchange.com/questions/63979/shebang-line-with-usr-bin-env-command-argument-fails-on-linux\nP.S.: Shipping something like a nodem or mnode shim with node might fix that though.",
                            "createdAt": "2018-01-26T17:30:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Or we could try it in this PR, write tests, and see if issues are had.",
                            "createdAt": "2018-01-26T17:33:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jkrems",
                                "__typename": "User"
                            },
                            "bodyText": "Or we could try it in a PR, write tests, and see if issues are had.\n\nNot sure I follow - this isn't hard to verify. The following:\n$ cat test.js\n#!/usr/bin/env node --harmony\nconsole.log(process.argv, process.execArgv);\n\nWorks on OSX but won't run on (all) Linux (the same without --harmony works on both):\n./test.js\n/usr/bin/env: node --harmony: No such file or directory",
                            "createdAt": "2018-01-26T17:37:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "Not sure I follow - this isn't hard to verify. The following\n\nMany times ideas are shot down with a quick SO post without actually seeing if, in the given scenario, it is doable or an issue is able to be worked around.\nPinging @ceejbot and @chrisdickinson who had this in their npm proposal, though it was unimplemented (wondering if they ran into similar issues or if they've thought of anything to workaround the gotcha).\n\nP.S.: Shipping something like a nodem or mnode shim with node might fix that though.\n\nThat may be it \ud83d\ude0b. I never considered something like that. Kinda neat!",
                            "createdAt": "2018-01-26T17:58:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "Question: with such a proposal, how would I write a \"dual mode package\", one which works whether we require the package or whether we import it. This is possible in the mjs proposal, but I don't see how you can do it in this proposal.\nIf we go with this proposal, all library developers that want to migrate to the esm model will need to fork their modules. So we will have moment and moment-esm. lodash and lodash-esm, uuid and uuid-esm, etc...\nGiven that we're going to live in dual-mode world for a long time, I believe this is not viable.",
                            "createdAt": "2018-01-26T20:11:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar You would still use the .mjs approach for such a behavior. This PR is ontop of .mjs and seeks to alleviate common cases that do not need such a behavior since it is already available through .mjs. A variety of situations do not need to support dual mode packages, such as top level applications that are never meant to be treated as dependencies.",
                            "createdAt": "2018-01-26T20:16:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "Another question: if I am doing an import \"./foo/bar/gar/qux.js\", would Node need to check whethe there is a package.json in ./foo/bar/gar and then ./foo/bar and then ./foo and .? That feels like a performance hit. If it doesn't, how does it figure out what the \"package boundary\" of the file is?",
                            "createdAt": "2018-01-26T20:33:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar yes it would stat every directory for a package.json once per process, and then it can cache it for later. It will need to do that also for other features like per package loader hooks. If startup performance is still a concern I recommend using a bundler, even for Node. This \"mode\" field is static, cached, and not determined by any runtime API so it should not be difficult to figure out if bundlers want to support it. It is not in a first iteration, but the design document does have a link to the fact that this \"mode\" might have more complex file format models as well in the future for things like Flow or JSX. Those designs have been discussed but are not in this iteration until we get more feedback on \"mode\".",
                            "createdAt": "2018-01-26T20:40:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck: OK, so \"package boundary\" is a new concept in Node. Didn't exist until now, right? (this is not criticism, it's more trying to understand).\nAnd it's the first time, IIRC, that package.json contains something that influences the running of files \"underneath\" it. And this concept of \"package boundary\" will be used in the near future by the loader mechanism for things like transpiling flow/json/ts. Interesting.",
                            "createdAt": "2018-01-26T20:52:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar\n\nOK, so \"package boundary\" is a new concept in Node. Didn't exist until now, right? (this is not criticism, it's more trying to understand).\n\nCorrect, it has existed in userland to some extent under differing definitions/mechanisms, but this is the first time something of its nature has been proposed to come to Node's core.\n\nAnd it's the first time, IIRC, that package.json contains something that influences the running of files \"underneath\" it. And this concept of \"package boundary\" will be used in the near future by the loader mechanism for things like transpiling flow/json/ts. Interesting.\n\nWe are still hashing out those workflows details, but thats the plan. The recommendation will remain not to do heavy workflows like completely transpiling on every startup though. Loaders will want to design a cache mechanism across processes, and/or manage to ensure they can be run ahead of time if they want to avoid startup time problems.",
                            "createdAt": "2018-01-26T21:00:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins the \"mode\" effectively sets how a module format is determined - using the extensionFormatEsm extension checks for \"esm\" mode and extensionFormatStd extension checks for the backwards compatible mode or \"commonjs\" or \"legacy\" or \"interop\" or whatever we want to call that.\nThe distinctions can evolve over time but the basic changes in \"esm\" mode are (1) \".js\" files within that same mode boundary are treated as ES modules and (2) loading files without file extensions is not permitted.",
                            "createdAt": "2018-01-27T09:34:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford that eventually hit me... commented as such above.\nfrom above\n\nI have mixed feelings about how this enables importing a .js to have different semantic meaning based on meta data in the folder. It seems ambiguous in a way that isn't statically analyzable. Does this mean that if you directly require a file by full path name we need to check the system for a package.json and parse that package.json for the mode every time?\n\nOne one hand I really like that it is configurable. We can make a default, and that default can change as the ecosystem transitions between module systems. On the other hand it feels like there may be too much magic and it is hiding the differences in a way that introduces a lot of complexity into the module resolution algorithm (it would to check and crawl up all folders until finding a package.json to know mode for this algorithm afaict).\nI think I may prefer the pattern of having mode be global, more similar to the npm proposal, and forcing the use of import.meta.require for cjs modules when in the esm mode. The keeps the use of import consistent and would allow us to eventually moonlight the complexity of transparent interop at some point by changing defaults while still giving application developers a legacy mode if we don't remove the cjs mode.\nWith all that being said I'm not 100% how I feel about this just yet and will think on this quite a bit more and discuss with folks before landing on specific semantics. I'm not going to block anything, but I've marked this in-progress and would like chat more about the long term implications of this implementation before landing.\nThanks for all the hard work on this, it is really stellar stuff!",
                            "createdAt": "2018-01-27T09:50:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins\n\nOne one hand I really like that it is configurable. We can make a default, and that default can change as the ecosystem transitions between module systems. On the other hand it feels like there may be too much magic and it is hiding the differences in a way that introduces a lot of complexity into the module resolution algorithm (it would to check and crawl up all folders until finding a package.json to know mode for this algorithm afaict).\n\nIt crawls up until it finds a package.json file. Usually it shouldn't be incredibly deep, but it might be deep. This behavior is also required for things like per-package hooks into the loader so perhaps isolating all of this magic into one place is a good thing?\n\nI think I may prefer the pattern of having mode be global, more similar to the npm proposal, and forcing the use of import.meta.require for cjs modules when in the esm mode. The keeps the use of import consistent and would allow us to eventually moonlight the complexity of transparent interop at some point by changing defaults while still giving application developers a legacy mode if we don't remove the cjs mode.\n\nEven without transparent interop and with import.meta.require we still need a flag if we want to disambiguate .js files, like the one in this proposal. We cannot let consumer be the definer of file format if we want any static analyzability without ambiguity.",
                            "createdAt": "2018-01-27T13:20:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "Ping @guybedford",
                            "createdAt": "2018-02-01T14:13:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR I believe his is on vacation right now, what is up?",
                            "createdAt": "2018-02-01T14:49:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Would it help for review and consideration if I removed the top-level --mode flag here for now? That would bring the diff down by about 150-200 lines I believe.\nThe main reason I bundled this in is because one of the major complaints with the previous proposal was for the scenario of node x.js where there is no package.json resulting in unnecessary statting, so the flag provides the mechanism for avoiding that, while also aligning with the npm proposal quite nicely. But it could be deferred to a separate PR if that would simplify.",
                            "createdAt": "2018-02-04T13:47:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford +1 since we can do that separate PR and it seems to be a bigger talking point on this one.",
                            "createdAt": "2018-02-04T13:48:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford If it's not too difficult to split, +1.",
                            "createdAt": "2018-02-04T13:49:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Ok I've split out the features here and updated the description above (#18392 (comment)) to reflect that this is just the package.json \"mode\": \"esm\" feature now. The separate --mode flag is at https://github.com/guybedford/node/tree/package-top-mode.\nI hope that helps to review, and let me know if there's anything more I can do to help make this easier to consider.",
                            "createdAt": "2018-02-04T15:41:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks! I'm going to test it on a project and review.",
                            "createdAt": "2018-02-04T15:44:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "It looks like this is breaking CJS interop.\nGiven:\n\ntest.mjs:\n\nimport value from 'cjs';\nconsole.log(value);\n\nnode_modules/cjs/package.json:\n\n{\n  \"main\": \"src/index.js\"\n}\n\nnode_modules/cjs/src/index.js\n\nmodule.exports = 42;\nCurrent master branch prints 42.\nThis PR throws:\nError [ERR_MODULE_RESOLUTION_LEGACY]: cjs not found by import in file:///test.mjs. Legacy behavior in require() would have found it at /node_modules/cjs/src/index.js\n    at search (internal/loader/DefaultResolve.js:33:15)\n    at Loader.resolve [as _resolve] (internal/loader/DefaultResolve.js:71:7)\n    at Loader.resolve (internal/loader/Loader.js:49:18)\n    at Loader.getModuleJob (internal/loader/Loader.js:81:40)\n    at ModuleWrap.promises.module.link (internal/loader/ModuleJob.js:37:40)\n    at link (internal/loader/ModuleJob.js:36:36)\n    at <anonymous>",
                            "createdAt": "2018-02-04T18:52:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@targos great catch, I've pushed the fix now with a test case. This was a typo missing out the boolean argument copying from https://github.com/nodejs/node/blob/master/src/module_wrap.cc#L575.",
                            "createdAt": "2018-02-04T20:31:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "After little testing, I think this is doing what I would expect!\n@guybedford Could you take a look at image-js/tiff@834c0ad ?\nWould it be the right way to update a library to support both ESM and CJS if this PR lands?\nIf so, +1. I want that :)",
                            "createdAt": "2018-02-05T15:40:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@targos that would work if you only provide a \"main\" entry point to your module. Yes.",
                            "createdAt": "2018-02-05T15:42:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@targos glad it seems sensible to you. Nice dual-target approach - yes that works well!",
                            "createdAt": "2018-02-05T17:45:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins I definitely agree there can be a deprecation workflow here, although I think it would be best-suited to the package manager to manage this:\n\nPackages could have \"mode\": \"cjs\" automatically inserted on install if they don't have \"mode\": \"esm\"\nThe warning for the local package could be provided by the package manager, with an automatic fix option (which we can't do from Node really)\nWhen running init it can be standard to include \"mode\": \"esm\" this is a crucial part of making this workflow easy.\n\nI'm adding these features to my own package manager work, and the hope is others could do the same. Then we can start to coordinate that deprecation path definitely.",
                            "createdAt": "2018-02-06T10:16:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@targos much appreciated for review, and catching the inconsistencies in the test names. If we can expand that query to confirm the \"mode\" property is safe, would be keen to add that validation.",
                            "createdAt": "2018-02-06T10:17:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford I guess the question for me is \"Does Node intend to eventually change the default\"? If the answer is yes, which I hope it is, I think the onus is on us to warn that this behavior is going to change.",
                            "createdAt": "2018-02-06T14:47:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins certainly Node could have a warning, but if we added that today we'd get 100 10s of warnings for every single npm package dependency loaded from ESM, with no easy action from the end-user apart from sending a PR. If the package manager could take the first step adding on install that will avoid this painful middle ground, but otherwise I suppose we can go for this bulldozer warning approach :P",
                            "createdAt": "2018-02-06T19:00:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford I'm imagining this would only be a warning for the top level package. Seem reasonable?",
                            "createdAt": "2018-02-07T19:43:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins or we could just state that there was at least 1 warning and tell them to use something like NODE_DEBUG if they want to see all of them.",
                            "createdAt": "2018-02-07T19:46:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck not sure I'm following. Could you rephrase?",
                            "createdAt": "2018-02-07T19:47:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins I imagine we could have:\n$ node my-app\nWarning: Encountered a package without a \"mode\" field in its package.json\nuse NODE_DEBUG=loader to get more details.\n\nAnd only print the warning once per process, and when the flag is set:\n$ NODE_DEBUG=loader node my-app\nLOADER 12345: Encountered a package without a \"mode\" field in its package.json at file:///app/package.json\nLOADER 12345: Encountered a package without a \"mode\" field in its package.json at file:///app/node_modules/foo/package.json\nLOADER 12345: Encountered a package without a \"mode\" field in its package.json at file:///app/node_modules/bar/package.json",
                            "createdAt": "2018-02-07T19:56:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck so I was imagining it being a bit more descriptive\n$ node my-app\nWarning: Encountered a package without a \"mode\" field in its package.json. This currently defaults to the `cjs` mode but will default to the `esm` mode in the future\n\nThat copy is bad, and needs work... but that is what I wanted to be explicit about.\nWith all this being said I'm still having mixed feelings about the mode being on a per package level for external imports. I don't think that I have totally wrapped my head around all of the edge cases though, so I'm going to keep most of that opinion to myself until I've worked it out",
                            "createdAt": "2018-02-07T20:05:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Providing only the first warning could definitely make sense. I'd still be averse to implementing this if that warning could apply to a third party package without some type of greater upgrade path strategy (ideally with package manager buy-in though). Let me know if you disagree, but for now I'd say it falls out of the scope of this PR (until tangible upgrade path plans can be put in place, but they will definitely be possible).",
                            "createdAt": "2018-02-07T21:35:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "I'm fine punting the warning mechanics to afterwards.",
                            "createdAt": "2018-02-07T21:37:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "I'd personally like the single warning at a top level that defaults are subject to change in this PR. This is closer to a -0 than a -1, but I want to set expectations early",
                            "createdAt": "2018-02-07T21:45:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ceejbot",
                                "__typename": "User"
                            },
                            "bodyText": "What is a package consumer supposed to do when they encounter this warning? What does the warning mean, in practical terms? What is it warning against?\nWhat does the package author achieve by marking a directory as containing only module-parse-goal files or common-js-requireable files? What if the package author has, say, a bin dir with files intended to be used by older and newer nodes in a hybrid package? How would they silence the noise? Is an override per-file possible for hybrids?\nI realize I'm new to this PR, but is there a design doc I could read outlining the overall vision & use cases we'd like to support? That would help me aim feedback usefully.",
                            "createdAt": "2018-02-08T05:02:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@ceejbot thanks so much for taking a look, as mentioned in previous comments this is something that works much better together with the package manager, so it would be really great to hear your feedback further. The original proposal for this is located at https://github.com/nodejs/node-eps/pull/60/files. This mode does not affect the way CommonJS loading works and won't stop require from loading .js files marked as esm, it is only for the es module resolver.\nThe warnings as discussed here would simply be to ensure the mode is explicit - \"mode\": \"cjs\" is currently equivalent to not having a mode or even having an invalid mode property. Currently there are no warnings and I'm resistant to integrate any warnings until we have actionable steps for them. Directories marked as module files only affect the ES module resolver, CommonJS require doesn't change behaviour at all with this PR so dual packages work fine like in #18392 (comment). In addition a package.json in a subdirectory can provide directory-level overrides.\nThe warnings are about getting to a place where the default mode can eventually (mid to long term) be switched to treating js files as ES modules. To prepare for this Node could warn for packages not containing a mode, with for example, \"mode\": \"esm\" added during npm init workflows with a prompt of \"Use ES Modules for js files?\" or similar and \"mode\": \"cjs\" automatically written into the package.json for installed packages when no mode is present. This is where package manager support comes in as I say. That might then allow us to eventually change the default as Myles suggests.\n@MylesBorins I guess the top-level main is usually guaranteed to be a user package except in the case of running bin scripts, where the warning would then be completely unwanted. If there was a way we could at least distinguish those running cases it might be possible to add something sooner, but until all actionable steps are fully worked out I'd say we should wait.",
                            "createdAt": "2018-02-08T06:37:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "This mode does not affect the way CommonJS loading works and won't stop require from loading .js files marked as esm, it is only for the es module resolver.\n\nIt was my understanding that when we wrote the explainer require('esm/foo.js') would throw when you opt into this flag in order to keep files from being ambiguous. Is this behavior of not throwing a requirement / use case? I would like to add the behavior of throwing when require loads ESM as a requirement to ship for my goals right now, but am not seeking to block this if implementation of such throwing behavior needs time to check against require which is much more stable.",
                            "createdAt": "2018-02-08T13:39:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "It was my understanding that when we wrote the explainer require('esm/foo.js') would throw when you opt into this flag in order to keep files from being ambiguous. Is this behavior of not throwing a requirement / use case?\n\nFor 100% backwards compatibility with existing CommonJS code I don't think we should have this throw, at least until we're down the end-of-life path on NodeJS without unflagged modules.",
                            "createdAt": "2018-02-08T21:46:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "This needs a rebase - and what is the status here?",
                            "createdAt": "2018-02-16T22:34:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "I've rebased this PR against latest master now, which simplifies the PR quite a bit further.",
                            "createdAt": "2018-02-17T09:40:06Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "targos",
                                "__typename": "User"
                            },
                            "bodyText": "I still cannot really review the C++ changes but this LGTM.\n/cc @nodejs/modules",
                            "createdAt": "2018-02-17T10:10:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "It would be nice to move towards merging this. Does anyone still have any concerns here?",
                            "createdAt": "2018-02-25T20:47:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "It seems like the longer-term goal is to provide a package-level boundary that can map in-band disambiguators (extensions, mime types, etc) to module formats (CJS, ESM, wasm, html, etc).\nGiven that, would it be more future-facing to introduce that map now, rather than a boolean property that only handles one of the mappings? I\u2019m thinking something like:\n\"extensions\": {\n  \"mjs\": \"esm\",\n  \"js\": \"cjs\",\n  \"wasm\": \"wasm\"\n}\nwith perhaps a runtime error if they conflict or if any unknown value is found. Then to accomplish esm:true you\u2019d specify:\n\"extensions\": {\n  \"js\": \"esm\"\n}\nMy thought is that it would likely make things easier for both humans and tooling (cc @TheLarkInn).",
                            "createdAt": "2018-02-25T21:10:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb from a usability perspective it is quite important to have something easy here for interop workflows to provide to users I think. Also I do worry if we allow users full customization at the file extension level that may create some anti-patterns as well.\nBecause \"mode\": \"esm\" disallows loading files without an extension that aren't the Node main, we can add custom support for new file extensions in future anytime. But there's no reason a \"mode\": \"custom\" couldn't be introduced that allows what you describe as well.\n//cc @ceejbot did you find time to look into further feedback here at all?",
                            "createdAt": "2018-02-25T21:25:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford\n\nBecause \"mode\": \"esm\" disallows loading files without an extension that aren't the Node main, we can add custom support for new file extensions in future anytime. But there's no reason a \"mode\": \"custom\" couldn't be introduced that allows what you describe as well.\n\nI thought this PR was just about changing formats, does it now change how resolution works? If so, I'm going to have to move to a -1.",
                            "createdAt": "2018-02-25T22:33:34Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck not loading files without an extension is in the existing\nimplementation I believe, I wasn\u2019t aware of any change in this stance?\n\u2026\nOn Mon, 26 Feb 2018 at 00:33, Bradley Meck ***@***.***> wrote:\n @guybedford <https://github.com/guybedford>\n\n Because \"mode\": \"esm\" disallows loading files without an extension that\n aren't the Node main, we can add custom support for new file extensions in\n future anytime. But there's no reason a \"mode\": \"custom\" couldn't be\n introduced that allows what you describe as well.\n\n I thought this PR was just about changing formats, does it now change how\n resolution works? If so, I'm going to have to move to a -1.\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18392 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAkiysIihU9doocKubwXGEzzzZqKPAj2ks5tYd_DgaJpZM4RuKM8>\n .",
                            "createdAt": "2018-02-25T23:05:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford oh, for some reason I was thinking specifiers not resolved paths. Carry on.",
                            "createdAt": "2018-02-25T23:12:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb\n\nwith perhaps a runtime error if they conflict or if any unknown value is found. Then to accomplish esm:true you\u2019d specify:\n\"extensions\": {\n  \"js\": \"esm\"\n}\n\n\nYou can think of \"mode\" as being able to take multiple things, including well known presets. That would avoid needing to have a more complicated structure for common usages.",
                            "createdAt": "2018-02-25T23:14:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/modules can we add this to the agenda for wednesday?",
                            "createdAt": "2018-02-26T08:19:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "Absolutely! Add the agenda label and I'll make sure it is included in the\nagenda.\n\u2026\nOn Mon, Feb 26, 2018, 3:19 AM Benjamin Gruenbaum ***@***.***> wrote:\n @nodejs/modules <https://github.com/orgs/nodejs/teams/modules> can we add\n this to the agenda?\n\n \u2014\n You are receiving this because you were mentioned.\n Reply to this email directly, view it on GitHub\n <#18392 (comment)>, or mute\n the thread\n <https://github.com/notifications/unsubscribe-auth/AAecV3F_Rm16DikgvGS0VTHfjvY_tTpwks5tYmkHgaJpZM4RuKM8>\n .",
                            "createdAt": "2018-02-26T15:38:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I do certainly like that this distills the package.json disambiguation approach down to something even simpler, but I think a lot of the higher-level issues / concerns from the previous package.json approaches still apply.\nAt least as a baseline - are we really ok with putting more core dependency on package.json? I'm... still not really sure, but I do think this may make a reasonable case for it.",
                            "createdAt": "2018-02-28T21:11:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 this field in particular has some interesting gains if we look at what it can be used for beyond \"esm\". It is not in scope for this PR, but things like having more complex mime DBs and loaders fit well with it. The package.json seems ok to me since this field has over-arching concerns that would also hit on #18233 and affects things outside of purely module resolution if we do decide to go down the MIME DB route.\nSince other features I consider important also are going to lean on a package boundary and also on package.json in current designs, I would like to hear arguments about using package.json for anything at all. In particular, I would like to hear about fields that use it as a package boundary, unlike \"main\" which only affects a very specific part of module resolution and only redirects to a single part of a package rather than the package as a whole.",
                            "createdAt": "2018-02-28T21:17:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "\\cc @TheLarkInn for any webpack concerns and @weswigham and @DanielRosenwasser for any TypeScript concerns.",
                            "createdAt": "2018-02-28T22:48:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "What I specifically am concerned about here (#18392 (comment), and referred to today in the modules meeting) is that \"esm\" mode means \"all .js files inside the boundary are ESM\", but there's no way for me to say, for example, \"all .jsx files inside the boundary are ESM\" and \"all .cjs files inside the boundary are CJS\". I feel that a generic mechanism for overriding the default mapping of extensions to parsing goals would be extensible in the future, would allow for \"all .js files inside the boundary are ESM\" now anyways, but would also allow for - at a package level, so as to not impact code the author of that package.json didn't write - any alterations to the defaults they like.",
                            "createdAt": "2018-02-28T22:51:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb I am happy to make a follow on proposal and intend to based upon previous designs. This PR's design doesn't have any problems that I see on a glance except a possible identifier collision with MIME DB lookup strings that we can hash out during the follow on.",
                            "createdAt": "2018-02-28T22:54:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "What I'm worried about is that as soon as something like this lands, packages using it will be published into the ecosystem - so either that will preclude conflicting usage, or it will force a new field name to be used, or it will break early-adopter packages. Even if we're OK with the last option, it seems preferable to avoid it?",
                            "createdAt": "2018-02-28T23:01:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb can you explain? If the \"mode\" is a dictionary of file name patterns -> format/MIME why do we need a new field? It could even be something like file:///path/to/mime/db.json in a follow on proposal.",
                            "createdAt": "2018-02-28T23:04:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb, the way I see it, mode=esm does not just mean that the files in the package boundary are all ESM. It also means that it participates in all the \"ESM ecosystem\". I specifically mean the loader ecosystem, which enables you to define loaders for various files or file extensions.\nIt is the EMS loaders that will enable different file extensions to be loaded (e.g. \".ts\" will load as \"typescript\", \".wasm\" as \"web assembly). But because of mode=esm they will be loaded as ES Modules and not CJS.\nSo mode=esm specifies which module system you want your files to work under (whether js, mjs, ts, or wasm), and if that module system is ESM, you can use the loader mechanism to specify how to load them.\nAnd if you specify mode=cjs, then you can still load ts and others, by using the regular old \"override require.extensions\" method used by everybody for this purpose. The confusing part of mode=cjs (and which makes people think that mode has to do with file extensions) is that in mode=cjs, the mjs file extension means that the file actually belongs to the ES Module system.\nTL;DR: mode=esm specifies which module system the files work under, and does not actually concern itself with file extensions (except for the small caveat defined above).",
                            "createdAt": "2018-02-28T23:47:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar I want to be very clear that I don't want this field to have any affect except changing the formats that files are in. I don't want anything about\n\nit participates in all the \"ESM ecosystem\"\n\nto land if it does more than affect formats in this feature. I think it is more valuable if it just affects formats and does not diverge behavior of loading mechanisms (import/require) beyond that. I would harshly discourage any behavioral branching upon the value/existence of a field in package.json that is not extremely well defined like file formats.",
                            "createdAt": "2018-02-28T23:51:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck doesn't \"mode\": \"esm\" conceptually map to a package-scoped loader with the mode's default semantics?",
                            "createdAt": "2018-03-01T00:02:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "i'm unequivocally -1 on what @giltayar purposed, for the reasons bmeck listed.",
                            "createdAt": "2018-03-01T00:06:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@weswigham With a follow on ... not exactly, though you could use a loader to instrument just import. Per the gist I've linked a couple of times, setting the format can be used in a way that isn't just for ESM and it can also be used in a manner that global/per-package loaders can pick the format without using user land loaders and having people read code. I see per-package loaders actually as more limited in some ways than my expectations for future usage of this field since they only affect import. At the same time, they are also less limited since you can do things like changing resolution, or branching logic on things like environment variables.\nNode doesn't have a clear resource fetching pipeline like WHATWG specifies but I would absolutely love having that in Node since I've worked around various resource APIs for bundling for years. I'm not just interested in loading JS assets ;-p and only through import. This is all a follow on though... so not to really go into depth here.",
                            "createdAt": "2018-03-01T00:18:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar multi-mode packages are a must; if i can\u2019t ship a package that works in both CJS and ESM then we\u2019ve failed. Separately, there\u2019s no guarantee that a package will have .js files at all in order to participate in the ESM ecosystem, so hardcoding a mode that only privileges one file extension seems odd.\n@bmeck while a future object format under \u201cmode\u201d would be compatible, that doesn\u2019t mean it\u2019s worth the future cognitive and tooling tax to support the field forever in both string and object formats.",
                            "createdAt": "2018-03-01T04:57:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb dual-mode packages are made possible by the .mjs extension. \"mode\": \"esm\" is somewhat orthogonal, but would effectively allow dual-mode packages to work with having \".js\" extensions for ES modules as well (with say \".mjs\" for entry points loading \".js\" files where each entry point has a separate \".js\" and \".mjs\" option). This is just one possibility for dual-mode though. Knowing the format of \".js\" is the primary ambiguity we are trying to resolve though with the mode though, although that doesn't preclude possible future ambiguities the mode might also assist with.",
                            "createdAt": "2018-03-01T05:55:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck @devsnek - There may have been a misunderstanding: I was not trying to propose anything. I was just trying to give my interpretation of the mode field in the package.json (which I thought was obvious, but in hindsight may not be, and may even be incorrect).\nLet me try again. My interpretation is that mode=esm does not only affect how js files are treated, but also how other files are treated: whether they are loaded via the CJS require mechanisms or loaded via ESM loaders (i.e. the maybe badly named \"ESM ecosystem\").\nI'll give an example:\nLet's say I have code in main.js which is a CJS module, and I require('./foo/bar.json'). If the foo directory does not have a package.json, then this works, as the require knows how to load a json file using the regular mechanisms in NodeJS CJS loading.\nBut if the foo directory includes a package.json with mode=esm, then that require('./foo/bar.json') should (and does?) fail, because now bar.json can only be loaded using ES Module import, and so that require needs to be changed to an await import('./foo/bar.json'). Moreover, if you do await import that json file, then it goes through the ESM loader mechanism.\nSame goes for wasm modules and any other extension that can be loaded by the ESM loader mechanism.\nIf I am incorrect about my assumptions, and mode=esm only impacts js files, then please tell me that this is so, because I believe it shouldn't affect just js files.",
                            "createdAt": "2018-03-02T12:01:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb - definitely, dual-mode packages are a must, but that is solved having a main=\"entry\" field in the package.json and having both an ESM entry.mjs file and a CJS entry.js file. This works today and is orthogonal to mode=esm.",
                            "createdAt": "2018-03-02T12:03:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar you're drawing the right general assumptions here about the behaviours, but \"mode\": \"esm\" as written doesn't currently alter the way that CommonJS behaves - not meddling with CJS is based on never wanting to break existing packages. Perhaps it would be adequate though to assume that no existing packages will contain \"mode\": \"esm\" in which case it could be safe to do what you suggest though.\nAt the moment we kind of have two distinctions at the resolver level:\n(1) Legacy CommonJS resolver or modern ES resolver: The NodeJS main entry point with --experimental-modules uses the ES resolver, ES modules resolve with the ES resolver, and CommonJS modules once loaded resolve their dependencies with the legacy CJS resolver.\n(2) ES Resolver package mode interpretation: The mechanism used by the ES resolver (called for the main, and when resolving ES module dependencies) to determine the module format of a given file.",
                            "createdAt": "2018-03-02T12:20:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford - I agree, but again, I was not suggesting anything, but merely trying to understand/interpret what I thought is the current behavior. From what you said, I believe you meant that in my example, what I said should be happening, does happen. This is great!\nAs for not meddling with CJS behavior, I agree, and did not mean to infer that there is any meddling (as you said, no existing packages should have mode=esm and thus will continue with the current behavior). But correct me if I am wrong: in a mode=esm package boundary, there is no CJS behavior, so there is nothing to meddle with.\nRegarding your two distinctions, I believe (1) is for files in a package with mode=cjs (or no mode at all) and (2) is for files in a package with mode=esm.\nAnd I love this! Just like mjs makes it clear to the reader per-file that this file is loaded as an ES Module, mode=esm makes it clear to the reader\u2014per-package-boundary\u2014that all the files are loaded as ES Modules.",
                            "createdAt": "2018-03-02T12:35:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar I was referring to this comment:\n\nBut if the foo directory includes a package.json with mode=esm, then that require('./foo/bar.json') should (and does?) fail\n\nThis doesn't currently fail without altering the CommonJS resolver to make it fail. A case could certainly be made that require('./foo/bar.js')  into a \"mode\": \"esm\" boundary should fail in the CJS resolver with a nicer error, but otherwise users would get an \"Unexpected token import\" or something similar I think. Note also that the \"mode\": \"esm\" boundary affects the format module loaded by the ES resolver, from any parent - not just parents within that boundary.\nAs for the other formats - \"json\", \"wasm\" etc. the distinction here comes from which resolver they are loaded by, over the mode affecting these things (currently, again, this could always change).\nYes the idea is to hopefully get to a point where this is a simple to understand distinction, illustrative examples should hopefully go a lot further to getting an easy full picture of it, including possible catches.",
                            "createdAt": "2018-03-02T12:44:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford - I just pulled the PR and tried it (as I should have from the start...).\nMy interpretation (as given in the above comments) of the current situation is incorrect. When using require, the CJS loading mechanism completely ignores the package boundaries and mode=esm. The mode flag is read only when using import.\nToo bad. It was a nice interpretation :-). I would have loved to have CJS observe the new package boundaries too, but thinking about it a bit more, I understand why we shouldn't\u2014it would mean that all require-s will now also get the performance hit (of finding the package boundary by going up the directory tree to find a package.json) required by this feature. And we should not meddle with CJS, as you said.\nBut this means that mode=esm is a misnomer because it applies only when using ESM, and applies only to js files. The problem is that \"esm\", in the context of the mode flag is meant to be understood as \"treat js files as ESM`, whereas in all other parts of the documentation/syntax/etc, it just means the ES module system. (and this was at the basis of my misunderstanding)",
                            "createdAt": "2018-03-02T14:00:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@guybedford - also, as part of playing around with this PR, I checked this note of yours (as it was somewhat controversial):\n\nloading files without file extensions is not permitted.\n\nAnd yet it does:\nmain.mjs (which imports a js file, but without using a file extension):\nimport('./mode-esm/foo-esm').then(console.log)\n\nmode-esm/package.json:\n{\"mode\": \"esm\"}\n\nmode-esm/foo-esm.js:\nexport default {foo: 'bar'}\n\nAnd the whole thing works when I run node --experimental-modules ./main.mjs",
                            "createdAt": "2018-03-02T14:08:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "he meant loading files where the filename doesn't contain an extension such as a file named foo-esm without .mjs or .js",
                            "createdAt": "2018-03-02T14:23:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar yes but if using \"mode:esm\" means i can't have a dual-mode package, but using the extensions mapping I'm proposing would still allow that (while allowing ESM to be in .js files) then wouldn't that be a strict improvement?",
                            "createdAt": "2018-03-02T17:21:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb your idea doesn't affect the resolver though, it would need to discuss how it affects the resolver probably too. Also I'd be hesitant to let it be an object, having it be a different file would let it be shared across modules rather than inline in each package.json and also means it doesn't have to be in JSON format.",
                            "createdAt": "2018-03-02T17:30:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar it could well be valid to strictly throw in the CommonJS side early, and would allow a nicer error message than the confusing \"Unexpected token import\". So I think this may well be a direction worth exploring as part of the adoption path for \"mode\": \"esm\". I believe @bmeck was also interested in this previously too. This current implementation comes from a stance of not breaking require first and foremost, but so long as we can show \"mode\": \"esm\" is a unique property, then it does actually sound like a very sensible next step to me!\n@ljharb dual-mode packages with \".mjs\" are fully compatible with \"mode\": \"esm\" as it works now. If we implement what Gil has suggested above then they would be compatible with \"mode\": \"esm\" provided that a custom package.json resetting the \"mode\": \"esm\" was located in the CommonJS folder of the package. Mostly \".mjs\" as a dual mode mechanism is orthogonal to this mode as Gil mentioned previously.",
                            "createdAt": "2018-03-02T17:31:55Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "With this proposal, what is the intended behavior of external tools that need to understand a file's parsing mode given its path? I see three possible things that a tool could do:\n\nReimplement the decision logic from Node, by searching through all parent directories looking for package.json files until it reaches the filesystem root.\nAlways treat .mjs as a module and .js as a script (effectively the same as if \"mode\": \"esm\" wasn't implemented)\nDecide based on external tool-specific configuration\n\nMy suspicion is that option 2 would create a poor experience for users that write ESM in .js files, because it would render their codebases incompatible with tooling. Option 3 is effectively what tools do now, but it creates a suboptimal user experience because users have to configure the parsing mode in multiple different places (once for Node, and once for each tool).\nAssuming option 1 would be preferred, I want to draw attention to a goal of keeping Node's behavior relatively simple. Whatever gets decided here will have to be reimplemented by many tools outside of Node.js core, and the simpler/more performant the behavior is, the more likely it is that any given tool will implement it, rather than falling back to options 2 or 3.\nThe current behavior without this PR (where everything .mjs is a module and everything .js is a script) is extremely simple to implement, and is compatible with existing tools that differentiate formats based on file extensions. Adding a package.json flag makes the behavior significantly more complex. I think this will result in a notably worse tooling experience for users, because fewer tools will implement the behavior correctly, and tools that do implement it will incur a performance cost.\nIs that tradeoff worth it? Personally, I'm not convinced it is, given that the main advantage of this proposal is just to save people from using a different file extension. But I realize many details of this discussion have already been discussed at great length, and I'm not going to block this proposal -- I just want to point out that there are very significant downsides to adding configurability here.",
                            "createdAt": "2018-03-06T23:06:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "Option 4: Node exposes it's esm resolver internals for reuse in the ecosystem.",
                            "createdAt": "2018-03-07T01:39:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "Reimplement the decision logic from Node, by searching through all parent directories looking for package.json files until it reaches the filesystem root.\n\n\nSince all build tools already re-implement the NodeJS module resolution algorithm in order to have module resolution work correctly, the Node algorithm for interpreting modules should itself be considered a public ecosystem convention from this perspective. The general unwritten rule here is \"If it works in Node, it should work through build tools\" and I think the same can be seen to extend to the new module loading rules Node makes. Anything that goes against this will be filed as a bug against a build tool until it is fixed, so that is where things will tend to converge.\nAside: there is a further point here that if Node does something seen to be beyond some limit of unnecessary for tools supporting module resolution, tools will route around things with their own conventions (eg to support \".js\" extensions). But if Node gets things \"right\", the above should be the case, and is an ecosystem-unifying ideal that is important to provide a cohesive experience for the ecosystem as a whole.\n\n\nAlways treat .mjs as a module and .js as a script (effectively the same as if \"mode\": \"esm\" wasn't implemented)\n\n\nTreating .mjs as a module is fine, but how \".js\" is treated is the ambiguous question.\n\n\nDecide based on external tool-specific configuration\n\n\nAll tools will have specific overrides, but what is important is the default configuration of the tool, based on following how NodeJS does things first and foremost.\n\nOption 4: Node exposes it's esm resolver internals for reuse in the ecosystem.\n\nThis would certainly be helpful to tools, but most tools will have \"changes\" to make to the resolver algorithm (such as supporting the browser field in main lookups). Rather than sharing the implementation, sharing the \"loading convention\" is the important artifact I think.\nSo in summary:\n\nHowever Node resolves modules should be treated as a convention that ecosystem tools can follow.\nThis \"mode\": \"esm\" field is completely aiming to provide this sort of guidance to wider tooling for supportinng \".js\".\nIf you have a simpler suggestion, please make it! Consensus is king.\n\n//cc @TheLarkInn",
                            "createdAt": "2018-03-07T10:52:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "Thanks for the responses!\n\nSince all build tools already re-implement the NodeJS module resolution algorithm in order to have module resolution work correctly, the Node algorithm for interpreting modules should itself be considered a public ecosystem convention from this perspective. The general unwritten rule here is \"If it works in Node, it should work through build tools\" and I think the same can be seen to extend to the new module loading rules Node makes. Anything that goes against this will be filed as a bug against a build tool until it is fixed, so that is where things will tend to converge.\n\nI think this is true for the most popular tools, but there is a long tail of tools that make incorrect assumptions about how module resolution works. For example, some tools incorrectly assume that if module A depends on B and C, then B will be able to import C. This is true in most cases, but it fails when B has a separate dependency on a different version of C, or when the modules are arranged in different node_modules folders, e.g. when using lerna. (See the lerna documentation on module resolution, which describes how some tools implement it incorrectly.)\nAdditionally, many tools need to understand the source type of a module without needing to resolve its dependencies. (For example: linters, minifiers, and some codemods operate on a single file without resolving its dependencies.) For those tools, this would be a new problem since they wouldn't already be implementing Node's module resolution.\nIt's also worth noting that some of these tools aren't written in JS, which would make it more difficult for them to take advantage if Node exposed its esm resolution logic as suggested in #18392 (comment). (For example, Rails has a helper function that inserts a <script> tag to import a given JavaScript file. Presumably, it would be convenient for that helper function to automatically insert type=\"module\" as appropriate, in which case the helper function would need to implement the same resolution algorithm as Node.)\n\nAside: there is a further point here that if Node does something seen to be beyond some limit of unnecessary for tools supporting module resolution, tools will route around things with their own conventions (eg to support \".js\" extensions). But if Node gets things \"right\", the above should be the case, and is an ecosystem-unifying ideal that is important to provide a cohesive experience for the ecosystem as a whole.\n\nAgreed! I think we both share the goal of establishing a convention that tools can reuse.\n\nIf you have a simpler suggestion, please make it! Consensus is king.\n\nUnfortunately, I'm not sure I have a simpler suggestion other than simply not adding a package.json flag. I suppose my perspective is that .mjs already addresses all of the use cases for deciding whether a file is a module, and it's also a very simple switch for tools to implement. My understanding is that the main reason for users to write modules in .js files as opposed to .mjs files is an aesthetic preference for the .js file extension, as opposed to technical limitations that require the use of .js. (I'm not sure about this, so please correct me if I've missed the point.) As a result, I'm unconvinced that it's worth increasing complexity here just so that users can continue to use the file extension that they like.",
                            "createdAt": "2018-03-07T18:07:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zackschuster",
                                "__typename": "User"
                            },
                            "bodyText": "My understanding is that the main reason for users to write modules in .js files as opposed to .mjs files is an aesthetic preference for the .js file extension, as opposed to technical limitations that require the use of .js\n\n\nit would require a massive amount of distributed effort by the community to initiate new people with that knowledge (i'm shuddering just considering the number of SO questions that'll be posted about this)\nit would force a ton of libraries to update source & recompile, with all the fragmenting risks that enables\nlots of subtler things like file previews breaking that, while presumably trivial on their own, in aggregate represent a degraded dev experience that's impossible to fix",
                            "createdAt": "2018-03-07T21:17:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "@zackschuster Thanks for the response; this helps me understand why some users prefer .js. However, it's not clear to me how these problems are solved by introducing a package.json flag alongside the .mjs extension.\n\nit would require a massive amount of distributed effort by the community to initiate new people with that knowledge (i'm shuddering just considering the number of SO questions that'll be posted about this)\n\nRegardless of how modules are disambiguated, the community will need to be made aware of it. I don't see how it would be more difficult to tell people to use .mjs than it would be to tell people to add a flag to package.json. In fact, it seems like it would be easier for a user to determine why their file is being parsed incorrectly when there is only one factor that can affect parsing (the filename), as opposed to multiple factors (the filename as well as package.json).\n\nit would force a ton of libraries to update source & recompile, with all the fragmenting risks that enables\n\nLibraries would need to update their source anyway if they choose to switch from CJS to ESM. Since the consumer of a library in Node doesn't need to care about whether it uses ESM, I don't see how this would lead to fragmentation. It doesn't seem to me that having a package.json flag would substantially improve the migration process; renaming a file is very simple in comparison to updating code to use import/export statements.\n\nlots of subtler things like file previews breaking that, while presumably trivial on their own, in aggregate represent a degraded dev experience that's impossible to fix\n\nI'm not sure what you mean by \"file previews\" in this context. Could you clarify?\nAssuming this refers to existing file-viewing tools that currently don't know how to handle the .mjs extension: I see how this would be a problem in the short term, but I don't see how this would be \"impossible to fix\", as you described it.",
                            "createdAt": "2018-03-08T00:36:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "drzraf",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\nAs developers we just want our codebases, using standard native ES6 modules (already working in modern browsers, even served by php -S) be also be supported by node.js.\nThese are all standard syntaxes or common tools, extensions, technologies that just-work in the latest versions of main browsers.\nCJS is orthogonal to the life of the javascript language.\nECMA specs are the top ones (if not the only ones) to respect as an ecosystem-unifying ideal.\nTo avoid node.js being the next CJS, best to avoid requesting that every other software dealing with javascript must adapt to that *.mjs thing. It's not realistic nor fair.",
                            "createdAt": "2018-03-08T02:21:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "@drzraf It's important to note that the ES spec does not provide a way to distinguish between scripts and modules; the decision is made outside of the JavaScript file. This means that any implementation which conforms to the ES spec must must use some out-of-band information (whether it's a file extension, a package.json flag, or a type=module attribute for HTML) to disambiguate between scripts and modules. (This has been discussed extensively elsewhere.) As a result, there is no solution that \"just-works\" without requiring out-of-band information. Either other software will have to adapt to *.mjs, or other software will have to adapt to both *.mjs and a package.json flag -- there isn't any existing standard solution for distinguishing between module and script files.",
                            "createdAt": "2018-03-08T02:44:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "justinfagnani",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark Node could use the same style of out-of-band information that the browser does, which is determining script vs module based on the type of import:\n\n\n\n\nScript\nModule\n\n\n\n\nWeb\n<script>\n<script type=module>/import\n\n\nNode\nrequire()\nimport",
                            "createdAt": "2018-03-08T18:07:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@justinfagnani that isn't entirely how it work son the web. <script> doesn't care about MIME at all, <script type=module>/import use a JS MIME to denote ESM and have no way to load a Script (which as we pointed out doesn't use a specific MIME on the web). The main contention here is that node is going to be supporting multiple module types. It gets even more complex once you start to realize that you can still load things into the wrong mode if you use the consumption method as determination of format; it means that you could load something as both a Script and a Module, which likely is an error and leads to having multiple Script or Module records for a single indistinguishable resource. This PR lets resources have a single well defined format.",
                            "createdAt": "2018-03-08T18:12:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck I've been meaning to ask this... If the mime type is supposedly the canonical way of detecting if a file is a module...  What's the canonical way for a webserver to choose the correct mime type to serve a loose js file with? I'm pretty sure saying mime determines mode just punts the problem into someone else's court, which node does not actually have the luxury of doing.",
                            "createdAt": "2018-03-08T18:32:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "What's the canonical way for a webserver to choose the correct time type\nto serve a loose just file with?\n\nThe registry contains the list of types that are currently landed. You can\ncheck it out at\nhttps://www.iana.org/assignments/media-types/media-types.xhtml\n\nThis registry has an entry for a few things using `.js` as their known\nextensions, environments would need to choose on the proper MIME in the\ncase of collisions.\n\nDue to the JS spec having some problems of intention to reuse a single\n`text/javascript` MIME, we ended up having to add a goal parameter in\nhttps://tools.ietf.org/html/draft-ietf-dispatch-javascript-mjs-01 . This\nfaces a similar problem of disambiguation where environments would need to\nspecify what a missing goal parameter means. There are some people in\nWHATWG who have expressed some regret at not considering using a new MIME\nfor ESM. I think this is fine since regular old Scripts only load when MIME\nis not checked by browsers (you can even serve JS as text/html [which\npeople do...]).\n\nMy comments about how browsers work is regarding how `import` determines\nwhat a resource is and how to form the Module Record for it. Browsers only\nread JS MIMEs for `import`/`type=module` not for regular script tags so\neffectively they don't recognize a JS MIME as being a script ever (and\nthere are some fun things about the type attribute where it doesn't\nactually parse MIMEs but just some well known strings matching type/subtype\nof a MIME).",
                            "createdAt": "2018-03-08T18:39:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Pauan",
                                "__typename": "User"
                            },
                            "bodyText": "@bmeck it means that you could load something as both a Script and a Module\n\nWhy is that a problem? It works that way in browsers, so Node doing it as well doesn't make the situation any worse.\nYes it's true that it's probably a mistake to load the same file as both a Script and Module, but is it really worth the extra complexity to avoid a rare situation like that?",
                            "createdAt": "2018-03-08T18:46:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "weswigham",
                                "__typename": "User"
                            },
                            "bodyText": "environments would need to choose on the proper MIME in the\ncase of collisions.\n\nThat's.... exactly node's problem... node is effectively both the browser and the webserver, as it both hosts and executes the files... Deferring to mime types doesn't solve any problems, it just changes the problem statement from \"what's the correct goal\" to \"what's the correct mime\", which is a roundabout way of asking \"what's the correct goal\"... And webservers don't have a JS parser on hand (always) to use some kind of intelligent disambiguation when there's no user intent (ie, no .htaccess covering the file or explicit config in IIS), meaning they'd be even worse at deciphering intent when there is none than the browser is...",
                            "createdAt": "2018-03-08T19:03:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "@weswigham I'm not sure I understand your problem; this PR is explicitly about declaring the format of files.",
                            "createdAt": "2018-03-08T19:34:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bmeck",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe this is the missing piece to note: https://www.iana.org/assignments/media-types/application/node CommonJS has a different MIME from JS/ESM.",
                            "createdAt": "2018-03-08T20:03:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zackschuster",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\n\nRegardless of how modules are disambiguated, the community will need to be made aware of it. I don't see how it would be more difficult to tell people to use .mjs than it would be to tell people to add a flag to package.json. In fact, it seems like it would be easier for a user to determine why their file is being parsed incorrectly when there is only one factor that can affect parsing (the filename), as opposed to multiple factors (the filename as well as package.json).\n\nYou have maintainers right now saying they'll stick to CJS if they're forced to use .mjs for native modules. I get a bit into why below, but the net effect is that migration of old code hits a substantially lower ceiling without maintainer buy-in, which makes everyone's lives worse in the long tail.\n\nLibraries would need to update their source anyway if they choose to switch from CJS to ESM. Since the consumer of a library in Node doesn't need to care about whether it uses ESM, I don't see how this would lead to fragmentation. It doesn't seem to me that having a package.json flag would substantially improve the migration process; renaming a file is very simple in comparison to updating code to use import/export statements.\n\nThen you also have to train yourself to always create a new file with the new extension & and not get annoyed into oblivion whenever you forget. Oh, and did you want to switch back to one of your old CJS projects? Sorry, you're never gonna escape the negative transfer, no matter what you do.\nWhether or not the annoyance is small (and it is), it's still a time bomb for flow & a pointless waste of time. You're right that mode isn't ideal, but it does offer a way out from that mess.\n(That's not the only reason, to be sure, but it's a pretty salient one -- the backbone of Node.js is all that free work & .mjs is a barrier to that work continuing)\n\nI'm not sure what you mean by \"file previews\" in this context. Could you clarify?\n\nI was referencing this tweet by @jdalton, which I wasn't able to find when I originally posted.\n\nAssuming this refers to existing file-viewing tools that currently don't know how to handle the .mjs extension: I see how this would be a problem in the short term, but I don't see how this would be \"impossible to fix\", as you described it.\n\nIt's not, but it hints at the actual problem -- all the sunken code out there that has a hardcoded map for .js -> javascript. Short of statistical modeling, no one will never convince me that even a single percentage point of that code will be changed.",
                            "createdAt": "2018-03-09T00:00:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@zackschuster any of that code that's not changeable for mjs is also not changeable for modern JS syntax, potentially including import and export.",
                            "createdAt": "2018-03-09T00:10:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "Regardless of how modules are disambiguated, the community will need to be made aware of it. I don't see how it would be more difficult to tell people to use .mjs than it would be to tell people to add a flag to package.json.\n\nYou have maintainers right now saying they'll stick to CJS if they're forced to use .mjs for native modules. I get into some of the reasons why below, but the net effect is that migration of old code hits a substantially lower ceiling without maintainer buy-in, which makes everyone's lives worse in the long tail.\n\nMy original comment here was with regard to communicating mjs to new users (since you said that \"it would require a massive amount of distributed effort by the community to initiate new people with that knowledge\").\nRegarding maintainer buy-in: I think many of the reasons that users prefer the .js extension are based on misconceptions about what is possible given the JS spec (e.g. #18392 (comment)), or preferences for variations that would not have allowed modules to migrate without breaking changes (e.g. #18392 (comment)). Many people have many different ideas about how how module loading should work, and almost all of these ideas have already been discussed extensively (in nodejs/node-eps#13 and other places). I think some users have a knee-jerk reaction to changing file extensions on the incorrect assumption that Node failed to consider some easier path. In fact, the decision to introduce a new file extension was not made lightly -- it was made after considering just about every other option.\nIn other words, I think some users are opposed to .mjs because they believe that a simpler solution exists involving .js, not because they believe the cost of changing a file extension is exorbitant. If we added a package.json solution, the sentiment might just shift from a belief that .mjs is unnecessary to a belief that a package.json flag is unnecessary.\nI also think the set of people who keep track of Node's experimental proposals is not a representative sample of the Node community as a whole. People who follow experimental proposals are more likely to be power users who are generally very familiar with how Node works, and for whom adding a package.json flag is not a big concern. On the other hand, for beginners using a specific file extension is much easier than adding a package.json flag, because the ESM behavior effectively becomes the default. (If someone is creating a file, then they need to figure out what extension to add anyway; it's easy to tell them to just always use mjs. Adding a package.json flag is an additional step that a beginner is more likely to forget.) As a result, I think there is a disproportionate amount of negative feedback about the .mjs extension, and a disproportionate amount of positive feedback here about a package.json flag, in comparison to how beneficial these behaviors would be for the ecosystem as a whole.\n\nThen you also have to train yourself to always create a new file with the new extension & and not get annoyed into oblivion whenever you forget. Oh, and did you want to switch back to one of your old CJS projects? Sorry, you're never gonna escape the negative transfer, no matter what you do.\nWhether or not the annoyance is small (and it is), it's still a stacking debuff that takes quite a while to clear & will most certainly interrupt whatever flow you're in. You're right that mode isn't ideal, but it does offer a way out from that mess.\n\nThis seems like a general problem with having two different file modes, and not a problem with the .mjs file extension in particular. Sure, it's possible to accidentally use the wrong file extension, but it's also possible to accidentally use module.exports = foo rather than export default foo. Adding a mode flag doesn't help in this case.\n\nIt's not, but it hints at the actual problem -- all the sunken code out there that has a hardcoded map for .js -> javascript. Short of statistical modeling, no one will never convince me that even a single percentage point of that code will be changed.\n\nI don't share your skepticism about this point. As I said before, I see how this would be a problem in the short term, but it seems reasonable to me that tools for tools that end up processing .mjs files would eventually be updated to handle them appropriately.",
                            "createdAt": "2018-03-09T01:21:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "zackschuster",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark sorry, got my points a bit mixed up. since we're taking up a lot of space here, i'll suggest we switch to email if you want to continue the discussion :)",
                            "createdAt": "2018-03-09T17:32:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\nYou have made some great points about the added complexity of introducing yet another way of figuring out whether the file is a module or script. I was starting to get convinced...\n\nMy understanding is that the main reason for users to write modules in .js files as opposed to .mjs files is an aesthetic preference for the .js file extension, as opposed to technical limitations that require the use of .js\n\nIf you were right, I would definitely adher to simplicity above aesthetics, even though the community is very vocal about the mjs extension (negatively). Your point about beginners understanding using .mjs as a much easier entryway to ESM as opposed to a flag in package.json struck a chord in me.\nUnfortunately, there is, I believe, another reason that developers want to continue using .js for ES modules: the browser community. NPM and the module ecosystem is now a dual-mode ecosystem: it serves both the browser and the nodejs community.\nIn the browser community, .mjs is unneeded. Most developers that write code using modern tooling are already using ESM (via bundlers/transpilers), and they're using it with the .js extension. They don't understand why they would need a different extension. And this works even if they don't use bundlers but rather use the native ESM support (because it is the \"import site\" that defines the parsing goal of the importee)\nSince U don't want a split in the npm community, and as a lot of those packages work both in the browser and in nodejs, I believe we need a way to enable packages to say\u2014my .js files are ESM and not CJS.\nWhich is why, even though this PR adds complexity, I still want to accept it.",
                            "createdAt": "2018-03-10T07:52:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@justinfagnani the approach you describe in #18392 (comment) is completely valid - and the trade-offs are seen towards the edges of the workflows:\n\nBuild tools have to deal with double linking (the build is now (a) build the ES module tree (b) build CJS module tree, dealing with code splitting boundaries carefully across these two layers etc and making sure things like circular references and execution order all work out)\nNo non-breaking upgrade path for libraries to move from CommonJS to ES modules.\nCognitive overhead for all users to know what module format they are importing for each package they import. Whereas with a flag, it is a cognitive overhead only incurred when creating my app once, and then you never think about it for new package installs.\nApplication code including require means ES modules are tainted to not be immediately runnable in the browser with just a resolver due to the sync require. There are mapping schemes for shimming CommonJS if we use the resolver for this stuff.\n\nThese problems are all surmountable, but it is a matter of weighing up wider ecosystem costs.\nFor an example of how this stuff works with a mode flag, say I have an app with import React from 'react' where react is still provided as CJS (no \"mode\": \"esm\"):\n\nMy app can build React with existing build tools already do today without needing to use a double-linking (ES module execute first, then CJS module execute second) build technique that is yet to be developed and understood using both ES module linking and a require linking with an internal registry (internal module registries are necessary for builds of CJS in order to ensure execution, while they aren't for ES modules due to the mergeability property of modules).\nWhen the browser has a resolver manifest or similar, I can run this code in the browser, just by setting up a map for React to a CDN source. If the code used require this wouldn't be possible due to require not being possible to shim in browsers without CPU-consuming in-browser code analysis.\nReact can add a mode: esm as a non-breaking change, and my app still works.\nWith the ESM version of React my build tooling and browser workflows can remain identical - just now with an ES module build of react. There is no need to change from require to import.\n\nWe should do the utmost to ensure the transition we create is the simplest one possible for users throughout the ecosystem. Weighing up these wider trade-offs is important to that, and I look forward to discussing this further from all perspectives.\n//cc @ceejbot @chrisdickinson @iarna",
                            "createdAt": "2018-03-10T11:09:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "michael-ciniawsky",
                                "__typename": "User"
                            },
                            "bodyText": "module.js\nimport esm from './module.js'\nimport pkg from '@pkg/module'\n\nimport('./module.js').then((module) => ...)\nimport('@pkg/module').then((module) => ...)\n\n// ESM <= CJS (Migration)\nconst { require, ... } = import.meta\n\nconst cjs = require('@pkg/main')\ncjs.js\nconst pkg = require('@pkg/main')\nconst cjs = require('./cjs.js')\n\n// CJS <= ESM (Interop)\nimport('./module.js').then((module) => ...)\nimport('@pkg/module').then((module) => ...)\nWhat are the benefits of mode: 'esm' over explicitly declaring which files of a package are CJS (main) and which are ESM (e.g module) ? I still don't grasp how especially a dual-mode package would look like/work with mode: 'esm'. Assuming it doesn't and you have to either publish two packages anyway or use .mjs for dual-mode within a package, which is really confusing. How should build tools handle mode: 'esm' ?  I think something like module (explicit) is definitely cleaner and enables would allow dual-mode packages aswell. It's also more in 'cognitive alignment' with <script src=\"./script.js\"></script> <=> pkg.main = './cjs.js' && <script src=\"./module.js\" type=\"module\"></script> <=> pkg.module = './module.js\n\n\n\n''\nCJS\nESM\n\n\n\n\nnode\nrequire\nimport/import()\n\n\nnpm\nmain\nmodule\n\n\nBrowser\n<script>\n<script type=\"module\">\n\n\n\nimport cjs from './cjs.js' \u274c\nimport pkg from 'pkg/main' \u274c (or no `mode: 'esm'`)\n\n\u2139\ufe0f I'm not specifically referring to any known pkg.module proposal here, my main concern is the implicitness of mode compared to something like e.g  module",
                            "createdAt": "2018-03-10T17:48:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "@giltayar Thanks for the response, that's an interesting point.\n\nIn the browser community, .mjs is unneeded. Most developers that write code using modern tooling are already using ESM (via bundlers/transpilers), and they're using it with the .js extension. They don't understand why they would need a different extension. And this works even if they don't use bundlers but rather use the native ESM support (because it is the \"import site\" that defines the parsing goal of the importee)\n\nI'm just going to focus on the use case involving bundlers/transpilers for now, because (a) I think using bundlers/transpilers is currently much more common than using native browser ESM support, and (b) when using native ESM support without transpiling, whatever we decide about Node is irrelevant, e.g. a package.json flag wouldn't work either since the browser would only check for type=\"module\".\nThe current behavior of Babel is non-spec-compliant in several ways. For example, using import {foo} from 'bar' grabs the 'foo' property off of the default export object in Babel, whereas the two objects should be distinct according to the ES spec. I think Babel also has a non-spec-compliant way of distinguishing between CJS and ESM. Babel is considering changing this behavior in the next major release, but it's not currently proposed that Node should adopt Babel's non-spec-compliant behavior. As a result, most people using Babel for ESM will probably have to do a migration anyway to get it to work without Babel, regardless of what Node decides here. It's true that someone might wonder why they have to use a different file extension, but they might also wonder why they have to use import bar from 'bar' rather than import {foo} from 'bar' when bar has no foo export. In both cases, a migration would be necessary for good reason. As a result, I don't think the existing use of .js when using transpilers is a convincing case for supporting ESM modules with .js when using Node.",
                            "createdAt": "2018-03-10T18:03:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\n\nBabel is considering changing this behavior in the next major release, but it's not currently proposed that Node should adopt Babel's non-spec-compliant behavior.\n\nThere is a PR for named exports of at least builtin modules over at #18131",
                            "createdAt": "2018-03-10T18:09:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton To clarify, I mean that Node is not planning to do that implicitly for external modules, as Babel does. If I'm understanding that PR correctly, it would only be applied to the modules that are shipped with Node, which would have the same effect as just doing export { readFile, readFileSync, ... } in those modules anyway.",
                            "createdAt": "2018-03-10T18:13:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\nThe ESM facade for CJS could be applied broader (more than just builtin modules).\nI'm experimenting with that in my implementation at the moment.",
                            "createdAt": "2018-03-10T18:17:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark #16675 would have made node form named exports for all cjs modules, if you go to the bottom you'll see why we can't do it",
                            "createdAt": "2018-03-10T18:17:30Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek\n\nwould have made node form named exports for all cjs modules, if you go to the bottom you'll see why we can't do it\n\n* shrug * Using the technique from #18131 I've gotten it to work well with CJS modules in the ecosystem. That said, I also have a few more support toggles than the older #16675 and #18131 attempt.\nUpdate:\nRegardless, I'd like to avoid derailing this PR with chatter on others. My initial comment was meant as just a quick FYI.",
                            "createdAt": "2018-03-10T18:21:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@jdalton can you come on irc for a sec? btw you'll need to register with the nickserv to join #node-dev (i believe thats why you couldn't send messages last time)",
                            "createdAt": "2018-03-10T18:22:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark\nReally? Babel is non-compliant that way? I didn't know that. That definitely lessens my argument, because, as you said, work migrating to native ESM in NodeJS will need to be done anyway. But it doesn't kill the argument entirely.\nIf babel/webpack suddenly got more compliant in the way that you mentioned, and people would have to deal with the default export thing, they would grumble and mutter, but do the change, because \"it conforms to the spec\".\nBut imagine, for a second, that for the sake of not causing a rift in the npm world, babel 7 would require the NodeJS way of defining whether a module is CJS or ESM, i.e. an .mjs extension. Think of the uproar that would cause. And for good reason! The browser community would say that the move to .mjs is due to NodeJS concerns, and not browser concerns, and so they should not be asked to change the extension.\nThe mode=esm flag is a way to deal with that. They (the browser community) continue to use the js extension, and if they want the code to also work in NodeJS, they just add a mode=esm to their package.json. There's a Stack Overflow for that! :-)\nI, for one, will use the .mjs extension, as it's much clearer. But I understand people that would like to stick to .js.",
                            "createdAt": "2018-03-11T06:25:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "But imagine, for a second, that for the sake of not causing a rift in the npm world, babel 7 would require the NodeJS way of defining whether a module is CJS or ESM, i.e. an .mjs extension. Think of the uproar that would cause. And for good reason! The browser community would say that the move to .mjs is due to NodeJS concerns, and not browser concerns, and so they should not be asked to change the extension.\n\nYou may be surprised to hear that babel is already considering this at babel/babel#7501. I personally don't think there would be that much uproar*, for a few reasons:\n\nNode can establish a convention that gets used for all JavaScript files (even those that don't run on Node directly), and following the same convention would make things easier for everyone.\nBabel is a tool that runs with Node, even if the target files sometimes don't.\nIn the big scheme of things, not that many people care about file extensions.\n\n* ...in comparison to the size of the userbase, anyway. Notwithstanding the fact that every discussion about file extensions seems to turn into a very long discussion on GitHub.\nedit: To clarify, Babel is considering changing the default behavior. I don't think they are considering requiring the use of a file extension -- the inferred mode from the file extension option can be overridden with a directive in a .babelrc file.",
                            "createdAt": "2018-03-11T07:08:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "giltayar",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark - Oh, wow. I hope that PR will land! I am all for .mjs...\nBut as you said, Babel will allow treating js files as ES modules using a directive in .babelrc. And this makes sense, given that most people prefer their files .js style and aren't concerned with the (probably very small) bad consequences of the choice in their code. Note the wording the PR uses:\n\nI also want to make clear that you can still easily set sourceType:module in your Babel config to keep the current behavior, but the important question here is the default.\n\nI interpret the tone of that sentence as the writer of the PR understanding that it would be difficult to transition everybody to a .mjs world immediately, and that there would be a backlash.\nSo even if that PR will land, I believe people will continue using .js, which brings us back to square one, where I believe NodeJS should define a similar directive, which is the mode=esm flag.",
                            "createdAt": "2018-03-11T07:40:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "There are a few differences between Babel and Node in this regard:\n\nBabel already reads a config file with many configuration options to control how it behaves. (This allows Babel to be very powerful, but it's also a disadvantage in the sense that it makes Babel more difficult for users to set up.) In contrast, Node generally does not have much configurability, which is (IMO) a good thing.\nBabel has a lot of users that are already using (some variant of) ESM in .js files. I think they plan to change the defaults to make them more spec-compliant, but they are adding configuration options to keep the old behavior so that users can upgrade to a new version easily without breaking everything.  In contrast, there is currently no ESM code that runs directly on Node without experimental flags, so no config flags are needed for legacy compatibility.\n\nI think these factors would make it a good idea for Babel to have a source type override flag, but not necessarily a good idea for Node to have one.",
                            "createdAt": "2018-03-11T08:03:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "Forgive me for joining this discussion so late, but rather than (or in addition to) an .mjs file extension or flag in package.json or --mode command-line flag, why not treat the presence of import and export statements in input source code as a way to tell Node whether to use \u201cES module mode\u201d? Just like \"use strict\" triggers strict mode, an import or export statement by itself would be enough to trigger ES module mode, the same as using an .mjs extension or a package.json or CLI flag. And this automatic ES module detection would presumably save a lot of projects from needing to refactor to use Node\u2019s native ES module support.\nIf your code doesn\u2019t happen to do any importing or exporting, and you still want to trigger ES module mode through code alone, you could put export default {} somewhere in your file. This use case would be if you wanted to have a freestanding script without any of the CommonJS globals defined, and in strict mode.\nThis came up for me because I\u2019m trying to implement support for modules in a downstream tool and running into the issue that there\u2019s currently no way to tell Node to treat string input as an ES module rather than in CommonJS mode (#19725). Adding --mode=esm would solve that particular issue, but I\u2019m wondering why it\u2019s necessary. An import or export statement in CommonJS mode is currently always a SyntaxError, so I would think that such statements should automatically trigger ES module mode. If you really wanted the error, a new --mode=cjs or package.json option could force Node to treat the input as CommonJS. Especially if ES module mode is supposed to be the standard and the new default, it makes sense that extra configuration effort should be required to not use it, rather than to opt in to it, at least when we know a file is probably intended to be an ES module (because it has import and export statements).",
                            "createdAt": "2018-04-01T20:29:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@GeoffreyBooth that\u2019s been discussed many many times; the nonzero possibility that a file can be parsed both as a Script and a Module means that this option simply isn\u2019t tenable as a default (altho users can do whatever they want with a custom loader). Efforts in TC39 to make parsing unambiguous failed, and node (correctly) won\u2019t deviate from the spec and browsers in this regard.",
                            "createdAt": "2018-04-01T20:36:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "@GeoffreyBooth this has been proposed, with a previous proposal at https://github.com/bmeck/UnambiguousJavaScriptGrammar. Perhaps we need somewhere to summarize the arguments that came against it but I believe it came down to empty source ambiguity being a very real problem (modules are by default in strict mode, so interpreted completely differently - it would be a complete semantic change between having or not having any import or export statements), and also that there is currently no way to do such a thing in the engine, let alone performantly as it implies a double-parsing process. I may well have missed other arguments here.",
                            "createdAt": "2018-04-01T20:36:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "I searched around before posting this suggestion and couldn\u2019t find any discussion if it, so if it\u2019s out there, please point the way. I found https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md, which seems to be under consideration because of this PR, so I figured these issues were still open for debate.\nIn particular, when the \u201cdetect ES modules automatically\u201d idea was shot down before, was the idea of external configuration on the table? External configuration being the package.json key discussed in this PR, or the --mode CLI flag, or the .mjs file extension itself. Because if it wasn\u2019t, the ability to override the default might solve the ambiguity problem. Even if looking for import statements is too vague, a new \"use modules\" string like \"use strict\" could potentially solve the issue. It\u2019s not a pattern we want to follow, for sure, but it\u2019s not like .mjs and external flags don\u2019t have their own issues.",
                            "createdAt": "2018-04-01T20:45:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "https://github.com/bmeck/UnambiguousJavaScriptGrammar references package.json flags, and \"in defense of js\" was created before the unambiguous grammar proposal, so yes configuration was already very much on the table when these decisions were made.",
                            "createdAt": "2018-04-01T20:50:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "I\u2019d love to read an explanation of why automatic detection shouldn\u2019t happen as the fallback behavior, if no explicit configuration is specified by the user. As in, I feel like this should not throw an error:\nnode --experimental-modules --eval 'import path from \"path\"; console.log(path.sep);'\nIn my mind, \u201cthe nonzero possibility that a file can be parsed both as a Script and a Module\u201d means that Node needs to provide configurability, so that the user can specify Script or Module mode explicitly to avoid ambiguity. We\u2019re all in agreement on that, and both the .mjs extension and this PR provide ways for that configuration to be specified. The issue I\u2019m trying to address is what Node should do when the user hasn\u2019t made their intentions explicit, such as in the example here. I feel like Node should attempt to infer what the user wants, rather than always default to CommonJS even when that\u2019s unlikely to be desired.\nI\u2019m sorry if this feels like something you debated and settled upon years ago. Perhaps the README for https://github.com/nodejs/modules would be a great place for some links to the various proposals and why each was rejected.",
                            "createdAt": "2018-04-01T21:14:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@GeoffreyBooth ideally I would like --mode=esm to be the default mode, which would do what you describe. but before that we have to figure out the semantics of modes and how it will interact  with package.json etc rtc etc. until then it will continue to default to cjs. also I am working in nodejs/modules#35 to do just what you ask with listing all the information.",
                            "createdAt": "2018-04-01T21:29:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "not-an-aardvark",
                                "__typename": "User"
                            },
                            "bodyText": "@GeoffreyBooth I think the general issue with Node inferring the source type is that users would start to rely on Node's inference behavior. As a result, users would end up with confusing behavior switches caused by seemingly-unrelated changes to code (e.g. their entire source text would start getting interpreted in strict mode after they add an import). Also, Node would be unable to change the heuristic it uses to infer source type in the future without breaking user code.\nI think this is a case where trying to guess what the user wants seems like it would be useful in the short term, but would not be worthwhile in the long term because users wouldn't understand why their source code is being parsed the way that it is. In that respect, it's similar to language features like implicit coercion in JS with the == operator; it might provide a minor convenience in simple cases, but it's generally discouraged because its behavior can lead to surprises.",
                            "createdAt": "2018-04-01T21:43:18Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "@not-an-aardvark I understand your point, but I don\u2019t think this is equivalent to == vs === or quirks mode vs strict mode. Adding an import will cause the entire file to be in strict mode whether or not you adopt my proposal. My proposal might make that effect less obvious, as it would happen automatically as opposed to the user having to spend some time fussing with Node and build pipeline configuration in order to get their import statement to work before they would discover the change; but it would happen either way.\nThe bottom line is that Node inferring the module mode, when it can do so safely, would lead to a better user experience. A better user experience for ES modules mode will lead to more rapid adoption. The current approach of the .mjs extension leaves so much to be desired that we have this PR, and even this PR leaves so much to be desired that I, for one, wish things were easier. It doesn\u2019t really feel like Node 10 is adding native support for modules if that support is opt in, forever, via .mjs or package.json or --mode.",
                            "createdAt": "2018-04-01T22:35:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@GeoffreyBooth adding an import to a Script, with the current plans, would cause your program to crash because it's invalid in a Script - until you explicitly changed it to a Module. It's far better to force explicitness than to infer something that might be wrong.",
                            "createdAt": "2018-04-01T22:39:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "adding an import to a Script, with the current plans, would cause your program to crash because it\u2019s invalid in a Script - until you explicitly changed it to a Module.\n\nAnd a crash is so obviously not what the user wants that that\u2019s why it makes sense to infer that they want Node to treat the code as a Module.\nAnyway, please merge in this PR as soon as possible so that --mode provides a way to activate ES module mode for forms of input other than files, such as --eval or stdin or the REPL.",
                            "createdAt": "2018-04-01T22:47:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "WebReflection",
                                "__typename": "User"
                            },
                            "bodyText": "please merge in this PR as soon as possible\n\napparently @bmeck has been explicitly required for this review and I really hope this will be in ASAP too.",
                            "createdAt": "2018-04-01T23:41:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "this pr is currently frozen while the node modules team discusses implementation/usage stuff. once again you can follow what we're doing at https://github.com/nodejs/modules. sorry for the delay :)",
                            "createdAt": "2018-04-01T23:46:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "guybedford",
                                "__typename": "User"
                            },
                            "bodyText": "And a crash is so obviously not what the user wants that that\u2019s why it makes sense to infer that they want Node to treat the code as a Module.\n\nOnce we've decided on what we want users to do here, I'd like us to catch this error and add an extra note to users informing them how to make module code run in Node.",
                            "createdAt": "2018-04-02T10:52:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "Any further progress here?",
                            "createdAt": "2018-04-28T14:07:38Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR blocked because its a new feature and modules team doesn't want to land new features atm",
                            "createdAt": "2018-04-28T14:14:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek is there an issue that could be referenced to know when things are going to be unblocked again?",
                            "createdAt": "2018-04-28T14:19:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@BridgeAR i re-opened nodejs/modules#42 which should be good enough for now i suppose",
                            "createdAt": "2018-04-28T14:24:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@devsnek nodejs/modules#42 is closed, any other reference?",
                            "createdAt": "2019-03-01T15:08:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "devsnek",
                                "__typename": "User"
                            },
                            "bodyText": "@MylesBorins maybe has something, I'm not 100% sure",
                            "createdAt": "2019-03-01T15:56:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "richardlau",
                                "__typename": "User"
                            },
                            "bodyText": "Is this superseded by #26745?",
                            "createdAt": "2019-03-19T02:00:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "GeoffreyBooth",
                                "__typename": "User"
                            },
                            "bodyText": "Is this superseded by #26745?\n\nYes.",
                            "createdAt": "2019-03-19T02:01:00Z"
                        }
                    }
                ]
            }
        }
    },
    {
        "node": {
            "number": 19335,
            "title": "process: add allowedNodeEnvironmentFlags property",
            "author": {
                "login": "boneskull"
            },
            "state": "CLOSED",
            "closedAt": "2018-08-25T01:17:16Z",
            "comments": {
                "totalCount": 143,
                "edges": [
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "The whitelist of NODE_OPTIONS-able flags (not counting v8 flags) correspond to the set of flags a CLI application may want to pass along to a spawned node process. Put another way, other Node.js-specific flags are essentially useless to CLI apps wrapping node.\n\nI'm not sure this is true. The original idea was for NODE_OPTIONS to be able to pass through any flags except a few that didn't make sense, but it was changed to a whitelist due to security concerns (#12028).\nIt seems quite likely to me that there are flags that cli apps like mocha might want to pass to node that are not in the NODE_OPTIONS whitelist.\nEDIT: I'm not sure what the best solution to this is, but maybe it would be enough to just expose all of the command line flags, and then filter the ones you don't need in mocha.",
                            "createdAt": "2018-03-14T10:43:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "It doesn't address V8 flags\n\nWhat would be your preferred solution to this @bnoordhuis ? Presumably the best solution would be to add a similar option to V8 that returns a list of flags, and then expose those flags in a similar way. Things probably start to get complex though, we'd probably want process.flags.node, process.flags.v8, and maybe process.flags.both (not to mention maybe process.flags.nodeOptions for the NODE_OPTIONS whitelist).\nI guess alternatively we could do what you suggested in #17740 (comment) and parse the output of d8 --help when building node or something?\nEither way, as long as we allow for the option of adding V8 options in the future, I don't see why we'd need to add V8 options at the same time as node options.\nAm I right in thinking that all V8 options start with --v8? If so then with this config variable you can easily work out whether a flag should be forwarded to node or not",
                            "createdAt": "2018-03-14T11:18:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "What's the use case for this?",
                            "createdAt": "2018-03-14T11:55:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "What's the use case for this?\n\n@jasnell that's covered in the linked issue (#17740).",
                            "createdAt": "2018-03-14T13:15:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "-1. The justification seems pretty unconvincing.",
                            "createdAt": "2018-03-14T13:27:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "-1. The justification seems pretty unconvincing.\n\n@vkurchatkin Can you provide a little more detail? Is the use case invalid? Or is this something that doesn't need to be in core? Or...what's unconvincing?",
                            "createdAt": "2018-03-14T14:54:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vkurchatkin",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott In the issue @boneskull admits, that something like --node-flags= would solve the problem. That's something that I would do without a second thought.\nYes, I would say that the use case is invalid, in my opinion. Even if it wasn't, just one pretty specific use case doesn't warrant such an addition.",
                            "createdAt": "2018-03-14T15:15:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "Okay, so thinking about this further (and talking to @boneskull), if the purpose of this option is to allow people who write cli apps to know which flags a user might want to pass through to node, then having the list of relevant flags match the list in NODE_OPTIONS might make sense. It depends whether there's a difference between the two lists.",
                            "createdAt": "2018-03-14T15:31:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "This would be useful for any CLI app which chooses to \"pass through\" Node.js options.  It provides a better UX than having to execute a script via node <flags> /path/to/executable <more flags>.  It's also easier to stomach for those users who are new to the command line.  Likewise, it's a better UX than prefixing each with --node-.\nIf the above seems too particular or unnecessary, I hope reviewers can briefly put themselves in the shoes of maintainers, contributors, and consumers of userland CLI apps.  In other words, please don't dismiss it just because it's not something which you often encounter or struggle with.\n\nThe reason this does not include \"all\" flags (v8 flags nor non-NODE_OPTIONS-flags) is threefold:\n\nCLI apps can match against /--v8-.+/ and pass those through. There's no such easy regex for matching Node.js flags.\n--version, --help and its ilk (flags not appearing in NODE_OPTIONS) are essentially useless, as they fundamentally change node's behavior to something other than \"execute this script\"\nIt will add more complexity / overhead to gather the v8 flags, whether at compile or runtime\n\nThen, I don't know of a use case (this does not imply there isn't one, of course) for \"all\" flags unless besides the human need to be completionist.  Collect 'em all, etc.  \ud83d\ude09",
                            "createdAt": "2018-03-15T21:20:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "One reason for \"all\" flags is, then I don't have to know to pass through v8 options - I just have this list as a single source of truth.",
                            "createdAt": "2018-03-15T22:47:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb This is true.\nEntertaining the idea further, if they were to be added:\nIf I were to parse d8 --help (or whatever node --v8-options calls) at build time, what would be the preferred way to pull that output in?  Generate a text file and parse it?  Generate a header file?  #define a bunch of stuff?\nIf we do do that, it means we're parsing output intended to be human-readable.  IMO, this isn't too terribly kind to the v8 team.  The output will also vary by architecture.\nMaybe better to read flag-definitions.h directly?",
                            "createdAt": "2018-03-15T23:21:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "I'd like to get @addaleax's take on this. I know she's been giving some thought to improved handling of the command line arguments here recently and may have some ideas on how to best proceed here.",
                            "createdAt": "2018-03-16T14:28:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "(a friendly nag at @addaleax)",
                            "createdAt": "2018-03-26T21:15:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull Sorry, kinda missed the ping here. I don\u2019t have strong opinions on this, and I don't think the kind of refactor I'm having in mind would necessarily change the API for this feature.\nI would, however, appreciate a more expressive name than envFlags -- maybe something like process.allowedEnvironmentNodeFlags? It's verbose but it gets to the point of what this array means.",
                            "createdAt": "2018-03-26T21:54:20Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I'll go ahead and change the name.\nCan I please have some guidance as asked in this comment?  I would like to see if I can pull the v8 flags in as well, but I'm unsure of how others would approach this.",
                            "createdAt": "2018-03-27T00:42:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "Maybe better to read flag-definitions.h directly?\n\nThat won't work (reliably) for the following reasons:\n\nits implementation changes over time (maintenance hassle)\nits content changes based on V8's build flags, which are different from node's build flags\nit gives the wrong answers when linking against a shared library build of V8\n\nA couple of solutions/workarounds:\n\nPetition V8 for an API that lets you query the flags at runtime.\nTwo-stage build: parse output of node --v8-options and compile that into the stage 2 build\nHack: redirect stderr with e.g. fmemopen() and call v8::V8::SetFlagsFromString(\"--help\").\n\n(2) and (3) are still prone to break when the format changes; (1) is arguably the best option.",
                            "createdAt": "2018-03-27T09:21:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I'd rather not introduce (2) or (3) if it's prone to break, unless there are some guarantees from V8 that it won't.  I'll follow up there.\n@ljharb Does this sound reasonable?\n\nWe exposed process.allowedEnvironmentNodeFlags (roughly as this PR is written)\nPetition V8 for runtime access to flags\nAdd the V8 flags as e.g. process.allowedV8Flags when/if runtime access to V8 flags lands",
                            "createdAt": "2018-03-27T19:46:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull seems like a good plan. Any chance they could be an object mapping arg names to provided values rather than just a list of allowed names?",
                            "createdAt": "2018-03-27T20:14:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb That sounds like just cross-referencing with process.execArgv...?",
                            "createdAt": "2018-03-27T21:04:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "fair, it just seems like it\u2019d be nice to avoid the extra step.",
                            "createdAt": "2018-03-27T21:28:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I've made some modifications:\n\nrenaming of property to allowedEnvironmentNodeFlags (cc @addaleax)\ncross-reference list of flags with NODE_OPTIONS to ensure I wasn't missing anything (cc @gibfahn)\nwrote a list of explicitly excluded flags and justification\n\nInsofar as petitioning V8 (as suggested by @bnoordhuis), I had hoped it would be obvious how to do such a thing, but I was mistaken.  How should I do this?  Mailing list?  Bug tracker? Any other suggestions on how to frame the request?",
                            "createdAt": "2018-04-09T22:25:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@nodejs/process",
                            "createdAt": "2018-04-09T23:37:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "Insofar as petitioning V8 (as suggested by @bnoordhuis), I had hoped it would be obvious how to do such a thing, but I was mistaken. How should I do this? Mailing list? Bug tracker? Any other suggestions on how to frame the request?\n\nSounds like a question for @nodejs/v8",
                            "createdAt": "2018-04-10T20:56:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "Having briefly read this thread and related issue, I have to reply with a firm no wrt exposing a list of V8 flags through an API that Node.js users would rely on. Here are some reasons:\n\nUnless explicitly stated otherwise, V8 flags are not safe to play around with. To paraphrase the issue title, they should not belong in a list of allowed flags. The fact that some frameworks rely on V8's internal flags should not be encouraged.\nV8 flags are not considered part of the a public API. In fact, they are neither thread safe nor safe to use across multiple isolates. Most of them are either debugging help, a way to test incomplete features, or heuristic settings.\nV8 developers love the flexibility of being able to introduce new flags, no strings attached. Having Node.js depend on V8's internal flags would ruin this freedom.\nI personally have seen very bad examples of how V8 flags have been used. --allow-natives-syntax, --use-strict, --always-opt, and most of the experimental --harmony-XX flags for incomplete language features, just to name a few.\nCustom flags that are not the shipping configuration do not get sufficient test coverage. You could run into stability issues or worse.\n\nThat being said, there are a few flags that are safe to use, and probably won't change much over the years. E.g. --no-opt, --prof, --trace-deopt, etc. But I think it's overkill to introduce a way to feature-detect them.",
                            "createdAt": "2018-04-10T21:18:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@hashseed isn't that list of \"bad examples\" a contradiction to your claim that V8 devs have the flexibility to add new flags without consequence?",
                            "createdAt": "2018-04-10T21:31:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "it's that list of \"bad examples\" a contradiction ...\n\nI wouldn't think so if you view the flags as experimental and debugging switches as opposed to Things-To-Use-In-Production, which is the distinction that I believe @hashseed is making here.\nWhat I could see as a possible option here... is making process.allowedEnvironmentNodeFlags([options]) a method with an includev8: true option that would include a whitelisted subset of known-safe v8 flags. It's not a great option by any stretch, but it is an option.",
                            "createdAt": "2018-04-10T21:38:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "V8 flags fundamentally differ from Node flags in their purpose. I'll admit that this difference is not obvious and it's unfortunate that users have been misunderstanding the purpose of V8's flags, but that doesn't mean we need to encourage these uses.",
                            "createdAt": "2018-04-10T21:44:04Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "who is to whitelist the subset of v8 flags?  I don\u2019t believe Node should be in the business of determining which are safe.\nI\u2019d like to remind us that listing any v8 flags is beyond the original scope, and adding them may only be for the sake of completionism instead of any real use case.",
                            "createdAt": "2018-04-11T02:50:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis @ljharb :\nLooking at this thread, it looks like you were the ones interested in having the V8 flags included. Given the feedback from @hashseed , do you still think this PR should include the V8 flags?",
                            "createdAt": "2018-04-11T10:46:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "I do. Anything users can do to change the runtime is something i need to detect; for example, some v8 flags make new core modules available. @hashseed\u2019s concern seems to be users using the flags; making them easier to detect at runtime doesn\u2019t seem to me to conflict with that.",
                            "createdAt": "2018-04-11T14:15:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I withdraw my previous comment, as it sounds like @ljharb has a use case.",
                            "createdAt": "2018-04-11T16:58:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jdalton",
                                "__typename": "User"
                            },
                            "bodyText": "@ljharb Can you expand on your use case. The project this bit can be helpful with, how you're working around the lack of this now, etc.",
                            "createdAt": "2018-04-11T17:02:10Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "For one, the resolve module currently has a long hardcoded list of core modules with quasi semver ranges, to be able to determine what a core module is (for linters, bundlers, module loaders, etc). Since there are some core modules that are only available when a flag is set, i currently have to report them as either always core, or never core. I would prefer to report them as core only when they are requireable as such - which would necessitate me checking the flags. A reliable and ergonomic way to do this would be nice, as i think parsing argv is too much complexity for a small leaf package like resolve.",
                            "createdAt": "2018-04-11T17:29:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@hashseed,\nI understand that the v8 team discourages users from actually using these flags, but at the same time, we can't pretend they don't exist.  Since they exist, users will use them.  As it currently stands, a userland  module couldn't efficiently warn a user about consuming flags they shouldn't:\n$ node --some-v8-flag script.js\nWARNING: \"--some-v8-flag\" is unsupported!!\nA brittle workaround is to parse the output of v8's --help.  But nobody expects the \"help\" output of their executable to be parsed by a machine! \ud83d\ude04",
                            "createdAt": "2018-04-11T17:29:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not pretending that users are not going to use these flags. I'm merely advising not to encourage users to use them. Offering an API as requested sounds like encouragement to me. That would give the appearance and false sense that their usage is tested and supported.\nSince every V8 flag should be considered unsupported by default, I don't really see the benefit of providing an API to get these unsupported flags. In this use case\n$ node --some-v8-flag script.js\nthere should always be a warning unless the flag is in a very small and manually curated set of flags that have been explicitly confirmed to be safe. I agree that this set could be curated by V8 and exposed via API, but in that case, don't be surprised if that list is very short.",
                            "createdAt": "2018-04-11T18:25:49Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "If they\u2019re not safe, then I\u2019d argue they shouldn\u2019t be there at all. Users always do whatever they\u2019re allowed to do - the only way to prevent usage is to actually remove the capability.",
                            "createdAt": "2018-04-11T18:29:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "Then I would ask Node to not call v8::V8::SetFlagsFromString or filter its input. That API was originally intended for V8's developer shell for testing.",
                            "createdAt": "2018-04-11T19:33:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "any change to Node.js' behavior around passing v8 flags should probably be tackled in a separate issue...",
                            "createdAt": "2018-04-11T20:15:35Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "Since every V8 flag should be considered unsupported by default, I don't really see the benefit of providing an API to get these unsupported flags. In this use case\n$ node --some-v8-flag script.js\n\nthere should always be a warning unless the flag is in a very small and manually curated set of flags that have been explicitly confirmed to be safe.\n\nI'm confused; Node & userland can't warn a user about using v8 flags if we don't know what the v8 flags are.  This is why we want the list of flags...",
                            "createdAt": "2018-04-11T20:21:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "I agree.\nLet me recap on the V8 flags issue. The use case is to be able to tell whether flags from CLI should be passed through to Node and V8. For this, you need a list of supported flags.\nWhat I'm saying is that V8 flags should by default be considered unsupported. If you expect that V8 provide an API to list supported flags, and that this API would return the same set of flags that d8 --help lists, then I have to reject because these flags do not in fact belong on thay list. Just because they are already in use does not mean they are well tested.\nYou are essentially asking the manufacturer of Qtips to list cleaning your ear as a safe use case on the packaging. Yes, people use Qtips to clean their ears. No, it's not safe to do so.",
                            "createdAt": "2018-04-11T20:34:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "I'm confused; Node & userland can't warn a user about using v8 flags if we don't know what the v8 flags are. This is why we want the list of flags...\n\nThe way I understood this is that you want the list of supported flags to include V8 flags. If you know what flags are safe, can't you tell that all remaining flags are unsafe?",
                            "createdAt": "2018-04-11T20:39:51Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "This feature is called \"allowed\", not \"supported\" - inclusion in this list imo doesn't imply any support, nor any safety, just that it's a flag that does something.",
                            "createdAt": "2018-04-11T20:42:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "The way I understood this is that you want the list of supported flags to include V8 flags. If you know what flags are safe, can't you tell that all remaining flags are unsafe?\n\nHmm, this is the source of the confusion.  I don't care about which v8 flags are \"safe\" (I assume none of them!).  I only care that they are flags, (i.e. listed in v8's help output).\nMaybe I should have been more clear in my terminology...  \"supported\" isn't a good word.  I'm not asking v8 to \"support\" any flags; rather just provide the list of flags as they appear in the 'help' output--in a machine-readable manner.\nYes \"allowed\" is correct",
                            "createdAt": "2018-04-11T20:42:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "BridgeAR",
                                "__typename": "User"
                            },
                            "bodyText": "Then I would ask Node to not call v8::V8::SetFlagsFromString or filter its input. That API was originally intended for V8's developer shell for testing.\n\nThis might be a solution to this problem. If we pass through only a subset of possible V8 flags, all others would definitely not be \"allowed\" and would not have to be listed anywhere.\n@hashseed if you could add a API to provide a \"safe\" list of V8 flags that may be used by end users, we could make all other V8 flags no-ops. That would be a breaking change but I guess it is the best way forward.\nAny further ideas?",
                            "createdAt": "2018-04-29T17:24:52Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "With such an API, changes to V8 flags considered to be safe to use would constitute breaking changes, right?\nSo far some breaking changes in V8 required a very long time for deprecation, e.g. removal of debug context. I wonder whether that would apply to flag changes too. If yes, I can imagine that V8 would be very hesitant to include flags in this list.",
                            "createdAt": "2018-04-29T17:35:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "Arguably they\u2019re already breaking changes, with or without an explicit list. If you can decide arbitrarily that the current set of flags aren\u2019t considered part of your api, i don\u2019t see why you couldn\u2019t arbitrarily decide that the list of \u201csafe\u201d flags also isn\u2019t part of it.",
                            "createdAt": "2018-04-29T17:39:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "Given the lack of an API to provide a list of safe flags, all of them are unsafe. Arguing about whether changes to unsafe flags constitute a breaking change is a bit pointless imo. I don't want to repeat the arguments I brought up in above comments.\nI'm just pointing out that these considerations do not encourage adding many flags to such a list. The number of flags I would vouch for to stay stable and do not open an unmaintainable API surface probably does not exceed a dozen. At this point this API might become useless, since I doubt that a PR to ignore all unlisted flags is going to be popular.",
                            "createdAt": "2018-04-29T18:18:08Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Avoiding SetFlagsFromString entirely is not currently feasible as we use it specifically during bootstrap to temporarily enable --allow-natives-syntax to gain access to things that are not available otherwise. We then use it again to switch that back off also doing bootstrap.",
                            "createdAt": "2018-04-29T18:21:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "That's... horrible. That means bootstrapping relies on V8's internal implementation details. Runtime functions exposed via --allow-natives-syntax may change any time without any warning. Considering that we are moving away from JS-implemented builtins, removing runtime functions or changing their semantics is a very real possibility. Can you point me to where these are used so that we can work on a fix?",
                            "createdAt": "2018-04-29T18:32:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Do a quick search in src/node.cc and you'll find it.",
                            "createdAt": "2018-04-29T18:35:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "@hashseed Fwiw, the place where we actually use those features is in lib/internal/v8.js. :)",
                            "createdAt": "2018-04-29T18:41:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "I found it. And I'm horrified. %MapIteratorClone is only used in v8/src/debug/mirrors.js, which implements the old debug context, and we were planning to remove it yesterday.",
                            "createdAt": "2018-04-29T18:48:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "It's generally the equivalent to our process.binding().... We tell people not to use it but they do anyway because there's no other way to do what they need to do. If we can identify the things we need and can get supported apis to do those things, then we're happy to avoid using it. :)",
                            "createdAt": "2018-04-29T18:51:29Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "hashseed",
                                "__typename": "User"
                            },
                            "bodyText": "All of this kind of backs my opinion to not unnecessarily expose V8 flags. It just introduces technical debts.",
                            "createdAt": "2018-04-29T19:01:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "Is it possible to move forward with the Node flags as implemented in this PR, and work out the V8 flags later (if at all)?\nAgain, supporting the V8 flags was not my original intent, and it seems to me it can be tackled in another issue/PR, since some have a use for it.",
                            "createdAt": "2018-04-30T17:09:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I would like to move forward here, yeah.  Looks like I'll need to resolve conflicts though.",
                            "createdAt": "2018-06-01T21:18:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Let's get that rebase and then I can take on the responsibility for making sure this gets reviewed and hopefully landed. Sorry the process stalled out on you.",
                            "createdAt": "2018-06-01T21:47:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@bnoordhuis @ljharb Is it acceptable in your opinion if this doesn't show the V8 flags (because of the difficulties/pitfalls discussed above) as long as that fact is documented conspicuously?",
                            "createdAt": "2018-06-01T21:51:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull Leave a comment here when the rebase has happened and I'll run Ci.",
                            "createdAt": "2018-06-01T21:52:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ljharb",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott i mean, i wouldn't block (even if i had the power to do so) on it, but I do think it's important to include them. If v8 doesn't want people using them, then they shouldn't be exposed to node users \u00af\\_(\u30c4)_/\u00af",
                            "createdAt": "2018-06-01T22:13:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "bnoordhuis",
                                "__typename": "User"
                            },
                            "bodyText": "I kinda feel the same way.  Node accepts V8 flags; ergo, a list of node flags needs to include V8 flags.\nIf it's just exposing the whitelist, then I guess this PR is okay, but as pointed out further up in the thread, that seems to be of limited usefulness.",
                            "createdAt": "2018-06-02T09:16:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott I've resolved the conflicts.  I am seeing some seemingly unrelated failures locally in the JS and markdown linters.",
                            "createdAt": "2018-06-04T21:52:19Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull For the markdown linter, you probably need to do a make lint-md-clean && make lint-md-build to fix it.",
                            "createdAt": "2018-06-06T04:21:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull Sorry to say that I think something went wrong in the rebase. For example, if I'm not mistaken, the rebase undoes the changes a43e889 made to src/node.cc which alphabetized the options.\nCan you do something like this?:\ngit checkout env-flags\ngit reset --hard HEAD c5c1749751d5c21379ded7c4ae2f378ff59c69ad\ngit fetch upstream\ngit rebase upstream/master\n# resolve conflicts here...once resolved and rebase is finished...\ngit push --force-with-lease origin env-flags",
                            "createdAt": "2018-06-06T04:36:48Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "FWIW looks like git reset -q --hard is needed",
                            "createdAt": "2018-06-06T16:56:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott The markdown linter seems fixed now, but JS linter is not:\nRunning JS linter...\nInvalid count value\nRangeError: Invalid count value\n    at String.repeat (<anonymous>)\n    at OffsetStorage.getDesiredIndent (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/rules/indent.js:438:42)\n    at Program:exit.sourceCode.lines.forEach (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/rules/indent.js:1531:75)\n    at Array.forEach (<anonymous>)\n    at Program:exit (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/rules/indent.js:1513:38)\n    at listeners.(anonymous function).forEach.listener (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/util/safe-emitter.js:47:58)\n    at Array.forEach (<anonymous>)\n    at Object.emit (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/util/safe-emitter.js:47:38)\n    at NodeEventGenerator.applySelector (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/util/node-event-generator.js:251:26)\n    at NodeEventGenerator.applySelectors (/Users/boneskull/projects/node/tools/node_modules/eslint/lib/util/node-event-generator.js:280:22)\nmake: *** [lint-js] Error 1",
                            "createdAt": "2018-06-06T17:41:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott I reconciled my changes with the alphabetization",
                            "createdAt": "2018-06-06T17:44:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "again? ugh",
                            "createdAt": "2018-06-06T18:42:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "ok, rebased again, JS tests pass, but linter is still hinky",
                            "createdAt": "2018-06-06T18:53:40Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull Odd. When I check out this branch, all linting passes. Let's see what CI says.\nCI: https://ci.nodejs.org/job/node-test-pull-request/15299/",
                            "createdAt": "2018-06-06T21:39:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "It's not a linting error, it's something in ESLint's guts.  Must be something weird with my node_modules.  How can I wipe the JS linting dependencies then reinstall them?  What version of node/npm should I be using to do the installation of the deps?",
                            "createdAt": "2018-06-06T21:51:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull ESLint is checked into the source code so it shouldn't be anything in your dependencies. And the node that should run ESLint is the one compiled from the source tree.\n@nodejs/linting Any idea what's up? (See @boneskull's output in #19335 (comment).)",
                            "createdAt": "2018-06-06T21:57:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott Are the ARM failures expected?",
                            "createdAt": "2018-06-06T23:47:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott Are the ARM failures expected?\n\nI wouldn't say \"expected\" but perhaps \"unsurprising\" or \"likely no cause for alarm\".\nLooks like cross-compiling has been broken a whole bunch there. @nodejs/build: https://ci.nodejs.org/job/node-cross-compile/17150/console",
                            "createdAt": "2018-06-07T02:21:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "AIX re-run: https://ci.nodejs.org/job/node-test-commit-aix/15581/",
                            "createdAt": "2018-06-07T02:22:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I'm not sure how to tell why or how this is failing on AIX / ARM.  It's possible the available flags aren't the same, and the JS tests are failing.  @gibfahn can you help me find the problem?",
                            "createdAt": "2018-06-08T15:30:54Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "AIX is unrelated. That error has been spotted in other CI runs lately.\nARM is unrelated too. It was a snafu that happened for a few hours.",
                            "createdAt": "2018-06-08T22:52:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/15346/",
                            "createdAt": "2018-06-08T22:53:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "CI has passed. This still needs at least one Collaborator approval (and given the semver-minor nature and the skepticism expressed about the feature in #17740, I'd greatly prefer we get at least two approvals).\nIn #17740, @bnoordhuis and @apapirovski seemed to express the most skepticism. In #19335 (comment), @bnoordhuis seems not-opposed to this as it stands.\n@apapirovski Do you have an opinion one way or the other on this implementation?\nIn #17740, the Collaborators who came closest to endorsing the feature were @jasnell and @benjamingr. Any chance the two of you would review this and offer your opinion as to its maintainability etc.?",
                            "createdAt": "2018-06-09T04:58:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@gibfahn might approve",
                            "createdAt": "2018-06-09T15:23:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "Added tsc-agenda for API approval. @bnoordhuis can you confirm the actual technical contents (which flags) LGTY?",
                            "createdAt": "2018-06-09T19:22:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "also @mhdawson; this PR improves QoL for CLI apps",
                            "createdAt": "2018-06-09T19:36:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Added tsc-agenda for API approval.\n\nGood idea. I don't believe semver-minor/new features require TSC review, although that proposal has been floated on at least one occasion. But it's a good idea here since we really ought to be able to say \"yes\" or \"no\" to this and right now it's kind of in limbo. I'm totally OK with saying \"no, sorry\" to this as long as we can do it relatively quickly and not have this drag on for months. :-D I'm also OK with \"yes, sure, thanks\" too. Either way. But three months for an open PR should be plenty of time to come to a final conclusion on a feature of this relatively small scale, I would hope.",
                            "createdAt": "2018-06-09T23:12:24Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "(My hope is that this will be resolved before the TSC has to take it up, but if not, yeah, let's have the TSC take it up.)",
                            "createdAt": "2018-06-09T23:12:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott given we have a technical review now (from Ben) and a sorta-technical one from me and I'm willing to advocate the use case - does this need to go through the TSC or can we land it?",
                            "createdAt": "2018-06-11T08:51:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "@vkurchatkin are you still -1 on this in its latest incarnation?",
                            "createdAt": "2018-06-11T08:52:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "The TSC is only required for breaking changes or module additions, not for new APIs to existing modules.",
                            "createdAt": "2018-06-13T22:08:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "Ok so, it seems that this was at an impasse but it was not clearly described as such when tagged.\nSee #19335 (comment)",
                            "createdAt": "2018-06-13T22:12:33Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "mhdawson",
                                "__typename": "User"
                            },
                            "bodyText": "@benjamingr can you add more detail on the specific case that made you a supporter of this.",
                            "createdAt": "2018-06-13T22:18:26Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I\u2019m not sure what you\u2019re requesting.  A theoretical PR based on this API?\n@Fishrock123 \u201call possible flags\u201d meaning what, exactly? stuff that changes node\u2019s behavior to something other than \u201cexecute script\u201d is pretty useless; e.g. \u2014help.  there hasn\u2019t been willing collaboration from V8 to avoid the necessity of parsing its \u2014help output (brittle & gross)",
                            "createdAt": "2018-06-14T03:21:23Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Compiling TSC comments/reviews here and in nodejs/TSC#551, I get this:\nYes, this should land: 5 (@mcollina @mhdawson @ofrobots @jasnell @gibfahn)\nNo, this should not land: 2 (@Fishrock123 @ChALkeR)\nAbstain: 10 @Trott @fhinkel @cjihrig @danbev @targos @joyeecheung  @MylesBorins @addaleax @thefourtheye @TimothyGu\nDid not (yet) vote: @rvagg",
                            "createdAt": "2018-06-14T05:07:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "jasnell",
                                "__typename": "User"
                            },
                            "bodyText": "Count mine as a yes",
                            "createdAt": "2018-06-14T06:05:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott, note that mine isn't a specific \"no\" vote forever.\nI just doubt that this is usable in the current form and would be happy to be proven otherwise. I don't think that this pr should be either landed or closed in the current form as a result of the vote, so why exactly are we counting votes at this point?",
                            "createdAt": "2018-06-14T08:00:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull, yes. More specifically \u2014 I doubt this will help much in the current form, as you still would want to list V8 flags somewhere. If these are passed through, users would probably expect V8 flags to be passed through, (e.g. memory-related), wouldn't they?\nSo you would still want to add a list of allowed flags on userland side for the very same reason why you want this API, and that list of flags, strictly speaking, would depend on the Node.js version (as V8 versions differ). Thus I am not sure that this specific API addition here would be very helpful for the described (or any other) usecase.\nA draft PR based on this could explain things better and would be a good starting point to determine if this is actually useful for any real problem or not.",
                            "createdAt": "2018-06-14T08:13:47Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "MylesBorins",
                                "__typename": "User"
                            },
                            "bodyText": "I abstain (updated rich's comment)",
                            "createdAt": "2018-06-14T16:26:15Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ofrobots",
                                "__typename": "User"
                            },
                            "bodyText": "There is a lot of discussion of V8 flags in this thread, but note that Node runs with other VMs too. It was a mistake for Node to forward V8 flags transparently, and I think it would be a mistake to further expose V8 flags whether through an extension of this mechanism or otherwise. That would further entrench V8 implementation details into the package ecosystem, and would not be a good thing for Node. In fact, going forward, I would like us (Node) to take steps to sequester VM flags. There might be some flags that we adopt as first class Node flags (e.g. --prof), but all else should be probably be behind something like --vm-flags=\"--trace-gc --harmony-dynamic-import\".\nBut this particular issue is explicitly keeping the scope narrow to just the node environment flags. In that form \u2013 where V8 flags are explicitly out of scope \u2013 I am in favor of this PR.\n(I have updated @Trott's comment with the tally).",
                            "createdAt": "2018-06-14T16:43:50Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "P.S I have updated the counts - they were off\nI would love it if you could address @ChALkeR's comment before we land this even if this \"win\"s the vote @boneskull",
                            "createdAt": "2018-06-14T16:53:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "so why exactly are we counting votes at this point?\n\n@ChALkeR I wrote up the \"why\" in nodejs/TSC#551 but didn't put it here, so here it is:\n\n\u2026@vkurchatkin is -1 on it, so I don't think it can land without TSC approval.\n@nodejs/tsc: I'd invite you to look closely at that issue as a vote seems likely. It would be great if we could have sufficient opinions formed to be able to get a result on the vote one way or the other. The PR has been open for 3 months and I think the case has been made for both sides pretty thoroughly.\nFor the record, I'm fine with \"yes\" or \"no\" on it, but I'm less comfortable with \"send it back to GitHub\". We're asking a lot (even if it's mostly psychologically) of @boneskull to manage a PR for months without knowing if there's support for the feature or not.\n\nMaybe it would help if the vote were explicitly scoped to \"Can this land over @vkurchatkin's specific objection?\" (FWIW, that's how I was thinking of it, but thinking it without saying it doesn't do much good.) More recent blocking objections that are for different reasons don't have to be covered by the vote. But if we're definitely not overriding @vkurchatkin's -1, there's no point in @boneskull continuing. That -1 has been there for almost exactly three months. Everything there is to say about it has likely been said by now. If it's going to stand, let's close this pull request. If it's not going to stand, cool, let's clear it and talk about other comments/objections. But I don't think it's a good use of @boneskull's time or the time of reviewers to discuss anything further if there's no chance this lands.",
                            "createdAt": "2018-06-14T17:11:45Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I won\u2019t have time to address any concerns or send an updated PR until next week.",
                            "createdAt": "2018-06-14T17:16:28Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "To @ChALkeR\u2019s request, single \u201cdemo\u201d PR will only show some LoC removed, which isn\u2019t that impressive.\nThe \u201ckiller feature\u201d is the number of future PRs which this API will help avoid. As flags are added to node, there should be no further corresponding hardcoded changes to Mocha for those flags.",
                            "createdAt": "2018-06-14T17:23:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "benjamingr",
                                "__typename": "User"
                            },
                            "bodyText": "I won\u2019t have time to address any concerns or send an updated PR until next week.\n\nThere is absolutely no rush - don't overcommit - I think everyone is fine waiting another few days until you've had time to make the changes.",
                            "createdAt": "2018-06-15T10:43:16Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull, I understand that, but I still would like to see what exactly does it change for consumers of this API on some example.\nA PR using this to remove some lines should be fine.\nMy concern was that it wouldn't be of much practical use, i.e. that an attempt to rely upon it would still be stuck with having to deal manually with V8 flags.",
                            "createdAt": "2018-06-18T15:15:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "addaleax",
                                "__typename": "User"
                            },
                            "bodyText": "Yes, I should be counted as an abstention for everything related to this specific PR \u2013 I\u2019m sorry I don\u2019t have the time for looking into anything here in more depth, but this shouldn\u2019t be blocked on me.",
                            "createdAt": "2018-06-18T21:57:01Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "As it stands now, I would be fine with landing this as experimental for now (i.e. under a flag or printing an experimental warning) and see if there is interest in this API in such form and how would ecosystem use that (e.g. take a look at PRs), but while still being able to refine (or remove) it if there would be problems with it. My concern is that that API might turn out not useful and might need to be replaced with something else.",
                            "createdAt": "2018-06-19T08:12:37Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I've made changes as requested by @bnoordhuis and @jdalton.",
                            "createdAt": "2018-06-20T22:40:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "TimothyGu",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott I'll abstain as well.",
                            "createdAt": "2018-06-21T16:15:36Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "As requested by @ChALkeR, here's a PoC PR for the feature: mochajs/mocha#3423",
                            "createdAt": "2018-06-21T16:54:22Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "TSC vote indicates this can land over the -1 from @vkurchatkin. That does not affect the other two Request-for-Changes that are blocking, but at least one of those seems to be moving along via discussion so I don't feel there's a need for any TSC action on them at this time.",
                            "createdAt": "2018-06-21T23:05:25Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott I'm not sure which changes you mean at this point.",
                            "createdAt": "2018-06-22T16:34:05Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "gibfahn",
                                "__typename": "User"
                            },
                            "bodyText": "AFAICT the only blocking reviews are:\n@Fishrock123 in #19335 (review)\n\nIMO this would need to include all possible flags to justify adding such an API\n\n@ChALkeR in #19335 (review)\n\nI agree with what @Fishrock123 said above, unless there is a good way to provide such an API in the userland based on the API introduced in this PR and that requires the API introduced at this PR.\nI would like to see a more detailed usecase, preferrable with some code.\n@boneskull perhaps there is a PR to mocha (or a similar app) that would expect this API?\n\nIt looks like @boneskull addressed @ChALkeR 's request in #19335 (comment), so that's just a question of giving @ChALkeR time to re-review.\nNot sure there's much @boneskull can do about @Fishrock123's review, given the previous discussion above,\u00a0so if that stands then I guess we'll need another TSC vote on this.",
                            "createdAt": "2018-06-22T16:50:00Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I'm thinking it's unlikely (save for a pending review by @ChALkeR) anything in this PR has changed which would cause a materially different voting outcome.",
                            "createdAt": "2018-06-22T18:21:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "I'm thinking it's unlikely (save for a pending review by @ChALkeR) anything in this PR has changed which would cause a materially different voting outcome.\n\nThe TSC vote was scoped to @vkurchatkin's objection only, so we'd need another vote to unblock @Fishrock123's objection if they're not content with the PR as it stands and we're otherwise at an impasse there. I agree that it's unlikely that such a vote would have a different outcome, but we'll see (if it comes to a vote).",
                            "createdAt": "2018-06-23T04:41:14Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "What's next here?",
                            "createdAt": "2018-06-25T16:54:53Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "Based on https://github.com/mochajs/mocha/pull/3423/files, I still don't think that this is a good API addition in this form \u2014 userland still have to use complex logic with hard-coded Node.js flags to implement that. Also see my comments in that PR \u2014 it has a lot of things missed during this update. This specific API change just makes it a little less complex, but it doesn't make things significantly better for consumers compared to just hardcoding the flags. Also, don't forget about LTS like 6.x support (which that PR doesn't do).\nWhile I dismissed my review and won't block it if others want to land and support this in this form, I would suggest to land it in Experimental status (with a warning) for a while and avoid using it in production, so that it could be updated when/if we would have a better understanding of how to make using this easier for the ecosystem without going through the full deprecation cycle. This just doesn't look solid enough to me.",
                            "createdAt": "2018-06-25T17:37:41Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "As an example of how we could change this API: perhaps it would make sense to expose both the list of the flags and their values/arguments for the current process? I'm not suggesting that (yet), just speculating about possible changes that we could want to make here.",
                            "createdAt": "2018-06-25T17:44:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "To be explicit: I retracted both my review and -1 and won't block this from landing if others think that this is ok, just sharing my concerns.",
                            "createdAt": "2018-06-25T17:45:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I've updated that PR; I had overlooked a handful of previously hardcoded V8 options.  The changes should now be backwards-compatible.\nEvery flag that was removed from the switch statement is now handled by allowedEnvironmentNodeFlags.\n\nBased on https://github.com/mochajs/mocha/pull/3423/files, I still don't think that this is a good API addition \u2014 userland still have to use complex logic with hard-coded Node.js flags to implement that.\n\nI disagree, but perhaps I didn't understand what you wanted to see.  The Mocha PR provides backwards compatibility with random stuff that's been requested over the years.  For example, the -d and debug (not --debug) flags are shorthand; furthermore, Mocha needs to disable its timeouts when the debugger is enabled; this is unique to Mocha.  -gc is shorthand for --expose-gc.\nThere's a handful of V8-specific options which were hardcoded as well.  If I was to break backwards compat, I would remove all of these, and support them via --v8-<flag>.\nThe only thing here that's incongruous, IMO, is support for --preserve-symlinks and --preserve-symlinks-main, neither of which appear in process.allowedEnvironmentNodeFlags.  A userland app would need to explictly support these, which is a good thing, due to security implications.\nA greenfield CLI app which wanted to support Node.js flags could do this:\nconst newArgs = ['my-executable'];\nprocess.argv.slice(2).forEach(arg => {\n  const flag = arg.split('=')[0];\n  if (process.allowedEnvironmentNodeFlags.includes(flag)) {\n    // flags to node\n    newArgs.unshift(arg);\n  } else {\n    // flags to my-executable\n    newArgs.push(arg);\n  }\n});\n\nchild_process.spawn(process.execPath, newArgs);\nNo grotesque hardcoded flags!",
                            "createdAt": "2018-06-25T19:25:57Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR\n\nThis specific API change just makes it a little less complex, but it doesn't make things significantly better for consumers compared to just hardcoding the flags.\n\nI disagree; the above example currently needs to be written this way:\nconst newArgs = ['my-executable'];\nconst nodeFlags = [\n  '--enable-fips',\n  '--experimental-modules',\n  '--experimenatl-repl-await',\n  '--experimental-vm-modules',\n  '--experimental-worker',\n  '--force-fips',\n  '--icu-data-dir',\n  '--inspect',\n  '--inspect-brk',\n  '--inspect-port',\n  '--loader',\n  '--napi-modules',\n  '--no-deprecation',\n  '--no-force-async-hooks-checks',\n  '--no-warnings',\n  '--openssl-config',\n  '--pending-deprecation',\n  '--redirect-warnings',\n  '--require',\n  '--throw-deprecation',\n  '--tls-cipher-list',\n  '--trace-deprecation',\n  '--trace-event-categories',\n  '--trace-event-file-pattern',\n  '--trace-events-enabled',\n  '--trace-sync-io',\n  '--trace-warnings',\n  '--track-heap-objects',\n  '--use-bundled-ca',\n  '--use-openssl-ca',\n  '--v8-pool-size',\n  '--zero-fill-buffers',\n  '-r',\n  '--abort_on_uncaught_exception',\n  '--max_old_space_size',\n  '--perf_basic_prof',\n  '--perf_prof',\n  '--stack_trace_limit'\n];\n\nprocess.argv.slice(2).forEach(arg => {\n  const flag = arg.split('=')[0];\n  if (nodeFlags.includes(flag)) {\n    // flags to node\n    newArgs.unshift(arg);\n  } else {\n    // flags to my-executable\n    newArgs.push(arg);\n  }\n});\n\nchild_process.spawn(process.execPath, newArgs);\nThis PR is clearly an upgrade; but it will also significantly reduce churn when a new flag is added to Node.js.",
                            "createdAt": "2018-06-25T19:32:27Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull\n\nThe changes should now be backwards-compatible.\n\nI don't think that is correct atm, see e.g. comment about --prof. Also, a fallback is needed.",
                            "createdAt": "2018-06-25T19:59:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull Also note how that PR fails to consume process.allowedEnvironmentNodeFlags correctly.\nTo consume process.allowedEnvironmentNodeFlags in the form in which this PR introduces it, you have to do the following:\n\nCheck if arg is present there.\nCheck if arg.replace(/-/g, '_') is present there.\n\nInstead, you hardcoded --perf-basic-prof into the whitelist in mochajs/mocha#3423, which duplicates --perf_basic_prof here, and omitted --perf-prof and --max-old-space-size for some reason.\nThis is one of the reasons why this specific API looks hard to consume.",
                            "createdAt": "2018-06-25T20:07:42Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR I've explained why one thing is hardcoded and another isn't; the reason is backwards compatibility.\nI'm not sure I understand the - vs _.  --perf-prof is the flag as in node.cc.  Is --perf_prof also allowed, and does the same?  Does this go for any flag with a - in it?",
                            "createdAt": "2018-06-25T20:13:21Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@hashseed @bnoordhuis\nRe: V8 options \u2014 the only use-case yet why we need this PR afaik is for the ability for userland to filter out Node.js options from some other options, to pass Node.js options to child processes, if I understood things correctly. (Note: still not entirely sure why that can't be done the other way around).\nOn order for them do achieve that, they would most likely need way to filter V8 options too \u2014 from the user POV there is no much difference between those when they execute the app from the command line and they would expect similar behavior on those.\nWhile I can agree that it might be not a great idea to expose V8 options among Node.js options, it could be fine to expose those somewhere under require('v8'), if we do something like this with Node.js options. Thoughts?",
                            "createdAt": "2018-06-25T20:17:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull\n\nI'm not sure I understand the - vs _.  --perf-prof is the flag as in node.cc.  Is --perf_prof also allowed, and does the same?  Does this go for any flag with a - in it?\n\nTake a look at https://github.com/nodejs/node/pull/19335/files#diff-cd53544f44aab2c697bcd7b6a57f23ccR628.\nI even left a comment a while ago. \ud83d\ude09\nNote that --perf-basic_prof also works.",
                            "createdAt": "2018-06-25T20:19:46Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "Ok. I am not exactly sure yet, but perhaps something like process.getNodeFlag('--flagname') would be much more useful for this specific usecase? That would return the current flag value and will throw if the flag is not recognized. It should be relatively easy to try-catch determine if the flag is valid for mocha, and I don't think there is any performance concern here, so I think that it would sense to keap the API lean.\nA list might also be useful (to get all flags), but using it to check if some flag is present in it to solve the specific usecase that mochajs/mocha#3423 has (and which was the reason behind opening this PR) does not look like a solid solution.\nAbout V8 \u2014 it seems to me that implementing something like that for V8 flags would require changes on the V8 API side, though probabably relative small ones. I don't think we should bother with that now, let's take a look at now the Node.js flags API goes first.\nAnother possible way \u2014 process.nodeFlags property that allows getting the flag by any allowed form, but iterates flags only using their canonical forms.",
                            "createdAt": "2018-06-27T00:24:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR\n\nAnother possible way \u2014 process.nodeFlags property that allows getting the flag by any allowed form, but iterates flags only using their canonical forms.\n\nAre you thinking a custom Iterable object, maybe a subclass of Set, or...?  This sounds appealing.",
                            "createdAt": "2018-06-28T02:23:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@ChALkeR ping was hoping for some clarification here.  Thanks",
                            "createdAt": "2018-07-30T22:36:59Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123\n\nTo clarify - did this PR not originally apply to all node flags and NOT specifically those from NODE_OPTIONS - is that the major change here?\n\nThe PR only applies to flags from NODE_OPTIONS; this hasn't changed.  Any flag not available in NODE_OPTIONS will still require manual detection by userland code.\nWhere I'm a hung up right now is the fact that some V8-specific options which are available in NODE_OPTIONS (e.g., --stack-trace-limit) can be specified using - or _ for word separators.  This behavior is equivalent when specified either in NODE_OPTIONS or a flag:\n$ NODE_OPTIONS=\"--stack-trace-limit=5\" node -c 'throw new Error()'\n# is equivalent to:\n$ node --stack-trace-limit=5 -c 'throw new Error()'\n(Somewhat annoyingly, Node.js-specific options don't exhibit this behavior; you can't use --no_deprecation, only --no-deprecation.)\nThis means that unless we wish to essentially duplicate V8-specific flags using different -/_ word separators, an iterable list of allowed flags won't contain every flag that Node.js recognizes within NODE_OPTIONS.  I'm interested in the idea that @ChALkeR proposed, but need further details to proceed.\nI might as well ask what others think of duplicating some flags in process.allowedEnvironmentNodeFlags?  Every V8-specific flag in a list like this would exist once containing - and another time containing _.\nIt seems a little gross, yet it's a straightforward solution.",
                            "createdAt": "2018-08-02T21:21:31Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "richardlau",
                                "__typename": "User"
                            },
                            "bodyText": "On the -/_ in V8 options -- I believe any combination works, e.g. --stack-trace_limit would work, so it's not just two variants.",
                            "createdAt": "2018-08-02T21:25:09Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@richardlau Eh, ok, that makes the list-containing-dupes even less palatable.",
                            "createdAt": "2018-08-02T23:44:39Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Fishrock123",
                                "__typename": "User"
                            },
                            "bodyText": "I think my question may have been misunderstood:\nWhen the PR was first opened, did it return flags outside of those supported to NODE_OPTIONS?\nNow it only returns those supported by NODE_OPTIONS, correct?",
                            "createdAt": "2018-08-03T15:57:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Fishrock123 No, it\u2019s only ever been NODE_OPTIONS.",
                            "createdAt": "2018-08-03T16:32:07Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "ChALkeR",
                                "__typename": "User"
                            },
                            "bodyText": "@boneskull First of all, sorry for the delay on this :-(. I did not understand at first that this was waiting for my reply until you explicitly mentioned that recently.\nRe: Iterable/Set/anything else -- I don't have a strong preference atm. Perhaps cc-ing @nodejs/collaborators for a discussion might help.\nAlso note that I am not blocking this, and my main concern was that this API is not simple to consume in this form and would require some additional complex code on the user side to be useful in the specified usecase. Also not clear how useful would this be without v8 flags.\nI am fine with this landing in the current form if you (as the author) are fine with this and other Node.js collaborators are fine too. Note: this is not an LGTM though, I am speaking about the actual API addition. Additional API changes could be added later, if required. Though clean design from the start is preferred, it wouldn't make sense to block against it indefinitely if no one is willing to champion that =).",
                            "createdAt": "2018-08-04T23:03:03Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vsemozhetbyt",
                                "__typename": "User"
                            },
                            "bodyText": "As for the doc list: it seems this option was removed:\n--expose-http2\n\nand these options were added:\n--experimental-repl-await\n--experimental-worker\n--title",
                            "createdAt": "2018-08-05T12:03:11Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@vsemozhetbyt Maybe it'd make sense to remove the list itself from the docs.  The wording is purposely ambiguous:\n\nAn example of the possible output looks like:\n\nWe'd have to update it every single time something is added, and we don't have a way of automating it.",
                            "createdAt": "2018-08-16T20:44:32Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "vsemozhetbyt",
                                "__typename": "User"
                            },
                            "bodyText": "If nobody objects, I am OK. cc @nodejs/documentation.",
                            "createdAt": "2018-08-16T20:55:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "I'm thinking of making a subclass of Set which will override has, returning true when:\n\nA flag is allowed, as given\nA flag is allowed, ignoring leading dashes\nA flag is allowed, as given, ignoring leading dashes, and/or is one of the few V8-specific flags which can use both underscores and dashes.\n\nExample:\n// Node-specific\nprocess.allowedEnvironmentNodeFlags.has('--no-deprecation'); // true\nprocess.allowedEnvironmentNodeFlags.has('no-deprecation'); // true\nprocess.allowedEnvironmentNodeFlags.has('no_deprecation'); // false\n\n// from V8\nprocess.allowedEnvironmentNodeFlags.has('--perf_basic_prof'); // true\nprocess.allowedEnvironmentNodeFlags.has('perf_basic_prof'); // true\nprocess.allowedEnvironmentNodeFlags.has('perf-basic-prof'); // true\nprocess.allowedEnvironmentNodeFlags.has('perf_basic-prof'); // true\nprocess.allowedEnvironmentNodeFlags.has('--perf-basic_prof'); // true\n\nprocess.allowedEnvironmentNodeFlags.forEach(flag => {\n  // contains '--no-deprecation' and '--perf_basic_prof'.\n  // does not contain 'no-deprecation', 'perf-basic-prof', '--perf-basic-prof', or other permutations\n});\nLike before, this object will be frozen.\n@nodejs/collaborators Is this too fancy?  This would answer both \"is this flag allowed?\" and \"what are the allowed flags?\" in a usable way.",
                            "createdAt": "2018-08-16T22:18:02Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@vsemozhetbyt I've made some doc changes, including your request.\nI hesitate to ask everyone, but please review my recent changes, as the API is no longer just an array of strings; this is how it works.\ncc @nodejs/collaborators",
                            "createdAt": "2018-08-17T23:37:58Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "With the significant API change, some of the folks who approve previous iterations of this PR should indicate that they still approve.",
                            "createdAt": "2018-08-18T21:44:12Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "failure is tools/doc/type-parser.js doesn't recognize Set",
                            "createdAt": "2018-08-22T16:24:43Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "boneskull",
                                "__typename": "User"
                            },
                            "bodyText": "@Trott It's not clear to me what needs to happen to get this merged.  wait 72h?\nI've addressed recent comments, and the lone rejection was withdrawn.  It doesn't seem--for lack of a better word--fair to require every approver to re-approve this...",
                            "createdAt": "2018-08-24T17:56:56Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "It doesn't seem--for lack of a better word--fair to require every approver to re-approve this...\n\nIt's not required. I was just suggesting that, given the changes, a few re-approvals would be good.\nI think this is good to land if CI is green. I'll alphabetize that one entry in type-parser.js while landing. As far as @ljharb's comment that we should add Map etc., I don't dispute it, but that can certainly happen in another PR. (Maybe there's a good way to generate them dynamically rather than having them hard-coded. But again, outside the scope of this PR for sure.)",
                            "createdAt": "2018-08-24T22:30:13Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "CI: https://ci.nodejs.org/job/node-test-pull-request/16740/",
                            "createdAt": "2018-08-24T22:34:44Z"
                        }
                    },
                    {
                        "node": {
                            "author": {
                                "login": "Trott",
                                "__typename": "User"
                            },
                            "bodyText": "Landed in 80143f6.",
                            "createdAt": "2018-08-25T01:17:16Z"
                        }
                    }
                ]
            }
        }
    }
]