[
    {
        "number": 51752,
        "title": "Reusing state logic is either too verbose or too difficult",
        "author": "Remi Rousselet",
        "state": "OPEN",
        "createdAt": "2020-03-02T00:19:16Z",
        "closedAt": null,
        "comments": [
            {
                "author": "rrousselGit",
                "bodyText": "cc @dnfield @Hixie\nAs requested, that's the full details on what are the problems solved by hooks.",
                "createdAt": "2020-03-02T00:22:01Z"
            },
            {
                "author": "dnfield",
                "bodyText": "I'm concerned that any attempt to make this easier within the framework will actually hide complexity that users should be thinking about.\nIt seems like some of this could be made better for library authors if we strongly typed classes that need to be disposed with some kind of abstract class Disposable.  In such a case you should be able to more easily write a simpler class like this if you were so inclined:\nclass AutomaticDisposingState<T> extends State<T> {\n  List<Disposable> _disposables;\n\n  void addDisposable(Disposable disposable) {\n    assert(!_disposables.contains(disposable));\n    _disposables.add(disposable);\n  }\n\n  @override\n  void dispose() {\n    for (final Disposable disposable in _disposables)\n      disposable.dispose();\n    super.dispose();\n  }\n}\nWhich gets rid of a few repeated lines of code.  You could write a similar abstract class for debug properties, and even one that combines both.  Your init state could end up looking something like:\n@override\nvoid initState() {\n  super.initState();\n  controller = TextEditingController(text: 'Hello world');\n  addDisposable(controller);\n  addProperty('controller', controller);\n}\nAre we just missing providing such typing information for disposable classes?",
                "createdAt": "2020-03-02T07:56:17Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'm concerned that any attempt to make this easier within the framework will actually hide complexity that users should be thinking about.\n\nWidgets hides the complexity that users have to think about.\nI'm not sure that's really a problem.\nIn the end it is up to users to factorize it however they want.\n\nThe problem is not just about disposables.\nThis forgets the update part of the problem. The stage logic could also rely on lifecycles like didChangeDependencies and didUpdateWidget.\nSome concrete examples:\n\nSingleTickerProviderStateMixin which has logic inside didChangeDependencies.\nAutomaticKeepAliveClientMixin, which relies on super.build(context)",
                "createdAt": "2020-03-02T08:25:59Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "There are many examples in the framework where we want to reuse state logic:\n\nStreamBuilder\nTweenAnimationBuilder\n...\n\nThese are nothing but a way to reuse state with an update mechanism.\nBut they suffer from the same issue as those mentioned on the \"builder\" part.\nThat causes many problems.\nFor example one of the most common issue on Stackoverflow is people trying to use StreamBuilder for side effects, like \"push a route on change\".\nAnd ultimately their only solution is to \"eject\" StreamBuilder.\nThis involves:\n\nconverting the widget to stateful\nmanually listen to the stream in initState+didUpdateWidget+didChangeDependencies\ncancel the previous subscription on didChangeDependencies/didUpdateWidget when the stream changes\ncancel the subscription on dispose\n\nThat's a lot of work, and it's effectively not reusable.",
                "createdAt": "2020-03-02T08:59:40Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Problem\nReusing a State logic across multiple StatefulWidget is very difficult, as soon as that logic relies on multiple life-cycles.\nA typical example would be the logic of creating a TextEditingController (but also AnimationController, implicit animations, and many more). That logic consists of multiple steps:\n\ndefining a variable on State.\nTextEditingController controller;\n\ncreating the controller (usually inside initState), with potentially a default value:\n@override\nvoid initState() {\n super.initState();\n controller = TextEditingController(text: 'Hello world');\n}\n\ndisposed the controller when the State is disposed:\n@override\nvoid dispose() {\n  controller.dispose();\n  super.dispose();\n}\n\ndoing whatever we want with that variable inside build.\n(optional) expose that property on debugFillProperties:\nvoid debugFillProperties(DiagnosticPropertiesBuilder properties) {\n super.debugFillProperties(properties);\n properties.add(DiagnosticsProperty('controller', controller));\n}\n\n\nThis, in itself, is not complex. The problem starts when we want to scale that approach.\nA typical Flutter app may have dozens of text-fields, which means this logic is duplicated multiple times.\nCopy-pasting this logic everywhere \"works\", but creates a weakness in our code:\n\nit can be easy to forget to rewrite one of the steps (like forgetting to call dispose)\nit adds a lot of noise in the code\n\n\nI really have trouble understanding why this is a problem. I've written plenty of Flutter applications but it really doesn't seem like that much of an issue? Even in the worst case, it's four lines to declare a property, initialize it, dispose it, and report it to the debug data (and really it's usually fewer, because you can usually declare it on the same line you initialize it, apps generally don't need to worry about adding state to the debug properties, and many of these objects don't have state that needs disposing).\nI agree that a mixin per property type doesn't work. I agree the builder pattern is no good (it literally uses the same number of lines as the worst case scenario described above).",
                "createdAt": "2020-07-28T04:49:40Z"
            },
            {
                "author": "Hixie",
                "bodyText": "With NNBD (specifically with late final so that initiializers can reference this) we'll be able to do something like this:\ntypedef Initializer<T> = T Function();\ntypedef Disposer<T> = void Function(T value);\n\nmixin StateHelper<T extends StatefulWidget> on State<T> {\n  bool _active = false;\n  List<Property<Object>> _properties = <Property<Object>>[];\n\n  @protected\n  void registerProperty<T>(Property<T> property) {\n    assert(T != Object);\n    assert(T != dynamic);\n    assert(!_properties.contains(property));\n    _properties.add(property);\n    if (_active)\n      property._initState();\n  }\n\n  @override\n  void initState() {\n    _active = true;\n    super.initState();\n    for (Property<Object> property in _properties)\n      property._initState();\n  }\n\n  @override\n  void dispose() {\n    for (Property<Object> property in _properties)\n      property._dispose();\n    super.dispose();\n    _active = false;\n  }\n\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    for (Property<Object> property in _properties)\n      property._debugFillProperties(properties);\n  }\n}\n\nclass Property<T> {\n  Property(this.owner, this.initializer, this.disposer, [ this.debugName ]) {\n    owner.registerProperty(this);\n  }\n\n  final StateHelper<StatefulWidget> owner;\n  final Initializer<T> initializer;\n  final Disposer<T> disposer;\n  final String debugName;\n\n  T value;\n\n  void _initState() {\n    if (initializer != null)\n      value = initializer();\n  }\n\n  void _dispose() {\n    if (disposer != null)\n      disposer(value);\n    value = null;\n  }\n\n  void _debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    properties.add(DiagnosticsProperty(debugName ?? '$T property', value));\n  }\n}\nYou'd use it like this:\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> with StateHelper<MyHomePage> {\n  late final Property<int> _counter = Property<int>(this, null, null);\n  late final Property<TextEditingController> _text = Property<TextEditingController>(this,\n    () => TextEditingController(text: 'button'),\n    (TextEditingController value) => value.dispose(),\n  );\n\n  void _incrementCounter() {\n    setState(() {\n      _counter.value += 1;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'You have pushed the ${_text.value.text} this many times:',\n            ),\n            Text(\n              '${_counter.value}',\n              style: Theme.of(context).textTheme.headline4,\n            ),\n            TextField(\n              controller: _text.value,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\nDoesn't seem to really make things better. It's still four lines.",
                "createdAt": "2020-07-28T05:35:03Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Widgets hides the complexity that users have to think about.\n\nWhat do they hide?",
                "createdAt": "2020-07-28T05:37:47Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The problem is not the number of lines, but what these lines are.\nStreamBuilder may be about as many lines as stream.listen + setState + subscription.close.\nBut writing a StreamBuilder can be done without any reflection involved, so to say.\nThere is no mistake possible in the process. It's just \"pass the stream, and build widgets out of it\".\nWhereas writing the code manually involves a lot more thoughts:\n\nCan the stream change over time? If we forgot to handle that, we have a bug.\nDid we forget to close the subscription? Another bug\nWhat variable name do I use for the subscription? That name may not be available\nWhat about testing? Do I have to duplicate the test? With StreamBuilder, there's no need to write unit tests for listening to the stream, that would be redundant. But if we write it manually all the time, it's entirely feasible to make a mistake\nIf we listen to two streams at once, we now have multiple variables with very similar names polluting our code, it may cause some confusion.",
                "createdAt": "2020-07-28T09:25:34Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "What do they hide?\n\n\nFutureBuilder/StreamBuilder hides the listening mechanism and keeps track of what is the current Snapshot.\nThe logic of switching between two Future is fairly complex too, considering it doesn't have a subscription.close().\nAnimatedContainer hides the logic of making a tween between the previous and new values.\nListview hides the logic of \"mount a widget as it appears\"\n\n\napps generally don't need to worry about adding state to the debug properties\n\nThey don't, because they do not want to deal with the complexity of maintaining the debugFillProperties method.\nBut if we told developers \"Would you like it is out of the box all of your parameters and state properties were available on Flutter's devtool?\" I'm sure they would say yes\nMany people have expressed to me their desire for a true equivalent to React's devtool. Flutter's devtool is not yet there.\nIn React, we can see all the state of a widget + its parameters, and edit it, without doing anything.\nSimilarly, people were quite surprised when I told them that when using provider + some other packages of mine, by default their entire application state is visible to them, without having to do anything (modulo this annoying devtool bug)",
                "createdAt": "2020-07-28T10:01:55Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I have to admit that I'm not a big fan of FutureBuilder, it causes a lot of bugs because people don't think about when to trigger the Future. I think it would not be unreasonable for us to drop support for it. StreamBuilder is ok I guess but then I think Streams themselves are too complicated (as you mention in your comment above) so...\nWhy does someone have to think about the complexity of creating Tweens?\nListView doesn't really hide the logic of mounting a widget as it appears; it's a big part of the API.\n\nThe problem is not the number of lines, but what these lines are.\n\nI really don't understand the concern here. The lines seem pretty much like simple boilerplate. Declare the thing, initialize the thing, dispose of the thing. If it's not the number of lines, then what's the problem?",
                "createdAt": "2020-07-28T18:12:18Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'll agree with you that FutureBuilder is problematic.\nIt's a bit off-topic, but I would suggest that in development, Flutter should trigger a fake hot-reload every few seconds. This would highlight misuses of FutureBuilder, keys, and many more.\n\nWhy does someone have to think about the complexity of creating Tweens?\nListView doesn't really hide the logic of mounting a widget as it appears; it's a big part of the API.\n\nWe agree on that. My point was that we cannot criticize something like hooks with \"it hides logic\", as what hooks do is strictly equivalent to what a TweenAnimationBuilder/AnimatedContainer/... do.\nThe logic is not hidden\nIn the end, I think animations are a good comparison. Animations have this concept of implicit vs explicit.\nImplicit animations are loved because of their simplicity, composability and readability.\nExplicit animations are more flexible, but more complex.\nWhen we translate this concept to listening to streams, StreamBuilder is an implicit listening, whereas stream.listen is explicit.\nMore specifically, with StreamBuilder you cannot forget to handle the scenario where the stream changes, or forget to close the subscription.\nYou can also combine multiple StreamBuilder together\nstream.listen is slightly more advanced and more error-prone.\nBuilders are powerful to simplify the application.\nBut as we agreed on previously, the Builder pattern is not ideal. It's both verbose to write and to use.\nThis issue, and what hooks solve, is about an alternate syntax for *Builders\nFor example, flutter_hooks has a strict equivalent to FutureBuilder and StreamBuilder:\nWidget build(context) {\n  final AsyncSnapshot<T> snapshot = useStream(stream);\n}\nIn the continuation, AnimatedContainer & alike could be represented by a useAnimatedSize / useAnimatedDecoractedBox / ... such that we have:\ndouble opacity;\n\nWidget build(context) {\n  final double animatedOpacity = useAnimatedDouble(opacity, duration: Duration(milliseconds: 200));\n  return Opacity(\n    opacity: animatedOpacity,\n    child: ...,\n  );\n}",
                "createdAt": "2020-07-28T19:47:36Z"
            },
            {
                "author": "Hixie",
                "bodyText": "My point was that we cannot criticize something like hooks with \"it hides logic\",\n\nThat's not the argument. The argument is \"it hides logic that developers should be thinking about\".",
                "createdAt": "2020-07-28T19:53:39Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Do you have an example of such logic that the developers should be thinking about?",
                "createdAt": "2020-07-28T19:55:27Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Like, who owns the TextEditingController (who creates it, who disposes of it).",
                "createdAt": "2020-07-28T19:56:19Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Like with this code?\nWidget build(context) {\n  final controller = useTextEditingController();\n  final focusNode = useFocusNode();\n}\nThe hook creates it and disposes of it.\nI'm not sure what is unclear about this.",
                "createdAt": "2020-07-28T19:58:53Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Yes, exactly. I have no idea what the lifecycle of the controller is with that code. Does it last until the end of the lexical scope? The lifetime of the State? Something else? Who owns it? If I pass it to someone else, can they take ownership? None of this is obvious in the code itself.",
                "createdAt": "2020-07-28T20:01:28Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It looks like your argument is caused more by a lack of understanding on what hooks do rather than a real issue.\nThese questions have a clearly defined answer that is consistent with all hooks:\n\nI have no idea what the lifecycle of the controller is with that code\n\nNor do you have to think about it. It is no longer the responsibility of the developer.\n\nDoes it last until the end of the lexical scope? The lifetime of the State\n\nThe lifetime of the State\n\nWho owns it?\n\nThe hook owns the controller. It is part of the API of useTextEditingController that it owns the controller.\nThis applies to useFocusNode, useScrollController, useAnimationController, ...\nIn a way, these questions apply to StreamBuilder:\n\nWe don't have to think about the life-cycles of the  StreamSubscription\nThe subscription lasts for the lifetime of the State\nthe StreamBuilder owns the StreamSubscription",
                "createdAt": "2020-07-28T20:13:14Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "In general, you can think of:\nfinal value = useX(argument);\nas a strict equivalent to:\nXBuilder(\n  argument: argument,\n  builder: (context, value) {\n\n  },\n);\nThey have the same rules and the same behavior.",
                "createdAt": "2020-07-28T20:29:44Z"
            },
            {
                "author": "Hixie",
                "bodyText": "It is no longer the responsibility of the developer\n\nI think fundamentally that's the disagreement here. Having a function-like API that returns a value that has a defined life-time that isn't clear is, IMHO, fundamentally very different than an API based on passing that value to a closure.\nI have no problem with someone creating a package that uses this style, but it's a style contrary to the kind that I would want to include in the core flutter API.",
                "createdAt": "2020-07-28T22:10:33Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "@Hixie\nI don't think what @rrousselGit was saying was that they are the same thing but just that they have \"the same rules and the same behaviour\" regarding life cycle? Correct?\nThey don't solve the same problems though.\nMaybe I'm wrong here but last fall when trying out flutter I believe that if I would have needed three of those builders in one widget it would have been a lot of nesting. Compared to three hooks (three lines).\nAlso. Hooks are composable so if you need to share state logic composed of multiple hooks you could make a new hook that uses other hooks and some extra logic and just use the one new hook.\nSuch stuff like sharing state logic easily between widgets was a thing I was missing when trying out flutter fall of 2019.\nThere could of course be a lot of other possible solutions. Maybe it's already been solved and I just didn't find it in the docs.\nBut if not there are a lot that could be done to speed up development a great deal if a thing like hooks or another solution for the same problems where available as a first class citizen.",
                "createdAt": "2020-07-28T23:33:31Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I'm definitely not suggesting using the builder approach, as the OP mentions, that has all kinds of problems. What I would suggest is just using initState/dispose. I don't really understand why that's a problem.\nI'm curious how people feel about the code in #51752 (comment). I don't think it's any better than initState/dispose, but if people like hooks, do they like that too? Is hooks better? Worse?",
                "createdAt": "2020-07-28T23:47:00Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@Hixie Hooks are nice to use because they compartmentalize the life cycle into a single function call. If I use a hook, say useAnimationController, I don't have to think about initState and dispose anymore. It removes the responsibility from the developer. I don't have to worry whether I disposed every single animation controller I created.\ninitState and dispose are fine for a single thing but imagine having to keep track of multiple and disparate types of state. Hooks compose based on the logical unit of abstraction instead of spreading them out in the life cycle of the class.\nI think what you're asking is the equivalent of asking why have functions when we can manually take care of effects every time. I agree it is not exactly the same, but it broadly feels similar. It seems that you have not used hooks before so the problems don't seem too apparent to you, so I would encourage you to do a small or medium size project using hooks, with the flutter_hooks package perhaps, and see how it feels. I say this with all respect, as a user of Flutter I have run into these issues that hooks provide solutions to, as have others. I am unsure how to convince you that these problems truly exist for us, let us know if there's a better way.",
                "createdAt": "2020-07-29T00:57:47Z"
            },
            {
                "author": "gaearon",
                "bodyText": "I'll add a few thoughts from the React perspective.\nPardon if they're not relevant but I wanted to briefly explain how we think about Hooks.\nHooks are definitely \"hiding\" things. Or, depending on how you look at it, encapsulate them. In particular, they encapsulate local state and effects (I think our \"effects\" are the same things as \"disposables\"). The \"implicitness\" is in that they automatically attach the lifetime to the Component inside of which they're called.\nThis implicitness is not inherent in the model. You could imagine an argument being explicitly threaded through all calls \u2014 from the Component itself throughout custom Hooks, all the way to each primitive Hook. But in practice, we found that to be noisy and not actually useful. So we made currently executing Component implicit global state. This is similar to how throw in a VM searches upwards for the closest catch block instead of you passing around errorHandlerFrame in code.\nOkay, so it's functions with implicit hidden state inside them, that seems bad? But in React, so are Components in general. That's the whole point of Components. They're functions that have a lifetime associated with them (which corresponds to a position in the UI tree). The reason Components themselves are not a footgun with regards to state is that you don't just call them from random code. You call them from other Components. So their lifetime makes sense because you remain in the context of UI code.\nHowever, not all problems are component-shaped. Components combine two abilities: state+effects, and a lifetime tied to tree position. But we've found that the first ability is useful on its own. Just like functions are useful in general because they let you encapsulate code, we were lacking a primitive that would let us encapsulate (and reuse) state+effects bundles without necessarily creating a new node in the tree. That's what Hooks are. Components = Hooks + returned UI.\nAs I mentioned, an arbitrary function hiding contextual state is scary. This is why we enforce a convention via a linter. Hooks have \"color\" \u2014 if you use a Hook, your function is also a Hook. And the linter enforces that only Components or other Hooks may use Hooks. This removes the problem of arbitrary functions hiding contextual UI state because now they're no more implicit than Components themselves.\nConceptually, we don't view Hook calls as plain function calls. Like useState() is more use State() if we had the syntax. It would be a language feature. You can model something like Hooks with Algebraic Effects in languages that have effect tracking. So in that sense, they would be regular functions, but the fact that they \"use\" State would be a part of their type signature. Then you can think of React itself as a \"handler\" for this effect. Anyway, this is very theoretical but I wanted to point at prior art in terms of the programming model.\nIn practical terms, there are a few things here. First, it's worth noting Hooks aren't an \"extra\" API to React. They're the React API for writing Components at this point. I think I'd agree that as an extra feature they wouldn't be very compelling. So I don't know if they really make sense for Flutter which has an arguably different overall paradigm.\nAs for what they allow, I think the key feature is the ability to encapsulate state+effectful logic, and then chain it together like you would with regular function composition. Because the primitives are designed to compose, you can take some Hook output like useState(), pass it as an input to a cusom useGesture(state), then pass that as an input to several custom useSpring(gesture) calls which give you staggered values, and so on. Each of those pieces is completely unaware of the others and may be written by different people but they compose well together because state and effects are encapsulated and get \"attached\" to the enclosing Component. Here's a small demo of something like this, and an article where I briefly recap what Hooks are.\nI want to emphasize this is not about reducing the boilerplate but about the ability to dynamically compose pipelines of stateful encapsulated logic. Note that it is fully reactive \u2014 i.e. it doesn't run once, but it reacts to all changes in properties over time. One way to think of them is they're like plugins in an audio signal pipeline. While I totally get the wary-ness about \"functions that have memories\" in practice we haven't found that to be a problem because they're completely isolated. In fact, that isolation is their primary feature. It would fall apart otherwise. So any codependence has to be expressed explicitly by returning and passing values into the next thing in the chain. And the fact that any custom Hook can add or remove state or effects without breaking (or even affecting) its consumers is another important feature from the third-party library perspective.\nI don't know if this was helpful at all, but hope it sheds some perspective on the programming model.\nHappy to answer other questions.",
                "createdAt": "2020-07-29T01:37:43Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'm definitely not suggesting using the builder approach, as the OP mentions, that has all kinds of problems. What I would suggest is just using initState/dispose. I don't really understand why that's a problem.\nI'm curious how people feel about the code in #51752 (comment). I don't think it's any better than initState/dispose, but if people like hooks, do they like that too? Is hooks better? Worse?\n\nThe late keyword makes things better, but it still suffers from some issues:\nSuch Property may be useful for states that are self-contained or that do not depend on parameters that can change over time. But it may get difficult to use when in a different situation.\nMore precisely, it lacks the \"update\" part.\nFor example, with StreamBuilder the stream listened can change over time. But there is no easy solution to implement such thing here, as the object is initialized only once.\nSimilarly, hooks have an equivalent to Widget's Key \u2013 which can cause a piece of state to be destroyed and re-created when that key changes.\nAn example of that is useMemo, which is a hook that cache an instance of object.\nCombined with keys, we can use useMemo to have implicit data fetching.\nFor example, our widget may receive a message ID \u2013 which we then use to fetch the message details. But that message ID may change over time, so we may need to re-fetch the details.\nWith useMemo, this may look like:\nString messageId;\n\nWidget build(context) {\n  final Future<Message> message = useMemo(() => fetchMessage(messageId), [messageId]);\n\n}\nIn this situation, even if the build method is called again 10 times, as long as messageId does not change, the data-fetching is not performed again.\nBut when the messageId changes, a new Future is created.\n\nIt's worth noting that I do not think flutter_hooks in its current state is refined for Dart. My implementation is more of a POC than a fully-fledged architecture.\nBut I do believe that we have an issue with code reusability of StatefulWidgets.\nI didn't remember where, but I remember suggesting that hooks in the ideal world would be a custom function generator, next to async* & sync*, which may be similar to what Dan suggest with use State rather than useState",
                "createdAt": "2020-07-29T02:54:04Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@gaearon\n\nI want to emphasize this is not about reducing the boilerplate but about the ability to dynamically compose pipelines of stateful encapsulated logic.\n\nThat isn't the problem being discussed here. I recommend filing a separate bug to talk about the inability to do what you describe. (That sounds like a very different problem and honestly a more compelling one than the one described here.) This bug is specifically about how some of the logic is too verbose.",
                "createdAt": "2020-07-29T03:51:34Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "No he is right, it is my wording that may be confusing.\nAs I mentioned previously, this is not about the number of lines of code, but the lines of code themselves.\nThis is about factorizing state.",
                "createdAt": "2020-07-29T03:54:23Z"
            },
            {
                "author": "Hixie",
                "bodyText": "This bug is extremely clear about the problem being \"Reusing state logic is too verbose/difficult\" and being all about how there is too much code in a State when you have a property that needs to have code to declare it, in initState, in dispose, and in debugFillProperties. If the problem you care about is something different then I recommend filing a new bug that describes that problem.\nI really, really strongly recommend forgetting about hooks (or any solution) until you fully understand the problem you want to solve. It's only by having a clear understanding of the problem that you will be able to articulate a convincing argument in favour of a new feature, because we must evaluate features against the problems that they solve.",
                "createdAt": "2020-07-29T03:57:01Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I think you are misunderstanding what I said in that issue then.\nThe problem is by no mean boilerplate, but reusability.\nBoilerplate is a consequence of an issue with reusability, not the cause",
                "createdAt": "2020-07-29T04:00:48Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "What this issue describes is:\nWe may want to reuse/compose state logic. But the options available are either mixins, Builders, or not reusing it \u2013 all of which have their own issues.\nThe issues of the existing options may be related to boilerplate, but the problem we are trying to solve isn't.\nWhile reducing the boilerplate of Builders is one path (which is what hooks do), there may be a different one.\nFor example, something I wanted to suggest for a while was to add methods like:\ncontext.onDidChangeDependencies(() {\n\n});\ncontext.onDispose(() {\n\n});\nBut these have their own issues and do not fully solve the problem, so I didn't.",
                "createdAt": "2020-07-29T04:12:15Z"
            },
            {
                "author": "timsneath",
                "bodyText": "@rrousselGit, feel free to edit the original problem statement at the top here to better reflect the problem. Also feel free to create a design doc: https://flutter.dev/docs/resources/design-docs that we can iterate on together (again, as @Hixie suggests, focusing for now on the tightest possible exposition of the problem statement). I'd love you to feel as empowered as any other Flutter engineer -- you're part of the team, so let's iterate together!",
                "createdAt": "2020-07-29T18:31:40Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I've looked through the issue again a few times. In all honesty, I do not understand where the misunderstanding is coming from, so I'm not sure what to improve.\nThe original comment repeatedly mentions the desire for reusability/factorization. The mentions about boilerplate are not \"Flutter is verbose\" but \"Some logics are not reusable\"\nI don't think the design doc suggestion is fair. It takes a significant amount of time to write such a document, and I am doing this in my free time.\nI am personally satisfied with hooks. I'm not authoring these issues in my interest, but to raise awareness about a problem that impacts a significant number of people.\nA few weeks ago, I was hired to discuss architecture about an existing Flutter app. Their probably was exactly what is mentioned here:\n\nThey have some logic that needs to be reused in multiple widgets (handling loading states / marking \"messages\" as read when some widgets become visible / ...)\nThey tried to use mixins, which caused major architecture flaws.\nThey also tried to manually handle the \"create/update/dispose\" by rewriting that logic in multiple locations, but it caused bugs.\nIn some places, they forgot to close subscriptions. In others, they didn't handle the scenario where their stream instance changes",
                "createdAt": "2020-07-30T03:00:23Z"
            },
            {
                "author": "Hixie",
                "bodyText": "marking \"messages\" as read when some widgets become visible\n\n\nThat's an interesting case because it's similar to issues I've had in one of my own apps, so I looked at how I'd implemented the code there and I really don't see much of the problems that this bug describes, which may be why I'm having trouble understanding the problem. This is the code in question:\nhttps://github.com/jocosocial/rainbowmonkey/blob/master/lib/src/views/forums.dart\nDo you have examples of actual apps I could study to see the problem in action?",
                "createdAt": "2020-07-30T05:43:48Z"
            },
            {
                "author": "Hixie",
                "bodyText": "(BTW, in general I would strongly recommend not using Streams at all. I think they generally make things worse.)",
                "createdAt": "2020-07-30T05:44:38Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "(BTW, in general I would strongly recommend not using Streams at all. I think they generally make things worse.)\n\n(I wholeheartedly agree. But the community currently has the opposite reaction. Maybe extracting ChangeNotifier/Listenable/ValueNotifier out of Flutter into an official package would help)\n\nDo you have examples of actual apps I could study to see the problem in action?\n\nSadly no. I can only share the experience I had while helping others. I don't have an app at hand.\n\nThat's an interesting case because it's similar to issues I've had in one of my own apps, so I looked at how I'd implemented the code there and I really don't see much of the problems that this bug describes, which may be why I'm having trouble understanding the problem. This is the code in question:\n\nIn your implementation, the logic isn't tied to any life-cycle and placed inside build, so it kind of works around the problem.\nIt may make sense in that specific case. I'm not sure if that example was good.\nA better example may be pull-to-refresh.\nIn a typical pull-to-refresh, we will want:\n\non the first build, handle loading/error states\non refresh:\n\nif the screen was in error state, show the loading screen once again\nif the refresh was performed during loading, cancel pending HTTP requests\nif the screen showed some data:\n\nkeep showing the data while the new state is loading\nif the refresh fails, keep showing the previously obtained data and show a snackbar with the error\n\n\nif the user pops and re-enters the screen while the refresh is pending, show the loading screen\nmake sure that the RefreshIndicator says visible while the refresh is pending\n\n\n\nAnd we'll want to implement such a feature for all resources and multiple screens. Furthermore, some screens may want to refresh multiple resources at once.\nChangeNotifier + provider + StatefulWidget will have quite a lot of difficulties factorizing this logic.\nWhereas my latest experiments (which is immutability based & relies on flutter_hooks) supports the entire spectrum out of the box:\nfinal productsProvider = FutureProvider<List<Product>>.autoDispose((ref) async {\n  final cancelToken = CancelToken();\n  ref.onDispose(cancelToken.cancel);\n\n  return await repository.fetchProducts(cancelToken: cancelToken);\n});\n\n// ...\n\nWidget build(context) {\n  // Listens to the Future created by productsProvider and handles all the refresh logic\n  AsyncValue<List<Product>> products = useRefreshProvider(\n    productsProvider,\n    // TODO consider making a custom hook to encaplusate the snackbar logic\n    onErrorAfterRefresh: (err, stack) => Scaffold.of(context).showSnackBar(...),\n  );\n\n  return RefreshIndicator(\n    onRefresh: () => context.refresh(productsProvider),\n    child: products.when(\n      loading: () {\n        return const SingleChildScrollView(\n          physics: AlwaysScrollableScrollPhysics(),\n          child: CircularProgressIndicator(),\n        );\n      },\n      error: (err, stack) {\n        return SingleChildScrollView(\n          physics: const AlwaysScrollableScrollPhysics(),\n          child: Text('Oops, something unexpected happened\\n$err'),\n        );\n      },\n      data: (products) {\n        return ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (context, index) {\n            return ProductItem(products[index]);\n          },\n        );\n      },\n    ),\n  );\n}\nThis logic is entirely self-contained. It can be reused with any resource inside any screens.\nAnd if one screen wants to refresh multiple resources at once, we can do:\nAsyncValue<First> first = useRefreshProvider(\n  firstProvider,\n  onErrorAfterRefresh: ...\n);\nAsyncValue<Second> second = useRefreshProvider(\n  secondProvider,\n  onErrorAfterRefresh: ...\n);\n\nreturn RefreshIndicator(\n  onRefresh: () {\n     return Future.wait([context.refesh(firstProvider), context.refresh(secondProvider)]);\n  }\n  ...\n)",
                "createdAt": "2020-07-30T12:26:56Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I would recommend putting all of that logic in the app state, outside of the widgets, and just having the app state reflect the current app state. Pull to refresh needs no state within the widget, it just has to tell the ambient state that a refresh is pending and then wait for its future to complete.",
                "createdAt": "2020-07-30T15:59:07Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It isn't the responsibility of the ambient state to determine how to render an error vs loading vs data\nHaving this logic in the ambient state doesn't remove all logics from the UI\nThe UI still need to determine whether to show the error in full screen or in a snack-bar\nIt still need to force errors to be refreshed when the page is reloaded\nAnd this is less reusable.\nIf the rendering logic is fully defined in the widgets rather than the ambient state, then it will work with any Future and can even be included directly inside Flutter.",
                "createdAt": "2020-07-30T20:47:03Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I don't really understand what you are advocating for in your last comment. My point is that you don't need changes to the framework to do something just as simple as the refresh indicator code above, as is demonstrated by the code I cited earlier.",
                "createdAt": "2020-07-30T20:59:23Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "If we have a lot of these types of interactions, not just for refresh indicators, but for animations, and others, it is better to encapsulate them where they are closest to being needed rather than putting them in the app state, because the app state doesn't need to know the specifics of every single interaction in the app if it's not needed in multiple places in the app.",
                "createdAt": "2020-07-30T21:10:56Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I don't think we are agreeing on the complexity of the feature and its reusability.\nDo you have an example which showcase that such feature is easy?",
                "createdAt": "2020-07-30T21:11:05Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I linked to the source of one app I wrote above. It's certainly not perfect code, and I plan to rewrite bits of it for the next release, but I didn't experience the problems you describe in this issue.",
                "createdAt": "2020-07-30T21:26:14Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "But you are one of the tech leads of Flutter.\nEven when faced with a problem, you would have enough skill to immediately come up with a solution.\nYet on the other side, a significant number of people do not understand what is wrong with the following code:\nFutureBuilder<User>(\n  future: fetchUser(),\n  builder: ...,\n)\nThis fact is proven by how popular a Q/A I made on StackOverflow is.\nThe problem is not that it is impossible to abstract state logic in a reusable and robust way (otherwise there is no point in making this issue).\nThe problem is that it requires both time and experience to do so.\nBy providing an official solution, this reduces the likelihood that an application ends up unmaintainable \u2013 which increases the overall productivity and developer experience.\nNot everyone could come up with your Property suggestion. If such a thing was built inside Flutter, it would be documented, get visibility, and ultimately help people that would have never thought about it to begin with.",
                "createdAt": "2020-07-31T00:43:39Z"
            },
            {
                "author": "Hixie",
                "bodyText": "The problem is that it really depends on what your app is, what your state looks like, and so on. If the question here is just \"how do you manage app state\" then the answer isn't anything like hooks, it's lots of documentation talking about different ways to do it and recommending different techniques for different situations... basically, this set of documents: https://flutter.dev/docs/development/data-and-backend/state-mgmt",
                "createdAt": "2020-07-31T07:04:54Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "There is ephemeral and app state, but there seems to be another use case as well: state that is only concerned with a single type of widget but that you nevertheless want to share between that type of widget.\nFor example, a ScrollController may invoke some type of animation, but it's not necessarily appropriate to put that into the global app state, because it's not data that needs to be used across all of the app. However, multiple ScrollControllers might have the same logic, and you want to share that life cycle logic between each of them. The state is still for only ScrollControllers, so not global app state, but copy-pasting the logic is prone to error.\nMoreover, you may want to package this logic to make it more composable for your future projects, but also to others. If you look at the site useHooks, you'll see many pieces of logic that compartmentalize certain common actions. If you use useAuth you write it once and never have to worry about whether you missed an initState or dispose call, or whether the async function is has a then and catch. The function is written only once so the room for error basically disappears. Therefore, this kind of solution is not only more composable for multiple parts of the same app and between multiple apps, but it is also safer for the end programmer.",
                "createdAt": "2020-07-31T13:45:24Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I have no objection to people using hooks. As far as I can tell, nothing is preventing that. (If something is preventing that, then please file a bug about that.)\nThis bug isn't about hooks, it's about \"Reusing state logic is too verbose/difficult\", and I'm still struggling to understand why this requires any changes to Flutter. There's been many examples (including hooks) showing how it's possible to avoid the verbosity by structuring one's application one way or another, and there's lots of documentation about it already.",
                "createdAt": "2020-08-01T00:40:16Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I see, so you're asking why, if there exists something like a hooks package which was built with no changes to Flutter already, there needs to be a first party solution for hooks? I suppose @rrousselGit can answer this better but the answer probably involves better support, more integrated support and more people using them.\nI can agree with you that besides that, I am also confused why any fundamental changes need to be made to Flutter to support hooks, since ostensibly the flutter_hooks package exists already.",
                "createdAt": "2020-08-01T00:52:28Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'm still struggling to understand why this requires any changes to Flutter.\n\nSaying that this problem is solved because the community made a package is like saying that Dart doesn't need data-classes + union types because I made Freezed.\nFreezed may be quite liked by the community as a solution to both of these problems, but we still can do better.\nThe Flutter team has a lot more leverage than the community ever will. You have both the capability to modify the entire stack; people that are experts on each individual part; and a salary to sponsor the work needed.\nThis problem needs that.\nRemember: One of the goals of the React team is for hooks to be part of the language, kind of like with JSX.\nEven without language support, we still need work in analyzer; dartpad; flutter/devtools; and many hooks to simplify all the different things that Flutter does (such as for implicit animations, forms, and more).",
                "createdAt": "2020-08-01T03:10:26Z"
            },
            {
                "author": "timsneath",
                "bodyText": "That's a good argument, I agree, even though the general philosophy of Flutter to have a small core. For that reason, we've been increasingly adding new functionality as packages even when it comes from Google, c.f. characters and animations. That gives us greater flexibility to learn and change over time. We would do the same for this space, unless there's a compelling technical reason why a package was insufficient (and with extension methods, that's even less likely than ever).\nPutting things into the core of Flutter is tricky. One challenge is, as you know well from first-hand experience, is that state is an area that is evolving as we all learn more about what works well in a reactive UI architecture. Two years ago, if we'd been forced to pick a winner, we might have selected BLoC, but then of course your provider package took over and is now our default recommendation.\nI could comfortably conceive of Google-employed contributors supporting flutter_hooks or a similar hooks package that had traction (although we have plenty of other work that is competing for our attention, obviously). In particular, we should If you're looking for us to take it over from you, that's obviously a different question.",
                "createdAt": "2020-08-01T16:23:07Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Interesting argument, @timsneath. The Rust community also does something similar, because once introduced into the core or standard library of a language or framework, it is very difficult to take it out. In Rust's case, it is impossible as they want to maintain backwards compatibility forever. Therefore, they wait until packages have arrived and competed with each other until only a few winners emerge, then they fold that into the language.\nThis could be a similar case with Flutter. There might be something better than hooks later on, just as React had to move from classes to hooks but still had to maintain classes, and people had to migrate. It might then be better to have competing state management solutions before being added to the core. And perhaps we the community should innovate on top of hooks or try finding even better solutions.",
                "createdAt": "2020-08-01T16:33:22Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I understand that concern, but this isn't about a state management solution.\nSuch feature is closer to Inheritedwidget & StatefulWidget. It is a low level primitive, that could be as low as a language feature.\nHooks may be independent from the framework, but that's only through luck.\nAs I mentioned before, another path to this problem may be:\ncontext.onDispose(() {\n\n});\nAnd similar event listeners.\nBut that is impossible to implement out of the framework.\nI do not know what the team would come up with.\nBut we can't exclude the possibility that such solution would have to be directly next to Element",
                "createdAt": "2020-08-01T16:54:21Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Do extensions help with that?",
                "createdAt": "2020-08-01T21:02:28Z"
            },
            {
                "author": "Hixie",
                "bodyText": "(Maybe we should talk about that in a different issue, though. It's sort of off-topic here. I really would prefer if we had one issue per problem that people are seeing, so we could discuss solutions in the right place. It's not clear how context.onDispose would help with verbosity.)",
                "createdAt": "2020-08-01T21:04:54Z"
            },
            {
                "author": "dnfield",
                "bodyText": "I strongly suspect there are some really good language proposals we could come up with related to this.\nI think it'd be be helpful to talk about them more specifically than how they might enable a specific state management idiom. We could then more seriously consider what they would enable and what tradeoffs they might entail.",
                "createdAt": "2020-08-01T21:12:20Z"
            },
            {
                "author": "dnfield",
                "bodyText": "In particular, we'd be able to consider how and whether they could work in both the VM and JS runtimes",
                "createdAt": "2020-08-01T21:13:54Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It's not clear how context.onDispose would help with verbosity.)\n\nAs I mentioned before, this issue is more about code-reusability than verbosity. But if we can reuse more code, this should implicitly reduce the verbosity.\nThe way context.onDispose is related to this issue is, with the current syntax we have:\nAnimationController controller;\n\n@override\nvoid initState() {\n  controller = AnimationController(...);\n}\n\n@override\nvoid dispose() {\n  controller.dispose();\n}\nThe problem is:\n\nthis is tightly coupled to the class definition, so cannot be reused\nas the widget grows, the relationship between the initialization and dispose becomes harder to read since there is hundreds of lines of code in the middle.\n\nWith a context.onDispose, we could do:\n@override\nvoid initState() {\n  controller = AnimationController(...);\n  context.onDispose(controller.dispose);\n}\nThe interesting part is:\n\nthis is no-longer tightly coupled with the class definition, so it can be extracted into a function.\nWe could theoretically have semi-complex logic:\nAnimationController someReusableLogic(BuildContext context) {\n  final controller = AnimationController(...);\n  controller.onDispose(controller.dispose);\n  controller.forward();\n  void listener() {}\n  controller.addListener(listener);\n  context.onDispose(() => controller.removeListener(listener));\n}\n...\n\n@override\nvoid initState() {\n  controller = someReusableLogic(context);\n}\n\nall the logic is bundled together. Even if the widget grows to be 300 long, the logic of controller is still easily readable.\n\nThe problem with this approach is:\n\ncontext.myLifecycle(() {...}) is not hot-reloadable\nit is unclear how to have someReusableLogic read properties from the StatefulWidget without tightly coupling the function to the widget definition.\nFor example, the AnimationController's Duration may be passed as a parameter of the widget. So we need to handle the scenario where the duration changes.\nit is unclear how to implement a function which returns an object that can change over time, without having to resort to a ValueNotifier and dealing with listeners\n\nThis is especially important for computed states.\n\n\n\n\nI'll think about a language proposal. I have some ideas, but nothing worthy of talking about right now.",
                "createdAt": "2020-08-02T01:27:20Z"
            },
            {
                "author": "Hixie",
                "bodyText": "As I mentioned before, this issue is more about code-reusability than verbosity\n\nOk. Can you please file a new bug then that talks about that specifically? This bug is literally called \"Reusing state logic is too verbose/difficult\". If verbosity is not the issue then this isn't the issue.\n\nWith a context.onDispose, we could do:\n@override\nvoid initState() {\n  controller = AnimationController(...);\n  context.onDispose(controller.dispose);\n}\n\nI'm not sure why context is relevant in this (and onDispose violates our naming conventions). If you just want a way to register things to run during dispose, though, you can do this easily today:\nmixin StateHelper<T extends StatefulWidget> on State<T> {\n  List<VoidCallback> _disposeQueue;\n\n  void queueDispose(VoidCallback callback) {\n    _disposeQueue ??= <VoidCallback>[];\n    _disposeQueue.add(callback);\n  }\n\n  @override\n  void dispose() {\n    if (_disposeQueue != null) {\n      for (VoidCallback callback in _disposeQueue)\n        callback();\n    }\n    super.dispose();\n  }\n}\nCall it like this:\nclass _MyHomePageState extends State<MyHomePage> with StateHelper<MyHomePage> {\n  TextEditingController controller;\n\n  @override\n  void initState() {\n    super.initState();\n    controller = TextEditingController(text: 'button');\n    queueDispose(controller.dispose);\n  }\n\n  ...\n\nAnimationController someReusableLogic(BuildContext context) {\n  final controller = AnimationController(...);\n  controller.onDispose(controller.dispose);\n  controller.forward();\n  void listener() {}\n  controller.addListener(listener);\n  context.onDispose(() => controller.removeListener(listener));\n}\n...\n\n@override\nvoid initState() {\n  controller = someReusableLogic(context);\n}\n\nYou can do that too:\nAnimationController someReusableLogic<T extends StatefulWidget>(StateHelper<T> state) {\n  final controller = AnimationController(...);\n  state.queueDispose(controller.dispose);\n  controller.forward();\n  void listener() {}\n  controller.addListener(listener);\n  state.queueDispose(() => controller.removeListener(listener));\n  return controller;\n}\n...\n\n@override\nvoid initState() {\n  controller = someReusableLogic(this);\n}\n\nThe problem with this approach is:\n\ncontext.myLifecycle(() {...}) is not hot-reloadable\n\n\nIn this context it doesn't seem to matter since it's only for things called in initState? Am I missing something?\n\n\nit is unclear how to have someReusableLogic read properties from the StatefulWidget without tightly coupling the function to the widget definition.\nFor example, the AnimationController's Duration may be passed as a parameter of the widget. So we need to handle the scenario where the duration changes.\n\n\nIt's pretty simple to add a didChangeWidget queue just like the dispose queue:\nmixin StateHelper<T extends StatefulWidget> on State<T> {\n  List<VoidCallback> _disposeQueue;\n  List<VoidCallback> _didUpdateWidgetQueue;\n\n  void queueDispose(VoidCallback callback) {\n    _disposeQueue ??= <VoidCallback>[];\n    _disposeQueue.add(callback);\n  }\n\n  void queueDidUpdateWidget(VoidCallback callback) {\n    _didUpdateWidgetQueue ??= <VoidCallback>[];\n    _didUpdateWidgetQueue.add(callback);\n  }\n\n  @override\n  void didUpdateWidget(T oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (_didUpdateWidgetQueue != null) {\n      for (VoidCallback callback in _didUpdateWidgetQueue)\n        callback();\n    }\n  }\n\n  @override\n  void dispose() {\n    if (_disposeQueue != null) {\n      for (VoidCallback callback in _disposeQueue)\n        callback();\n    }\n    super.dispose();\n  }\n}\n\nAnimationController conditionalAnimator(StateHelper state, ValueGetter<bool> isAnimating, VoidCallback listener) {\n  final controller = AnimationController(vsync: state as TickerProvider, duration: const Duration(seconds: 1));\n  state.queueDispose(controller.dispose);\n  controller.addListener(listener);\n  state.queueDispose(() => controller.removeListener(listener));\n  if (isAnimating())\n    controller.repeat();\n  state.queueDidUpdateWidget(() {\n    if (isAnimating()) {\n      controller.repeat();\n    } else {\n      controller.stop();\n    }\n  });\n  return controller;\n}\nUsed like this:\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHomePage(animating: false),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key, this.animating}) : super(key: key);\n\n  final bool animating;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState();\n}\n\nclass _MyHomePageState extends State<MyHomePage> with StateHelper<MyHomePage>, SingleTickerProviderStateMixin {\n  AnimationController controller;\n\n  @override\n  void initState() {\n    super.initState();\n    controller = conditionalAnimator(this, () => widget.animating, () { print(controller.value); });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: FadeTransition(\n        opacity: controller,\n        child: Text('Hello', style: TextStyle(fontSize: 100.0, color: Colors.white)),\n      ),\n    );\n  }\n}\n\n\n\nit is unclear how to implement a function which returns an object that can change over time, without having to resort to a ValueNotifier and dealing with listeners\n\nThis is especially important for computed states.\n\n\n\n\nNot sure what this means here, what's wrong with ValueNotifier and, say, a ValueListenableBuilder?",
                "createdAt": "2020-08-02T02:28:54Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "As I mentioned before, this issue is more about code-reusability than verbosity\n\nOk. Can you please file a new bug then that talks about that specifically? This bug is literally called \"Reusing state logic is too verbose/difficult\". If verbosity is not the issue then this isn't the issue.\n\nI'm starting to get quite uncomfortable with this discussion. I have already answered this point before:\nThe topic of this issue is reusability, and verbosity is discussed as a consequence of a reusability issue; not as the primary topic.\nThere is only a single bullet point in the top comment mentioning verbosity, and that is with StreamBuilder, targeting mainly the 2 levels of indentations.\n\nI'm not sure why context is relevant in this [...]. If you just want a way to register things to run during dispose, though, you can do this easily today:\n\nWhen I brought up context.onDispose, I mentioned explicitly that I don't think it a good solution.\nI explained it because you asked how it is related to the discussion.\nAs for why context instead of StateHelper, it is because this is more flexible (like working with StatelessWidget)\n\n\ncontext.myLifecycle(() {...}) is not hot-reloadable\n\nIn this context it doesn't seem to matter since it's only for things called in initState? Am I missing something?\n\nWe may change:\ninitState() {\n  context.myLifecycle(() => print('hello'));\n}\ninto:\ninitState() {\n  context.myLifecycle(() => print('world'));\n}\nThis will not apply the changes to the myLifecycle callback.\nBut if we used:\nmyLifecycle() {\n  super.myLifecycle();\n  print('hello');\n}\nthen hot-reload would work.\n\nNot sure what this means here, what's wrong with ValueNotifier and, say, a ValueListenableBuilder?\n\nThis syntax was designed to avoid having to use Builders, so we circled back to the original problem.\nFurthermore, if we really want to make our function composable, instead of your ValueGetter + queueDidUpdateWidget suggestion, functions will have to take a ValueNotifier as parameter:\nAnimationController conditionalAnimator(StateHelper state, ValueListenable<bool> isAnimating, VoidCallback listener) {\n...\n}\nas we may want to obtain isAnimating from somewhere other than didUpdateWidget depending on which widget is using this function.\nIn one place, it may be didUpdateWidget; in another it may be didChangeDependencies; and in yet another place it may be inside the callback of a stream.listen.\nBut then we need a way to convert these scenarios into a ValueNotifier easily and make our function listen to such notifier.\nSo we are making our life significantly harder.\nIt more realiable and easier to use a ConditionalAnimatorBuilder than this pattern I think.",
                "createdAt": "2020-08-02T04:18:32Z"
            },
            {
                "author": "Hixie",
                "bodyText": "As for why context instead of StateHelper, it is because this is more flexible (like working with StatelessWidget)\n\nStatelessWidget is for, well, stateless widgets. The whole point is that they wouldn't create state, dispose things, react on didUpdateWidget, etc.\nRe the hot reload thing, yes. That's why we use methods rather than putting closures in initState.\nI'm sorry I keep saying this, and I understand that it must be frustrating, but I still don't understand what the problem we're trying to solve here is. I thought it was verbosity, per the original bug summary and a big chunk of the original description, but I understand that that is not it. So what is the problem? It sounds like there are many mutually exclusive desires here, spread across the many many comments in this bug:\n\nDeclaring how to dispose something should be done in the same place that allocates it...\n...and the place that allocates it needs to run only once since it's allocating it...\n...and it needs to work with hot reload (which by definition doesn't rerun code that only runs once)...\n...and it needs to be able to create state that works with stateless widgets (which by definition don't have state)...\n...and it needs to enable hooking into things like didUpdateWidget and didChangeDependencies...\n\nThis iterative dance we're involved in here isn't a productive way to get things done. As I've tried to say before, the best way to get something here is to describe the problem you're facing in a way that we can understand, with all the needs described in one place and explained with use cases. I recommend not listing solutions, especially not solutions that you know do not satisfy your needs. Just make sure the need that makes those solutions inappropriate is listed in the description.\nTo be honest, fundamentally it sounds to me like you're asking for an entirely different framework design. That's perfectly fine, but it isn't Flutter. If we were to do a different framework it would be, well, a different framework, and we've still got a lot of work to do on this framework. Actually, a lot of what you describe is very similar to how Jetpack Compose is designed. I'm not a huge fan of that design because it requires compiler magic, so debugging what's going on is really hard, but maybe it's more up your alley?",
                "createdAt": "2020-08-02T05:19:29Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It sounds like there are many mutually exclusive desires here, spread across the many many comments in this bug:\n\nThey are not mutually exclusive. Hooks do every single one of these. I won't go into details since we don't want to focus on solutions, but they do check all the boxes.\n\nAs I've tried to say before, the best way to get something here is to describe the problem you're facing in a way that we can understand, with all the needs described in one place and explained with use cases.\n\nI still fail to understand how that top comment fails to do that.\nIt isn't clear to me what isn't clear to others.\n\nActually, a lot of what you describe is very similar to how Jetpack Compose is designed. I'm not a huge fan of that design because it requires compiler magic, so debugging what's going on is really hard, but maybe it's more up your alley?\n\nI'm not familiar with it, but with a quick search, I would say yes.",
                "createdAt": "2020-08-02T05:33:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "They are not mutually exclusive.\n\nAre all the bullet points I listed above part of the problem we're trying to solve here?\n\nbut they do check all the boxes\n\nCan you list the boxes?\n\nI still fail to understand how that top comment fails to do that.\n\nFor example, the OP explicitly says that the problem is about StatefulWidgets, but one of the recent comments on this issue said a particular suggestion was no good because it didn't work with StatelessWidgets.\nIn the OP you say:\n\nIt is difficult to reuse State logic. We either end up with a complex and deeply nested build method or have to copy-paste the logic across multiple widgets.\n\nSo from this I assume that the requirements include:\n\nSolution must not be deeply nested.\nSolution must not require lots of similar code in places that try to add state.\n\nThe first point (about nesting) seems fine. Definitely not trying to suggest that we should do things that are deeply nested. (That said, we may disagree about what is deeply nested; that isn't defined here. Other comments later imply that builders cause deeply nested code, but in my experience builders are pretty good, as shown in the code I cited earlier.)\nThe second point seems to straight up be a requirement that we not have verbosity. But then you've explained several times that this is not about verbosity.\nThe next statement that the OP makes that's describing a problem is:\n\nReusing a State logic across multiple StatefulWidget is very difficult, as soon as that logic relies on multiple life-cycles.\n\nHonestly I don't really know what this means. \"Difficult\" to me usually means that something involves a lot of complicated logic that is hard to understand, but allocating, disposing, and reacting to life-cycle events is very simple. The next statement that gives a problem (here I'm skipping the example which is explicitly described as \"not complex\" and therefore presumably not a description of the problem) is:\n\nThe problem starts when we want to scale that approach.\n\nThis suggested to me that by \"very difficult\" you meant \"very verbose\" and that the difficulty came from there being a lot of occurrences of similar code, since the only difference between the \"not complex\" example you give and the \"very difficult\" result of scaling the example is literally just that the same code happens many times (i.e. verbosity, boilerplate code).\nThis is further supported by the next statement that describes a problem:\n\nCopy-pasting this logic everywhere \"works\", but creates a weakness in our code:\n\nit can be easy to forget to rewrite one of the steps (like forgetting to call dispose)\n\n\nSo presumably it's very difficult because the verbosity makes it easy to make a mistake when copy and pasting the code? But again, when I tried to address this problem, which I would describe as \"verbosity\", you said the problem isn't verbosity.\n\n\nit adds a lot of noise in the code\n\n\nAgain this sounds like just saying verbosity/boilerplate to me, but again you've explained that it isn't that.\nThe rest of the OP is just describing solutions that you don't like, so it's presumably not describing the problem.\nDoes this explain how the OP fails to explain the problem? Everything in the OP that actually describes a problem seems to be describing verbosity, but every time I suggest that that is the problem, you say it isn't and that there is another problem.",
                "createdAt": "2020-08-02T05:58:56Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I think the misunderstanding boils down to the word meaning.\nFor example:\n\n\nit adds a lot of noise in the code\n\nAgain this sounds like just saying verbosity/boilerplate to me, but again you've explained that it isn't that.\n\nThis point isn't about the number of controller.dispose(), but the value that these lines of code bring to the reader.\nThat line should always be there and is always the same. As such, its value for the reader is almost null.\nWhat matters is not the presence of this line, but its absence.\nThe problem is, the more of such controller.dispose() we have, the more likely we are to miss an actual issue in our dispose method.\nIf we have 1 controller and 0 dispose, it's easy to catch\nIf we have 100 controllers and 99 dispose, finding the one missing is difficult.\nThen we have:\n\nSo presumably it's very difficult because the verbosity makes it easy to make a mistake when copy and pasting the code? But again, when I tried to address this problem, which I would describe as \"verbosity\", you said the problem isn't verbosity.\n\nAs I've mentioned in the previous point, not all lines of codes are equal.\nIf we compare:\n+ T state;\n\n@override\nvoid initState() {\n  super.initState();\n+  state = widget.valueNotifier.value;\n+  widget.valueNotifier.addListener(_listener);\n}\n\n+ void _listener() => seState(() => state = widget.valueNotifier.value);\n\nvoid dispose() {\n+ widget.valueNotifier.removeListener(_listener);\n  super.dispose();\n}\nvs:\n+ ValueListenableBuilder<T>(\n+   valueListenable: widget.valueNotifier,  \n+   builder: (context, value, child) {\n\n+    },\n+ );\nthen both of these snippets have the same number of lines and do the same thing.\nBut ValueListenableBuilder is preferable.\nThe reason for that is, it's not the number of lines that matters, but what these lines are.\nThe first snippet has:\n\n1 property declaration\n1 method declaration\n1 assignment\n2 method calls\nall of which are spread across 2 different life-cycles. 3 if we include build\n\nThe second snippet has:\n\n1 class instantiation\n1 anonymous function\nno life-cycle. 1 if we include build\n\nWhich makes the ValueListenableBuilder simpler.\nThere is also what these lines do not say:\nValueListenableBuilder handles valueListenable changing over time.\nEven in the scenario where widget.valueNotifier does not change over time as we speak, it doesn't hurt.\nOne day, that statement may change. In which case, ValueListenableBuilder gracefully handles the new behavior, whereas, with the first snippet, we now have a bug.\nSo not only is ValueListenableBuilder simpler, but it is also more resilient to changes in the code \u2013 for the exact same number of lines.\n\nWith that, I think we can both agree that ValueListenableBuilder is preferable.\nThe question is then, \"Why not have an equivalent to ValueListenableBuilder for every reusable state logic?\"\nFor example, instead of:\nfinal controller = TextEditingController(text: 'hello world');\n...\ncontroller.dispose();\nwe would have:\nTextEditingControllerBuilder(\n  initialText: 'hello world',\n  builder: (context, controller) {\n\n  },\n);\nwith the added benefit that changes to initialText can be hot-reloaded.\nThis example may be a bit trivial, but we could use this principle for slightly more advanced reusable state logics (like your ModeratorBuilder).\nThis is \"fine\" in small snippets. But it causes some problems as we want to scale the approach:\n\nBuilders circle back to the  \"too much noise\" issue.\n\nFor example, I've seen some people manage their model this way:\nclass User {\n  final ValueNotifier<String> name;\n  final ValueNotifier<int> age;\n  final ValueNotifier<Gender> gender;\n}\nBut then, a widget may want to listen to both name, age and gender all at once.\nWhich means we would have to do:\nreturn ValueListenableBuilder<String>(\n  valueListenable: user.name,\n  builder: (context, userName, _) {\n    return ValueListenableBuilder<int>(\n      valueListenable: user.age,\n      builder: (context, userAge, _) {\n        return ValueListenableBuilder<Gender>(\n          valueListenable: user.gender,\n          builder: (context, userGender, _) {\n            return Text('$userGender. $userName ($userAge)');\n          },\n        );\n      },\n    );\n  },\n);\nThis is obviously not ideal. We removed the pollution inside initState/dispose to pollute our build method.\n(let's ignore Listenable.merge for the sake of the example. It doesn't matter here; it's more about the composition)\nIf we used Builders extensively, it's easy to see ourselves in this exact scenario \u2013 and with no equivalent to Listenable.merge (not that I like this constructor, to begin with \ud83d\ude1b )\n\n\nWriting a custom builder is tedious\nThere is no easy solution to create a Builder. No refactoring tool will help us here \u2013 we can't just \"extract as Builder\".\nFurthermore, it isn't necessarily intuitive. Making a custom Builder isn't the first thing that people will think about \u2013 especially as many will be against the boilerplate (although I'm not).\nPeople are more likely to bake a custom state-management solution and potentially end-up with bad code.\n\n\nManipulating a tree of Builders is tedious\nSay we wanted to remove a ValueListenableBuilder in our previous example or add a new one, that's not easy.\nWe can spend a few minutes stuck counting () and {} to understand why our code doesn't compile.\n\n\n\nHooks are there to solve the Builder issues we've just mentioned.\nIf we refactor the previous example to hooks, we would have:\nfinal userName = useValueListenable(user.name);\nfinal useAge = useValueListenable(user.age);\nfinal useGender = useValueListenable(user.gender);\n\nreturn Text('$userGender. $userName ($userAge)');\nIt is identical to the previous behavior, but the code now has a linear indentation.\nWhich means:\n\nthe code drastically more readable\nit is easier to edit. We don't need to fear (){}; to add a new line.\n\nThat's one of the main provider is liked. It removed a lot of nesting by introducing MultiProvider.\nSimilarly, as opposed to the initState/dispose approach, we benefit from hot-reload.\nIf we added a new useValueListenable, the change would be applied immediately.\nAnd of course, we still have the ability to extract reusable primitives:\nString useUserLabel(User user) {\n  final userName = useValueListenable(user.name);\n  final useAge = useValueListenable(user.age);\n  final useGender = useValueListenable(user.gender);\n\n  return '$userGender. $userName ($userAge)';\n}\n\nWidget build(context) {\n  final label = useUserLabel(user);\n  return Text(label);\n}\nand such change can be automated with extract as function, which would work in most scenarios.\n\nDoes that answer your question?",
                "createdAt": "2020-08-02T08:48:48Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Sure. The problem with something like that though is that it just doesn't have enough information to actually do the right thing. For example:\nWidget build(context) {\n  if (random.nextBool())\n    final title = useLabel(title);\n  final label = useLabel(name);\n  return Text(label);\n}\n...would end up being buggy in really confusing ways.\nYou can work around that with compiler magic (that's how Compose does it) but for Flutter that violates some of our fundamental design decisions. You can work around it with keys, but then performance suffers greatly (since variable lookup ends up involving map lookups, hashes, and so on), which for Flutter violates some of our fundamental design goals.\nThe Property solution I suggested earlier, or something derived from that, seems like it avoids the compiler magic while still achieving the goals you've described of having all the code in one place. I don't really understand why it wouldn't work for this. (Obviously it would be extended to also hook into didChangeDependencies and so on to be a full solution.) (We wouldn't put this into the base framework because it would violate our performance requirements.)",
                "createdAt": "2020-08-02T19:31:03Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Precisely due to the bugs that might occur, as you say, is the reason why hooks should not be called conditionally. See the Rules of Hooks document from ReactJS for more details. The basic gist is that since in their implementation they are tracked by call order, using them conditionally will break that call order and thus not allow them to be tracked correctly. To properly use the hook, you call them at the top level in build without any conditional logic. In the JS version, you get back\nconst [title, setTitle] = useLabel(\"title\");\nThe Dart equivalent can be similar, it is only longer due to not having unpacking like JS does:\nvar titleHook = useLabel(\"title\");\nString title = titleHook.property;\nFunction setTitle = titleHook.setter;\nIf you want conditional logic, you can then decide to use title in the build method after having called them at the top level, because now the call order is still preserved.  Many of these issues you raise have been explained in the hooks document I linked above.",
                "createdAt": "2020-08-02T19:44:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Sure. And you can do that in a package. I'm just saying that that kind of requirement would violate our design philosophy, which is why we wouldn't add that to Flutter the framework. (Specifically, we optimize for readability and debuggability; having code that looks like it works but, because of a conditional (which might not be obvious in the code) sometimes doesn't work, is not something we want to encourage or enable in the core framework.)",
                "createdAt": "2020-08-02T19:55:45Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The debugging / conditional behavior is not an issue. That's why an analyzer plugin is important. Such a plugin would:\n\nwarn if a function uses a hook without being named useMyFunction\nwarn if a hook is used conditionally\nwarn if a hook is used in a loop/callback.\n\nThis covers all the potential mistakes. React proved that this is a feasible thing.\nThen we are left with the benefits:\n\nmore readable code (as shown previously)\nbetter hot-reload\nmore reusable/composable code\nmore flexible \u2013 we can easily make computed states.\n\nAbout computed states, hooks are quite powerful to cache the instance of an object. This can be used to rebuild a widget only when its parameter changes.\nFor example, we can have:\nclass Example extends HookWidget {\n  final int userId;\n\n  Widget build(context) {\n    // Calls fetchUser whenever userId changes\n    // It is the equivalent to both initState and didUpdateWidget\n    final future = useMemo1(() => fetchUser(userId), userId);\n\n    final snapshot = useFuture(future);\n    if (!snapshot.hasData)\n      return Text('loading');\n    return Text(snapshot.data.name);\n  }  \n}\nSuch useMemo hook allows easy performance optimizations and handling both init + update declaratively, which avoids bugs too.\nThis is something that the Property / context.onDispose  proposal miss.\nThey are difficult to use for declarative states without tightly coupling the logic to a life-cycle or complexifying the code with ValueNotifier.\nMore onto why the ValueGetter proposal is not practical:\nWe may want to refactor:\nfinal int userId;\n\nWidget build(context) {\n  final future = useMemo1(() => fetchUser(userId), userId);\ninto:\nWidget build(context) {\n  final userId = Model.of(context).userId;\n  final future = useMemo1(() => fetchUser(userId), userId);\nWith hooks, this change works flawlessly, as useMemo isn't tied to any life-cycle.\nBut with Property + ValueGetter, we would have to change the implementation of the Property to make this work \u2013 which is undesired as the Property code may be reused in multiple places. So we lost reusability once again.\nFWIW this snippet is equivalent to:\nclass Example extends StatefulWidget {\n  final int userId;\n  @override\n  _ExampleState createState() => _ExampleState();\n}\n\nclass _ExampleState extends State<Example> {\n  Future<User> future;\n\n  @override\n  void initState() {\n    super.initState();\n    future = fetchUser(widget.userId);\n  }\n\n  @override\n  void didUpdateWidget(Example oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (oldWidget.userId != widget.userId) {\n      future = fetchUser(widget.userId);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<User>(\n      future: future,\n      builder: (context, snapshot) {\n        if (!snapshot.hasData)\n          return Text('loading');\n        return Text(snapshot.data.name);\n      },\n    );\n  }\n}",
                "createdAt": "2020-08-02T20:17:51Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I suppose we'll have to find a solution that solves the same problems as @rrousselGit mentions but also has readability and debuggability in mind, then. Vue has its own implementation that might be more in line with what you're looking for, where conditionals or call order do not cause bugs like in React.\nMaybe a next step is to create a solution unique to Flutter that is this framework's version of hooks, given Flutter's constraints, just as Vue has made their version given Vue's constraints. I use React's hooks regularly and I would say that just having an analyzer plugin can sometimes be not enough, it should probably be more integrated into the language.",
                "createdAt": "2020-08-02T20:24:21Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "In any case, I don't think we will ever reach a consensus. It sounds like we disagree even on what is readable\nAs a reminder, I'm sharing this only because I know that the community has some issues with this problem. I personally do not mind if Flutter does nothing about this (although I find this kind of sad), as long as we have:\n\na proper analyzer plugin system\nthe ability to use packages inside dartpad",
                "createdAt": "2020-08-02T20:35:36Z"
            },
            {
                "author": "Hixie",
                "bodyText": "If you want to pursue the hooks plugin, which I strongly encourage, but are running into some problems, then I recommend filing issues for those problems, and filing PRs to fix those issues. We are more than happy to work with you on that.\nHere's a new version of the earlier Property idea. It handles didUpdateWidget and disposal (and can easily be made to handle other such things like didChangeDependencies); it supports hot reload (you can change the code that registers the property and hot reload, and it'll do the right thing); it's type-safe without needing explicit types (relies on inference); it has everything in one place except the property declaration and usage, and performance should be reasonably good (though not quite as good as the more verbose ways of doing things).\nProperty/PropertyManager:\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/widgets.dart';\n\ntypedef InitStateCallback<T> = T Function(T oldValue);\ntypedef DidUpdateWidgetCallback<T, W extends StatefulWidget> = T Function(W oldWidget);\n\nclass Property<T, W extends StatefulWidget> {\n  Property({\n    T value,\n    this.initState,\n    this.didUpdateWidget,\n    this.dispose,\n  }) : _value = value;\n\n  T get value {\n    assert(_value != null);\n    return _value;\n  }\n  T _value;\n\n  final InitStateCallback<T> initState;\n  void _initState(Property<T, W> oldProperty) {\n    if (initState != null)\n      _value = initState(oldProperty?.value);\n    assert(_value != null);\n  }\n\n  final DidUpdateWidgetCallback<T, W> didUpdateWidget;\n  void _didUpdateWidget(StatefulWidget oldWidget) {\n    if (didUpdateWidget != null) {\n      final T newValue = didUpdateWidget(oldWidget);\n      if (newValue != null)\n        _value = newValue;\n    }\n  }\n\n  final ValueSetter<T> dispose;\n  void _dispose() {\n    if (dispose != null)\n      dispose(value);\n  }\n}\n\nmixin PropertyManager<W extends StatefulWidget> on State<W> {\n  final Set<Property<Object, W>> _properties = <Property<Object, W>>{};\n  bool _ready = false;\n\n  Property<T, W> register<T>(Property<T, W> oldProperty, Property<T, W> property) {\n    assert(_ready);\n    if (oldProperty != null) {\n      assert(_properties.contains(oldProperty));\n      _properties.remove(oldProperty);\n    }\n    assert(property._value == null);\n    property._initState(oldProperty);\n    _properties.add(property);\n    return property;\n  }\n\n  @override\n  void initState() {\n    super.initState();\n    _ready = true;\n    initProperties();\n  }\n\n  @override\n  void reassemble() {\n    super.reassemble();\n    initProperties();\n  }\n\n  @protected\n  @mustCallSuper\n  void initProperties() { }\n\n  @override\n  void didUpdateWidget(W oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    for (Property<Object, W> property in _properties)\n      property._didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void dispose() {\n    _ready = false;\n    for (Property<Object, W> property in _properties)\n      property._dispose();\n    super.dispose();\n  }\n}\nHere's how you'd use it:\nimport 'dart:async';\n\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'properties.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Example(userId: 1),\n    );\n  }\n}\n\nclass User {\n  User(this.name);\n  final String name;\n}\n\nFuture<User> fetchUser(int userId) async {\n  await Future.delayed(const Duration(seconds: 2));\n  return User('user$userId');\n}\n\nclass Example extends StatefulWidget {\n  Example({ Key key, this.userId }): super(key: key);\n\n  final int userId;\n\n  @override\n  _ExampleState createState() => _ExampleState();\n}\n\nclass _ExampleState extends State<Example> with PropertyManager {\n  Property future;\n\n  @override\n  void initProperties() {\n    super.initProperties();\n    future = register(future, Property(\n      initState: (_) => fetchUser(widget.userId),\n      didUpdateWidget: (oldWidget) {\n        if (oldWidget.userId != widget.userId)\n          return fetchUser(widget.userId);\n      }\n    ));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<User>(\n      future: future.value,\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) return Text('loading');\n        return Text(snapshot.data.name);\n      },\n    );\n  }\n}\nFor convenience you could create prepared Property subclasses for things like AnimationControllers and so on,\nYou can probably make a version of this that would work in State.build methods too...",
                "createdAt": "2020-08-02T23:15:55Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "I share some of the doubts that @Hixie brings to the table. On the other side I see the clear advantages that Hooks have and it seems quite a number of developers like it.\nMy problem with the package approach that @timsneath proposed is that code using Hooks looks dramatically different from code without. If they don't get them into the official canon we will end up with Flutter code that isn't readable for people just following the Flutter canon.\nIf packages start to implement things that should be the responsebility of the framework we will get a lot of different Flutter dialects which makes learning new code bases difficult. So for me I probably would start using hooks the moment it get part of Flutter.\nIt's much like my current view on the freezed package. I love the functionality but unless Unions and data classes arent part of Dart I don't want to include them in my code base because it would make it more difficult for people to read my code.",
                "createdAt": "2020-08-05T16:34:34Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@escamoteur Just so I understand, are you suggesting that we fundamentally change how widgets work? Or are you suggesting that there should be some specific new abilities? Given how things like Hooks and the Property proposal above are possible without any changes to the core framework it's not clear to me what you would actually like changed.",
                "createdAt": "2020-08-05T17:49:08Z"
            },
            {
                "author": "timsneath",
                "bodyText": "It's orthogonal from the conversation about any proposed change itself, but I think what I've heard from @escamoteur, @rrousselGit and others both here and elsewhere is that being in the framework is perceived as an important way to establish the legitimacy of a particular approach. Correct me if you disagree.\nI understand that line of thinking -- since there's a lot that comes out of being in the framework (e.g. DartPad doesn't support third-party packages today, some customers are leery about how many packages they depend on after being burned with NPM, it feels more 'official', it is guaranteed to move forward with changes like null-safety).\nBut there are also significant costs of being included: in particular, it ossifies an approach and an API. That's why we both hold a very high bar to what we add, particularly when there's not unanimous agreement (c.f. state management), where there's the likelihood of evolution, or where we can as easily add something as a package.\nI wonder if we need to document our package-first philosophy, but again, where it goes is separate from a discussion about what we might want to change to improve state logic reuse.",
                "createdAt": "2020-08-05T18:03:42Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Our package policy is documented here: https://github.com/flutter/flutter/wiki/Style-guide-for-Flutter-repo#deciding-where-to-put-code",
                "createdAt": "2020-08-05T18:11:38Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I fully understand the package-first approach and agree that it is an important thing.\nBut I also believe that some problems need to be solved in the core, not by packages.\nThat is why I am not arguing that provider should be merged in Flutter, but also believe that this issue describes a problem that Flutter should solve natively (not necessarily with hooks of course).\nWith Provider, Flutter ships a built-in primitive to solve this sort of problem: InheritedWidgets.\nProvider only adds an opinionated layer on the top to make it \"\"nicer\"\".\nHooks are different. They are the primitive. They are an unopinionated low-level solution to a specific problem: Reusing logic across multiple states.\nThey aren't the final product, but something that people are expected to use to build custom packages (like I did with hooks_riverpod)",
                "createdAt": "2020-08-05T18:17:38Z"
            },
            {
                "author": "Hixie",
                "bodyText": "It would be helpful for me (in terms of understanding the desires here, and the needs that hooks meets and so on) if someone could provide a detailed review of how the Property approach I doodled above above compares to hooks. (My goal with the Property idea is very much to layer opinion on top of the framework to solve the problem of how to reuse logic across multiple states.)",
                "createdAt": "2020-08-05T19:14:07Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I think the Property proposal fails to solve a key goal of this issue: State logic should not care about where the parameters are coming from and in which situation they are updating.\nThis proposal increases readability to some extent by regrouping all the logic in one place; but it fails to solve the reusability issue\nMore specifically, we cannot extract:\nProperty(\n  initState: (_) => fetchUser(widget.userId),\n  didUpdateWidget: (oldWidget) {\n    if (oldWidget.userId != widget.userId)\n      return fetchUser(widget.userId);\n  }\n)\nout of _ExampleState and reuse it in a different widget, as the logic is bound to Example and initState+didUpdateWidget",
                "createdAt": "2020-08-05T19:28:58Z"
            },
            {
                "author": "Hixie",
                "bodyText": "What would it look like with hooks?",
                "createdAt": "2020-08-05T19:38:27Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I agree with @timsneath after having seen something similar in the Rust community. It is very difficult to extract something out of the core once it's out in. The BLoC pattern was specified before provider came along but now provider is the recommended version. Perhaps flutter_hooks can be the \"blessed\" version in the same way. I say this because in the future there might be improvements over hooks that people come up with. React, having had hooks now, can't really change them or get out of them. They must support them, much as they do class components, essentially forever, since they are in the core. Therefore, I agree with the package philosophy.\nThe problem seems to be that adoption will be low and people will use whatever suits them. This can be solved as I say by recommending people to use flutter_hooks. This also might not be a large problem if we analogously look at how many state management solutions there are, even if many people use provider. I also have experienced some problems and \"gotchas\" wit hooks in other frameworks that should be addressed in order to create a superior solution to composable and reusable life cycle logic.",
                "createdAt": "2020-08-05T19:39:11Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "What would it look like with hooks?\n\nWithout using any primitive hooks shipped by React/flutter_hooks, we could have:\nclass FetchUser extends Hook<AsyncSnapshot<User>> {\n  const FetchUser(this.userId);\n  final int userId;\n\n  @override\n  _FetchUserState createState() => _FetchUserState();\n}\n\nclass _FetchUserState extends HookState<AsyncSnapshot<User>, FetchUser> {\n  Future<User> userFuture;\n\n  @override\n  void initHook() {\n    userFuture = fetchUser(hook.userId);\n  }  \n\n  void didUpdateHook(FetchUser oldHook) {\n    if (oldHook.userId != hook.userId)\n      userFuture = fetchUser(hook.userId);\n  }\n\n\n  @override\n  User build() {\n    return useFuture(userFuture);\n  }\n}\nThen used:\nclass Example extends HookWidget {\n  const Example({Key key, this.userId}) : super(key: key);\n\n  final int userId;\n\n  @override\n  Widget build(BuildContext context) {\n    AsyncSnapshot<User> user = use(FetchUser(userId));\n\n    if (!user.hasData)\n      return CircularProgressIndicator();\n    return Text(user.data.name);\n  }\n}\nIn this situation, the logic is completely independent from Example and the life-cycles of a StatefulWidget.\nSo we could reuse it in a different widget that manages its userId differently. Maybe that other widget will be a StatefulWidget that manages its userId internally. Maybe it will obtain the userId from an InheritedWidget instead.\nThis syntax should make it obvious that hooks are like independent State objects with their own life-cycles.",
                "createdAt": "2020-08-05T19:54:34Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "As a side-note, one drawback of the package-first approach is: Packages authors are less likely to publish packages relying on hooks to solve problems.\nFor example, one common problem that Provider users faced is, they want to automatically dispose of the state of a provider when it is no longer used.\nThe issue is, Provider users are also quite fond of the context.watch/context.select syntax, in opposition to the verbose Consumer(builder: ...)/Selector(builder:...) syntax.\nBut we cannot have both this nice syntax and solve the previously mentioned problem without hooks (or #33213, which was rejected).\nThe problem is:\nProvider cannot depend on flutter_hooks to solve this problem.\nDue to how popular Provider is, it would be unreasonable to depend on hooks.\nSo in the end, I opted for:\n\nforking Provider (under the codename of Riverpod)\nvoluntarily lose the \"Flutter favorite\"/Google recommendation as a consequence\nsolve this problem (and some more)\nadd a dependency on hooks to offer a syntax that people who enjoy context.watch would like.\n\nI am quite satisfied with what I came up with, as I think it brings a significant improvement over Provider (It makes InheritedWidgets compile-safe).\nBut the way to get there left me a bad aftertaste.",
                "createdAt": "2020-08-05T20:15:44Z"
            },
            {
                "author": "Hixie",
                "bodyText": "There's basically three differences as far as I can tell between the hooks version and the Property version:\n\nThe Hooks version is a lot more backing code\nThe Property version is a lot more boilerplate code\nThe Hooks version has the problem in build methods where if you call the hooks in the wrong order things go bad and there's not really any way to immediately see that from the code.\n\nIs the boilerplate code really that big of a deal? I mean, you can easily reuse the Property now, the code is all in one place. So it really is only a verbosity argument now.\nI think a good solution should not depend on other packages knowing about it. It should not matter whether it's in the framework or not. People not using it should not be a problem. If people not using it is a problem then that, IMHO, is a red flag for the API.",
                "createdAt": "2020-08-05T20:51:29Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I mean, you can easily reuse the Property now, the code is all in one place.\n\nThe code being in one place does not mean it is reusable.\nWould you mind making a secondary widget that reuses the code currently located inside _ExampleState in a different widget?\nWith a twist: that new widget should manage its userID internally inside its State, such that we have:\nclass _WhateverState extends State with PropertyManager {\n  // may change over time after some setState calls\n  int userId;\n}",
                "createdAt": "2020-08-05T21:04:46Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "If people not using it is a problem then that, IMHO, is a red flag for the API.\n\nPeople not using something because it isn't official doesn't mean that the API is bad.\nIt is totally legitimate to not want to add extra dependencies because this is extra work to maintain (due to versioning, license, depreciation and other things).\nFrom what I remember, Flutter has a requirement to have as few dependencies as possible.\nEven with Provider itself, which is widely accepted and almost official now, I have seen people say \"I prefer to use the built-in InheritedWidgets to avoid adding a dependency\".",
                "createdAt": "2020-08-05T21:07:03Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Would you mind making a secondary widget that reuses the code currently located inside _ExampleState in a different widget?\n\nThe code in question is all about getting a userId from a widget and passing it to a fetchUser method. Code for managing the userId changing locally in the same object would be different. That seems to be fine? I'm not really sure what problem you're trying to solve here.\nFor the record I would not use Property to do what you describe, it would just look like:\nclass Example extends StatefulWidget {\n  Example({ Key key }): super(key: key);\n\n  @override\n  _ExampleState createState() => _ExampleState();\n}\n\nclass _ExampleState extends State<Example> with PropertyManager {\n  int _userId;\n  Future<User> _future;\n\n  void _setUserId(int newId) {\n    if (newId == _userId)\n      return;\n    setState(() {\n      _future = fetchUser(_userId);\n    });\n  }\n\n  // ...code that uses _setUserId...\n\n  @override\n  Widget build(BuildContext context) {\n    return FutureBuilder<User>(\n      future: _future.value,\n      builder: (context, snapshot) {\n        if (!snapshot.hasData) return Text('loading');\n        return Text(snapshot.data.name);\n      },\n    );\n  }\n}\n\nPeople not using something because it isn't official doesn't mean that the API is bad.\n\nAgreed.\nThe fact that people don't use something itself being bad is what means the API is bad. When you say \"Packages authors are less likely to publish packages relying on hooks to solve problems\", that indicates that hooks depends on other people using it to be useful to you. A good API, IMHO, does not become bad if nobody else adopts it; it should hold up even if nobody else knows about it. For example, the Property example above does not depend on other packages using it to itself be useful.\n\nEven with Provider itself, which is widely accepted and almost official now, I have seen people say \"I prefer to use the built-in InheritedWidgets to avoid adding a dependency\".\n\nWhat's wrong with people preferring to use InheritedWidget? I don't want to force a solution on people. They should use what they want to use. You're literally describing a non-problem. The solution to people preferring to use InheritedWidget is to get out of their way and let them use InheritedWidget.",
                "createdAt": "2020-08-05T21:20:32Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": ". A good API, IMHO, does not become bad if nobody else adopts it; it should hold up even if nobody else knows about it. For example, the Property example above does not depend on other packages using it to itself be useful.\n\nThere is a misunderstanding.\nThe problem is not about people not using hooks in general.\nIt's about Provider not being able to use hooks to fix problems because hooks are not official whereas Provider is.\n\n\nCode for managing the userId changing locally in the same object would be different. That seems to be fine? I'm not really sure what problem you're trying to solve here.\nFor the record I would not use Property to do what you describe, it would just look like:\n\nThis doesn't answer the question. I asked this specifically to compare code reusability between hooks vs Property.\nWith hooks, we could reuse FetchUser:\nclass _WhateverState extends State with PropertyManager {\n  // may change over time after some setState calls\n  int userId;\n\n  Widget build(context) {\n    final user = use(FetchUser(userId));\n  }\n}",
                "createdAt": "2020-08-05T21:34:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "With hooks, we could reuse FetchUser:\n\nI don't understand why this is desirable. FetchUser does not have any interesting code, it's just an adapter from Hooks to the fetchUser function. Why not just call fetchUser directly? The code that you're reusing isn't interesting code.\n\nIt's about Provider not being able to use hooks to fix problems because hooks are not official whereas Provider is.\n\nIMHO a good solution to the code reuse problem would not need to be adopted by Provider at all. They would be entirely orthogonal concepts. This is something the Flutter style guide talks about under the heading \"avoid complecting\".",
                "createdAt": "2020-08-05T21:49:44Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I don't understand why this is desirable. FetchUser does not have any interesting code, it's just an adapter from Hooks to the fetchUser function. Why not just call fetchUser directly? The code that you're reusing isn't interesting code.\n\nIt doesn't matter. We are trying to demonstrate code-reusability. fetchUser could be anything \u2013 including ChangeNotifier.addListener for example.\nWe could have an alternate implementation that does not depend on fetchUser, and simply provide an API to do implicit data-fetching:\nint userId;\n\nWidget build(context) {\n  AsyncSnapshot<User> user = use(ImplicitFetcher<User>(userId, fetch: () => fetchUser(userId));\n}\n\nIMHO a good solution to the code reuse problem would not need to be adopted by Provider at all. They would be entirely orthogonal concepts. This is something the Flutter style guide talks about under the heading \"avoid complecting\".\n\nThat's why I mentioned that hooks are a primitive\nAs a metaphor:\npackage:animations depends on Animation. But that is not a problem, because this is core primitive.\nIt would be a different matter if instead package:animations was using a fork of Animation maintained by the community",
                "createdAt": "2020-08-05T22:08:41Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "@escamoteur Just so I understand, are you suggesting that we fundamentally change how widgets work? Or are you suggesting that there should be some specific new abilities? Given how things like Hooks and the Property proposal above are possible without any changes to the core framework it's not clear to me what you would actually like changed.\n\n@Hixie no my point is that if hooks gets even more popular we should think of including them in the framework and teach them to all so that we keep a common understanding how Flutter code looks and behaves like.\nI very much share your concerns but on the other side a Widget with hooks looks really elegant.\nIt wouldn't prohibit to do things as before.",
                "createdAt": "2020-08-05T22:21:10Z"
            },
            {
                "author": "pedromassango",
                "bodyText": "It wouldn't prohibit to do things as before.\n\nI think it will, I don't think it will be a good idea for the Flutter team to say \"hey we now recommend flutter hooks but you still can do things as before\" people will get confused about this. Also if Flutter team recommends hooks in the future then they also will need to stop publishing the actual flutter code as examples.\nPeople always follow the \"official way\" of doing things and I thing there should not have two official ways of using Flutter.",
                "createdAt": "2020-08-05T22:32:09Z"
            },
            {
                "author": "Hixie",
                "bodyText": "It doesn't matter. We are trying to demonstrate code-reusability. fetchUser could be anything \u2013 including ChangeNotifier.addListener for example.\n\nSure. That's what functions are good for: abstracting out code. But we already have functions. The Property code above, and the _setUserId code above, shows that you can bring all the code that calls those functions to one place without needing any particular help from the framework. Why do we need Hooks to wrap the calls to those functions?\n\n\nIMHO a good solution to the code reuse problem would not need to be adopted by Provider at all. They would be entirely orthogonal concepts. This is something the Flutter style guide talks about under the heading \"avoid complecting\".\n\nThat's why I mentioned that hooks are a primitive\n\nThey are a convenience, they're not a primitive. If they were a primitive, the question \"what is the problem\" would be much easier to answer. You'd say \"here is a thing I want to do and I can't do it\".\n\nAs a metaphor:\npackage:animations depends on Animation. But that is not a problem, because this is core primitive.\nIt would be a different matter if instead package:animations was using a fork of Animation maintained by the community\n\nThe Animation class hierarchy does something fundamental: it introduces tickers and a way to control them and subscribe to them. Without the Animation class hierarchy, you have to invent something like the Animation class hierarchy to do animations. (Ideally something better. It's not our best work.) Hooks doesn't introduce a new fundamental feature. It just provides a way to write the same code differently. It might be that that code is simpler, or factored differently than it would otherwise be, but it's not a primitive. You don't need a Hooks-like framework to write code that does the same thing that Hooks-using code does.\n\nFundamentally, I don't think the problem described in this issue is something the framework needs to fix. Different people will have very different needs for how to address it. There's lots of ways to fix it, we've discussed several in this bug already; some of the ways are very simple and can be written in a few minutes, so it's hardly a problem so difficult to solve that it provides value for us to own and maintain the solution. Each of the proposals has strengths and weaknesses; the weaknesses are in each case things that would be blockers for someone to use them. It's not even really clear that the everyone agrees that the problem needs fixing at all.",
                "createdAt": "2020-08-05T23:13:37Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Hooks are primitives\nHere's a thread from Dan: https://twitter.com/dan_abramov/status/1093698629708251136 explaining this. Some wordings differ, but the logic mostly applies to Flutter due to the similarity between React class Components and Flutter StatefulWidgets\nMore specifically, you could think of flutter_hooks as dynamic State mixins.\n\nIf they were a primitive, the question \"what is the problem\" would be much easier to answer. You'd say \"here is a thing I want to do and I can't do it\".\n\nIt is in the OP:\nIt is difficult to reuse State logic. We either end up with a complex and deeply nested build method or have to copy-paste the logic across multiple widgets.\nIt is neither possible to reuse such logic through mixins nor functions.\n\nIt might be that that code is simpler, or factored differently than it would otherwise be, but it's not a primitive. You don't need a Hooks-like framework to write code that does the same thing that Hooks-using code does.\n\nYou don't need classes to write a program. But classes allows you to structure your code and factorize it in a meaningful way.\nAnd classes are primitives.\nSame thing with mixins, which are primitives too\nHooks are the same thing.\n\nWhy do we need Hooks to wrap the calls to those functions?\n\nFor when we need to call this logic not in one place but in two places.",
                "createdAt": "2020-08-05T23:27:33Z"
            },
            {
                "author": "Hixie",
                "bodyText": "It is neither possible to reuse such logic through mixins nor functions.\n\nPlease give me a concrete example where this is the case. So far all the examples we've studied have been simple without hooks.",
                "createdAt": "2020-08-05T23:38:03Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "So far in this thread I haven't seen any other solution than @rrousselGit hooks that solve and make it easy to reuse and compose state logic.\nGranted I haven't been doing much dart and flutter lately so I might be missing things in the property solution code samples above but, are there any solutions? What are the options today that doesn't require copy paste instead of reuse?\nWhat are the answer to @rrousselGit question:\n\nWould you mind making a secondary widget that reuses the code currently located inside _ExampleState in a different widget?\nWith a twist: that new widget should manage its userID internally inside its State\n\nIf it's not possible to reuse such an easy state logic with the property solution above what are the other options?\nIs the answer simply that it shouldn't be easy reusable in flutter? Which is totally fine but a bit sad IMHO.\nBTW, Does SwiftUI do it in a new/other inspiring way? Or are they lacking the same state logic reusability aswell? Haven't used swiftui at all myself. Maybe it just too different?",
                "createdAt": "2020-08-06T01:05:42Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "All Builders, basically. Builders are the only way to reuse state at the moment.\nHooks makes Builders more readable and easier to create\n\nHere's a collection of custom hooks me or some clients made last month for different projects:\n\nuseQuery  \u2013 which is an equivalent of the ImplicitFetcher hook I gave previously but makes a GraphQL query instead.\nuseOnResume which gives a callback to perform custom action on AppLifecycleState.resumed without having to\ngo to the trouble of making a WidgetsBindingObserver\nuseDebouncedListener which listens to a listenable (usually TextField or ScrollController), but with a debounce on the listener\nuseAppLinkService which allows widgets to perform some logic on a custom event similar to AppLifecycleState.resumed but with business rules\nuseShrinkUIForKeyboard for smoothly handling the keyboard appearance. It returns a boolean that indicates whether the UI should adapt to the bottom padding or not (which is based on listening to a focusNode)\nuseFilter, which combines useDebouncedListener and useState (a primitive hook which declares a single property) to expose a filter for a search bar.\nuseImplicitlyAnimated<Int/Double/Color/...> \u2013 equivalent to TweenAnimationBuilder as a hook\n\nApps also use many low-level hooks for different logic.\nFor example, instead of:\nWhatever whatever;\n\ninitState() {\n  whatever = doSomething(widget.id);\n}\n\ndidUpdateWidget(oldWidget) {\n  if (oldWidget.id != widget.id)\n    whatever = doSomething(widget.id);\n}\nThey do:\nWidget build(context) {\n  final whatever = useUnaryEvent<Whatever, int>(widget.id, (int id) => doSomething(id));\n}\nThis avoids duplicate between initState/didUpdateWidget/didChangeDependencies.\nThey also use a lot of useProvider, from Riverpod which would otherwise have to be a StreamBuilder/ValueListenableBuilder\n\nThe important part is, widgets rarely use \"just one hook\".\nFor example, a widget may do\nclass ChatScreen extends HookWidget {\n  const ChatScreen({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final filter = useFilter(debounceDuration: const Duration(seconds: 2));\n    final userId = useProvider(authProvider).userId;\n    final chatId = useProvider(selectedChatProvider);\n    final chat = useQuery(ChatQuery(userId: userId, chatId: chatId, filter: filter.value));\n\n    return Column(\n      children: [\n        Searchbar(onChanged: (value) => filter.value = value),\n        Expanded(\n          child: ChatList(chat: chat),\n        ),\n      ],\n    );\n  }\n}\nIt's concise and very readable (assuming you have a basic knowledge of the API of course).\nAll the logic can be read from top to bottom \u2013 there is no jump from between methods to understand the code.\nAnd all hooks used here are reused in multiple places in the codebase\nIf we were to do the exact same thing without hooks, we would have:\nclass ChatScreen extends StatefulWidget {\n  const ChatScreen({Key key}) : super(key: key);\n\n  @override\n  _ChatScreenState createState() => _ChatScreenState();\n}\n\nclass _ChatScreenState extends State<ChatScreen> {\n  String filter;\n  Timer timer;\n\n  @override\n  void dispose() {\n    timer?.cancel();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Consumer<Auth>(\n      provider: authProvider,\n      builder: (context, auth, child) {\n        return Consumer<int>(\n          provider: selectedChatProvider,\n          builder: (context, chatId, child) {\n            return GraphQLBuilder<Chat>(\n              query: ChatQuery(\n                userId: auth.userId,\n                chatId: chatId,\n                filter: filter.value,\n              ),\n              builder: (context, chat, child) {\n                return Column(\n                  children: [\n                    Searchbar(\n                      onChanged: (value) {\n                        timer?.cancel();\n                        timer = Timer(const Duration(seconds: 2), () {\n                          filter = value;\n                        });\n                      },\n                    ),\n                    Expanded(\n                      child: ChatList(chat: chat),\n                    ),\n                  ],\n                );\n              },\n            );\n          },\n        );\n      },\n    );\n  }\n}\nThis is significantly less readable.\n\nWe have 10 levels of indentation \u2013 12 if we make a FilterBuilder to reuse the filter logic\nThe filter logic is not reusable as it stands.\n\nwe may forget to cancel the timer by mistake\n\n\nhalf of the build method is not useful for the reader. The Builders distracts us from what matters\nI lost a good 5 minutes trying to understand why the code doesn't compile because of a missing parenthesis",
                "createdAt": "2020-08-06T01:16:23Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "As a user of flutter_hooks myself, I'll contribute my opinion. Before using hooks I was happy with Flutter. I didn't see the need for something like it. After reading about it and watching a youtube video about it, I still wasn't convinced, it looked cool, but I needed some practice or examples to really motivate it. But then I noticed something. I was avoiding stateful widgets at all cost, there was just a lot of boilerplate involved, and skipping around the class trying to find things. Because of that I had moved most of my ephemeral state into a state management solution along with the rest of the app state, and just used stateless widgets. However, this causes the business logic to depend on Flutter quickly because of reliance on getting the Navigator, or BuildContext for accessing InheritedWidgets / Providers higher in the tree. Not saying it was a good state management approach, I know it was not. But I did anything I could do to not to have to worry about state management in the UI.\nAfter using hooks for a little while I found myself a lot more productive, a lot more happy using Flutter, putting ephemeral state in the right place (along with the UI) rather than with the app state.\nTo me, it is like a garbage collector for ephemeral state / controllers. I don't have to remember to dispose of all the subscriptions in the UI, although I'm still very conscious of the fact that this is what flutter_hooks does for me. It also makes it a ton easier to maintain & refactor my code. Speaking from writing ~10 apps in the past year for my graduate research and fun.\nLike others, I don't know exactly what the main motivation should be to include it in the Flutter SDK itself. However, here are two thoughts on that subject.\n\n\nOccasionally I'll make a hook to make it easier to use a package that has controllers that need to be initialized / disposed. (For example golden_layout, or zefyr). I believe that the other users using flutter_hooks would benefit from such a package. However, I can't seem to justify publishing a package that literally contains 1-3 functions. The alternative would be to create a kitchen-sink package that contains a lot of hooks for various packages that I use, I can then just use a git dependency, but then anyone using those other packages + flutter_hooks would have to depend on my git in order to benefit (which is less discoverable, and likely contains dependencies on packages they don't care about), or on a package that contains 3 functions or I publish a garden-sink package to pub.dev. All ideas seem ridiculous, and not very discoverable. The other users of flutter_hooks could easily copy and paste those functions into their code or try to figure out the logic themselves, but that totally misses the point of sharing code / packages. The functions would much better go into the original packages, and not in some 'extension package'. If flutter_hooks was part of the framework, or even just a package used or exported from the framework like characters, then the authors of the original package would much more likely accept a pull request for simple hook functions, and we won't have a mess of 1-3 function packages.\nIf flutter_hooks is not adopted by Flutter I foresee a bunch of 1-3 function packages cluttering up the pub.dev search results. The fact that these packages would be really small makes me really agree with @rrousselGit that this is a primitive. If the 1228 stars on the flutter_hooks repository isn't any indication of it solving the problems mentioned by @rrousselGit I don't know what is.\n\n\nI was watching a youtube video about contributing to the Flutter repo since I've been interested in seeing what I could do to help out. As I was watching, the person creating the video added in the new property fairly easily but very nearly forgot to take care of updating dispose, didUpdateWidget, and debugFillProperties. Seeing all of the complexities of a stateful widget again, and how easy it is to miss something made me distrust them again, and made me not as excited about contributing to the main Flutter repository. Not saying that it completely deterred me, I'm still interested in contributing, but it feels like I would be creating boilerplate code that is hard to maintain & review. It is not about the complexity of writing the code, but the complexity of reading the code and verifying that you've properly disposed and taken care of ephemeral state.\n\n\nSorry for the long-winded response, however, I've been looking at this issue from time to time, and am somewhat baffled by the response from the Flutter team. It seems like you have not taken the time to try an app both ways, and see the difference for yourself. I understand the desire to not maintain an additional dependency or integrate it too much into the framework. However, the core part of the flutter_hook framework is only 500ish lines of pretty well documented code. Again, sorry if this is tangential to the conversation & I hope I'm not offending anyone for giving my 2 cents and speaking up. I didn't speak up earlier because I felt @rrousselGit was making very good points and being clear.",
                "createdAt": "2020-08-06T02:14:11Z"
            },
            {
                "author": "jpohhhh",
                "bodyText": "Sorry for the long-winded response, however, I've been looking at this issue from time to time, and am somewhat baffled by the response from the Flutter team. It seems like you have not taken the time to try an app both ways, and see the difference for yourself.\n\nTo be fair, this is an incredibly long thread and the founder of the framework has actively contributed several times daily, with several solutions, requested feedback on them, and engaged with them as well as worked to understand what's being requested. I honestly struggle to think of a clearer example of a maintainer being helpful.\nI wish this was slightly more patience with this issue - I don't understand hooks any more deeply after reading through this thread, other than they're another way of tying lifetime of Disposables to a State. I don't prefer that approach stylistically, and I feel there's something fundamentally flawed if the position is 'just take the time to write a whole new app in the paradigm, then you'll understand why it needs to be shoehorned into the framework!' - as the React engineer noted in this thread, it really wouldn't be advisable for Flutter, and benefits described in this thread are small compared to the cost of the kind of rewiring that means you need a whole new codebase to see the benefit.",
                "createdAt": "2020-08-06T06:23:33Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I honestly struggle to think of a clearer example of a maintainer being helpful.\n\nAgreed. I am grateful for Hixie to take the time to participate in this discussion.\n\ni  don't understand hooks any more deeply after reading through this thread\n\nTo be fair this issue is explicitly trying to avoid talking about hooks specifically.\nThis is more about trying to explain the problem rather than the solution\nDo you feel that it fails to do that?",
                "createdAt": "2020-08-06T06:34:59Z"
            },
            {
                "author": "Kounex",
                "bodyText": "I can feel both sides (@rrousselGit and @Hixie) here and wanted to leave some feedback from a (my) usage side / perspective of the Flutter framework.\nThe flutter_hooks approach does reduce the boilerplate quite a lot (just from the examples shown here since we can reuse such state configurations) and reduces complexity by not having to actively think about initialising / disposing ressources. Generally speaking it does a good job improving and supporting the development flow / speed... even though it does not fit in so nicely to the \"core\" of Flutter itself (subjectively).\nLike at least >95% of the code I write results in the build method to be declarative only, no local variables or calls outside the returned widget subtree, all the logic part is inside those state functions to initialise, assign and dispose ressources and add listeners (in my case MobX reactions) and such logical stuff. Since this is also the approach for the most part in Flutter itself, it feels very native. Doing so also gives you the developer the opportunity to always be explicit and open about what you do - it does force me to always convert such widgets to be a StatefulWidget and writing similar code in initState / dispose, but it also always results in writing down exactly what you intend to do directly in the Widget its being used. For me personally, like @Hixie already mentioned himself, it does not bother me in any way writing this kind of boilerplate code and allows me as the developer to decide how to handle it right on instead of relying on something like flutter_hooks to do it for me and resulting in not understanding why something might behave like it does. Extracting widgets in small bits also ensures that those kind of boilerplate is spot on the use case it's being used for. With flutter_hooks I would still need to think about what kind of states are worth being written to be a hook and therefore reused - different flavours might either result in various \"single\" use hooks or no hooks at all since I might not reuse configurations too often but tend to write more custom ones.\nDon't get me wrong, the approach in such hooks seems very nice and useful, but for me it feels like a very fundamental concept which changes the core concept of how to handle this. It feels very good as a package itself to give devs the opportunity to use this kind of approach if they are not happy with how to do it \"natively\", but making it part of the Flutter framework itself would, at least to be clean / unified, result in either rewriting big parts of Flutter to make use of this concept (a lot of work) or use it for future / selected stuff (which might be confusing to have such mixed approaches).\nIf it would be integrated into the Flutter framework itself and supported / actively used, I would obviously hop into this. Since I understand and even like the current approach and see the (possible) actions needed to implement this natively, I can understand the hesitation and / or why it should not be done and rather keep it as a package.",
                "createdAt": "2020-08-06T09:23:18Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "Correct me if I'm wrong but this thread is about the problems of reusing state logic in multiple widgets in a readable and composable way. Not hooks specifically. I believe this thread was opened because of wishes to have a discussion around the problem with an open approach to what the solution should be.\nHooks are mentioned though since they are one solution and I believe @rrousselGit has been using them here to try and explain the issue/problem that they solve (since they are a solution) so that another solution perhaps more native to flutter could be come up with and presented. So far to my knowledge there hasn't been any other solutions presented in this thread though that solves the reusability issues?\nWith that said, I don't know where the thread is going at the moment.\nI think the issue really exists. Or are we debating this?\nIf we are all agreeing that it's hard to reuse state logic in a composable way in multiple widgets with the core of flutter today, what solutions are there that could be a core solution? since builders really are (to quote)\n\nsignificantly less readable\n\nThe property solution doesn't seem to be so easily reusable or is that a wrong conclusion I've drawn(?) since there was no answer on how to use it to:\n\nmaking a secondary widget that reuses the code currently located inside _ExampleState in a different widget?\nWith a twist: that new widget should manage its userID internally inside its State",
                "createdAt": "2020-08-06T10:01:35Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "I'd be willing to help with a design document as @timsneath suggested. I think it is probably a better format to explain the problem with a few case study examples, as well as mention the different solutions and explore if we can find a solution that fits flutter and where it is at. I agree that the discussion in the issue is getting a little lost.",
                "createdAt": "2020-08-06T12:59:55Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'm quite skeptical about the idea of making a design document at the moment.\nIt is evident that for now, @Hixie is against solving this problem inside Flutter directly.\nTo me, it looks like we are disagreeing on the importance of the problem and the role of Google in solving that problem.\nIf both sides don't agree on this, I don't see how we can have a productive discussion on how to tackle this problem \u2013 whatever the solution might be.",
                "createdAt": "2020-08-06T14:58:13Z"
            },
            {
                "author": "rydmike",
                "bodyText": "This issue thread was a very interesting read and I am happy to see that the exchange of viewpoints has remained civil. I am however a bit surprised at the current impasse.\nWhen it comes to hooks, my view is that while Flutter does not necessarily need the specific hooks solution presented by @rrousselGit, nor is he saying that. Flutter does need a solution that delivers similar benefits as hooks does, for exactly all the reasons Remi and other proponents mention. @emanuel-lundman summarized the arguments well above and I agree with his views.\nIn lack of any other viable proposals offering the same capabilities and given the fact that hooks have a well proven track record in React, and that there is an existing solution that it could be based on for Flutter, I don\u2019t think it would be a bad choice to do so. I do not think the hooks concept, as a primitive that is also included in the Flutter SDK (or even lower), would take anything away from Flutter. In my opinion it would only enrich it and make it even easier to develop maintainable and delightful apps with Flutter.\nWhile the argument that hooks is available as a package for those that want to reap its benefits, is a valid point, I feel that it is not optimal for a primitive like hooks. Here is why.\nVery often when making even internally reusable packages, we debate if the package needs to be \u201cpure\u201d, in the sense that it may only depend on the Dart+Flutter SDK, or if we allow some other packages in it and if so, which ones. Even Provider is out for \u201cpure\u201d packages, but often allowed in for higher-level packages. For an app there is always also the same debate, which packages are OK and which are not. Provider is green, but something like Hooks is still a question mark as a package.\nIf a hooks like solution would be a part of the SDK, it would be an obvious choice to use the capabilities it offers. While I want to use Hooks and allow it in already now as a package, I\u2019m also concerned that it creates a Flutter code style and introduces concepts that might not be familiar to Flutter devs not using it. It feels a bit like a fork in the road if we go down this path without support in the SDK. For smaller personal projects, it is an easy choice to use Hooks. I recommend trying it together with Riverpod.\n(Our package conservatism comes I guess from being burned by packages and dependency mess on other package managers in the past, probably not unique.)\nI am not saying that hooks would be the only way to solve the current problem, even if it is the only working demonstrated solution so far. It could certainly be interesting and a valid approach to investigate options on a more generic level before committing to a solution. For that to happen there needs to be a recognition of that Flutter SDK currently has a flaw when it comes to easy re-usable state logic, which there despite elaborate explanations currently does not seem to be.",
                "createdAt": "2020-08-06T15:51:59Z"
            },
            {
                "author": "Hixie",
                "bodyText": "For me there are two main reasons to not just put Hooks into the core framework. The first is that the API has dangerous traps in it. Primarily, if you somehow end up calling the hooks in the wrong order then things will break. This seems like a fatal problem to me. I understand that with discipline and following the documentation you can avoid it but IMHO a good solution to this code reuse problem would not have that flaw.\nThe second is that there really should be no reason people can't just use Hooks (or another library) to solve this problem. Now, with Hooks specifically that doesn't work, as people have discussed, because writing the hook is burdensome enough that people wish that unrelated libraries would support hooks. But I think a good solution to this problem wouldn't need that. A good solution would stand alone and not need every other library to know about it.\nWe recently added RestorableProperties to the framework. It would be interesting to see if they could be leveraged here somehow...",
                "createdAt": "2020-08-06T17:10:31Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I agree @Hixie on the API having hidden problems that require an analyzer or linter to solve. I think we, as in whoever wants to participate, should look into various solutions, maybe via the design doc suggestion, or otherwise, on the problem of reusable life cycle management. Ideally it would be more Flutter-specific and leverage Flutter APIs while also solving the problems that the hook API does. I think the Vue version is a good model to start from, as I mentioned before, as it doesn't rely on hook call order. Is anyone else interested in investigating with me?",
                "createdAt": "2020-08-06T17:21:47Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "@Hixie but you do agree with the issue then that there ain't a good way to reuse state logic in a composable way between widgets? That's why you started to think about leveraging ResuableProperties somehow?\n\nFor me there are two main reasons to not just put Hooks into the core framework. The first is that the API has dangerous traps in it. Primarily, if you somehow end up calling the hooks in the wrong order then things will break. This seems like a fatal problem to me. I understand that with discipline and following the documentation you can avoid it but IMHO a good solution to this code reuse problem would not have that flaw.\n\nFrom having worked with hooks and worked with other people that use hooks this really ain't such a big issue IMHO. And not at all compared to all the big gains (big gains in dev speed, reusability, composability and easily readable code) they bring to the table.\nA hook is a hook, like a class is a class, not just a function, and you can't use it conditionally. You learn that fast. And your editor can help with this issue as well.\n\nThe second is that there really should be no reason people can't just use Hooks (or another library) to solve this problem. Now, with Hooks specifically that doesn't work, as people have discussed, because writing the hook is burdensome enough that people wish that unrelated libraries would support hooks. But I think a good solution to this problem wouldn't need that. A good solution would stand alone and not need every other library to know about it.\n\nWriting hooks aren't burdensome.\nIts still easier than the solutions available now IMHO (to use that phrase again \ud83d\ude09).\nMaybe I'm misinterpretating what you're writing. But I don't think anyone has said that?\nI read it like people really appreciate all the gains the hook solution brings to the table and wish they could use it everywhere. To reap all the benefits. Since a hook is reusable it would be great if third party developers could feel confident to code and ship their own hooks without requiring everyone to write their own wrappers. Reap the benifit of the reusability of the state logic.\nI think @rrousselGit and @gaearon have explained the primitive thing already. So I won't get into that.\nMaybe I don't get this statement because I can't see that it's a good summary of what people have written in this thread. I'm sorry.\nHope there is a way forward. But I think it's about time to at least agree this is an issue and either go forward coming up with alternate solutions that are better since hooks doesn't seem to be even on the table.\nOr just decide to skip fixing the issue in flutter core.\nWho decides path forward?\nWhat's the next step?",
                "createdAt": "2020-08-06T18:00:30Z"
            },
            {
                "author": "gaearon",
                "bodyText": "This seems like a fatal problem to me. I understand that with discipline and following the documentation you can avoid it but IMHO a good solution to this code reuse problem would not have that flaw.\n\nIn React, we solve this with a linter \u2014 static analysis. In our experience this flaw has not been important even in a large codebase. There are other problems that we might consider flaws, but I just wanted to point out that while the reliance on persistent call order is what people intuitively think will be a problem, the balance ends up pretty different in practice.\nThe real reason I'm writing this comment is that Flutter uses a compiled language though. \"Linting\" is not optional. So, if there is an alignment between the host language and the UI framework, it is definitely possible to enforce that \"conditional\" problem never comes up statically. But that only works when the UI framework can motivate language changes (e.g. Compose + Kotlin).",
                "createdAt": "2020-08-06T18:27:51Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@Hixie but you do agree with the issue then that there ain't a good way to reuse state logic in a composable way between widgets? That's why you started to think about leveraging ResuableProperties somehow?\n\nIt's certainly something people have brought up. It's not something I have a visceral experience with. It's not something I've felt was a problem when writing my own apps with Flutter. That doesn't mean that it's not a real problem for some people, though.\n\nSince a hook is reusable it would be great if third party developers could feel confident to code and ship their own hooks without requiring everyone to write their own wrappers\n\nMy point is that a good solution here wouldn't require anyone to write wrappers.\n\nWhat's the next step?\n\nThere are many next steps, for example:\n\nIf there are specific problems with Flutter that we haven't talked about here, file issues and describe the problems.\nIf you have a good idea for how to solve this issue's problem in ways that are better than Hooks, create a package that does so.\nIf there are things that can be done to improve Hooks, do so.\nIf there are problems with Flutter that prevent Hooks from reaching its full potential, file those as new issues.\netc.",
                "createdAt": "2020-08-06T18:43:29Z"
            },
            {
                "author": "intentionally-left-nil",
                "bodyText": "This issue thread was a very interesting read and I am happy to see that the exchange of viewpoints has remained civil.\n\nI'd hate to see what an uncivil thread looks like then. There's so very little empathy in this thread that it's been hard to read and follow from the sidelines",
                "createdAt": "2020-08-06T19:01:38Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "My point is that a good solution here wouldn't require anyone to write wrappers.\n\nYou don't have to write wrappers though. But you may want to reap the benefits and reusability stuff in your own code that you've grown acustomed to. You sure could still use the libraries as is. If you do write a hook wrapping stuff (if possible) it's probably not because you think it's burden but that it's better than the alternative.\nThat's actually a good reason and a reason mentioned why a solution to the issue in this thread would be great in core. A reusable composable state logic solution in core would mean that people wouldn't have to write wrappers since such reusable logic safely could be shipped in all packages without adding dependencies.",
                "createdAt": "2020-08-06T19:01:45Z"
            },
            {
                "author": "Hixie",
                "bodyText": "A reusable composable state logic solution in core would mean that people wouldn't have to write wrappers since such reusable logic safely could be shipped in all packages without adding dependencies.\n\nThe point I'm trying to make is that IMHO a good solution wouldn't require anyone to write that logic. There just wouldn't be any redundant logic to reuse. For example, looking at the \"fetchUser\" example from earlier, nobody would have to write a hook, or its equivalent, to call the \"fetchUser\" function, you would just call the \"fetchUser\" function directly. Similarly \"fetchUser\" wouldn't need to know anything about hooks (or whatever we use) and hooks (or whatever we use) wouldn't need to know anything about \"fetchUser\". All while keeping the logic that you do write trivial, like it is with hooks.",
                "createdAt": "2020-08-06T20:36:56Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The current restrictions are caused by the fact that hooks are a patch on the top of language limitations.\nIn some language, hooks are a language construct, such as:\nstate count = 0;\n\nreturn RaisedButton(\n  onPressed: () => count++,\n  child: Text('clicked $count times'),\n)\nThis would be a variant of async*/sync* functions, which can perserve some state across calls.\nIt doesn't require a non-conditional usage anymore since, as part of the language, we can differentiate each variable by their line number rather than their type.\nI would add that the hooks limitations are similar to the --track-widget-creation limitations.\nThis flag breaks the const constructor canonalisation for widgets. But that is not a problem as widgets are declarative.\nIn that sense, hooks are the same. The limitations don't really matter, as they are manipulated declaratively.\nWe won't obtain one very specific hook without reading the others.",
                "createdAt": "2020-08-06T21:08:57Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "Maybe the fetchuser example isn't the ideal one.\nBut the useStream, useAnimstion or useStreamCintroller make the Widget Tree much cleaner and prevents you from forgetting dispose or to take care of dudChangeDependencues.\nTherefore the current way has its on traps you can get caught in. So I guess the potential problem with the call sequence isn't a bigger one as those.\nI m not sure if I would start writing my own hooks, but having a collection of often needed ready to be use inside the framework would be nice.\nIt would just be an alternative way to deal with them.",
                "createdAt": "2020-08-06T21:23:44Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "@Hixie, really sorry for not being able to grasp what you're trying to describe, I blame that it's late in the evening here but probably it's just me \ud83d\ude33.. But in the good solution you describe, where would the state values, the state business logic and lifetime event logic that the solution to the problem wraps/encapsulates to easily be composable and shared between widgets reside? Could you elaborate a bit on what a good solution does and how you see it would ideally work?",
                "createdAt": "2020-08-06T21:36:45Z"
            },
            {
                "author": "filiph",
                "bodyText": "Just interjecting here a bit, seeing that there's mentions about civility of this discussion. I don't personally feel that anyone here is being uncivil.\nThat said, I think it's worth noting that this is a topic that people deeply care about, on all sides.\n\n@rrousselGit has been answering beginner questions about state management on StackOverflow and on the package:provider issue tracker for years now. I'm following only the latter of these firehoses, and I have nothing but respect for Remi's diligence and patience.\n@Hixie and others on the Flutter team care deeply about the API of Flutter, its stability, surface, maintainability, and readability. It's thanks to this that Flutter's developer experience is where it is today.\nFlutter developers care deeply about state management, because that's what they're doing a significant portion of their development time.\n\nIt's clear that all parties in this discussion have a good reason to argue for what they do. It's also understandable that it takes time to get the messages across.\nSo, I'd be happy if the discussion continued, either here or in some other form. If I can help in any way, like with a formal doc, just let me know.\nIf, on the other hand, people think the discussion here is getting out of hand, then let's pause and see if there's a better way to communicate.\n(Separately, I want to give a shout out to @gaearon for joining this discussion. React's experience in this respect is invaluable.)",
                "createdAt": "2020-08-06T22:58:25Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@emanuel-lundman\n\nBut in the good solution you describe, where would the state values, the state business logic and lifetime event logic that the solution to the problem wraps/encapsulates to easily be composable and shared between widgets reside? Could you elaborate a bit on what a good solution does and how you see it would ideally work?\n\nUnfortunately I can't elaborate because I don't know. :-)\n@escamoteur\n\nMaybe the fetchuser example isn't the ideal one.\nBut the useStream, useAnimstion or useStreamCintroller make the Widget Tree much cleaner and prevents you from forgetting dispose or to take care of dudChangeDependencues.\n\nOne of the difficulties in this issue has been a \"moving of the goalposts\" where a problem is described, then when it's analyzed, the problem is dismissed as not the real problem and a new problem is described, and so on. What might be really useful would be to come up with some canonical examples, e.g. a demo Flutter application that has a real example of the problem, one that isn't overly simplified for the sake of exposition. Then we could reimplement that using Hooks, and other proposals, and really evaluate them against each other in concrete terms. (I would do this myself except I don't really understand exactly what the problem is, so it's probably best if someone who advocates for Hooks would do it.)",
                "createdAt": "2020-08-06T23:03:28Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "What might be really useful would be to come up with some canonical examples, e.g. a demo Flutter application that has a real example of the problem, one that isn't overly simplified for the sake of exposition\n\nWhat do you think about the example I gave here? #51752 (comment)\nThis is a real-world code-snippet.",
                "createdAt": "2020-08-06T23:05:57Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I think that'd be a great start. Can we get it into a state where it runs as a stand-alone app, with a version that doesn't use hooks and a version that does?",
                "createdAt": "2020-08-06T23:10:14Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Sorry, I meant as a code-snippet, not as an app.\nI think one of the issue with the \"demo Flutter application\" idea is, the examples made in this thread are very much real.\nThey aren't oversimplified.\nThe primary use-case of hooks if to factorize micro states, like debounce, event handlers, subscriptions, or implicit side-effects \u2013 which are combined together to achieve more useful logics.\nI have some examples on Riverpod, such as https://marvel.riverpod.dev/#/ where the source code is here: https://github.com/rrousselGit/river_pod/tree/master/examples/marvel/lib\nBut that isn't going to be very different from what was mentioned until now.",
                "createdAt": "2020-08-06T23:26:54Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@Hixie\n\nI really have trouble understanding why this is a problem. I've written plenty of Flutter applications but it really doesn't seem like that much of an issue? Even in the worst case, it's four lines to declare a property, initialize it, dispose it, and report it to the debug data (and really it's usually fewer, because you can usually declare it on the same line you initialize it, apps generally don't need to worry about adding state to the debug properties, and many of these objects don't have state that needs disposing).\n\nI'm in the same boat.\nI admit, I don't really understand the issues described here either. I don't even understand what is the \"state logic\" people refer to, that needs to be reusable.\nI have many stateful form widgets, some that have tens of form fields, and I do have to manage the textcontrollers and focusnodes myself. I create and dispose them in the statelesswidget's lifecycle methods. While it is quite tedious, I don't have any widget that uses the same amount of controllers/focusNodes or for the same use case. The only common thing between them is the general concept of being stateful and being a form. Just because it's a pattern it doesn't mean the code is repeated.\nI mean, in a lot of parts of my code I have to loop through arrays, I wouldn't call doing \"for(var thing in things)\" throughout my app repeating code.\nI love  the power of the StatefulWidget which comes from the simplicity of its lifecycle api. It allows me to write StatefulWidgets that do one thing and do it in isolation from the rest of the app. The \"state\" of my widgets is always private to themselves, so reusing my widgets is not an issue, neither is code reuse.\nI have a couple of issues with the examples brought up here, which are somewhat in line with your points:\n\ncreating multiple stateful widgets with the exact same \"state logic\" seems just wrong and counter to the idea of having widgets self-contained. But again, I'm confused as to what people mean by common \"state logic\".\nhooks don't seem to do anything that I can't already do using plain dart and basic programming concepts (such as functions)\nthe issues seem to be related or caused by a certain style of programming, a style that seems to favor \"reusable global state\".\nabstracting away a couple of lines of code smells of \"premature code optimization\"and adds complexity in order to solve an issue that has little to nothing to do with the framework and everything to do with how people use it.",
                "createdAt": "2020-08-06T23:42:38Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "This is significantly less readable.\n\n\nWe have 10 levels of indentation \u2013 12 if we make a FilterBuilder to reuse the filter logic\n\n\nThe filter logic is not reusable as it stands.\n\nwe may forget to cancel the timer by mistake\n\n\n\nhalf of the build method is not useful for the reader. The Builders distracts us from what matters\n\n\nI lost a good 5 minutes trying to understand why the code doesn't compile because of a missing parenthesis\n\n\n\nYour example is more of a showcase of how verbose Provider is and why abusing InheritedWidgets for everything is a bad thing, rather than any real issue with Flutter's StatelessWidget and State lifecycle api.",
                "createdAt": "2020-08-06T23:58:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@rrousselGit Sorry if I wasn't clear. The suggestion I was making above was specifically to create vanilla Flutter applications (using StatefulWidget etc) that are realistic and show the problems you're describing, so that we can then make proposals based on a real full application. The concrete examples we've discussed here, such as the \"fetchUser\" example, have always ended up with a discussion along the lines of \"well you could handle that case like this and it would be simple and wouldn't need Hooks\" followed by \"well, that is oversimplified, in the real world you need Hooks\". So my point is, let's create a real world example that really does need Hooks, that isn't oversimplified, that shows the difficulty in reusing code, so that way we can see whether it is possible to avoid these problems without using any new code, or if we do need new code, and in the latter case, whether it has to be shaped like Hooks or if we can find an even better solution.",
                "createdAt": "2020-08-07T00:04:51Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I don't even understand what is the \"state logic\" people refer to, that needs to be reusable.\n\nFair enough\nA parallel to state logic would be UI logic, and what Widgets bring to the table.\nWe could technically remove the Widget layer. In that situation, what would be left is the RenderObjects.\nFor example, we could have a minimalist counter:\nvar counter = 0;\n\nfinal counterLabel = RenderParagraph(\n  TextSpan(text: '$counter'),\n  textDirection: TextDirection.ltr,\n);\n\nfinal button = RenderPointerListener(\n  onPointerUp: (_) {\n    counter++;\n    counterLabel.text = TextSpan(text: '$counter');\n  },\n  child: counterLabel,\n);\nThat's not necessarily complex. But it is error-prone. We have a duplicate on the counterLabel rendering\nWith widgets, we have:\nclass _CounterState exends State {\n  int counter = 0;\n\n  Widget build(context ) {\n    return GestureDetector(\n      onTap: () => setState(() => counter++);\n      child: Text('$counter'),\n    );\n  }\n}\nThe only thing this did is factorize the Text logic, by making it declarative.\nIt's a minimalist change. But over a large codebase, that is a significant simplification.\nHooks do the exact same thing.\nBut instead of Text, you get custom hooks for state logics. Which includes listeners, debouncing, making HTTP requests, ...\n\n\nYour example is more of a showcase of how verbose Provider is and why abusing InheritedWidgets for everything is a bad thing, rather than any real issue with Flutter's StatelessWidget and State lifecycle api.\n\nThis is unrelated to provider (this code does not use provider after-all).\nIf anything, provider have it better because it has context.watch instead of Consumer.\nThe standard solution would be to replace Consumer with ValueListenableBuilder \u2013 which leads to the exact same problem.",
                "createdAt": "2020-08-07T00:07:04Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I agree @Hixie, I do think we need two side by side comparisons to judge the effectiveness of just Flutter versus with hooks. This would also help to convince others whether hooks is better or not, or maybe another solution is even better if the vanilla app is built with this third solution. This vanilla app concept has been around for a while, with things like TodoMVC showing the difference between various front-end frameworks, so it's not necessarily new. I can help out with creating these example apps.",
                "createdAt": "2020-08-07T00:10:51Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@satvikpendem\nI'd be willing to help out.\nI think the example app in the flutter_hooks repo probably showcases several different hooks and what they make easier / problems they solve, and would be a good starting place.\nI also think that we could also use a few of the examples and approaches that are presented in this issue.\nUpdate: The code is here, https://github.com/TimWhiting/local_widget_state_approaches\nI'm not sure the proper name for the repository, so don't assume that that is the problem we are trying to solve. I've done the basic counter app in stateful and hooks. I don't have much time later tonight, but I'll try to add more use cases that are more illustrative of what might be the issue. Anyone who wants to contribute, please request access.",
                "createdAt": "2020-08-07T00:12:32Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The concrete examples we've discussed here, such as the \"fetchUser\" example, have always ended up with a discussion along the lines of \"well you could handle that case like this and it would be simple and wouldn't need Hooks\" followed by \"well, that is oversimplified, in the real world you need Hooks\".\n\nI disagree. I don't think I've seen such \"you could handle that case like this\" and agreed that the resulting code was better than the hook variant.\nMy point all along was that while we can do things differently, the resulting code is error-prone and/or less readable.\nThis applies to fetchUser too",
                "createdAt": "2020-08-07T00:15:54Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Hooks do the exact same thing.\nBut instead of Text, you get custom hooks for state logics. Which includes listeners, debouncing, making HTTP requests, ...\n\nNope, I still don't get what this common state logic is supposed to be. I mean I have many widgets that read from a database in their \"initState/didUpdateDependency\" methods, but I can't find two widgets that make the exact same query therefore their \"logic\" is not the same.\nUsing the example of making HTTP request. Assuming I have a \"makeHTTPRequest(url, paramters)\" somewhere in my service class that some of my widgets need to use, why would I use a hook instead of just calling the method directly whenever I need it? How is using hooks different from plain method calls in this case?\nListeners. I don't have widgets listening to the same things. Each of my widgets is responsible to subscribe to whatever they need to and make sure they unsubscribe. Hooks might be syntactic sugar for most of the things, but since my widgets wouldn't listen to the same combination of objects, the hooks would have to be \"parametrized\" somehow. Again, how are hooks different from a plain old function?\n\n\nThis is unrelated to provider (this code does not use provider after-all).\nIf anything, provider have it better because it has context.watch instead of Consumer.\n\nHuh? Your counterexample to what your \"ChatScreen\" HookWidget is supposed to solve, was this:\n@override\n  Widget build(BuildContext context) {\n    return Consumer<Auth>(\n      provider: authProvider,\n      builder: (context, auth, child) {\n        return Consumer<int>(\n          provider: selectedChatProvider,\n          builder: (context, chatId, child) {\n\nHow is this unrelated to provider? I'm confused. I'm no expert in Provider, but this definitely seems like code using Provider.",
                "createdAt": "2020-08-07T00:37:58Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I would like to insist on the fact that this issue is not about complex states.\nIt is about tiny increments that can be applied to the entire codebase.\nIf we disagree with the value of the examples given here, an application will not bring anything to the conversation \u2013 as there is nothing that we can do with hooks which we can't do with StatefulWidget.\nMy recommendation would be to instead compare side-by-side micro-snippets like ImplicitFetcher, and objectively determine which code is better using measurable metrics, and do that for a wide variety of small snippets.\n\n\nHow is this unrelated to provider? I'm confused. I'm no expert in Provider, but this definitely seems like code using Provider.\n\nThis code isn't from Provider but from a different project that doesn't use InheritedWidgets.\nProvider's Consumer doesn't have a provider parameter.\nAnd as I mentioned, you could replace Consumer -> ValueListenableBuilder/StreamBuilder/BlocBuilder/Observer/...\n\nin their \"initState/didUpdateDependency\" methods, but I can't find two widgets that make the exact same query therefore their \"logic\" is not the same.\n\nThe state logic we want to reuse is not \"make a query\" but \"do something when x changes\". The \"do something\" may change, but the \"when x changes\" is common\nConcrete example:\nWe may want a widget to make an HTTP request whenever the ID it receives changes.\nWe also want to cancel the pending requests using package:async's CancelableOperation.\nNow, we have two widgets wanting to do exactly the same thing, but with a different HTTP request.\nIn the end, we have:\nCancelableOperation<User> pendingUserRequest;\n\ninitState() {\n  pendingUserRequest = fetchUser(widget.userId);\n}\n\ndidUpdateWidget(oldWidget) {\n  if (widget.userId != oldWidget.userId) {\n      pendingUserRequest.cancel();\n      pendingUserRequest = fetchUser(widget.userId);\n  }\n}\n\ndispose() {\n  pendingUserRequest.cancel();\n}\nVS:\nCancelableOperation<Message> pendingMessageRequest;\n\ninitState() {\n  pendingMessageRequest = fetchMessage(widget.messageId);\n}\n\ndidUpdateWidget(oldWidget) {\n  if (widget.userId != oldWidget.messageId) {\n      pendingMessageRequest.cancel();\n      pendingMessageRequest = fetchMessage(widget.messageId);\n      message = pendingMessageRequest.value;\n  }\n}\n\ndispose() {\n  pendingMessageRequest.cancel();\n}\nThe only difference is that we changed fetchUser with fetchMessage. The logic is otherwise 100% the same. But we cannot reuse it, which is error-prone.\nWith hooks, we could factorize this into a useUnaryCancelableOperation hook.\nWhich means that with the same two widgets would instead do:\nWidget build(context) {\n  Future<User> user = useUnaryCancelableOperation(userId, fetchUser);\n}\nVS\nWidget build(context) {\n  Future<Message> message = useUnaryCancelableOperation(messageId, fetchMessage);\n}\nIn this scenario, all the logic related to making the request and canceling it is shared. We are left only with a meaningful difference, which is fetchUser vs fetchMessage.\nWe could even make a package out of this useUnaryCancelableOperation, and now everyone can reuse it in their app.",
                "createdAt": "2020-08-07T01:00:46Z"
            },
            {
                "author": "Hixie",
                "bodyText": "If we disagree with the value of the examples given here, an application will not bring anything to the conversation \u2013 as there is nothing that we can do with hooks which we can't do with StatefulWidget.\n\nIf that's really the case then I guess we should close this bug, because we've already discussed the examples given here and they haven't been compelling. I really would like to understand the situation better, though, and it sounded from earlier comments in this bug like the benefits are at the application level, hence my suggestion that we study examples of applications.",
                "createdAt": "2020-08-07T03:39:29Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "The only difference is that we changed fetchUser with fetchMessage. The logic is otherwise 100% the same. But we cannot reuse it, which is error-prone.\n\nWhat is error prone and what is there to reuse? Implementing a whole new layer of abstraction and class hierarchy just so we don't have to implement three methods in a class and is way overkill.\nAgain, just because something is a common pattern it doesn't mean that you need to create a new feature for it. Besides, if you want to reduce repetitive code in this case you can just extend the StatefulWidget* class and override the initstate/didUpdateWidget methods with the common bits.\n\nWith hooks, we could factorize this into a useUnaryCancelableOperation hook.\nWhich means that with the same two widgets would instead do:\nWidget build(context) {\n  Future<User> user = useUnaryCancelableOperation(userId, fetchUser);\n}\nVS\nWidget build(context) {\n  Future<Message> message = useUnaryCancelableOperation(messageId, fetchMessage);\n}\nIn this scenario, all the logic related to making the request and canceling it is shared. We are left only with a meaningful difference, which is fetchUser vs fetchMessage.\nWe could even make a package out of this useUnaryCancelableOperation, and now everyone can reuse it in their app.\n\nI'm sorry but that's big definite no from me. Aside from the fact that it saves only a minor amount of code redundancy, \"factorizing\" out a code that conceptually belongs to \"initState\" and \"update\" lifecycle methods, into the build method is a big no.\nI expect my build methods to only build the layout and nothing else. Setting up and tearing down dependencies definitely doesn't belong in the build method, and I'm quite happy having to explicitly rewrite the same type of code to make it explicit for my future self and others what my widget is doing. And let's not stick everything in the build method.",
                "createdAt": "2020-08-07T04:57:20Z"
            },
            {
                "author": "szotp",
                "bodyText": "If that's really the case then I guess we should close this bug\n\n@Hixie Please don't. People care about this issue. I have talked with you on reddit about the same thing, but in context of SwiftUI: https://github.com/szotp/SwiftUI_vs_Flutter\nIt's not about hooks, it's about somehow improving stateful widgets. People simply hate writing boilerplate. For devs writing SwiftUI code, who are used to RAII and copy semantics of Views, manually managing disposables seems just off.\nSo I encourage flutter team to at least see this as a problem and think about alternative solutions / improvements.",
                "createdAt": "2020-08-07T05:26:59Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "I expect my build methods to only build the layout and nothing else. Setting up and tearing down dependencies definitely doesn't belong in the build method,\nThat's an important point. Build methods should be pure. Still I wished we could have the advantages without the difficulties",
                "createdAt": "2020-08-07T06:05:13Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I really don't understand the push for more examples here. It's clear on it's face.\nThe problem solved by hooks is simply and obvious, it keeps the code DRY. The benefits of this are the obvious ones, less code == less bugs, maintenance is easier, less places for bugs to hide, lower line count overall increases readability, junior programmers are better insulated etc.\nIf you're talking a real world use case, it's an app where you're setting up and tearing down 12 animator controllers in 12 different views, every single time, leaving open the door to missing a dispose() call, or overriding some other lifecycle method. then apply that to dozens of other stateful instances, and you're easily looking at hundreds or thousands of pointless lines of code.\nFlutter is full of these cases where we need to constantly repeat ourselves, setting up, and tearing down state of little objects, that create all kinds of opportunities for bugs that do not need to exist, but do, because there's currently no elegant approach to sharing this rote setup/teardown/sync logic.\nYou can see this issue in literally any state that has a setup and teardown phase, or has some lifecycle hook that always needs to be tied into to.\nMyself I find using widgets is the best approach, I rarely use AnimatorController for example cause the setup/teardown is so annoying, verbose and bug prone, instead using TweenAnimationBuilder everywhere I can. But this approach has its limitations as you get to a higher number of stateful objects in a given view, forcing nesting and verbosity where really none should be required.",
                "createdAt": "2020-08-07T06:18:41Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@szotp I haven't... I would much rather we establish one or more baseline apps that demonstrate the problem so that we can evaluate the solutions. I would do it myself but I don't understand exactly what it is we're trying to solve so I'm the wrong person to do it.\n@escamoteur Baseline apps would help us design solutions that don't have the difficulties.\n@esDotDev We've discussed cases like this in this bug so far, but every time we have, solutions other than Hooks get dismissed because they don't solve some problem that wasn't included in the example that the solution addressed. Hence, simple descriptions of problems don't seem to be sufficient to capture the full extent. For example, the \"12 animator controllers\" case maybe could be solved by an array of animation controllers and the functional features in Dart. TweenAnimationBuilder might be another solution. Neither of those involve Hooks. But I'm sure if I suggest that, someone will point out something I've missed and say \"it doesn't work because...\" and bring up that (new, in the context of the example) problem. Hence the need for a baseline app that we all agree covers the full spread of the problem.\nIf anyone would like to drive this forward I really think the best way to do it is what I described above (#51752 (comment) and #51752 (comment)). That will give us a starting point that we can all agree represents the extent of the problem we're trying to solve; then, we can design solutions that address those problems in ways that address all the desires (e.g. @rrousselGit's need for reuse, @Rudiksz's need for clean build methods, etc), and most importantly we can evaluate those solutions in the context of the baseline apps.",
                "createdAt": "2020-08-07T06:22:52Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think we could all fairly easily agree on he problem:\nThere is no elegant way to share the setup/teardown tasks associated with things like Streams, AnimatorControllers etc. This leads to unnecessary verbosity, openings for bugs, and reduced readability.\nDoes anyone not agree with that? Can't we start there and move forward in search of a solution? We have to agree that is a core problem first, which it seems like we still do not.\nAs I write that though, I realized matches exactly the name of the issue, which is open ended and leaves room for discussion:\n\"Reusing state logic is either too verbose or too difficult\"\nTo me that is a very obvious problem, and we should be quickly moving past the debate stage and into brainstorming about what would work, if not hooks then what. We need micro-states that are re-usable... I'm sure we can figure something out.  It would really clean up a lot of Flutter views at the end of the day and make them more robust.",
                "createdAt": "2020-08-07T06:29:26Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@Hixie Please don't. People care about this issue. I have talked with you on reddit about the same thing, but in context of SwiftUI: https://github.com/szotp/SwiftUI_vs_Flutter\n\nYour SwiftUI example can be replicated in dart in a few lines of code, by simply extending the StatefulWidget class.\nI have StatefulWidgets that don't subscribe to any notifiers and/or do any external calls, and in fact most of them are like that. I have about 100 custom widgets (although not all Stateful), and maybe 15 of them have any kind of \"common state logic\" as described by the examples here.\nIn the long run, writing a few lines of code (aka boilerplate) is a small tradeoff in order to avoid unnecessary overhead. And again, this issue of having to implement the initState/didUpdate methods seems way overblown. When I create a widget that uses any of the patterns described here,  I maybe spend first 5-10 minutes on \"implementing\" the lifeCycle methods and then a few days actually writing and polishing the widget itself while never touching said lifecycle methods. The amount of time I spend on writing the so called boilerplate setup/teardown code is minuscule compared to my app code.\nAs I said the fact that StatefulWidgets make so few assumptions about what they are used for is what makes them so powerful and efficient.\nAdding a new type of widget to Flutter that subclasses StatefulWidget (or not) for this particular use case would be fine, but let's don't bake it into the StatefulWidget itself. I have a lot of widgets that don't need the overhead that would come with a \"hooks\" system or microstates.",
                "createdAt": "2020-08-07T06:36:29Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev I agree that that is a problem some people are facing; I even proposed some solutions earlier in this issue (search for my various versions of a Property class, might be buried now since GitHub doesn't like to show all the comments). The difficulty is that those proposals were dismissed because they didn't solve specific issues (e.g. in one case, didn't handle hot reload, in another, didn't handle didUpdateWidget). So then I made more proposals, but then those were again dismissed because they didn't handle something else (I forget what). This is why it's important to have some sort of baseline we agree represents the entire problem so that we can find solutions for that problem.",
                "createdAt": "2020-08-07T06:44:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The goal has never changed. The criticisms made are that the solutions suggested have a lack in flexibility. None of them continue to work outside of the snippet they were implemented for.\nThis is why the title in this issue mentions \"Difficult\": Because there is currently no flexibility in the way we currently solve problems.\n\nAnother way to look at it is:\nThis issue is basically arguing that we need to implement a Widget layer, for State logic.\nThe solutions suggested are \"But you can do it with RenderObjects\".",
                "createdAt": "2020-08-07T06:53:04Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "In the long run, writing a few lines of code (aka boilerplate) is a small tradeoff in order to avoid unnecessary overhead.\nCouple nits with this statement:\n\n\nIt's not really a few lines, if you take brackets, line spacing @overides, etc into acct, you can be looking at 10-15+ lines for a simple animator controller. That is non-trivial in my mind... like way beyond trivial. 3 lines to do this bugs me (in Unity it's Thing.DOTween()). 15 is ridiculous.\n\n\nIt's not about the typing, though that is a pain. It's about the silliness of having 50 line class, where 30 lines of it is rote boilerplate. Its obfuscation. It's about the fact that if you dont write the boilerplate, there's no warnings or anything, you just added a bug.\n\n\nI don't see any overhead worth discussing with something like Hooks. We're talking about an array of objects, with a handful of fxns on each. In Dart, which is very fast. This is a red herring imo.",
                "createdAt": "2020-08-07T06:57:26Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@esDotDev\n\nTo me that is a very obvious problem, and we should be quickly moving past the debate stage and into brainstorming about what would work, if not hooks then what.\n\nExtending widgets. Like the way ValueNotifier extends the ChangeNotifier to simplify a common usage pattern, everybody can write their own flavors of StatelessWidgets for their specific use cases.",
                "createdAt": "2020-08-07T07:01:02Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Yes I agree that is an effective approach, but it does leave something to be desired.  If I have 1 animator, then I can just use a TweenAnimationBuilder. Cool, it's still like 5 lines of code, but whatever. it works... not TOO bad.  But if I have 2 or 3? Now I'm in nesting hell, if I have a cpl other stateful objects for some reason, well it's all kinda become a mess of indentation, or I'm creating some very specific widget that encapsulates a random collection of setup, update and teardown logic.",
                "createdAt": "2020-08-07T07:03:00Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Extending widgets. Like the way ValueNotifier extends the ChangeNotifier to simplify a common usage pattern, everybody can write their own flavors of StatelessWidgets for their specific use cases.\n\nYou can extend only one base-class at a time. That does not scale\nMixins are the next logical attempt. But as the OP mentions, they do not scale either.",
                "createdAt": "2020-08-07T07:03:10Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@esDotDev\n\nor I'm creating some very specific widget that encapsulates a random collection of setup, update and teardown logic.\n\nA kind of widget that has to set up 3-4 kind of AnimationControllers does sound a like a very specific use case and supporting random collection of setup/teardown logic definitely shouldn't be part of a framework. In fact that's why the initState/didUpdateWidget methods are exposed int he first place, so you can do your random collection of setup to your heart's desire.\nMy longest initState method is 5 lines of code, my widgets don't suffer of excessive nesting, so we definitely have different needs and use cases. Or a different development style.",
                "createdAt": "2020-08-07T07:14:54Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@esDotDev\n\n3. I don't see any overhead worth discussing with something like Hooks. We're talking about an array of objects, with a handful of fxns on each. In Dart, which is very fast. This is a red herring imo.\n\nIf the proposed solution is anything like the flutter_hooks package that's wholy untrue. Yes, conceptually it's an array with functions in it, but the implementation is nowhere near trivial or efficient.\nI mean, I may be wrong, but it seems like the HookElement checks wheather it should rebuild itself in its own build method?!\nAlso checking wheather the hooks should be intialized, reinitialized or disposed on every single widget build seems like a significant overhead. It just doesn't feel right, so I hope I'm wrong.",
                "createdAt": "2020-08-07T08:08:03Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "Would it make sense to take one of @brianegan 's architecture examples as base app for a comparison?",
                "createdAt": "2020-08-07T08:53:59Z"
            },
            {
                "author": "Gustash",
                "bodyText": "If I may interject here, not sure if this was said already. But in React we don't really think of lifecycle with hooks, and that might sound scary if it's how you're used to building Components/Widgets, but here's why lifecycle doesn't really matter.\nMost times, when you're building Components/Widgets with state or actions to take based on props, you want something to happen when that state/props change (for example, like I saw mentioned in this thread, you'll want to re-fetch a user's details when the userId prop has changed). It's usually much more natural to think of that as an \"effect\" of the userId changing, rather than something that happens when all the props of the Widget change.\nSame thing for cleanup, it's usually much more natural to think \"I need to clean up this state/listener/controller when this prop/state changes\" rather than \"I need to remember to clean up X when all the props/state change or when the entire component gets destroyed\".\nI haven't written Flutter in a while, so I'm not trying to sound like I know the current climate or limitations this approach would have on the current Flutter mindset, I am open to differing opinions. I just think that a lot of people not familiar with React hooks are having the same confusion I had when I was introduced to them because my mindset was so ingrained in the lifecycle paradigm.",
                "createdAt": "2020-08-07T09:00:33Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@escamoteur @Rudiksz @Hixie there has been a GitHub project created by @TimWhiting that I've been invited to where we are starting to create these examples. Each person/group can create how they'd solve a predefined problem. They're not full blown apps, more like pages, but we can add apps as well, if they serve to show more complex examples. Then we can discuss problems and create a better API. @TimWhiting can invite anyone interested I presume.\nhttps://github.com/TimWhiting/local_widget_state_approaches",
                "createdAt": "2020-08-07T13:23:46Z"
            },
            {
                "author": "karthickr95",
                "bodyText": "Jetpack compose is also has similar to hooks, which was compared with react here.",
                "createdAt": "2020-08-07T13:57:39Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@satvikpendem @TimWhiting  That's great! Thank you.",
                "createdAt": "2020-08-07T18:09:38Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@esDotDev\nvery specific use case and supporting random collection of setup/teardown logic definitely shouldn't be part of a framework.\n\nThis is the nail that hooks hits on the head. Each type of object is responsible for it's own setup and teardown. Animators know how to create, update and destroy themselves, as do streams, and so on. Hooks specifically solves this issue of 'random collections' of state scaffolding scattered throughout your view. The allows the bulk of the view code to focus on business logic and layout formatting, which is a win. It doesn't force you into creating custom widgets, just to hide some generic boilerplate that is the same in every project.\n\nMy longest initState method is 5 lines of code, my widgets don't suffer of excessive nesting, so we definitely have different needs and use cases. Or a different development style.\n\nMine too. But it's initState() + dispose() + didUpdateDependancies(), and missing either of the last 2 can cause bugs.",
                "createdAt": "2020-08-07T18:10:43Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think the canonical example would be something like: Write a view that uses 1 streamcontroller and 2 animator controllers.\nYou have 3 options as far as I can see:\n\nAdd 30 lines or so of boilerplate to your class, and some mixins. Which is not only verbose, but fairly hard to follow initially.\nUse 2 TweenAnimationBuilders and a StreamBuilder, for about 15 indentation levels, before you even get to your view code, and you still have lots of boilerplate for the Stream.\nAdd like 6 lines of non-indented code at the top of build(), to get your 3 stateful sub-objects, and define any custom init/destroy code\n\nMaybe there's a 4th option which is a SingleStreamBuilderDoubleAnimationWidget, but this is just a make-work thing for developers and pretty annoying in general.\nAlso worth noting that the cognitive load of 3 is significantly lower than the other 2 for a new developer. Most new dev's don't even know that TweenAnimationBuilder exists, and simply learning the concept of SingleTickerProvider is a task in it's own. Just saying, \"Give me an animator please\", is a easier and more robust approach.\nI'll try and code something up today.",
                "createdAt": "2020-08-07T18:29:49Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "2. Use 2 TweenAnimationBuilders and a StreamBuilder, for about 15 indentation levels, before you even get to your view code, and you still have lots of boilerplate for the Stream.\n\nRight. Show us a real world example of code that uses 15 levels of indentation.\nHow does replacing 30 lines of code with 6 lines + hundreds of lines in a library reduce cognitive load? Yeah, I can just ignore the \"magic\" the library does, but not its rules. For example the hooks package tels you in no uncertain terms that hooks must be used only in build methods. Now you have an extra constraint to worry about.\nI have probably less than 200 lines of code that involves focusnodes, textcontrollers, singletickerproviders or the various lifecycle methods of my statefulwidgets, in a project with 15k lines of code. What cognitive overload are you talking about?",
                "createdAt": "2020-08-07T20:00:02Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Rudiksz please stop being passive aggressive.\nWe can disagree without fighting.\n\nHooks constraints are the least of my worries.\nWe aren't talking about hooks specifically, but about the problem.\nIf we have to, we can come up with a different solution.\nWhat matters is the problem we want to solve.\nFuthermore, Widgets can only be used inside build and unconditionally (or we are otherwise changing the tree depth, which is a no go)\nThat is identical to the hooks constraints, but I don't think people complained about it.",
                "createdAt": "2020-08-07T20:11:09Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Futhermore, Widgets can only be used inside build and unconditionally (or we are otherwise changing the tree depth, which is a no go)\nThat is identical to the hooks constraints, but I don't think people complained about it.\n\nNo ,it's not identical. The problem that is presented here seems to be related to code that prepares widgets before being (re)built. Preparing state, dependencies, streams, controllers, whatnot, and handling changes in the tree structure. None of these should be in the build method, even if it's  hidden behind a single function call.\nThe entry point for that logic should never be in the build method.\nForcing me to put initialization logic of any kind into the build method is nowhere the same as \"forcing\" me to compose a widget tree in the build method. The whole reason for the build method is to take an existing state (set of variables) and produce a widget tree that then gets painted.\nConversely, I would also be against forcing me to add code that builds widgets inside the initState/didUpdateWidget methods.\nAs it is now, statefulwidget lifecycle methods have a very clear role and make it very easy and straighforward to separate code with entirely different concerns.\nConceptually I'm starting to understand the problems that are being described here, but I still fail to see it as an actual problem. Maybe some real examples (that are not the counter app) can help me change my mind.",
                "createdAt": "2020-08-07T22:24:39Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "As a side-note, Riverpod, my latest experiment, has some very hook-like ideas, without the constraints.\nFor example, it solves the:\nConsumer(\n  provider: provider,\n  builder: (context, value) {\n    return Consumer(\n      provider: provider2,\n      builder: (context, value2) {\n        return Text('$value $value2');\n      },\n    );\n  },\n)\nby having:\nConsumer(\n  builder (context, watch) {\n    final value = watch(provider);\n    final value2 = watch(provider2);\n  },\n)\nWhere watch can be called conditionally:\nConsumer(\n  builder: (context, watch) {\n    final value = watch(provider);\n    if (something) {\n      final value2 = watch(provider2);\n    }\n  },\n)\nWe could even get rid of Consumer entirely by having a custom StatelessWidget/StatefulWidget base class:\nclass Example extends ConsumerStatelessWidget {\n  @override\n  Widget build(ConsumerBuildContext context) {\n    final value = context.watch(provider);\n    final value2 = context.watch(provider2);\n  }\n}\nThe main issue is, this is specific to one kind of object, and it works by relying on the fact that the object instance has a consistent hashCode across rebuilds.\nSo we are still far from the flexibility of hooks",
                "createdAt": "2020-08-07T23:30:05Z"
            },
            {
                "author": "sahandevs",
                "bodyText": "@rrousselGit I think without extending StatelessWidget/StatefulWidget classes and creating something like ConsumerStatelessWidget, it is possible to have something like context.watch by using extension methods on BuildContext class and having the provider provide the watch function with InheritedWidgets.",
                "createdAt": "2020-08-08T03:15:06Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "That's a different topic. But tl;dr, we can't rely on InheritedWidgets as a solution to this issue: #30062\nTo solve that issue, using InheritedWidgets would block us because of #12992 and  #33213",
                "createdAt": "2020-08-08T03:51:56Z"
            },
            {
                "author": "szotp",
                "bodyText": "Conceptually I'm starting to understand the problems that are being described here, but I still fail to see it as an actual problem.\n\nComparing Flutter to SwiftUI, to me it's obvious that there is actual problem, or rather - things are not as great as they could be.\nIt may be hard to see, because Flutter & others worked hard around it: we have wrappers for each specific case: AnimatedBuilder, StreamBuilder, Consumer, AnimatedOpacity, etc. StatefulWidget works great for implementing these small reusable utilities, but it's just too low level for non-reusable, domain specific components, where you may have multitude of text controllers, animations, or whatever business logic calls for. The usual solution is to either bite the bullet and write all that boilerplate, or make a carefully constructed tree of providers and listeners. Neither approach is satifying.\nIt's like @rrousselGit says, in the olden days (UIKit) we were forced to manually manage our UIViews (the equivalent of RenderObjects), and remember to copy values from model to view and back, delete unused views, recycle, and so on. This was not a rocket science, and many people did not see this old problem, but I think everyone here would agree that Flutter clearly improved the situation.\nWith statefulness, the issue is very similiar: it's boring, error prone work that could be automated.\nAnd, by the way, I don't think hooks solve this at all. It's just that hooks are the only approach that is possible without changing flutter's internals.",
                "createdAt": "2020-08-08T15:47:05Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "StatefulWidget works great for implementing these small reusable utilities, but it's just too low level for non-reusable, domain specific components, where you may have multitude of text controllers, animations, or whatever business logic calls for.\n\nI'm confused when you say that building your non-reusable domain specific  components you need a widget that is high-level. Usually it's the exact opposite.\nAnimatedBuilder, StreamBuilder, Consumer, AnimatedOpacity are all widget that implement a certain use case. When I need a widget that has so specific logic that I can't use any of these higher level widgets, that's when I drop down to a lower level api so I can write my own specific use case. The so called boilerplate is implementing how my unique widget manages its unique combination of streams, network calls, controllers and whatnot.\nAdvocating for hooks, hook like behaviour or even just \"automation\" is like saying that we need a low level widget that can handle high level, non-reusable logic anybody would ever want to have without having to write the so called boilerplate code.\n\nWith statefulness, the issue is very similiar: it's boring, error prone work that could be automated.\n\nAgain. You want to automate \"non-reusable, domain specific components, where you may have multitude of text controllers, animations, or whatever business logic calls for\"?!\n\nIt's like @rrousselGit says, in the olden days (UIKit) we were forced to manually manage our UIViews (the equivalent of RenderObjects), and remember to copy values from model to view and back, delete unused views, recycle, and so on. This was not a rocket science, and many people did not see this old problem, but I think everyone here would agree that Flutter clearly improved the situation.\n\nI did ios and android development 6-7  years ago (around the time Android switched to their material design) and I don't remember any of this managing and recycling views being an issue and Flutter doesn't seem better or worse. I can't speak about the current affairs, I quit when Swift and Kotlin were launched.\nThe boilerplate I am forced to write in my StatefulWidgets is about 1% of my code base. Is it error prone? Every line of code is a potential source of bugs, so sure. Is it cumbersome? 200 lines of code ouot of 15000? I really don't think so, but that's just my opinion. Flutter's text/animation controllers, focusnodes all have issues that can be improved upon, but being verbose is not one.\nI'm really curious to see what people are developing that they need so much boilerplate.\nListening to some of the comments here sounds like managing 5 lines of code instead of 1 is like 5 times harder. It's not.",
                "createdAt": "2020-08-08T16:38:51Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Wouldn't you agree though that instead of setting up initState and dispose for each AnimationController for example can be more error prone than just doing it once and reusing that logic? Same principle as using functions, reusability. I agree that it is problematic to put hooks in the build function though, there definitely is a better way.",
                "createdAt": "2020-08-08T16:50:38Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "It really feels like the difference between those who do and do not see the problem here are that the former have used hook like constructs before, such as in React, Swift, and Kotlin, and the latter have not, such as working in pure Java or Android. I think the only way to be convinced, in my experience, is to try hooks and see if you can go back to the standard way. Oftentimes, many people can't, again, in my experience. You know it when you use it.\nTo that end, I'd encourage people who are skeptical to use flutter_hooks for a small project and see how it fares, then redo it in the default way. It is not sufficient that we simply create versions of the app for one to read as in @Hixie 's suggestion (although we will do that as well of course), I do believe each person must use hooks themselves to see the difference.",
                "createdAt": "2020-08-08T16:56:58Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "It is not sufficient that we simply create versions of the app for one to read as in @Hixie 's suggestion (although we will do that as well of course), I do believe each person must use hooks themselves to see the difference.\n\nI wasted days trying provider, even more days trying bloc, I didn't find either of them was a good solution. If it works for you, great.\nIn order for me to even try your proposed solution to a problem that you are having, you need to demonstrate its advantages. I looked at examples with flutter hooks and I looked at its implementation. Just no.\nWhatever boilerplate reducing code is added to the framework, I hope the Stateful/StatelessWidgets are left unchaged. There's not much more I can add to this conversation.",
                "createdAt": "2020-08-08T17:09:11Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Let's start again, in a hypothetical world where we can change Dart, without talking about hooks.\nThe problem debated is:\nWidget build(context) {\n  return ValueListenableBuilder<String>(\n    valueListenable: someValueListenable,\n    builder: (context, value, _) {\n      return StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) {\n          return TweenAnimationBuilder<double>(\n            tween: Tween(...),\n            builder: (context, value3) {\n              return Text('$value $value2 $value3');\n            },\n          );\n        },\n      );\n    },\n  );\n}\nThis code is not readable.\nWe could fix the readability issue by introducing a new keyword which changes the syntax into:\nWidget build(context) {\n  final value = keyword ValueListenableBuilder(valueListenable: someValueListenable);\n  final value2 = keyword StreamBuilder(stream: someStream);\n  final value3 = keyword TweenAnimationBuilder(tween: Tween(...));\n\n  return Text('$value $value2 $value3');\n}\nThis code is significantly more readable, is unrelated to hooks, and doesn't suffer from its limitations.\nThe readability gain is not much about the number of lines, but the formatting and indentations.\n\nBut what about when the Builder is not the root widget?\nExample:\nWidget build(context) {\n  return Scaffold(\n    body: StreamBuilder(\n      stream: stream,\n      builder: (context, value) {\n        return Consumer<Value2>(\n          builder: (context, value2, child) {\n            return Text('${value.data} $value2');\n          },\n        );\n      },\n    ),\n  );\n}\nWe could have:\nWidget build(context) {\n  return Scaffold(\n    body: {\n      final value = keyword StreamBuilder(stream: stream);\n      final value2 = keyword Consumer<Value2>();\n      return Text('${value.data} $value2');\n    }\n  );\n}\n\nBut how does this relate to the reusability issue?\nThe reason why this is related is, Builders are technically a way to reuse state logic. But their issue is, they make the code not very readable if we plan to use many builders, like in this comment #51752 (comment)\nWith this new syntax, we fixed the readability problem. As such, we can extract more things into Builders.\nSo for example, the useFilter mentioned in this comment could be:\nFilterBuilder(\n  debounceDuration: const Duration(seconds: 2),\n  builder: (context, filter) {\n    return TextField(onChange: (value) => filter.value = value);\n  }\n)\nWhich we can then use with the new keyword:\nclass ChatScreen extends HookWidget {\n  const ChatScreen({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final filter = keyword FilterBuilder(debounceDuration: const Duration(seconds: 2));\n    final userId = keyword Consumer(authProvider).userId;\n    final chatId = keyword Consumer(selectedChatProvider);\n    final chat = keyword QueryBuilder(ChatQuery(userId: userId, chatId: chatId, filter: filter.value));\n\n    return Column(\n      children: [\n        Searchbar(onChanged: (value) => filter.value = value),\n        Expanded(\n          child: ChatList(chat: chat),\n        ),\n      ],\n    );\n  }\n}\n\nWhat about the \"extract as function\" we talked about with hooks, to create custom hooks/Builders?\nWe could do the same thing with such keyword, by extracting a combination of Builders in a function:\nBuilder<Chat> ChatBuilder()  {\n  final filter = keyword FilterBuilder(debounceDuration: const Duration(seconds: 2));\n  final userId = keyword Consumer(authProvider).userId;\n  final chatId = keyword Consumer(selectedChatProvider);\n  final chat = keyword QueryBuilder(ChatQuery(userId: userId, chatId: chatId, filter: filter.value));\n\n  return Builder(chat);\n}\n\nclass ChatScreen extends HookWidget {\n  const ChatScreen({Key key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    final chat = keyword ChatBuilder();\n\n    return Column(\n      children: [\n        Searchbar(onChanged: (value) => filter.value = value),\n        Expanded(\n          child: ChatList(chat: chat),\n        ),\n      ],\n    );\n  }\n}\nObviously, not much thought was given in all the implications of such syntax. But that's the basic idea.\n\nHooks are this feature.\nThe limitations of hooks exist because they are implemented as a package rather than a language feature.\nAnd the keyword is use, such that keyword StreamBuilder becomes use StreamBuilder, which is ultimately implemented as useStream",
                "createdAt": "2020-08-08T18:28:40Z"
            },
            {
                "author": "Hixie",
                "bodyText": "This code is significantly more readable\n\nI think this is a matter of opinion. I agree that some people think that versions you describe as more readable are better; personally I prefer the much more explicit magic-less versions. But I have no objection to making the second style possible.\nThat said, the next step is to work on @TimWhiting's app (https://github.com/TimWhiting/local_widget_state_approaches/blob/master/lib/stateful/counter.dart) to make it into something that has all the problems that we want to solve.",
                "createdAt": "2020-08-08T19:01:00Z"
            },
            {
                "author": "gaearon",
                "bodyText": "For what it's worth, #51752 (comment) pretty much parallels the inspiration for Hooks in React. The Builder pattern seems identical to the Render Props pattern that used to be prevalent in React (but led to similarly deep trees). Later @trueadm suggested syntax sugar for Render Props, and later that led to Hooks (to remove unnecessary runtime overhead).",
                "createdAt": "2020-08-08T19:42:42Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "`Widget build(context) {\n  return ValueListenableBuilder<String>(\n    valueListenable: someValueListenable,\n    builder: (context, value, _) {\n      return StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) {\n          return TweenAnimationBuilder<double>(\n            tween: Tween(...),\n            builder: (context, value3) {\n              return Text('$value $value2 $value3');\n            },\n          );\n        },\n      );\n    },\n  );\n}`\n\nIf readablity and indentation is the issue this can be rewritten as\n  @override\n  Widget build(context) {\n    return ValueListenableBuilder<String>(\n      valueListenable: someValueListenable,\n      builder: (context, value, _) => buildStreamBuilder(value),\n    );\n  }\n\n  StreamBuilder<int> buildStreamBuilder(String value) => StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) => buildTweenAnimationBuilder(value, value2),\n      );\n\n  Widget buildTweenAnimationBuilder(String value, AsyncSnapshot<int> value2) =>\n      TweenAnimationBuilder<double>(\n        duration: Duration(milliseconds: 500),\n        tween: Tween(),\n        builder: (context, value3, _) => Text('$value $value2 $value3'),\n      );\n\nIf functions are not your thing, or you need reusability then extract them as widgets\nclass NewWidget extends StatelessWidget {\n  var someValueListenable;\n\n  var someStream;\n\n  @override\n  Widget build(context) {\n    return ValueListenableBuilder<String>(\n      valueListenable: someValueListenable,\n      builder: (context, value, _) {\n        return MyStreamedWidget(value, someStream);\n      },\n    );\n  }\n}\n\nclass MyStreamedWidget extends StatelessWidget {\n  const MyStreamedWidget(\n    this.value,\n    this.someStream, {\n    Key key,\n  }) : super(key: key);\n\n  final String value;\n  final Stream someStream;\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<int>(\n      stream: someStream,\n      builder: (context, value2) => MyAnimatedWidget(value, value2),\n    );\n  }\n}\n\nclass MyAnimatedWidget extends StatelessWidget {\n  final String value;\n  final AsyncSnapshot<int> value2;\n\n  const MyAnimatedWidget(\n    this.value,\n    this.value2, {\n    Key key,\n  }) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return TweenAnimationBuilder<double>(\n      tween: Tween(),\n      builder: (context, value3, _) {\n        return Text('$value $value2 $value3');\n      },\n    );\n  }\n}\n\nThere's nothing in your example that warrants a new keyword or feature.\nI know what you are going to say. The 'value' variable has to be passed through all the widgets/function calls, but that's just a result of how you architect your application. I break up my code using both with \"build\" methods and custom widgets, depending on the use case, and never have to pass the same variable to a chain of three calls.\nReusable code is reusable when it relies as little as possible on external side effects (such as InheritedWidgets, or (semi)global state).",
                "createdAt": "2020-08-08T19:57:09Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@Rudiksz I don't think you're adding anything to the discussion here. We are aware of strategies to mitigate these issues because we do them all day long. If you don't feel like it's an issue, then you can simply continue to use things as they are and this does not affect you at all.\nClearly there are many many people who do see this as a fundamental pain point, and just cycling back and forth is pointless. You are not going, through various arguments, convince people that they do not want what they want or change anyone's mind here. Everyone in this discussion clearly has hundreds or thousands of hours in Flutter under their belt, and it's not expected that we all should agree on things.",
                "createdAt": "2020-08-08T20:15:32Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think this is a matter of opinion. I agree that some people think that versions you describe as more readable are better; personally I prefer the much more explicit magic-less versions. But I have no objection to making the second style possible.\n\nIf it is a matter of opinion, I would guess that it is quite lopsided in one direction.\n\nBoth have magic. I don't necessarily know what any of these builders are doing internally. The non-magic version is writing the actual boilerplate inside these builders. Using a SingleAnimationTIckerProvider mixin is magic too for 95% of Flutter devs.\nOne obfuscates very important variable names that will be used later in the tree, which is value1 and value2, the other has them front and center at top of build. This a clear parsing / maintenance win.\nOne has 6 levels of indendation before the widget tree even begins, the other has 0\nOne is 5 vertical lines, the other is 15\nOne shows the actual content piece prominently (Text()) the other hides it, nested, way down into the tree. Another clear parsing win.\n\nIn a general sense I could see this maybe being a matter of taste. But Flutter specifically has an issue with line count, indendation and signal:nois ratio in general. While I absolutely love the ability to declaratively form a tree in Dart code, it can lead to some extremely unreadable/verbose code, especially when you rely on multiple layers of wrapped builders. So in the context of Flutter itself, where we are continually fighting this battle, this sort of optimization is a killer feature, because it provides us a really excellent tool to combat this somewhat pervasive issue of general verbosity.\nTL;DR - Anything that significantly reduced indentation and line count in Flutter, is doubly valuable, due to the generally high line counts and indentation inherent in Flutter.",
                "createdAt": "2020-08-08T20:22:58Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@Rudiksz I don't think you're adding anything to the discussion here. We are aware of strategies to mitigate these issues because we do them all day long. If you don't feel like it's an issue, then you can simply continue to use things as they are and this does not affect you at all.\n\nExcept if it's a change in the core framework then it does affect me, no?\n\nClearly there are many many people who do see this as a fundamental pain point, and just cycling back and forth is pointless. You are not going, through various arguments, convince people that they do not want what they want or change anyone's mind here. Everyone in this discussion clearly has hundreds or thousands of hours in Flutter under their belt, and it's not expected that we all should agree on things.\n\nRight, this horse was already beaten to death countless times, so I won't fall in the trap of answering any more comments.",
                "createdAt": "2020-08-08T20:30:20Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Builders are technically a way to reuse state logic. But their issue is, they make the code not very readable.\n\nThis states it perfectly. To think of it in Flutter terms, we need single-line builders.\nBuilders that do not require dozens of tabs and lines, but still allow some custom boilerplate to be hooked into the widget lifecycle.\nThe \"everything is a widget\" mantra specifically is not a good thing here. The relevant code in a builder is usually just it's setup props, and the stateful thing that it returns which the build fxn needs. Every single line break and tab is basically pointless.",
                "createdAt": "2020-08-08T20:49:30Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "Except if it's a change in the core framework then it does affect me, no?\n\n@Rudiksz  I don't think anyone is proposing that we change Stateful widgets. You can always use them in their current form if you want. Whatever solution we might come up with would either use Stateful widgets with no changes, or another type of widget entirely. We aren't saying that Stateful widgets are bad, just that we'd like another type of Widget that allows more composable widget state. Think of it as a Stateful widget that instead of one state object associated with it contains multiple state objects, and one build function that is separate but has access to those state objects. This way, you can reuse bits of common state (along with state logic associated with that state) with their initState and dispose already implemented for you. Essentially more modular state, that can be composed in different ways in different situations. Again, this is not a concrete proposal, but maybe another way to think of it. Maybe it could turn into a solution that is more flutter like, but I don't know.",
                "createdAt": "2020-08-08T21:02:33Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "That said, the next step is to work on @TimWhiting's app (https://github.com/TimWhiting/local_widget_state_approaches/blob/master/lib/stateful/counter.dart) to make it into something that has all the problems that we want to solve.\n\nThis is tricky because this problem is inherently one of a death by a thousand cuts. It just adds bloat and decreases readability across the codebase. It's impact is felt worst in small widgets, where the entire class is <100 lines, and half of it is spent managing an animator controller. So I don't know what seeing 30 of these examples will show, that 1 does not.\nIt really is the difference between this:\n@override\n  Widget build(BuildContext context) {\n    final controller = get AnimationController(vsync: this, duration: widget.duration);\n    //do stuff\n  }\n\nAnd this:\n  AnimationController _controller;\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = AnimationController(vsync: this, duration: widget.duration);\n  }\n\n  @override\n  void didUpdateWidget(Example oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    if (widget.duration != oldWidget.duration) {\n      _controller.duration = widget.duration;\n    }\n  }\n\n  @override\n  void dispose() {\n    _controller.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    //Do Stuff\n  }\n\nThere simply is no better way to illustrate than this. You can extend this use case to any controller type object. AnimatorController, FocusController and TextEditingController are probably the most common and annoying ones to manage in day to day use. Now just picture 50, or 100 of these sprinkled all over my code base.\n\nYou have about 1000-2000 lines that could just disappear.\nYou have probably dozens of bugs and RTE's (at various pts of development) that did not ever need to exist because some override or another was missing.\nYou have widgets, that when looked at with cold eyes, are much harder to grok at a glance. I need to read each of these overrides, I can't simply assume they are boilerplate.\n\nAnd you can of course extend this to custom controllers. The entire concept of using controllers is less appealing in Flutter because you know you will have to bootstrap, manage and destroy them like this, which is annoying and bug prone. It leads you to avoid making your own and instead creating custom StatefulWidgets/Builders. It would be nice if controller type objects were just easier to use and more robust, since builders have readability issues (or at the least, are significantly more verbose and white-space laden).",
                "createdAt": "2020-08-08T23:51:02Z"
            },
            {
                "author": "Hixie",
                "bodyText": "This is tricky\n\nYup, API design is tricky. Welcome to my life.\n\nSo I don't know what seeing 30 of these examples will show, that 1 does not.\n\nIt's not 30 examples that will help, it's 1 example that's elaborate enough that it can't be simplified in ways that you would then say \"well, sure, for this example that works, but it doesn't for a real example\".",
                "createdAt": "2020-08-09T01:45:21Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It's not 30 examples that will help, it's 1 example that's elaborate enough that it can't be simplified in ways that you would then say \"well, sure, for this example that works, but it doesn't for a real example\".\n\nI've said it a few times already, but that way of judging hooks is unfair.\nHooks aren't about making possible something that was previously impossible. It's about providing a consistent API to solve this sort of problem.\nRequesting an application that shows something which can't be simplified differently is judging a fish by its ability to climb trees.",
                "createdAt": "2020-08-09T02:52:50Z"
            },
            {
                "author": "Hixie",
                "bodyText": "We're not just trying to judge hooks, we're trying to evaluate different solutions to see if there are any that address the needs of everyone.",
                "createdAt": "2020-08-09T03:11:46Z"
            },
            {
                "author": "Hixie",
                "bodyText": "(I'm curious what way you would evaluate different proposals here, if not by actually writing applications in each of the proposals and comparing them. What evaluation metric would you propose instead?)",
                "createdAt": "2020-08-09T03:12:50Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "A proper way to judge the solution to this problem is not an application (as each individual usage of the API will be dismissed like the examples here were).\nWhat we should judge the proposed solution on is:\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nIs it more readable?\nIs it easier to write?\n\n\nHow reusable is the code produced?\nHow many problems can be solved with this API?\n\nDo we lose some benefits for some specific problems?\n\n\n\nWhen evaluated on this grid, the Property/addDispose proposal may have a good \"is the resulting code better?\" score, but evaluate poorly against both reusability and flexibility.",
                "createdAt": "2020-08-09T03:16:59Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I don't know how to answer those questions without actually seeing each proposal in real use.",
                "createdAt": "2020-08-09T03:18:01Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Why?\nI didn't need to make applications using Property to know that this proposal will have difficulty with producing truly reusable code and solving many problems.\nWe can take any existing *Builder and try to reimplement them using the proposed solution.\nWe can also try and reimplement the hooks listed in this thread, or some hooks made in the React community (there are numerous compilations of hooks available online).",
                "createdAt": "2020-08-09T03:24:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I didn't need to make applications using Property to know that this proposal will have difficulty with producing truly reusable code and solving many problems.\n\nUnfortunately, I do not share your instincts here (as demonstrated by the fact that I thought Property (#51752 (comment)) worked great until you said it had to handle values both from a widget and local state with the same API, which I wasn't aware was a constraint until you brought it up). If I provide a version of Property that solves that problem as well, is it definitely going to be ok, or will there be some new problem that it doesn't cover? Without a target we all agree is the target, I don't know what we're designing solutions for.\n\nWe can take any existing *Builder and try to reimplement them using the proposed solution.\n\nClearly not any. For example, you gave one in the OP, and when I made my first Property proposal (#51752 (comment)) you pointed out problems with it that were not illustrated by the original Builder.\n\nWe can also try and reimplement the hooks listed in this thread, or some hooks made in the React community (there are numerous compilations of hooks available online).\n\nI don't mind where we start. If you have a particularly good example that you think illustrates the problem and it uses hooks, then great, let's add that to @TimWhiting's repository. The whole point is to implement the same thing in multiple different ways, I don't mind where the ideas come from.",
                "createdAt": "2020-08-09T03:33:29Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "It's not 30 examples that will help, it's 1 example that's elaborate enough that it can't be simplified in ways that you would then say \"well, sure, for this example that works, but it doesn't for a real example\".\n\nThere will never be anything more elaborate than the simple desire to to use an AnimatorController (or any other re-useable stateful component you can think of) without an unreadable builder or a bunch of bug-prone lifecycle boilerplate.\nThere has been no solution proposed that addressed the readability and robustness benefits requested, in a general purpose way.",
                "createdAt": "2020-08-09T03:46:27Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I do insist on the fact that any builder will do, as this issue could be renamed into \"We need syntax sugar for Builders\" and lead to the same discussion.\nAll other arguments made (such as creating and disposing an AnimationController) are made on the basis that they too could be extracted into a builder:\nWidget build(context) {\n  return AnimationControllerBuilder(\n    duration: Duration(seconds: 2),\n    builder: (context, animationController) {\n\n    }\n  );\n}\nIn the end, I think the perfect example is trying to reimplement StreamBuilder in its entirety, and test it in different scenarios:\n\nthe stream comes from the Widget\n// from an InheritedWidget\nfrom the local State\n\nand test each individual case against \"the stream can change over time\", so:\n\ndidUpdateWidget with a new stream\nthe InheritedWidget updated\nwe called setState\n\nThis is currently unsolvable with Property or onDispose",
                "createdAt": "2020-08-09T03:50:01Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev Can you enumerate \"the readability and robustness benefits requested\"? If someone makes a proposal that handles AnimationController with those readability and robustness benefits, then we're done here?\n@rrousselGit I'm not advocating Property, as you've said before that it doesn't solve your problems. But if someone were to create a solution that did everything that StreamBuilder does, but without the indentation, would that be it? You'd be happy?",
                "createdAt": "2020-08-09T03:57:23Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "But if someone were to create a solution that did everything that StreamBuilder does, but without the indentation, would that be it? You'd be happy?\n\nMost likely, yes\nWe'd need to compare this solution to other solutions of course. But that would reach the acceptable level.",
                "createdAt": "2020-08-09T03:58:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@esDotDev Can you enumerate \"the readability and robustness benefits requested\"?\n\nRobustness in that it can fully encapsulate the boilerplate around dependencies and lifecycle. ie. I should not have to tell fetchUser every single time, that it should probably rebuild when id changes, it knows to do that internally. Should not have to tell an Animation to dispose itself everytime it's parent Widget is disposed, etc. (I don't fully understand whether Property can do this tbh). This stops developers from making mistakes for rote tasks, all across the code base (one of the main benefits of using Builders currently imo)\nReadability being that we can get the stateful thing with a single line of non-indented code, and the variable for the thing is hoisted and clearly visible.\n\n@esDotDev If someone makes a proposal that handles AnimationController with those readability and robustness benefits, then we're done here?\n\nIf you mean specifically AnimationController no. If you mean any AnimationController/FocusController/TextEdiitingController-like object, then yes.",
                "createdAt": "2020-08-09T04:08:40Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Having a function-like API that returns a value that has a defined life-time that isn't clear is\n\nI think this is a key mis-understanding. The life-time of a hook is clear, because they are by definition sub-states. They always exist for the lifetime of the State which \"uses\" them. It could not actually be more clear. The syntax is maybe weird and unfamiliar, but it's certainly not lacking clarity.\nSimilar to how the lifetime of a TweenAnimationBuilder() is also clear. It will go away when it's parent goes away. Like a child widget, these are child states. They are fully independent state \"components\", we can assemble and re-use with ease and we explicitly do not manage their lifetime because we want it to naturally be bound to the state in which it's declared, a feature not a bug.",
                "createdAt": "2020-08-09T04:21:55Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev\n\netc\n\nCan you be more specific? (This is why I suggested coming up with a demo application that covered all the bases. I continue to think that's the best way to do this.) Are there features that matter other than only calling the initializer unless the configuration has changed and automatically disposing allocated resources when the host element is disposed?\n\nTextEdiitingController-like object\n\nCan you be more specific? Is TextEditingController more elaborate than AnimationController in some way?\n\n@rrousselGit\n\n\nBut if someone were to create a solution that did everything that StreamBuilder does, but without the indentation, would that be it? You'd be happy?\n\nMost likely, yes\n\nHere is a solution that does everything StreamBuilder does, without any of the indenting:\nWidget build(context) {\n  var result = Text('result:');\n  var builder1 = (BuildContext context, AsyncSnapshot<int> snapshot) {\n    return Row(children: [result, Text(snapshot.data)]);\n  };\n  result = StreamBuilder(stream: _stream1, builder: builder1);\n  var builder2 = (BuildContext context, AsyncSnapshot<int> snapshot) {\n    return Column(children: [result, Text(snapshot.data)]);\n  };\n  result = StreamBuilder(stream: _stream2, builder: builder2);\n}\nI'm guessing this violates some other constraint, though. Which is why I would prefer to have something we can all agree is a full description of the problem before we try to solve it.",
                "createdAt": "2020-08-09T04:24:09Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "It is simply the same constraints builders have @Hixie no one is asking for more than that. A builder can tie into widget.whatever, a builder can fully manage whatever internal state is required in the context of the widget tree. That is all a hook can do, and all that anyone is asking for a micro-state or whatever you want to call it.\n\n\nCan you be more specific? Is TextEditingController more elaborate than AnimationController in some way?\n\n\nNo, but it might do different things in init/dispose, or it will bind to different properties, and that I would want to encapsulate that specific boilerplate.",
                "createdAt": "2020-08-09T04:29:54Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev So you want the same thing as a builder, but without the indenting, and on one line (minus the builder callback itself, presumably)? The example I just posted (#51752 (comment)) does that with builders today, so presumably there are additional constraints beyond that?",
                "createdAt": "2020-08-09T04:32:54Z"
            },
            {
                "author": "Hixie",
                "bodyText": "(FWIW, I don't think builders, or something like builders but on one line, are a good solution, because they require that each data type have its own builder created for it; there's no good way to just build one on the fly.)",
                "createdAt": "2020-08-09T04:34:24Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "(FWIW, I don't think builders, or something like builders but on one line, are a good solution, because they require that each data type have its own builder created for it; there's no good way to just build one on the fly.)\n\nI don't understand what this means. Could you rephrase it? \ud83d\ude4f",
                "createdAt": "2020-08-09T04:38:50Z"
            },
            {
                "author": "Hixie",
                "bodyText": "You have to create an AnimationBuilder for Animations and a StreamBuilder for Streams and so on. Instead of just having a single Builder and saying \"here's how you get a new one, here's how you dispose it, here's how you get the data out\" etc when you create your StatefulWidget.",
                "createdAt": "2020-08-09T04:42:11Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I'm guessing this violates some other constraint, though. Which is why I would prefer to have something we can all agree is a full description of the problem before we try to solve it.\n\nI think it fairly obviously violates any request for readable code, which is ultimately the goal here, otherwise we'd all just use a million specifically typed-builders, nest em forever, and call it a day.\nI think what is being requested is some thing like (bear with me, I don't, use Streams much):\nWidget build(context) {\n   var snapshot1 = get AsyncSnapshot<int>(stream1);\n   var snapshot2 = get AsyncSnapshot<int>(stream2);\n   return Column(children: [Text(snapshot1.data), Text(snapshot2.data)]);\n}\n\nThis is all the code. There would be nothing more, as the Stream is created for us, the stream is disposed for us, we cant shoot ourselves in the foot AND the code is vastly more readable.",
                "createdAt": "2020-08-09T04:44:13Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "You have to create an AnimationBuilder for Animations and a StreamBuilder for Streams and so on.\n\nI don't see that as an issue. We have RestorableInt vs RestorableString vs RestorableDouble already\nAnd generics can solve that:\nGenericBuilder<Stream<int>>(\n  create: (ref) {\n    var controller = StreamController<int>();\n    ref.onDispose(controller.close);\n    return controller.stream;\n  }\n  builder: (context, Stream<int> stream) {\n\n  }\n)\nSimilarly, Flutter or Dart could include a Disposable interface if that really is a problem.",
                "createdAt": "2020-08-09T04:45:41Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev\n\nI think what is being requested is some thing like:\n\nThat would violate some of the pretty reasonable constraints others have listed (e.g. @Rudiksz), namely guaranteeing that no initialization code ever happens during the call to the build method.\n@rrousselGit\n\nI don't see that as an issue. We have RestorableInt vs RestorableString vs RestorableDouble already\n\nAnd we have AnimationBuilder and StreamBuilder and so on, yes. In both cases it is unfortunate.\n\nGenericBuilder\n\nThat's similar to what I proposed for Property, but if I understood your concerns there you believed that to be too verbose.\nEarlier, you said that if someone were to create a solution that did everything that StreamBuilder does, but without the indentation, you'd likely be happy. You haven't commented on my attempt at doing that (#51752 (comment)). Are you happy with that solution?",
                "createdAt": "2020-08-09T04:53:34Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@esDotDev\n\nI think what is being requested is some thing like:\n\nThat would violate some of the pretty reasonable constraints others have listed (e.g. @Rudiksz), namely guaranteeing that no initialization code ever happens during the call to the build method.\n\nIt is not important that this code be in build. The important part is that\n\nI am not forced to indent my tree, or add a ton of extra lines.\nThe lifecycle code specific to this thing is encapsulated.\n\nThis would be amazing:\nAsyncSnapshot<int> snapshot1 = createLifecycleState(widget.stream1);\nAsyncSnapshot<int> snapshot2 = createLifecycleState(widget.stream2);\nAniamtorController animator = createLifecycleState(duration: Duration(seconds: 1), (a)=>a.forward());\n   \nWidget build(context) {\n   return Opacity(opacity: animator.value, child: Column(children: [Text(snapshot1.data), Text(snapshot2.data)]));\n}\n\nOr, not as succint, but still way more readable than using builders, and less verbose & error prone than doing it directly:\nAsyncSnapshot<int> stream1;\nAsyncSnapshot<int> stream2;\n@override \nvoid initState(){\n    snapshot1 = createLifecycleState(widget.stream1);\n    snapshot2 = createLifecycleState(widget.stream2);\n   super.initState();\n}\n   \nWidget build(context) {\n   return Column(children: [Text(snapshot1.data), Text(snapshot2.data)]);\n}",
                "createdAt": "2020-08-09T05:05:26Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I don't understand why we keep coming back to verbosity.\nI explicitly said multiple times that it is not the problem and that the problem is reusability vs readability vs flexibility.\nI even made a grid to evaluate the solution #51752 (comment) and a test case #51752 (comment)\n\n\nEarlier, you said that if someone were to create a solution that did everything that StreamBuilder does, but without the indentation, you'd likely be happy. You haven't commented on my attempt at doing that (#51752 (comment)). Are you happy with that solution?\n\nThat reaches the minimum acceptable level of flexibility.\nEvaluating it as per #51752 (comment) gives:\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nThe default syntax (StreamBuilder without hacking) is less error prone. This solution doesn't avoid mistakes, it creates some \u274c\nIs it more readable?\nIt clearly isn't more readable \u274c\nIs it easier to write?\nIt isn't easy to write \u274c\n\n\nHow reusable is the code produced?\nStreamBuilder isn't tied to the Widget/State/life-cycles, so this pass \u2705\nHow many problems can be solved with this API?\nWe can make custom builders, and use this pattern. So this pass. \u2705\nDo we lose some benefits for some specific problems?\nNo, the syntax is relatively consistent. \u2705",
                "createdAt": "2020-08-09T05:09:20Z"
            },
            {
                "author": "szotp",
                "bodyText": "This feature IMO could extend to all builder widgets, including LayoutBuilder for example.\nThere needs to be a way to disable listening, so that you can create 10x controllers and pass them to leafs for rebuilding, or flutter needs to somehow know which part of the tree used the value obtained by the builder.\nUsing this should not be much more verbose that hooks.\nCompiler must be extended to handle this properly.\nDebugging helpers are needed. Let's say that you put breakpoins in one of your widgets that uses this. When reaching a breakpoint inside a build method, because one of the builders got triggered, IDE could display extra info for each builder that was used:\n\nWidget build(context) {\n   // this builder is not highlighted, but you can hover over it to see how often it rebuilds, how heavy were those rebuilds, and when was the last rebuild\n   var snapshot1 = keyword StreamBuilder(stream1);\n   // this builder will be highlighted because it triggered the rebuild\n   var constraints = keyword LayoutBuilder(); \n\n   // <-- I had a breakpoint here and parent constraint changed, breakpoints got reached.\n   return Column(children: [Text(snapshot1.data), Text(snapshot2.data)]);\n}\nAlso, @Hixie\n\nThat would violate some of the pretty reasonable constraints others have listed (e.g. @Rudiksz), namely guaranteeing that no initialization code ever happens during the call to the build method.\n\nWe are already implictly doing that by using *Builders. We just need a syntax sugar to deindent them. It's a lot like async/await and futures, I think.",
                "createdAt": "2020-08-09T05:17:36Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev What you describe sounds very similar to what I proposed earlier with Property (see e.g. #51752 (comment) or #51752 (comment)). Is there something that prevents this kind of solution from being created as a package? That is, what change would the core framework need to have made to it to allow you to use this kind of feature?\n@rrousselGit As with Shawn I would ask you the same thing then. If the only difference between the current StreamBuilder feature and one that would satisfy your needs is a different syntax, what is it that you require of the core syntax to enable you to use such a feature? Would it not be sufficient to just create the syntax you would prefer and use that?\nThe problem I have with your grid is that if I were to apply it to the solutions so far I would get this, which I assume is very different than what you would get:\nStatefulWidget\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nIt's the same as the default syntax, which isn't particularly error-prone. \ud83d\udd37\nIs it more readable?\nIt's the same, so it's equally readable, which is reasonably readable. \ud83d\udd37\nIs it easier to write?\nIt's the same, so it's equally easy to write, which is reasonably easy. \ud83d\udd37\n\n\nHow reusable is the code produced?\nThere is very little code to reuse. \u2705\nHow many problems can be solved with this API?\nThis is the baseline. \ud83d\udd37\nDo we lose some benefits for some specific problems?\nDoesn't seem that way. \u2705\n\nVariations on Property\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nIt moves the code to a different place, but doesn't particularly reduce the number of mistakes. \ud83d\udd37\nIs it more readable?\nIt puts initialization code and cleanup code and other lifecycle code in the same place, so it's less clear. \u274c\nIs it easier to write?\nIt mixes initialization code and cleanup code and other lifecycle code, so it's harder to write. \u274c\n\n\nHow reusable is the code produced?\nExactly as reusable as StatefulWidget, just in different places. \u2705\nHow many problems can be solved with this API?\nThis is syntactic sugar for StatefulWidget, so no difference. \ud83d\udd37\nDo we lose some benefits for some specific problems?\nPerformance and memory usage would suffer slightly. \u274c\n\nVariations on Builders\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nIt is basically the StatefulWidget solution but factored out; mistakes should be about equivalent. \ud83d\udd37\nIs it more readable?\nBuild methods are more complex, rest of logic moves to a different widget, so about the same. \ud83d\udd37\nIs it easier to write?\nHarder to write the first time (creating the builder widget), mildly easier thereafter, so about the same. \ud83d\udd37\n\n\nHow reusable is the code produced?\nExactly as reusable as StatefulWidget, just in different places. \u2705\nHow many problems can be solved with this API?\nThis is syntactic sugar for StatefulWidget, so mostly no difference. In some aspects it's actually better, for example, it reduces the amount of code that has to run when handling a dependency change. \u2705\nDo we lose some benefits for some specific problems?\nDoesn't seem that way. \u2705\n\nHook-like solutions\n\nIs the resulting code objectively better than the default syntax?\n\nDoes it avoid mistakes?\nEncourages bad patterns (e.g. construction in the build method), risks bugs if accidentally used with conditionals. \u274c\nIs it more readable?\nIncreases the number of concepts that must be known to understand a build method. \u274c\nIs it easier to write?\nDeveloper has to learn to write hooks, which is a new concept, so harder. \u274c\n\n\nHow reusable is the code produced?\nExactly as reusable as StatefulWidget, just in different places. \u2705\nHow many problems can be solved with this API?\nThis is syntactic sugar for StatefulWidget, so no difference. \ud83d\udd37\nDo we lose some benefits for some specific problems?\nPerformance and memory usage suffer. \u274c\n\n\nI don't understand why we keep coming back to verbosity.\nI explicitly said multiple times that it is not the problem and that the problem is reusability vs readability vs flexibility.\n\nApologies, I misremembered who it was who said that Property was too verbose. You're right, your concern was just that there was a new use case that hadn't been listed before that it didn't handle, though I think it would be trivial to extend Property to handle that use case as well (I haven't tried, it seems better to wait until we have a clear demo app so that we can solve things once and for all rather than have to iterate repeatedly as the requirements are adjusted).\n@szotp\n\n\nThis feature IMO could extend to all builder widgets, including LayoutBuilder for example.\n\n\nLayoutBuilder is a very different widget than most builders, FWIW. None of the proposals that have been discussed so far would work for LayoutBuilder-like problems, and none of the requirements described before your comment include LayoutBuilder. If we should also use this new feature to handle LayoutBuilder that's important to know; I recommend working with @TimWhiting to make sure the sample app we're going to base proposals on includes layout builders as an example.\n\n\nThere needs to be a way to disable listening, so that you can create 10x controllers and pass them to leafs for rebuilding, or flutter needs to somehow know which part of the tree used the value obtained by the builder.\n\n\nI'm not sure exactly what this means. As far as I can tell, you can do this today with listeners and builders (e.g. I use ValueListenableBuilder in the app I cited earlier to do exactly this).\n\n\nThat would violate some of the pretty reasonable constraints others have listed (e.g. @Rudiksz), namely guaranteeing that no initialization code ever happens during the call to the build method.\n\nWe are already implictly doing that by using *Builders.\n\nI don't think that's accurate. It depends on the builder, but some work very hard to separate initState, didChangeDependencies, didUpdateWidget, and build logic, so that only the minimum amount of code needs to run each build based on what has changed. For example, ValueListenableBuilder only registers the listeners when first created, its builder can rerun without either the parent or the initState of the builder rerunning. This is not something Hooks can do.",
                "createdAt": "2020-08-09T05:39:54Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@esDotDev What you describe sounds very similar to what I proposed earlier with Property (see e.g. #51752 (comment) or #51752 (comment)).\n\nIf I understand right, we could make UserProperty that automatically handles the DidDependancyChange for UserId, or AnimationProperty, or any other property we need to handle the init/update/dispose for that type? Then this seems nice to me. The most common use cases could quickly be created.\nThe only thing throwing me off is the future builder here. But I think this is just due to the example you've chosen?\nFor example, could I create this?\nclass _ExampleState extends State<Example> with PropertyManager {\n  AnimationProperty animProp1;\n  AnimationProperty animProp2;\n\n  @override\n  void initProperties() {\n    super.initProperties();\n    anim1= register(anim1, AnimationProperty (\n      AnimationController(duration: Duration(seconds: 1)),\n      initState: (animator) => animator.forward()\n      // Not dealing with updates or dispose here, cause AnimationProperty handles it\n    ));\n   anim2 = register(anim2, AnimationProperty(\n       AnimationController(duration: Duration(seconds: 2))..forward(),\n   ));\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(children: [\n       FadeTransition(opacity: anim1, child: ...),\n       FadeTransition(opacity: anim2, child: ...),\n   ])\n  }\n}\n\nIf so, this totally LGTM! In terms of adding to framework, its a case of whether this should be promoted to a first class syntactical approach (which means it becomes general practice in a year or so), or whether it exists as a plugin that some single digit percentage of developers use.\nIt's a matter of whether you want to be able to update the verbose and (slightly?) error prone examples with a better more concise syntax. Having to manually sync properties and manually dispose() things, does lead to bugs, and cognitive load.\nImo it would be nice if a developer could use animators, with proper didUpdate and dispose and debugFillProperties and the whole works, without ever having to think twice about it (exactly like we do when  we use TweenAnimationBuilder now, which is the main reason we recommend all our developers default to using it over manually managing Animators).",
                "createdAt": "2020-08-09T06:09:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "If so, this totally LGTM! In terms of adding to framework, its a case of whether this should be promoted to a first class syntactical approach (which means it becomes general practice in a year or so), or whether it exists as a plugin that some single digit percentage of developers use.\n\nGiven how trivial Property is, my recommendation to someone who likes that style would be to just create their own (maybe starting with my code if that helps) and using it directly in their app as they see fit, adjusting it to address their needs. It could be made into a package if lots of people like it, too, though again for something that trivial it's not clear to me how much that's beneficial vs just copying it into one's code and adjusting it as needed.\n\nThe only thing throwing me off is the future builder here. But I think this is just due to the example you've chosen?\n\nI was trying to address an example @rrousselGit gave. In principle it can be adapted to work for anything.\n\nFor example, could I create this?\n\nYou'd want to move the AnimationController constructor into a closure that would be called, rather than calling it every time, since initProperties is called during hot reload to get the new closures but typically you don't want to create a new controller during hot reload (e.g. it would reset animations). But yes, other than that it seems fine. You could even make an AnimationControllerProperty that takes the AnimationController constructor arguments and does the right thing with them (e.g. updating the duration on hot reload if it changed).\n\nImo it would be nice if a developer could use animators, with proper didUpdate and dispose and debugFillProperties and the whole works, without ever having to think twice about it (exactly like we do when we use TweenAnimationBuilder now, which is the main reason we recommend all our developers default to using it over manually managing Animators).\n\nMy worry about having developers not think about it is that if you don't think about when things are allocated and disposed you're more likely to end up allocating a lot of things you don't always need, or running logic that doesn't need to run, or doing other things that lead to less efficient code. That's one reason I'd be reluctant to make this a default recommended style.",
                "createdAt": "2020-08-09T06:20:30Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "You could even make an AnimationControllerProperty that takes the AnimationController constructor arguments and does the right thing with them (e.g. updating the duration on hot reload if it changed).\n\n\nThanks @Hixie that's really cool and I think addresses the issue quite well.\nI'm not suggesting devs should never think about these things, but I think the 99% use case these things are almost always bound to the StatefulWidget they are used in, and doing anything other than that is already bringing you into intermediate developer land.\nAgain, I don't see how this is fundamentally any different than recommending TweenAnimationBuilder over raw AnimatorController. It's basically the idea that IF you want the state wholly contained/managed within this other state (and that is usually what you want), then do it this way its simpler and more robust.",
                "createdAt": "2020-08-09T06:23:34Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "At this point, we should organize a call and discuss it together with the different interested parties.\nBecause this discussion isn't progressing, as we are answering the same question over and over.\nI don't understand how after such a long discussion, with so many arguments made, we can still argue that Builders do not avoid mistakes compared to StatefulWidget, or that hooks aren't more reusable than raw StatefulWidgets.\nThat is especially frustrating to argue considering all the major declarative frameworks (React, Vue, Swift UI, Jetpack Compose) have one way or another to natively solve this problem.\nIt seems like only Flutter refuses to consider this problem.",
                "createdAt": "2020-08-09T06:26:05Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev The main reason IMHO to use an AnimationBuilder or TweenAnimationBuilder or ValueListenableBuilder is that they rebuild only when the value changes, without rebuilding the rest of their host widget. It's a performance thing. It's not really about verbosity or code reuse. I mean, it's fine to use them for those reasons too, if you find them useful for those reasons, but that's not the main use case, at least for me. It's also something that Property (or Hooks) doesn't give you. With those, you end up rebuilding the entire widget when something changes, which is not good for performance.\n@rrousselGit\n\nIt seems like only Flutter refuses to consider this problem.\n\nI've spent literally hours of my own time this weekend, not to mention many hours of Google's time before that, considering this problem, describing possible solutions, and trying to drawn out precisely what we're trying to solve. Please don't confuse lack of understanding over what is a problem with refusal to consider it. Especially when I've already described the best thing that can be done to move this forward (creating a demo app that has all the state logic that is \"too verbose or too difficult\", to quote the issue title, to reuse), which others on this bug have taken on as a task, and which you have refused to participate in.",
                "createdAt": "2020-08-09T06:43:36Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The main reason IMHO to use an AnimationBuilder or TweenAnimationBuilder or ValueListenableBuilder is that they rebuild only when the value changes, without rebuilding the rest of their host widget. It's a performance thing. \nInteresting. For us we really have never measured or observed an improvement in performance from saving small rebuilds like this. It's much more important over a large app code base to keep the code succinct, readable, and free of any routine errors that can happen when you're kicking out hundreds of class files every couple of weeks.\nFrom our experience the cost of repainting the pixels, which seems to happens to the full tree unless you are purposeful about defining your RepaintBoundaries, is vastly more important a factor in realworld performance than partial widget layout costs. Especially when you get into 4k monitor range.\nBut this is a good example of when builders actually make sense for this sort of thing. If I want to create a sub-context, then a builder makes sense and is a nice way to get there.\nMany times we do not, and in this case, Builder is just adding clutter, but we accept it, cause the alternative is just a different type of clutter, and at least with Builder, things are more or less guaranteed bug free. In cases where the entire view rebuilds, or there is not necessarily view rebuilds at all (TextEditingController, FocusController) using a builder makes little sense, and in all cases, rolling the boilerplate by hand is fundamentally not DRY.",
                "createdAt": "2020-08-09T07:02:28Z"
            },
            {
                "author": "Hixie",
                "bodyText": "It's certainly very situation-specific, as performance issues often are. I think it makes sense for people to use something like Hooks or Property if they like that style. That's possible today and doesn't seem to need anything extra from the framework (and as Property shows, it really doesn't require much code).",
                "createdAt": "2020-08-09T07:08:38Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "No, but its a bit like asking the community to build TweenAnimationBuilder and ValueListenableBuilder and not providing them a StatefulWidget to build on.\nNot that you are asking, but one of the primary benefits of this type of architecture is that it naturally lends itself to tiny little components that can be easily shared. If you put one little foundational piece in place...",
                "createdAt": "2020-08-09T07:11:34Z"
            },
            {
                "author": "Hixie",
                "bodyText": "StatefulWidget is a lot of code, compared to Property, and it's non-trivial (unlike Property, which is mostly glue code). That said, if Property is something that makes sense to reuse widely (as opposed to crafting bespoke versions for each application or team based on its precise needs), then I would encourage someone who advocates for its use to make a package and upload it to pub. The same applies, indeed, to Hooks. If it is something the community likes then it will see a lot of use, just like Provider. It's not clear why we would need to put something like that in the framework itself.",
                "createdAt": "2020-08-09T07:17:23Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I guess because this is inherently extensible. Provider is not, it's just a simple tool. This is something that is made to be extended, just like StatefulWidget, but for StatefulComponents. The fact it is relatively trivial should not necessarily be held against it?\nA note on \"those who prefer this style\". If you can save 3 overrides and 15-30 lines, that is just going to be a readability win in most cases. Objectively speaking imo. It also objectively eliminates 2 entire classes of errors (forgetting to dispose things, forgetting to update deps).\nThanks so much for the awesome discussion, excited to see where this goes, I'll definitely leave it here :)",
                "createdAt": "2020-08-09T07:29:55Z"
            },
            {
                "author": "emanuel-lundman",
                "bodyText": "I'm sorry to say this thread makes me disillusioned getting back into flutter which was the plan when finishing up another project I'm working on. I also feel the frustration because of\n\nThat is especially frustrating to argue considering all the major declarative frameworks (React, Vue, Swift UI, Jetpack Compose) have one way or another to natively solve this problem.\n\nI agree with @rrousselGit in that I don't think we should spend time building flutter example apps since the issue has been described clearly over and over again in this thread. I can't see how it would not just get the same response. Because it will be the same things been presented here. My take of this thread is that from a flutter frameworks point of view it's better for flutter developers to repeat the same lifetime code in multiple widgets instead of just writing it once and be done with it.\nAlso, we can't write an app in flutter if we are looking for a solution since we need the solutions to write an app. Since the flutter people in this conversation at least have been pretty clear they don't like hooks. And Flutter just don't have another solution to the problem as described in the OP. How should it even be written.\nFeels (at least to me) that this isn't taken seriously, I'm sorry @Hixie, I mean it's not taken seriously in the sense of:  We understand the problem and want to solve it.  Like other declarative frameworks apparently seem to have done.\nOn another but kind of the same note things like this:\n\nIs it easier to write?\nDeveloper has to learn to write hooks, which is a new concept, so harder\n\nMakes me sad. Why improve or change anything ever? you could always make that argument no matter what. Even if the new solutions are much easier and pleasant once learned. You can replace hooks in that statement with many things. My mother could have used that kind of sentence about microwaves 30 years ago. It e.g. works the same if you replace \"hooks\" in the sentence with \"flutter\" or \"dart\".\n\nIs it easier to write?\nIt's the same, so it's equally easy to write, which is reasonably easy\n\nI don't think what @rrousselGit mean with is it easier to write? (a boolean answer question) was that if it's the same the answer is not false/undefined.\nI can't see how we will ever be able to get somewhere since we don't even agree there is a problem, only that a lot of people find this a problem. E.g:\n\nIt's certainly something people have brought up. It's not something I have a visceral experience with. It's not something I've felt was a problem when writing my own apps with Flutter. That doesn't mean that it's not a real problem for some people, though.\n\nAnd even though many have provided lots of arguments many times why a solution to the OP needs to be in core.\nE.g. it needs to be in core to make third parties able to use it just as easily and naturally as they use and create widgets today. And a multiple of other reasons. The mantra seems to be, just put in a package. But there already are packages as the hooks one. If that's what's been settled on then why not just close the thread.\nI really hope you take @rrousselGit up on his offer and organize a call, maybe it will be easier to have a realtime discussion about this instead of writing stuff back and fort back and forth all the time. If any folks from the other frameworks that have solved the issue described in the OP, if one of them is really kind maybe they could get into the call for awhile as well and share they 5-cents about stuff that comes up. One could always ask.\nAnyway, I'm unsubscribing now since I get a bit sad live-following this thread since I don't see it going anywhere. But I do hope this thread will get to the state of agreeing there is a problem so that it can focus on possible solutions to the OP. Since it seems a bit futile to propose solutions if you don't grasp the problem people are facing, as @Hixie probably agrees, I mean, since the people with the problems will tell you why the solution doesn't work afterwards.\nI really do wish you the best of luck in ending this thread either by just flatly saying flutter shouldn't solve this problem in core despite people wanting it. Or by finding a solution. \ud83d\ude18",
                "createdAt": "2020-08-09T08:07:07Z"
            },
            {
                "author": "szotp",
                "bodyText": "LayoutBuilder is a very different widget than most builders, FWIW. None of the proposals that have been discussed so far would work for LayoutBuilder-like problems, and none of the requirements described before your comment include LayoutBuilder. If we should also use this new feature to handle LayoutBuilder that's important to know; I recommend working with @TimWhiting to make sure the sample app we're going to base proposals on includes layout builders as an example.\n\n@Hixie Yes, we definitely need some samples. I'll prepare something (but I still think that compiler changes are needed so the sample may be incomplete). The general idea is - a syntax sugar that flattens builders and does not care about how the builder is implemented.\nStill, I'm getting impression than nobody at Flutter team took a deeper look at SwiftUI, I think our concerns would be easy to understand otherwise. It's important for the future of framework that people migrating from other platforms have as smooth ride as possible, and so, good understanding of other platforms is needed, and knowledge of pros & cons. And seeing if some of Flutter's cons could be fixed. Obviously Flutter took a lot of good ideas from React and I could do the same with newer frameworks.",
                "createdAt": "2020-08-09T08:11:51Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@emanuel-lundman\n\nFeels (at least to me) that this isn't taken seriously, I'm sorry @Hixie, I mean it's not taken seriously in the sense of: We understand the problem and want to solve it. Like other declarative frameworks apparently seem to have done.\n\nI completely agree that I don't understand the problem. That's why I keep engaging on this issue, trying to understand it. It's why I've suggested creating a demo app that encapsulates the problem. Whether it's something that in the end we decide to fix by fundamentally changing the framework, or by adding a small feature to the framework, or by a package, or not at all, really depends on what the problem actually is.\n@szotp\n\nStill, I'm getting impression than nobody at Flutter team took a deeper look at SwiftUI, I think our concerns would be easy to understand otherwise.\n\nI've studied Swift UI. It's certainly less verbose to write Swift UI code than Flutter code, but the readability cost is very high IMHO. There's a lot of \"magic\" (in the sense of, logic that works in ways that are not obvious in the consumer code). I can totally believe that it is a style that some people prefer, but I also believe that one of the strengths of Flutter is that it has very little magic. That does mean that you write more code sometimes, but it also means that debugging that code is much easier.\nI think there's room for lots of styles of frameworks. MVC-style, React-style, super terse magical, magic-free but verbose... One of the advantages of Flutter's architecture is that the portability aspect is entirely separate from the framework itself, so it is possible to leverage all of our tooling -- cross platform support, hot reload, etc -- but create an entirely new framework. (There are other Flutter frameworks, e.g. flutter_sprites, already.) Similarly the framework itself is designed in a layered fashion so that for example you can reuse all of our RenderObject logic but with a replacement for the Widgets layer, so if the verbosity of the Widgets is too much, someone could create an alternative framework that replaces it. And of course there's the packaging system so features can be added without losing any of the existing framework code.\nAnyway, the point of my digression here is just that this is not all-or-nothing. Even if on the long term we don't end up adopting a solution that makes you happy, that doesn't mean you can't continue to benefit from the parts of the offering that you do like.\n\nI urge people interested in this problem to work with @TimWhiting to create an app that demonstrates why you would want to reuse code and what it looks like today when you can't (https://github.com/TimWhiting/local_widget_state_approaches). This will directly help us create proposals for how to address this problem in a way that addresses the needs of all the people who are commenting here (including those who like Hooks and those who do not like Hooks).",
                "createdAt": "2020-08-09T08:43:44Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "It can't really be so hard to understand why \"a syntax sugar that flattens builders and does not care about how the builder is implemented.\" is desired by devs as a first class feature. We've outlined the issues with the alternative approaches over and over.\nIn short, builders solve the re-usability issue, but are hard to read and compose. The \"problem\" is simply that we would like builder-like functionality that is significantly easier to read.\nNo app can show that more clearly, if you just fundamentally don't agree that 3 nested builders are hard to read, or that builders in general do not really serve a code-reuse purpose. More important to just hear that many of us do in fact really like to cut down on nesting, and really do not like to duplicate code all over our application, and so we are stuck between 2 non-ideal options.",
                "createdAt": "2020-08-09T09:08:41Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I've spent literally hours of my own time this weekend, not to mention many hours of Google's time before that, considering this problem, describing possible solutions, and trying to drawn out precisely what we're trying to solve\n\nI'm grateful for that\n\nPlease don't confuse lack of understanding over what is a problem with refusal to consider it\n\nI am fine with a lack of understanding, but the current situation seems hopeless.\nWe are still debating about points that were made at the very beginning of the discussion.\nFrom my perspective, I feel like I spent hours writing detailed comments showcasing the different problems and answering questions, but my comments were dismissed and the same question was asked again.\nFor example, the lack of readability of the current syntax is at the center of the discussion.\nI made several analyses of the readability problem to back this up:\n\n#51752 (comment)\n#51752 (comment)\n\nThese analyses have a significant number of \ud83d\udc4d and other peoples seem to agree\nAnd yet according to your recent answer, there is no readability issue: #51752 (comment)\nYou also suggested:\nWidget build(context) {\n  var result = Text('result:');\n  var builder1 = (BuildContext context, AsyncSnapshot<int> snapshot) {\n    return Row(children: [result, Text(snapshot.data)]);\n  };\n  result = StreamBuilder(stream: _stream1, builder: builder1);\n  var builder2 = (BuildContext context, AsyncSnapshot<int> snapshot) {\n    return Column(children: [result, Text(snapshot.data)]);\n  };\n  result = StreamBuilder(stream: _stream2, builder: builder2);\n}\nknowing that this isn't readable\nFrom these two comments, we can conclude that:\n\nwe disagree that there is a readability issue\nit is still unclear whether readability is part of the scope of this issue or not\n\nThis is disheartening to hear, considering the sole purpose of hooks is to improve the syntax of Builders \u2013 which are at the peak of reusability but have a poor readability/writability\nIf we don't agree on such basic fact, I am not sure what we can do.",
                "createdAt": "2020-08-09T09:10:41Z"
            },
            {
                "author": "szotp",
                "bodyText": "@Hixie thanks, this helps a lot to understand your point of view. I agree that they may have went way overboard with code magic, but I'm sure there are at least few things that they got right.\nAnd I very much like Flutter's layered architecture. I would also like to keep using widgets. So perhaps the answer is to just improve extensibility of Dart & Flutter, which for me would be:\nMake code generation more seamless - it may be possible to implement SwiftUI magic in Dart, but the usual setup required is just too big and too slow.\nIf using code generation was as simple as importing package and slapping some annotations, then people who have the discussed issue would just do that and stop complaining. The rest would continue using good old StatefulWidgets directly.\nEDIT: I think flutter generate was a step in good direction, shame that it got removed.",
                "createdAt": "2020-08-09T09:22:26Z"
            },
            {
                "author": "jamesblasco",
                "bodyText": "I think this would be a very interesting question to ask in the next Flutter Developer Survey.\nIt would be a good start. Divide this problem in different parts/questions and see if this is a real problem that Flutter developers wish to be solved.\nOnce that it is clear, this conversation will be more fluent and enriching",
                "createdAt": "2020-08-09T09:29:32Z"
            },
            {
                "author": "Hixie",
                "bodyText": "From my perspective, I feel like I spent hours writing detailed comments showcasing the different problems and answering questions, but my comments were dismissed and the same question was asked again.\n\nIf I'm asking the same questions it's because I don't understand the answers.\nFor example, going back to your earlier comment (#51752 (comment)):\n\nThe problem debated is:\nWidget build(context) {\n  return ValueListenableBuilder<String>(\n    valueListenable: someValueListenable,\n    builder: (context, value, _) {\n      return StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) {\n          return TweenAnimationBuilder<double>(\n            tween: Tween(...),\n            builder: (context, value3) {\n              return Text('$value $value2 $value3');\n            },\n          );\n        },\n      );\n    },\n  );\n}\nThis code is not readable.\n\nI really don't see what isn't readable about it. It explains exactly what is happening. There's four widgets, three of the widgets have builder methods, one just has a string. I would personally not omit the types, I think that makes it harder to read because I can't tell what the variables all are, but it's not a huge problem.\nWhy is this unreadable?\nTo be clear, clearly you do find it unreadable, I'm not trying to say that you're wrong. I just don't understand why.\n\nWe could fix the readability issue by introducing a new keyword which changes the syntax into:\nWidget build(context) {\n  final value = keyword ValueListenableBuilder(valueListenable: someValueListenable);\n  final value2 = keyword StreamBuilder(stream: someStream);\n  final value3 = keyword TweenAnimationBuilder(tween: Tween(...));\n\n  return Text('$value $value2 $value3');\n}\nThis code is significantly more readable, is unrelated to hooks, and doesn't suffer from its limitations.\n\nIt's certainly less verbose. I'm not sure it's any more readable, at least for me. There are more concepts (now we have both widgets and this \"keyword\" feature); more concepts means more cognitive load. (It's also potentially less efficient, depending on how much these objects are independent; e.g. if the animation always changes more often than the value listenable and stream, now we're rebuilding the ValueListenableBuilder and the StreamBuilder even though normally they wouldn't be triggered; also the initializer logic now has to be entered and skipped every build.)\nYou've said that the verbosity is not the issue, so it being more terse isn't why it's more readable, I assume (though I'm confused about this too since you did put \"too verbose\" in the issue title and in the issue's original description). You mentioned wanting less indenting, but you described the version of using builders without indenting as unreadable as well, so presumably it's not the indenting in the original that is the problem.\nYou say that builders are the peak of reusability and that you just want an alternative syntax but the proposals you've suggested aren't anything like builders (they don't create widgets or elements), so it's not specifically the builder aspect that you are looking for.\nYou have a solution that you like (Hooks), which as far as I can tell works great, but you want something changed in the framework so that people will use Hooks? Which I don't understand either, because if people don't like Hooks enough to use it as a package, it is probably not a good solution for the framework either (in general, we're moving more towards using packages, even features the Flutter team creates, for what it's worth).\nI understand that there's a desire for easier code reuse. I just don't know what that means.\nHow does the following compare in readability to the two versions above?\nWidget build(context) {\n  return\n    ValueListenableBuilder(valueListenable: someValueListenable, builder: (context, value, _) =>\n    StreamBuilder(stream: someStream, builder: (context, value2) =>\n    TweenAnimationBuilder(tween: Tween(...), builder: (context, value3) =>\n    Text('$value $value2 $value3'),\n  )));\n}\n@szotp If there is too much friction around our current codegen solution, please don't hesitate to file a bug asking for improvements there.\n@jamesblasco I don't think there's any doubt that there's a real problem here that people want solved. The question for me is exactly what that problem is, so that we can design a solution.",
                "createdAt": "2020-08-09T09:41:51Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I could answer the concerns about the hooks flaws or the desired to be included in the code, but I don't think that's what we should focus on right now.\nWe should first agree on what the problem is. If we don't, I don't see how we could agree on other topics.\n\nI really don't see what isn't readable about it. It explains exactly what is happening. There's four widgets, three of the widgets have builder methods, one just has a string. I would personally not omit the types, I think that makes it harder to read because I can't tell what the variables all are, but it's not a huge problem.\n\nI think a big part of the issue here is that the way you code is drastically different from how most people code.\nFor example, Flutter and the app example you gave both:\n\ndo not use dartfmt\nuse always_specify_types\n\nWith just these two points, I would be surprised if that represented more than 1% of the community.\nAs such what you evaluate as readable is likely very different from what most people think is readable.\n\nI really don't see what isn't readable about it. It explains exactly what is happening. There's four widgets, three of the widgets have builder methods, one just has a string. I would personally not omit the types, I think that makes it harder to read because I can't tell what the variables all are, but it's not a huge problem.\nWhy is this unreadable?\n\nMy recommendation would be to analyze where your eye is looking at when searching for a specific thing, and how many steps it takes to get there.\nLet's make an experiment:\nI will give you two widget trees. One using a linear syntax, the other one with a nested syntax.\nI will also give you specific things you need to look for in that snippet.\nIs it easier to find the answer to using the linear syntax or the nested syntax?\nThe questions:\n\nWhat is the non-builder widget returned by this build method?\nWho creates the variable bar?\nHow many builders do we have?\n\nUsing builders:\n\nWidget build(context) {\n  return ValueListenableBuilder(\n    valueListenable: someValueListenable,\n    builder: (context, foo, _) {\n      return StreamBuilder(\n        stream: someStream,\n        builder: (context, baz) {\n          return TweenAnimationBuilder(\n            tween: Tween(...),\n            builder: (context, bar) {\n              return Container();\n            },\n          );\n        },\n      );\n    },\n  );\n}\n\nUsing a linear syntax:\n\n\nWidget build(context) {\n  final foo = keyword ValueListenableBuilder(valueListenable: someValueListenable);\n  final bar = keyword StreamBuilder(stream: someStream);\n  final baz = keyword TweenAnimationBuilder(tween: Tween(...));\n  return Image();\n}\n\n\n\nIn my case, I have a hard time looking through the nested code to find the answer.\nOn the other hand, finding the answer with the linear tree is instantaneous\n\nYou mentioned wanting less indenting, but you described the version of using builders without indenting as unreadable as well, so presumably, it's not the indenting in the original that is the problem.\n\nWas the StreamBuilder split in multiple variables a serious suggestion?\nFrom my understanding, this was a sarcastic suggestion to make an argument. Was it not? Do you really think that this pattern would lead to more readable code, even on large widgets?\nIgnoring the fact that the example does not work, I don't mind breaking it down to explain why it isn't readable. Would that be valuable?\n\nWidget build(context) {\n return\n   ValueListenableBuilder(valueListenable: someValueListenable, builder: (context, value, _) =>\n   StreamBuilder(stream: someStream, builder: (context, value2) =>\n   TweenAnimationBuilder(tween: Tween(...), builder: (context, value3) =>\n   Text('$value $value2 $value3'),\n )));\n}\n\nThat looks better.\nBut that is assuming people do not use dartfmt\nWith dartfmt, we have:\nWidget build(context) {\n  return ValueListenableBuilder(\n      valueListenable: someValueListenable,\n      builder: (context, value, _) => StreamBuilder(\n          stream: someStream,\n          builder: (context, value2) => TweenAnimationBuilder(\n                tween: Tween(),\n                builder: (context, value3) => Text('$value $value2 $value3'),\n              )));\n}\nwhich is almost no different from the original code.\n\nYou say that builders are the peak of reusability and that you just want an alternative syntax but the proposals you've suggested aren't anything like builders (they don't create widgets or elements), so it's not specifically the builder aspect that you are looking for.\n\nThat's an implementation detail.\nThere's no particular reason for having an element or not.\nIn fact, it may be interesting to have an Element, so that we could include LayoutBuilder and potentially GestureDetector.\nI think it's low priority. But in the React community, among the different hooks libraries, I've seen:\n\nuseIsHovered \u2013 returns a boolean that tells whether the widget is hovered\nuseSize \u2013 (Probably should be useContraints in Flutter) which gives the size of the associated UI.\n\n\n(It's also potentially less efficient, depending on how much these objects are independent; e.g. if the animation always changes more often than the value listenable and stream, now we're rebuilding the ValueListenableBuilder and the StreamBuilder even though normally they wouldn't be triggered; also the initializer logic now has to be entered and skipped every build.)\n\nThat depends on how the solution is solved.\nIf we go for a language fix, this issue would not be a problem at all.\nWe could make that:\nWidget build(context) {\n  final value = keyword ValueListenableBuilder(valueListenable: someValueListenable);\n  final value2 = keyword StreamBuilder(stream: someStream);\n  final value3 = keyword TweenAnimationBuilder(tween: Tween(...));\n\n  return Text('$value $value2 $value3');\n}\n\"compiles\" into:\nWidget build(context) {\n  return ValueListenableBuilder<String>(\n    valueListenable: someValueListenable,\n    builder: (context, value, _) {\n      return StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) {\n          return TweenAnimationBuilder<double>(\n            tween: Tween(...),\n            builder: (context, value3) {\n              return Text('$value $value2 $value3');\n            },\n          );\n        },\n      );\n    },\n  );\n}\nIf we are using hooks, then flutter_hooks comes with a HookBuilder widget, so that we can still split things when we need to.\nSimilarly, it would need proper benchmarks to determine whether it really is an issue, especially in the example made here.\nWith hooks, we are rebuilding only one Element.\nWith Builders the rebuild is split across multiple Elements. That adds some overhead too, even if small.\nIt is not impossible that it is faster to re-evaluate all the hooks. It appears that this was the conclusion the React team they came up with when designing hooks.\nThis may not apply to Flutter though.",
                "createdAt": "2020-08-09T11:14:34Z"
            },
            {
                "author": "mraleph",
                "bodyText": "Why is this unreadable?\n\nBecause of the nesting - nesting makes it harder to quickly scan through and know which parts you can ignore and which are essential for understanding of what is going on. The code is kinda \u201csequential\u201d in nature but nesting hides this. Nesting also makes it hard to work with it - imagine you want to reorder two things - or inject a new thing in between two - trivial in truly sequential code, but hard when you need to work with nesting.\nThis is very similar to async/await sugar vs working with raw Future API, dame continuation based concept underneath (and even arguments for and against are very similar) - yes Future API can be used directly and does not hide anything, but readability and maintainability is certainly not good - async/await is a winner there.",
                "createdAt": "2020-08-09T11:19:48Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "My recommendation would be to analyze where your eye is looking at when searching for a specific thing, and how many steps it takes to get there.\n\nI've been programming for 25 years now in over 10 different languages and that's easily the worse ways to evaluate what makes a code readable. Readability of source code is tricky, but it's more about how well it expresses programming concepts and logic, rather than \"where my eyes are looking\" or how many lines of code it uses.\nOr rather, it seems to me that you guys are focusing too much on readability and less on maintainability.\nYour examples are less readable, because the intent of the code is less evident and different concerns being hidden away into the same place makes it harder to maintain.\n\nfinal value = keyword ValueListenableBuilder(valueListenable: someValueListenable);\nWhat would the value even be? A widget? A string variable? I mean it is used inside a\nreturn Text('$value $value2 $value3');\nBasically what you want is that by referencing variable A in the build method of widget B, it should cause B to rebuild whenever the value of A changes? That's literally what mobx does, and it does it exactly with the right amount of magic/boilerplate.\n\nfinal value2 = keyword StreamBuilder(stream: someStream);\nWhat should this return? A widget? A stream? A String value?\nAgain, it looks like a string value. So you want to be able to simply reference a stream in a build method, cause that widget to rebuild whenever the stream emits a value and have access to the emitted value and create/update/dispose of the stream whenever the widget is created/updated/destroyed? In one single line of code? Inside the build method?\nYes, with mobx you can have your build methods look exactly like your \"more readable\" example (except you reference observables). You still have to write the actual code that does all the work, just like you do with hooks. The actual code is about 10 lines, and it is reusable in any widget.\n\nfinal value3 = keyword TweenAnimationBuilder(tween: Tween(...));\nA class called \"TweenAnimationBuilder\" returning a string?!  I'm not even going near why this is a terrible idea.",
                "createdAt": "2020-08-09T12:17:01Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "There is no difference in indent/readability between:\nFuture<double> future;\n\nAsyncSnapshot<double> value = keyword FutureBuilder<double>(future: future);\nand:\nFuture<double> future;\n\ndouble value = await future;\nBoth do the exact same thing: Listening to an object and unwrapping its value.",
                "createdAt": "2020-08-09T12:26:21Z"
            },
            {
                "author": "gaearon",
                "bodyText": "I really don't see what isn't readable about it. It explains exactly what is happening. There's four widgets, three of the widgets have builder methods, one just has a string. I would personally not omit the types, I think that makes it harder to read because I can't tell what the variables all are, but it's not a huge problem.\n\nThe same argument could be applied to Promise/Future chains.\nfoo().then(x =>\n  bar(x).then(y =>\n    baz(y).then(z =>\n      qux(z)\n    )\n  )\n)\nvs\nlet x = await foo();\nlet y = await bar(x);\nlet z = await baz(y);\nawait qux(z);\nOne could say that the first way of writing makes it clear that Promises are being created under the hood, and how exactly the chain is formed. I wonder if you subscribe to that, or if you consider Promises to be fundamentally different from Builders in that they deserve a syntax.\n\nA class called \"TweenAnimationBuilder\" returning a string?! I'm not even going near why this is a terrible idea.\n\nYou can make the same argument about Promises/Futures, and say that await obscures the fact that it returns a Promise.",
                "createdAt": "2020-08-09T13:14:44Z"
            },
            {
                "author": "gaearon",
                "bodyText": "I should note that the idea of \"unwrapping\" things via syntax is hardly new. Yes, in the mainstream languages it came via async/await, but, for example, F# has computational expressions, similar to do notation in some hardcore FP languages. There, it has a lot more power and is generalized to work with any wrappers that satisfy certain laws. I'm not suggesting adding Monads to Dart, but I think it's worth bringing up that there is definitely precedent for type-safe syntax for \"unwrapping\" things that doesn't necessarily correspond to asynchronous calls.",
                "createdAt": "2020-08-09T13:23:02Z"
            },
            {
                "author": "alexsullivan114",
                "bodyText": "Taking a step back, I think one thing many people here are struggling with (myself included) is this question about readability. As @rrousselGit has mentioned, there's been a lot of examples throughout this thread of readability issues with the current Builder based approach. To many of us, it seems self evident that this:\nWidget build(context) {\n  return ValueListenableBuilder<String>(\n    valueListenable: someValueListenable,\n    builder: (context, value, _) {\n      return StreamBuilder<int>(\n        stream: someStream,\n        builder: (context, value2) {\n          return TweenAnimationBuilder<double>(\n            tween: Tween(...),\n            builder: (context, value3) {\n              return Text('$value $value2 $value3');\n            },\n          );\n        },\n      );\n    },\n  );\n}\nis significantly less readable than this:\nWidget build(context) {\n  final value = keyword ValueListenableBuilder(valueListenable: someValueListenable);\n  final value2 = keyword StreamBuilder(stream: someStream);\n  final value3 = keyword TweenAnimationBuilder(tween: Tween(...));\n\n  return Text('$value $value2 $value3');\n}\nBut it's clearly not self evident, since @Hixie and @Rudiksz aren't convinced (or are actively opposed) to the idea that the second  is more readable than the first.\nSo here's my breakdown (for whatever small amount it's worth) about why the second code block is more readable than the first:\n1. The first code bock is significantly more indented than the second\nIn my experience, indentation typically equates to asynchronicity, branching, or callbacks, all of which require more cognitive load to think through than non indented, linear code. The first code block has several layers of indentation, and as such it takes me a non trivial amount of time to work through what's happening here, and what's ultimately being rendered (a single Text). Maybe other people are better at working through that indentation in their minds.\n\nIn the second code block, there's no indentation which alleviates the problem.\n2. The first code block requires more syntax to express its intent\nIn the first code block, there's three return statements, three builder statements, three lambda headers, three contexts and finally three values. Ultimately what we care about is those three values - the rest is boilerplate to get us there. I actually find this to be the most challenging part of this code block. There's so much going on, and the parts I actually care about (the values being returned by the builders) are such a small part that I spend most of my mental energy grokking the boilerplate as opposed to focusing on the parts that I actually need (again, the values).\n\nIn the second code block, there's a huge reduction of boilerplate so I can focus on the part I care about - again, the values.\n3. The first code block hides the most important part of the build method in the deepest part of the nesting\nI recognize that all of the portions of this build method are important, but I've found that when I'm reading this style of declarative UI code, the thing I'm usually looking for is whatever is displayed to the user, which in this case is the Text widget embedded in the deepest nested builder. Rather than being front and center, that Text widget is buried in multiple layers of indentation, syntax, and intent. If you throw a Column or a Row in one of these layers it becomes even more deeply nested, and at that point you don't even have the benefit of just tracing to the most indented section.\n\nIn the second code block, the actual render-able Widget being returned is at the bottom of the function, which is immediately apparent. Furthermore, I've found that when you have something like the syntax OP proposed, you can count on the visual Widget always being at the bottom of the function, which makes the code much more predictable and easy to read.",
                "createdAt": "2020-08-09T13:49:52Z"
            },
            {
                "author": "gaearon",
                "bodyText": "Regarding nesting, there's a difference between nesting expressing a tree and nesting expressing a sequence.\nIn the case of normal View -> Text nesting and such, nesting is important because it represents the parent-child relationships on the screen. For features like Context (not sure if Flutter has it), it represents the scope of contexts. So the nesting itself has important semantic meaning in those cases and cannot be disregarded. You can't just swap parent and child's places and expect the result to be the same.\nHowever, with nesting of Builders (aka \"Render Props\" in React), or nesting of Promises, the nesting is supposed to communicate a sequence of transformations / augmentations. The tree itself is not as important \u2014 for example, when nesting independent ABuilder -> BBuilder -> CBuilder, their parent-child relationships don't convey additional meaning.\nAs long as all three values are available in the scope below, their tree structure is not really relevant. It is conceptually \"flat\", and the nesting is only an artifact of the syntax. Of course, they may use each other's values (in which case their order matters), but this is the case with sequential function calls too, and that can be done without any nesting.\nThis is why async/await is compelling. It removes additional information (parent-child relationship of Promises) that describes a low-level mechanism, and instead lets you focus on the high-level intent (describing a sequence).\nA tree is a more flexible structure than a list. But when each parent only has one child, it becomes a pathological tree \u2014 essentially, a list. Async/Await and Hooks recognize we're wasting syntax on something that doesn't convey information, and remove it.",
                "createdAt": "2020-08-09T14:11:22Z"
            },
            {
                "author": "gaearon",
                "bodyText": "This is actually interesting because I earlier said \"this is not about the boilerplate\" and now it seems like I'm contradicting myself. I think there's two things here.\nBy itself, Builders (or at least Render Props in React) are the solution (AFAIK) to the \"reusable logic\" problem. It's just that they're not very ergonomic if you use a lot of them. You're naturally discouraged by the indentation to use more than 4 or 5 of them in the same component. Each next level is a readability hit.\nSo the part that seems unsolved to me is reducing the reader cost of nesting. And that argument is precisely the same argument as for async / await.",
                "createdAt": "2020-08-09T14:21:41Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "It's not as readable for the following reasons:\n\nExcessive use of whitespace does not scale well. We have only so many lines on our monitor, and forcing scrolling reduces readability and increases congitive load. Imagine that we already have a 60 line widget tree, and you just forced an additional 15 on me for builders, not ideal.\nIt wastes Hz space, which we are limited on leading to extra wrapping, which further wastes line space.\nIt pushes the leaf node, aka the content, further from the left side, and into the tree where it is harder to spot with a glance\nIt is significantly more difficult to identify the 'key players' or 'non boilerplate' at a glance. I have to \"find the important stuff\" before my reasoning can even begin.\n\nAnother way to look at this is to simply highlight the non-boilerplate code, and whether it's grouped together for your eye to easily feast upon, or scattered everywhere for your eye to have to scan around:\nWith the highlighting this is very easy to reason about. Without it, I need to read the entire chunk of verbosity before I can figure out who is using what and where:\n\nNow compare to this, the highlighting is basically redundant, cause there is nowhere else for my eye to go:\n\nWorth noting there is probably a disagreement in readability vs grokability. @Hixie likely spends his time in monolithic class files, where he must constantly read and understand massive trees, whereas your typical App Developer is much more about building hundreds of smaller classes, and when you're managing many small classes grok-ability is key. It's not so much that the code is readable when you slow down and read it, but it's can I tell what this is doing at a glance, so I can jump in and tweak or fix something.",
                "createdAt": "2020-08-09T14:22:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "For reference, the equivalent of Context in React is InheritedWidgets/Provider\nThe only difference between them is, in React before hooks we had to use the Builder pattern to consume a Context/Inheritedwidget\nWhereas Flutter has a way to bind the rebuild with a simple function call.\nSo there is no need for hooks to flatten trees using InheritedWidgets \u2014 which kind of works around the problem of Builders\nThat's probably one of the reasons why the discussion is harder, since we need Builders less often.\nBut it's worth mentioning introducing a hook-like solution would solve both #30062\nand #12992",
                "createdAt": "2020-08-09T14:27:21Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "It also appears that @Hixie is more used to reading deep nested trees because Flutter is basically all trees, much more so than other languages in my opinion. As one of the main developers on Flutter itself, of course, he would have much more experience with that. Flutter essentially can be thought of as a left to right framework, with deep nesting, much like HTML which I suppose @Hixie has had experience with, having created the HTML5 spec. This to say, the rightmost point of the code block is where the main logic and return value reside.\nHowever, most developers are not, or come from more top to bottom languages, where the logic is, again, read from top to bottom, rather than in nested trees; it is at the bottom-most point of the code block. Therefore, what's readable to him is not necessarily so with many other devs, which is potentially why you see the dichotomy of opinions on readability here.",
                "createdAt": "2020-08-09T14:29:53Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another way to look at it, is how much code does my brain need to visually redact. To me this accurately represents the \"grunt work\" my brain must do before I can parse what is being returned from the tree:\n\nSimply put, the builder version has a 4x taller vertical footprint while adding literally no additional information or context, AND packs the code in a far more sparse/scattered way. In my mind, that is an open and shut case, it is objectively less readable for that reason alone, and that is not even considering additional cognitive load around indentation and lining up curly braces which we have all dealt with in flutter.\nThink of my eye as a hungry cpu, which is more optimized for processsing? :)",
                "createdAt": "2020-08-09T14:41:21Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "In the case of normal View -> Text nesting and such, nesting is important because it represents the parent-child relationships on the screen. For features like Context (not sure if Flutter has it), it represents the scope of contexts. So the nesting itself has important semantic meaning in those cases and cannot be disregarded. You can't just swap parent and child's places and expect the result to be the same.\n\nTotally agree and I mentioned this earlier. Semantically it makes zero sense to be creating additional context layers in a visual display tree, because I'm using additional non-visual controllers that have state. Using 5 animators, now your widget is 5 layers deep? Just at that high level alone the current approach kinda smells.",
                "createdAt": "2020-08-09T14:59:26Z"
            },
            {
                "author": "dnfield",
                "bodyText": "There are two issues jumping out at me here.\n\n\nI suspect there's some disagreement over how difficult/explicit it should be when using some expensive resource. Flutter's philosophy is they it should be more difficult/explicit so that the developer thinks seriously about when and how to use them. Streams, animations, layout builders, etc. represent non-trivial costs that could be used inefficiently if they're too easy.\n\n\nBuild is sync, but most interesting things you deal with as an app developer are async. Of course we can't make build async. We created these conveniences like Stream/Animation/FutureBuilder but they don't always work well enough for what a developer needs.  It's probably telling that we don't use Stream or FutureBuilder much in the framework.\n\n\nI don't think the solution is to tell developers to just always write custom render objects when working with async operations of course.  But in the examples I'm seeing in this bug, there are mixtures of async and sync work that we can't just await.  Build has to produce something on every call.",
                "createdAt": "2020-08-09T15:25:46Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "fwiw, the React team addressed re-use the readability issue as the 1 motivation:\nHooks Motivation: It\u2019s hard to reuse stateful logic between components\nReact doesn\u2019t offer a way to \u201cattach\u201d reusable behavior to a component ... you may be familiar with patterns ... that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow.\nThis is very similar to how Flutter currently offers us no way to natively 'compose state'. It also echo's what happens when we us builders, which is modifying our layout tree and making it more cumbersome to work with, and \"harder to follow\", said tree.",
                "createdAt": "2020-08-09T15:41:55Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@dnfield if build must be called each time, perhaps we can make the hooks not in the build method so that build is always sync, ie put them inside the class where initState and dispose are. Are there problems with doing so, from those that write hooks?",
                "createdAt": "2020-08-09T15:51:43Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "You can make the same argument about Promises/Futures, and say that await obscures the fact that it returns a Promise.\n\nNo you don't. Await is literally just syntactic sugar for one single feature.  Weather you use the verbose Futures, or the declarative syntax, the intent of the code is the same.\nThe demands here are to move source code that deals with entirely different concerns under the same umbrella, hide all kinds of different behaviour behind a single keyword and claiming that somehow it reduces cognitive load.\nThat's entirely false, because now every time I use that keyword I need to wonder about wheather the result will do any asynchrounous operation, trigger unnecessary rebuilds, initialize long lived objects, do network calls, read files from the disk or simple return a static value. All these are very different situations and I would have to be familiar with the flavor of the hook I'm using.\nI understand from the discussion that most developers here don't like to be bother with these kinds of details and want easy development, by just being able to use these \"hooks\" without having to worry about the implementation details.\nUsing this so called \"hooks\" willy-nilly without understanding their full implication will lead to inefficient and bad code, and will cause people to shoot themselves in the foot - therefore it doesn't even solve the issue of \"protecting beginner developers\".\nIf your use cases are simple then yeah, you can use hooks willy-nilly. You can use and nest builders all you want, but as your app becomes complex that you find yourself in difficulty reusing code, I would think that having to pay more attention to your own code and architecture is warranted. If I was building an app for potentially millions of users I would be very hesitant to use \"magic\" that abstracts away important details from me. Right now I find Flutter's API just right to be simple for very simple use cases, and still flexible to allow anybody to implement any kind of complex logic in a very efficient way.",
                "createdAt": "2020-08-09T19:43:02Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@Rudiksz Again, no one is forcing you to move to hooks. The current style will still be there. What is your argument in the face of this knowledge?\nAnd anyway, people can still write efficient code once they see that multiple hooks are somehow blocking their app; they'll see it when they profile or even just run the app, much as you would with the current style.",
                "createdAt": "2020-08-09T19:47:33Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "@Rudiksz Again, no one is forcing you to move to hooks. The current style will still be there. What is your argument in the face of this knowledge?\n\nOh dear, this same argument applies to also the people complaining about issues with the framework. No one is forcing them not to use the hooks package.\nI'm going to be very blunt here.\nThis issue trully isn't about hooks, statefulwidget and who uses what, but rather about reverting decades of best practices in order for some people to be able to write 5 lines of code less.",
                "createdAt": "2020-08-09T19:53:50Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Your argument doesn't really work. The reason this issue was created was because the flutter_hooks package doesn't do everything that could be possible with having something in the framework, while the current model is, by virtue of already being in the framework natively. The argument is to move features of flutter_hooks into the framework natively. Your argument posits that whatever I can do with the current model, I can also do with the hooks package, which is untrue, it seems like from others in this discussion. If they were true, then it would work, which would also mean that hooks were in the framework natively, and therefore, again, since hooks and non-hooks would be equivalent, you can use the current model just as well as the hooks based model, which is what I was arguing.\nI'm not sure where your best practices are coming from, as I know that keeping code easily readable is a best practice, and that excessive nesting is an anti pattern. Which best practices exactly are you referring to?",
                "createdAt": "2020-08-09T20:00:59Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "fwiw, the React team addressed re-use the readability issue as the 1 motivation:\nHooks Motivation: It\u2019s hard to reuse stateful logic between components\nReact doesn\u2019t offer a way to \u201cattach\u201d reusable behavior to a component ... you may be familiar with patterns ... that try to solve this. But these patterns require you to restructure your components when you use them, which can be cumbersome and make code harder to follow.\n\nI hear everybody raving about how Flutter is so much more amazing than React. Maybe it's because it doesn't do everything the way React does? You can't have it both ways, you can't say Flutter is miles ahead of React and also ask that it does everything exactly like React does.\nWhatever solution Flutter decides to use for a given problem should stand on its own merits. I'm not familiar with React but apparently I'm missing out on some really amazing piece of technology. :/",
                "createdAt": "2020-08-09T20:03:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I don't think anyone is arguing that Flutter should do everything like React.\nBut the fact is, Flutter's widget layer is heavily inspired from React. That's stated in the official documentation.\nAnd as a consequence, Widgets have both the same benefits and the same problems than React Components.\nThis also means that React has more experience than Flutter on dealing with these issues.\nIt faced them for longer, and understands them better.\nSo it shouldn't be surprising that the solutions to Flutter problems are similar to the solutions to React problems.",
                "createdAt": "2020-08-09T20:11:57Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@Rudiksz Flutter's user API is very similar to React's class based model, even as the internal API may be different (I don't know if they do differ, I don't really run into the internal API much). I do encourage you to try React with hooks to see how it is, as I stated earlier that there seems to be a dichotomy of opinions based almost exclusively on those who have and have not used hook-like constructs in other frameworks.\nGiven their similarity, it should be no surprise that the solutions to problems looks similar, as said above.",
                "createdAt": "2020-08-09T20:29:26Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Please, let's try our best to not fight with each others.\nThe only thing fighting will lead us to is killing this discussion and failing to find a solution.",
                "createdAt": "2020-08-09T21:23:36Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I hear everybody raving about how Flutter is so much more amazing than React. Maybe it's because it doesn't do everything the way React does? You can't have it both ways, you can't say Flutter is miles ahead of React and also ask that it does everything exactly like React does.\n\nPointing out that the React team had similar motivations when they came up with hooks, validates the concerns we're expressing here. It certainly validates that there is a problem re-using and combining common stateful logic within this type of component based framework, and also to some degree validates the discussion on readability, nesting and the general problem with \"clutter\" in your views.\nNot raving about anything, I've never even worked in React, and I love Flutter. I can just easily see the problem here.",
                "createdAt": "2020-08-09T21:31:48Z"
            },
            {
                "author": "sahandevs",
                "bodyText": "@Rudiksz we can't be sure if it's performant in practice until we put it in the practice. It is not very easy to decide now.\n@Hixie this is an example for a journey that a common flutter user may have for implementing a widget for showing user's nickname from userId both with HookWidget and StatefulWidget.\nhook widget\nString useUserNickname(Id userid) {\n  final name = useState(\"\");\n  useEffect(async () {\n    name.value = \"Loading...\";\n    name.value = await fetchNicknames()[userId;\n  }, [userId]);\n  return name.value;\n}\n\nclass UserNickname extends HookWidget {\n\n  final userId;\n\n  Widget build(BuildContext context) {\n    final nickname = useUserNickname(userId);\n    return Text(nickname);\n  }\n}\n\nstateful widget\nclass UserNickname extends Widget {\n  final userId;\n  // ... createState() ...\n}\n\nclass UserNicknameState extends State {\n\n  String nickname= \"\";\n\n   initState() {\n     super.initState();\n     fetchAndUpdate();\n   }\n\n   fetchAndUpdate() async {\n      setState(() { this.nickname = \"Loading...\" });\n      final result = await fetchNicknames()[widget.userId];\n      setState(() { this.nickname = result });\n    }\n\n\n void didUpdateWidget(oldWidget) { \n     if (oldWidget.userId != widget.userId) {\n        fetchAndUpdate();\n     }\n   }\n\n  Widget build(BuildContext context) {\n    return Text(this.nickname);\n  }\n}\n\nso far nothing interesting. both solutions are pretty acceptable ,straightforward and performant.\nnow we want to use UserNickname inside a ListView. as you can see fetchNicknames returns a map of nick names, not only one nickname. so calling it everytime is redundant. few solutions we can apply here:\n\nmove calling fetchNicknames() logic to the parent widget and save the result.\nusing a cache manager.\n\nfirst solution is acceptable but has 2 problems.\n1 - it renders UserNickname useless because it is now only a Text widget and if you want to use it somewhere else you have to repeat what you did in the parent widget (which has the ListView). the logic for showing the nickname belongs to the UserNickname but we have to move it separately.\n2 - we may use fetchNicknames() in many other sub trees and it is better to cache it for all the app not only one part of the application.\nso imagine we choose cache manager and providing a CacheManager class with InheritedWidgets or Provider.\nafter adding support for caching:\nhook widget\nString useUserNickname(Id userid) {\n  final context = useContext();\n  final cache = Provider.of<CacheManager>(context);\n  final name = useState(\"\");\n  useEffect(async () {\n    name.value = \"Loading...\";\n    var cachedValue = cache.get(\"nicknames\");\n    if (cachedValue == null || cachedValue[widget.userId] == null) {\n        final result = await fetchNicknames();\n        cache.set(\"nicknames\", result );\n        cachedValue = result ;\n    }\n    final result = cachedValue[widget.userId];\n    name.value = result ;\n  }, [userId]);\n  return name.value;\n}\n\nclass UserNickname extends HookWidget {\n\n  final userId;\n\n  Widget build(BuildContext context) {\n    final nickname = useUserNickname(userId);\n    return Text(nickname);\n  }\n}\n\nstateful widget\nclass UserNickname extends Widget {\n  final userId;\n  // ... createState() ...\n}\n\nclass UserNicknameState extends State {\n\n  String nickname= \"\";\n  CacheManager cache;\n\n   initState() {\n     super.initState();\n     fetchAndUpdate();\n     this.cache = Provider.of<CacheManager>(context);\n   }\n\n   fetchAndUpdate() async {\n      setState(() { this.nickname = \"Loading...\" });\n      var cachedValue = this.cache.get(\"nicknames\");\n      if (cachedValue == null || cachedValue[widget.userId] == null) {\n        final result = await fetchNicknames();\n        this.cache.set(\"nicknames\", result );\n        cachedValue = result ;\n      }\n      final result = cachedValue [widget.userId];\n      setState(() { this.nickname = result });\n    }\n\n\n void didUpdateWidget(oldWidget) { \n     if (oldWidget.userId != widget.userId) {\n        fetchAndUpdate();\n     }\n   }\n\n  Widget build(BuildContext context) {\n    return Text(this.nickname);\n  }\n}\n\nwe have a socket server that notifies clients when nicknames changes.\nhook widget\nString useUserNickname(Id userid) {\n  final context = useContext();\n  final cache = Provider.of<CacheManager>(context);\n  final notifications = Provider.of<ServiceNotifications>(context);\n  final name = useState(\"\");\n\n  fetchData() async {\n    name.value = \"Loading...\";\n    var cachedValue = cache.get(\"nicknames\");\n    if (cachedValue == null || cachedValue[widget.userId] == null) {\n        final result = await fetchNicknames();\n        cache.set(\"nicknames\", result );\n        cachedValue = result ;\n    }\n    final result = cachedValue[widget.userId];\n    name.value = result ;\n   }\n  \n  useEffect(() {\n     final sub = notifications.on(\"nicknameChanges\", fetchData);\n     return () => sub.unsubscribe();\n   }, [])\n  \n  useEffect(fetchData, [userId]);\n  return name.value;\n}\n\nclass UserNickname extends HookWidget {\n\n  final userId;\n\n  Widget build(BuildContext context) {\n    final nickname = useUserNickname(userId);\n    return Text(nickname);\n  }\n}\n\nstateful widget\nclass UserNickname extends Widget {\n  final userId;\n  // ... createState() ...\n}\n\nclass UserNicknameState extends State {\n\n  String nickname= \"\";\n  CacheManager cache;\n  ServerNotification notifications;\n  CancelableOperation sub;\n\n   initState() {\n     super.initState();\n     fetchAndUpdate();\n     this.cache = Provider.of<CacheManager>(context);\n     this.notifications = Provider.of<ServerNotification>(context);\n     this.sub = notifications.on(\"nicknameChanges\", fetchAndUpdate);\n   }\n\n   dispose() {\n      super.dispose();\n      this.sub.unsubscribe();\n   }\n\n   fetchAndUpdate() async {\n      setState(() { this.nickname = \"Loading...\" });\n      var cachedValue = this.cache.get(\"nicknames\");\n      if (cachedValue == null || cachedValue[widget.userId] == null) {\n        final result = await fetchNicknames();\n        this.cache.set(\"nicknames\", result );\n        cachedValue = result ;\n      }\n      final result = cachedValue [widget.userId];\n      setState(() { this.nickname = result });\n    }\n\n\n void didUpdateWidget(oldWidget) { \n     if (oldWidget.userId != widget.userId) {\n        fetchAndUpdate();\n     }\n   }\n\n  Widget build(BuildContext context) {\n    return Text(this.nickname);\n  }\n}\n\nso far both implementation are acceptable and good. IMO the boilerplate in the statful one is no problem at all. the problem arises when we need a widget like UserInfo that has both user's nickname and avatar. also we can't use UserNickname widget because we need to show in a sentence like \"Welcome [username]\".\nhook widget\nuseFetchUserNickname(userId) // old code\nuseUserAvatar(userId) // implementation like `useFetchUserNickname`\n\nclass UserNickname extends HookWidget {\n  final userId;\n\n  Widget build(BuildContext context) {\n    final nickname = useUserNickname(userId);\n    final avatar = useUserAvatar(userId);\n    return Row(\n      children: [Image.network(avatar), Text(nickname)],\n    );\n  }\n}\n\nbut for the stateful widget we can't just use the logic that we wrote. we have to move the logic into a class (like a Property that you suggested) and still we need to write the widget glue with property class again in the new widget.\nif you see the changes in the first 3 example, we didn't change the widget itself at all because the only necessary changes were in the state logic and the only place that did change was all, state logic.\nthis gave us a clean (opinionated), composable and totally reusable state logic that we can use anywhere.\nIMHO the only problem is calling useUserNickname is scarry because a single function can do this much.\nbut in my years of experience in react and using flutter_hooks in 2 apps that are in production rn (that are using hooks heavily) proves that not having a good state management (I also tried MobX and other state management solutions but the glue in widget is always there) is much more scarier. I don't need to write 5 page docs for every screen in a frontend app that I may need to add some small feature in few month after the first release for it to understand how a page of my app works. App calls the sever too much? easy task I go the related hook and change it and the whole app fixes because whole app uses that hook. we can have similar things in the apps without using hooks with a good abstraction but what I'm saying is that hooks are that good abstraction.\nI'm pretty sure @gaearon can word it better than me. (if he agrees with me ofc)\nseeing example above, none of the methods above (stateful and hook widget) are more performant that the other. but the point is one of them encourages people to write the performant code.\nalso it's possible to update only the subtree that we need to update like StreamBuilder when there is too many updates (e.g animations) with:\n1 - simply creating a new widget which totally viable option for both HookWidget and StatefulWidget/StatelessWidget\n2 - using something similar to HookWidgetBuilder in flutter_hooks package because parent and child widgets data are very tightly coupled.\nSide note: I really appreciate @Hixie and @rrousselGit for discussing this topic and putting this much energy in this issue. I really looking forward for the result of these talks.",
                "createdAt": "2020-08-09T21:41:08Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I am coming up with something pretty cool/elegant I think,  based on @Hixie's starting point. Not quite ready to share yet, but it is allowing me to create some pretty decent code samples, that I think will be easier to compare apples:apples rather than hooks which looks so foreign.\nSo, imagine we have a StatefulWidget with this signature:\nclass ExampleSimple extends StatefulWidget {\n  final Duration duration1;\n  final Duration duration2;\n  final Duration duration3;\n\n  const ExampleSimple({Key key, this.duration1, this.duration2, this.duration3}) : super(key: key);\n\n  @override\n  _ExampleSimpleState createState() => _ExampleSimpleState();\n}\n\nIf we were to implement the state using vanilla animator controllers, we get something like:\nclass _ExampleSimpleVanillaState extends State<ExampleSimpleVanilla> with SingleTickerProviderStateMixin {\n  AnimationController _anim1;\n  AnimationController _anim2;\n  AnimationController _anim3;\n\n  @override\n  void initState() {\n    _anim1 = AnimationController(duration: widget.duration1, vsync: this);\n    _anim1.forward();\n    _anim2 = AnimationController(duration: widget.duration2, vsync: this);\n    _anim2.forward();\n    _anim3 = AnimationController(duration: widget.duration3, vsync: this);\n    _anim3.forward();\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      margin: EdgeInsets.symmetric(vertical: _anim2.value * 20, horizontal: _anim3.value * 30,),\n      color: Colors.red.withOpacity(_anim1.value),\n    );\n  }\n\n  @override\n  void didUpdateWidget(ExampleSimpleVanilla oldWidget) {\n    if (oldWidget.duration1 != widget.duration1) {\n      _anim1.duration = widget.duration1;\n    }\n    if (oldWidget.duration2 != widget.duration2) {\n      _anim1.duration = widget.duration1;\n    }\n    if (oldWidget.duration3 != widget.duration3) {\n      _anim1.duration = widget.duration1;\n    }\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void dispose() {\n    _anim1.dispose();\n    _anim2.dispose();\n    _anim3.dispose();\n    super.dispose();\n  }\n}\n\nIf we create it using a StatefulProperty, we yield something more like this:\nclass _ExampleSimpleState extends State<ExampleSimple> with StatefulPropertyManager {\n  StatefulAnimationProperty _anim1;\n  StatefulAnimationProperty _anim2;\n  StatefulAnimationProperty _anim3;\n\n  @override\n  void initStatefulProperties({bool firstRun = false}) {\n    _anim1 = initProperty(_anim1, StatefulAnimationProperty(duration: widget.duration1, playOnInit: true));\n    _anim2 = initProperty(_anim2, StatefulAnimationProperty(duration: widget.duration2, playOnInit: true));\n    _anim3 = initProperty(_anim3, StatefulAnimationProperty(duration: widget.duration3, playOnInit: true));\n    super.initStatefulProperties(firstRun: firstRun);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      margin: EdgeInsets.symmetric(vertical: _anim2.controller.value * 20, horizontal: _anim3.controller.value * 30,),\n      color: Colors.red.withOpacity(_anim1.controller.value),\n    );\n  }\n}\n\nSome notes on the differences here:\n\nOff the top, one is 20 lines, the other is 45. One is 1315 chars the other is 825. Only 3 lines and 200 characters matter in this class (what is happening in build), so this is already a massive improvement in signal:noise ratio (ie, is my eye directed to the important bits)\nThe vanilla options has multiple points where bugs can be created. Forget to dispose, or forget to handle didChange, or make a mistake in didChange, and you have a bug in your code base. This gets worse, when multiple types of controllers are used. Then you have single functions tearing down objects of all different types, which won't be named nice and sequentially like this. That gets messy and is quite easy to make mistakes or miss entries.\nThe vanilla option provides no method to re-use common patterns or logic, like playOnInit, so I have to duplicate this logic, or create some custom function in very single class that wants to use an Animator.\nThere is no need to understand SingleTickerProviderMixin here, which is 'magic' and obfuscated what a Ticker is for me for months (in hindsight, I should've just read the class, but every tutorial just says: Add this magic mixin). Here you can look directly at the source code for StatefulAnimationProperty, and see how the animation controllers uses a ticker provider directly and in context.\n\nYou do have to instead understand what StatefulPropertyManager does, but crucially this learned once and applied to objects of any type, SingleTickerProviderMixin is mainly specific to using Animator Controllers, and every controller may have it's own mixing to make usage easier, which gets messy. Just having discrete \"StatefulObjects\" that know all this stuff  (just like a builder does!), is much cleaner and scales better.\nThe code for StatefulAnimationProperty would look something like this:\nclass StatefulAnimationProperty extends BaseStatefulProperty<StatefulAnimationProperty> implements TickerProvider {\n  final Duration duration;\n  final TickerProvider vsync;\n  final bool playOnInit;\n\n  StatefulAnimationProperty({@required this.duration, @required this.vsync, this.playOnInit = false});\n\n  AnimationController get controller => _controller;\n  AnimationController _controller;\n\n  Ticker _ticker;\n\n  @override\n  Ticker createTicker(onTick) {\n    _ticker ??= Ticker((elapsed)=>handleTick(elapsed, onTick));\n    return _ticker;\n  }\n\n  handleTick(Duration elapsed, TickerCallback onTick) {\n    managerWidget.buildWidget(); //TODO: This just calls setState() on the host widget. Is there some better way to do this?\n    onTick(elapsed);\n  }\n\n  @override\n  void init(StatefulAnimationProperty old) {\n    _controller = old?.controller ??\n        AnimationController(\n          duration: duration ?? Duration(seconds: 1),\n          vsync: vsync ?? this,\n        );\n    if (playOnInit && old?.controller == null) {\n      _controller.forward();\n    }\n    super.init(old);\n  }\n\n  @override\n  void update(StatefulAnimationProperty old) {\n    if (duration != old.duration) {\n      _controller.duration = duration;\n    }\n    if (vsync != old.vsync) {\n      _controller.resync(vsync);\n    }\n    super.update(old);\n  }\n\n  @override\n  void dispose() {\n    _controller?.dispose();\n    _ticker?.dispose();\n    super.dispose();\n  }\n}\n\nFinally, worth noting, readability can be made even better with use of extensions, so we could have something like:\n  void initStatefulProperties({bool firstRun = false}) {\n    _anim1.init(duration: widget.duration1, playOnInit: true);\n    _anim2.init(duration: widget.duration2, playOnInit: true);\n    _anim3.init(duration: widget.duration3, playOnInit: true);\n    super.initStatefulProperties(firstRun: firstRun);\n  }\n\n[Edit] As if to make my own point, my vanilla example has a bug. I forgot to pass the correct duration to each animator in the didUpdateWidget. How long would it have taken us to find that bug in the wild, if no one noticed in code review?? Did anyone not spot it while reading? Leaving it in cause it's a perfect example of what happens in the real world.",
                "createdAt": "2020-08-10T17:33:38Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Here's a birds eye view, with boilerplate marked in red:\n\nThis wouldn't be so bad if it was pure boilerplate, and the compiler yelled at you if it was missing. But it's all optional! And when ommitted, creates bugs. So this is actually very bad practice and not DRY at all. This is where builders come in, but they are only good for simplistic use cases.",
                "createdAt": "2020-08-10T17:49:41Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "What I think is very interesting about this, is how a hundred lines and a simple mixin to State, renders a bunch of existing classes redundant. There is virtually no need now to ever use the TickerProviderMixins for example. TweenAnimationBuilder need almost never be used, unless you actually want to create a sub-context. Many traditional pain points like managing focus controllers and textInput controllers are eased substantially. Using Streams becomes way more attractive and less cludgy. Across the code base, use of Builders could be reduced in general which will lead to more easily grokable trees.\nAlso makes it extremely easy to make your own custom state objects, like the FetchUser example listed earlier, which currently basically requires a builder.",
                "createdAt": "2020-08-10T17:56:56Z"
            },
            {
                "author": "aytunch",
                "bodyText": "I think this would be a very interesting question to ask in the next Flutter Developer Survey.\nIt would be a good start. Divide this problem in different parts/questions and see if this is a real problem that Flutter developers wish to be solved.\nOnce that it is clear, this conversation will be more fluent and enriching\n\nThe Emoji reactions under each comment gives a clear idea on if community sees this as a problem or not. The opinion of developers who read 250+ long comments for this issue mean a lot imho.",
                "createdAt": "2020-08-10T17:58:35Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@esDotDev That's similar to some of the ideas I've been toying with, though I like your idea of just having the property itself be the ticker provider, I hadn't considered that. One thing that your implementation is missing that I think we'd need to add is handling of TickerMode (which is the point of the TickerProviderStateMixin).\nThe main thing I'm struggling with is how to do this in an efficient way. For example, ValueListenableBuilder takes a child argument that can be used to measurably improve performance. I don't see a way to do that with the Property approach.",
                "createdAt": "2020-08-10T18:06:51Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@Hixie\nI understand that efficiency losses with approaches like this seem to be inevitable. But I like the Flutter mindset of optimize after you profile your code. There are a lot of applications which would benefit from the clarity and conciseness of the Property approach. The option to profile your code, and refactor into builders or separate out a piece of the widget into it's own widget are always there.\nThe documentation would just need to reflect the best practices and make clear the tradeoffs.",
                "createdAt": "2020-08-10T18:11:19Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The main thing I'm struggling with is how to do this in an efficient way. For example, ValueListenableBuilder takes a child argument that can be used to measurably improve performance. I don't see a way to do that with the Property approach.\n\nHm, I think the entire point of the Properties is for non-visual objects. If something wants to have a context slot in the tree, then that thing should be a builder (actually these are the only things that should now be builders I think?)\nSo we would have a StatefulValueListenableProperty that we use most of the time when we just want to bind the entire view. We then also have a ValueListenableBuilder in the chance that we want some sub-section of our tree to rebuild.\nThis also addresses the nesting issue, as using a builder as a leaf node, is not nearly as disruptive to readability, as nesting 2 or 3 at the top of your widget tree.",
                "createdAt": "2020-08-10T18:15:42Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@TimWhiting A big part of Flutter's design philosophy is to guide people towards the right choice. I would like to avoid encouraging people to follow a style which they'd then have to move away from to get better performance. It may be that there is no way to address all the needs at once, but we should definitely give it a go.",
                "createdAt": "2020-08-10T18:19:49Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@Hixie\nWhat about something like this for builders?\nclass _ExampleSimpleState extends State<ExampleSimple> with StatefulPropertyManager {\n  StatefulAnimationProperty _anim1;\n  StatefulAnimationBuilderProperty _anim2;\n\n  @override\n  void initStatefulProperties({bool firstRun = false}) {\n    _anim1 = initProperty(_anim1, StatefulAnimationProperty(duration: widget.duration1, playOnInit: true));\n    _anim2 = initProperty(_anim3, StatefulAnimationBuilderProperty(duration: widget.duration3, playOnInit: true));\n    super.initStatefulProperties(firstRun: firstRun);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      color: Colors.red.withOpacity(_anim1.controller.value),\n      child: _anim2(child: SomeChildWidget()),\n    );\n  }\n}",
                "createdAt": "2020-08-10T18:33:05Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Can you elaborate? I'm not sure I understand the proposal.",
                "createdAt": "2020-08-10T18:35:37Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think he's saying that the StatefulProperty could provide an optional build method for properties that have some visual component:\nreturn Column(\n   children: [\n      TopContent(),\n      _valueProperty.build(SomeChildWidget()),\n   ]\n)\n\nWhich is quite \ud83d\udd25 imo,",
                "createdAt": "2020-08-10T18:37:47Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "Yes, I don't know if that would work, but the build method would take a child just like a regular builder, except the other properties of the builder are set by the property.\nIf you need the context from the builder, than the build method accepts a builder argument that provides the context.\nUnder the hood the method might just create a normal builder with the specified properties, and pass the child argument to the normal builder and return that.",
                "createdAt": "2020-08-10T18:39:52Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Suppose you had this code:\nWidget build(BuildContext context) {\n  return ExpensiveParent(\n    child: ValueListenableBuilder(\n      valueListenable: foo,\n      child: ExpensiveChild(),\n      builder: (BuildContext context, value, Widget child) {\n        return SomethingInTheMiddle(\n          value: value,\n          child: child,\n        );\n      }\n    ),\n  );\n}\n...how would you convert that?",
                "createdAt": "2020-08-10T18:43:16Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@esDotDev I like your idea of just having the property itself be the ticker provider, I hadn't considered that.\n\nYa one of the strongest aspects of this hook-style approach, is that you can fully encapsulate the stateful logic, whatever that may be. So in these case the full list for AC is:\n\nCreate the AC\nGive it a ticker\nHandle widget changes\nHandle cleanup of ac and ticker\nRebuild view on tick\n\nCurrently things are split with developers handling (or not handling) 1,3,4 manually and repetitively, and the semi-magical SingleTickerProviderMixin taking care of the 2 and 5 (with us passing 'this' as vsync, which confused me for months!). And SingleTickerProviderMixin itself is clearly an attempted fix for this type of problem, otherwise why not just go all the way and have us implement TickerProvider for each class, it would be much more clear.",
                "createdAt": "2020-08-10T18:45:21Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "Suppose you had this code:\nWidget build(BuildContext context) {\n  return ExpensiveParent(\n    child: ValueListenableBuilder(\n      valueListenable: foo,\n      child: ExpensiveChild(),\n      builder: (BuildContext context, value, Widget child) {\n        return SomethingInTheMiddle(\n          value: value,\n          child: child,\n        );\n      }\n    ),\n  );\n}\n...how would you convert that?\n\nclass _ExampleSimpleState extends State<ExampleSimple> with StatefulPropertyManager {\n  StatefulValueListenableBuilder _fooBuilder;\n\n  @override\n  void initStatefulProperties({bool firstRun = false}) {\n    _fooBuilder = initProperty(StatefulValueListenableProperty(valueListenable: widget.foo)); \n    super.initStatefulProperties(firstRun: firstRun);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ExpensiveParent(\n      child: SomethingInTheMiddle(\n        _fooBuilder.value,\n        _fooBuilder.builder(childBuilder: () => ExpensiveChild()),\n      ),\n    );\n  }\n}\n@Hixie\nThanks for the example. I gave it my best shot. I might have missed something.\nImportant to note would be that the builder caches the child. The question would be when does it need to actually rebuild the child? I think that was the question you were trying to raise..",
                "createdAt": "2020-08-10T18:53:16Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "@Hixie have you seen #51752 (comment)\nI think there are some really good points.\nI build today something with a lot of ValueListenableBuilder and I can only say its not nice to read.",
                "createdAt": "2020-08-10T19:40:24Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@Hixie\nThanks for the example. I gave it my best shot. I might have missed something.\n\nI don't think this works because the Property binds to the state it is defined in, so ExpensiveParent is always getting rebuilt here. Then I think the caching of the child is also problematic, as in the Builder example it would know to only rebuild the child when the parent state is built, but in this method the Property does not know when to invalidate it's cache (but maybe this is solvable?)\nBut tbh, this is the perfect use case for builders, when you want to introduce a new context. I think it's quite elegant to just have the context of StatefulProperties (pure state) and StatefulWidgets (mix of state and layout).\nAnytime you are intentionally creating a sub-context, you will by definition be doing it further down your tree, which helps combat one of the main drawbacks to builders (forced nesting across the entire tree)",
                "createdAt": "2020-08-10T19:51:04Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@escamoteur (and @sahandevs who wrote that comment) yeah I was studying that earlier. I think it certainly helps show the kind of logic that people want to remove. I think, though, that the example itself is a bit dubious in that I would expect most of the logic (e.g. everything around caching) to be in the app state business logic, and nowhere near the widgets. I also can't see a good way to get the syntax as brief as proposed in that comment without breaking hot reload (e.g. if you change the number of hooks you're using, it's not clear how they could be kept stateful across a reload).\nThat said, I think the work @esDotDev and @TimWhiting show above is very interesting and could solve these problems. It's not as brief as Hooks, but it is more reliable. I think it would make perfect sense to package something like that up, it could even be a Flutter Favorite if it works well. I'm not sure it makes sense as a core framework feature because the improvement is not that substantial once you take into account the complexity around building properties and the performance impact, and how different people would prefer different styles. At the end of the day, it should be fine for different people to use different styles, but we wouldn't want the core framework to have multiple styles, that's just misleading for new developers.\nThere's also an argument to be made that the right way to learn Flutter is to first understand widgets, and then learn the tools that abstract them away (Hooks or whatever), rather than jumping right to abstract syntax. Otherwise you are missing a key component of how the system works which is likely to lead you astray in terms of writing performant code.",
                "createdAt": "2020-08-10T19:55:34Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I also can't see a good way to get the syntax as brief as proposed in that comment without breaking hot reload (e.g. if you change the number of hooks you're using, it's not clear how they could be kept stateful across a reload).\n\nHooks do work with hot-reload without issue.\nThe first hook with a non-matching runtimeType cause all the subsequent hooks to be destroyed.\nThis supports adding, removing and reordering.",
                "createdAt": "2020-08-10T19:57:37Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think there is an argument that full abstraction is preferable to partial which exists currently.\nIf I want to understand how Animator works in the context of a Property, I either ignore it totally, or jump in, and it is all right there, self contained and coherent.\nIf I want to understand how AnimatorController works in context of a StatefulWidget, I need (am forced) to understand the basic lifecycle hooks, but then spared from understanding how the underlying tick mechanism works. This is worst of both worlds in some sense. Not enough magic to make it 'just work', but just enough to confuse new users and force them to just trust blindly in some mixin (which in itself is a new concept for most) and a magical vsync property.\nI'm not sure of other examples in the code base, but this would apply to any situation where some helper mixins have been provided for StatefulWidget, but there is still some other bootstrapping that must always be performed. Dev's will learn the bootstraping (the boring part) and ignore the Mixin (the interesting/complex bit)",
                "createdAt": "2020-08-10T20:02:37Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "That said, I think the work @esDotDev and @TimWhiting show above is very interesting and could solve these problems. It's not as brief as Hooks, but it is more reliable\n\nHow is this more reliable?\nWe still can't create/update properties conditionally or outside of its life-cycle as we could enter a bad state. For example, calling a property conditionally will not dispose of the property when the condition is false.\nAnd all properties are still re-evaluated on every rebuild.\nBut it causes multiple issues, such as forcing users to use ! everywhere after NNBD or potentially allowing users to access a property before it is updated.\nFor example, what if someone reads a property inside didUpdateWidget?\n\nDid initProperties execute before the life-cycle? But then that means we may have to update properties multiple times per build.\nDid initProperties get executed after didUpdateWidget? Then using properties inside didUpdateWidget may lead to an outdated state\n\nSo in the end, we have all the issues of hooks but:\n\nwe can't use Properties inside `StatelessWidget. So the readability of StreamBuilder/ValueListenableBuilder/... is still an issue \u2013 which was the main concern.\nthere are numerous edge-cases\nit's harder to create custom properties (we can't just extract a bunch of properties into a function)\nit's harder to optimize rebuilds\n\n\nIn the end, the example given is no different in behavior from:\nclass Example extends StatelessWidget {\n  @override\n  Widget build(context) {\n    final value1 = keyword TweenAnimationBuilder(tween: Tween(begin: 0, end: 1));\n    final value2 = keyword TweenAnimationBuilder(tween: Tween(begin: 0, end: 1));\n    final value3 = keyword TweenAnimationBuilder(tween: Tween(begin: 0, end: 1));\n\n    return Container(\n     margin: EdgeInsets.symmetric(vertical: value2 * 20, horizontal: value3 * 30),\n     color: Colors.red.withOpacity(value1),\n      child: _anim2(child: SomeChildWidget()),\n    );\n  }\n}\nBut this syntax supports a lot more things, such as:\nEarly returns:\nclass Example extends StatelessWidget {\n  @override\n  Widget build(context) {\n    final value1 = keyword TweenAnimationBuilder(tween: Tween(begin: 0, end: 1));\n\n    if (condition) {\n      return Container();\n    }\n\n    final value2 = keyword TweenAnimationBuilder(tween: Tween(begin: 0, end: 1));\n\n    ...\n  }\n}\nwhich would dispose of value2 when condition switches to false\nExtracting bundles of builders into a function:\nWidget build(context) {\n  final foo = keyword FooBuilder();\n  final bar = keyword BarBuilder();\n \n  return Text('$foo $bar');\n}\ncan be changed into:\nBuilder<String> LabelBuilder() builder* {\n  final foo = keyword FooBuilder();\n  final bar = keyword BarBuilder();\n\n  return '$foo $bar';\n}\n\nWidget build(context) {\n  final label = keyword LabelBuilder();\n \n  return Text(label);\n}\nOptimize rebuilds\nThe child parameter is still feasible:\nWidget build(context) {\n  final value = keyword StreamBuilder();\n \n  return Builder(\n    builder: (context, child) {\n      final value2 = keyword TweenAnimationBuilder();\n      final value = keyword ValueListenableBuilder();\n \n      return Whatever(child: child);\n    },\n    child: ExpensiveChild()\n  );\n}\nAs part of the language, we could even have syntax sugar for this:\nWidget build(context) {\n  return Scaffold(\n    body: {\n      final value = keyword TweenAnimationBuilder();\n      final value2 = keyword ValueListenableBuilder();\n\n      return Text();\n    },\n  );\n}\nBonus: As a language feature, conditional calls are supported\nAs part of the language, we can support such scenario:\nWidget build(context) {\n  String label;\n\n  if (condition) {\n    label = keyword LabelBuilder();\n  } else {\n    label = keyword AnotherBuilder();\n  }\n\n  final value2 = keyword WhateverBuilder();\n \n  return ...\n}\nIt's not very useful, but supported \u2013 as since the syntax is compiled, it is able to differentiate each usage of keyword by relying on metadata that is not available otherwise.",
                "createdAt": "2020-08-10T20:10:00Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Regarding readability of builders, here is the previous example, but done with builders. It solves all of the reliability and code-use needs, but look what it has done to my poor widget tree :'(\nclass _ExampleSimpleBuilderState extends State<ExampleSimpleBuilder> {\n  @override\n  Widget build(BuildContext context) {\n    return TweenAnimationBuilder<double>(\n        tween: Tween(begin: 0, end: 1),\n        duration: widget.duration1,\n        builder: (_, value1, __) {\n          return TweenAnimationBuilder<double>(\n              tween: Tween(begin: 0, end: 1),\n              duration: widget.duration2,\n              builder: (_, value2, __) {\n                return TweenAnimationBuilder<double>(\n                    tween: Tween(begin: 0, end: 1),\n                    duration: widget.duration3,\n                    builder: (_, value3, __) {\n                      return Container(\n                        margin: EdgeInsets.symmetric(vertical: value2 * 20, horizontal: value3 * 30),\n                        color: Colors.red.withOpacity(value1),\n                      );\n                    });\n              });\n        });\n  }\n}\n\nIt's much much harder (for my eye at least) to spot the code that matters.  Also, fwiw, I had to start over like 3 times when writing this, as I continually got confused as to which bracket belonged where, where my semi-colans should go etc. Nested builders are just no fun to write or work inside of.  One wrong semicolon and dartfmt bails completely crushing the whole thing.",
                "createdAt": "2020-08-10T20:16:58Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "How is this more reliable?\n\nThis is a perfect example of why this should be a core plugin imo. The domain knowledge required here is deep. I have the scripting knowledge to implement a simple caching system like this, I do not even have close to the domain knowledge to know every edge case that can happen, or bad states we can get into. Other than Remi, I think there is like 4 developers in the world outside the Flutter team that know this stuff! (exaggerating obviously).",
                "createdAt": "2020-08-10T20:25:03Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The issue of supporting Stateless Widgets is a good one. On one hand I get it, StatefulWidgets's are oddly verbose. On the other hand, here we truly are talking about pure verbosity. There are no bugs that can happen from having to define 2 classes, there is no way you can mess it up, compiler doesn't let you, there is never anything interesting I want to do in the StatelessWidget. So I'm not sold on this being a major issue... CERTAINLY would be nice to have, but it's the last 5% imo, not something to get stuck on.\nOn the other other hand... that syntax from remi with keyword support is absolutely beautiful and insanely flexible/powerful. And if it gives you StatelessWidget support for free, then that's just extra \ud83d\udd25",
                "createdAt": "2020-08-10T20:31:18Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Supporting StatelessWidget is a big deal IMO. Optional, but still very cool.\nWhile I agree that it is not critical, people are already fighting over using functions instead of StatelessWidget.\nRequiring people to use a StatefulWidget to use Builders (as most Builders would likely have a Property equivalent) would only deepen the conflict.\nNot only that but, in a world where we can create higher-order functions in dart (dart-lang/language#418), we could get rid of classes altogether:\n@StatelessWidget\nWidget Example(BuildContext context, {Key key, String param}) {\n  final value = keyword StreamBuilder();\n\n  return Text('$value');\n}\nthen used as:\nWidget build(context) {\n  // BuildContext and Key are automatically injected\n  return Example(param: 'hello');\n}\nThis is something that is supported by functional_widget \u2013 which is a code-generator where you write a function and it generates a class for you \u2013 which also supports HookWidget.\nThe difference being, having support for higher-order functions in Dart would remove the need for code-generation to support such syntax.",
                "createdAt": "2020-08-10T20:52:32Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I'm guessing what @Hixie meant by more reliable, is it doesn't suffer from the order of operations / conditional issue that hooks has, as that is very 'unreliable' from an architectural POV (though I realize it's an easy rule to learn and not violate once learned).\nBut neither does your proposal with the keyword. I think the case for new keyword is quite strong:\n\nMore flexible and composable than grafting onto State\nEven more succint syntax\nWorks in Stateless which is a very nice option to have\n\nWhat I don't like about it, is we're worrying about the cost of setting properties on some simple object multiple times/build, but then advocating a solution that basically will create a million levels of context and a bunch of layout cost. Am I misunderstanding?\nThe other downside is this idea of magic. But if you're going to do something magical, a new keyword is an effective way to get it done I think, as it makes it easy to highlight and call out to the community, and explain what it is and how it works. It would basically be all anyone talks about for the next yr in Flutter and I'm sure we would see an explosion of cool plugins that spawn out of it.",
                "createdAt": "2020-08-10T21:33:17Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I'm guessing what @Hixie meant by more reliable, is it doesn't suffer from the order of operations / conditional issue that hooks has, as that is very 'unreliable' from an architectural POV (though I realize it's an easy rule to learn and not violate once learned).\n\nBut hooks don't suffer from such issue either, as they are statically analyzable, and we can therefore have a compilation error when they are misused.\nThis is a non-problem\nSimilarly if custom errors are a no-go, then as I mentioned previously,  Property suffers from the exact same problem.\nWe can't reasonably write:\nProperty property;\n\n@override\nvoid initProperties() {\n  if (condition) {\n    property = init(property, MyProperty());\n  }\n}\nas switching condition from true to false will not dispose of the property.\nWe can't really call it in a loop either. It doesn't really make sense, since it's a single-time assignment. What is the use-case of running the property in a loop?\nAnd the fact that we can read properties in any order sounds dangerous\nFor example we could write:\nProperty first;\nProperty second;\n\n@override\nvoid initProperties() {\n  // The state of first depends on second, but second is updated after first\n  // So we could end up in a bad state, similar to how the build method of a Widget should depend\n  // on the context.size\n  first = init(property, MyProperty(second?.value));\n\n  second = init(property, Whatever());\n}",
                "createdAt": "2020-08-10T21:45:49Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "> class _ExampleSimpleBuilderState extends State<ExampleSimpleBuilder> {\n>   @override\n>   Widget build(BuildContext context) {\n>     return TweenAnimationBuilder<double>(\n>         tween: Tween(begin: 0, end: 1),\n>         duration: widget.duration1,\n>         builder: (_, value1, __) {\n>           return TweenAnimationBuilder<double>(\n>               tween: Tween(begin: 0, end: 1),\n>               duration: widget.duration2,\n>               builder: (_, value2, __) {\n>                 return TweenAnimationBuilder<double>(\n>                     tween: Tween(begin: 0, end: 1),\n>                     duration: widget.duration3,\n>                     builder: (_, value3, __) {\n>                       return Container(\n>                         margin: EdgeInsets.symmetric(vertical: value2 * 20, horizontal: value3 * 30),\n>                         color: Colors.red.withOpacity(value1),\n>                       );\n>                     });\n>               });\n>         });\n>   }\n> }\n\nThis is such a weird example. Are you sure AnimatedContainer can't already do this?",
                "createdAt": "2020-08-10T21:47:54Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Of course. The example here is to utilize 3 animations in some widget to do \"X\". The X is intentionally simplified in the example to highlight the amount of boilerplate.\nDon't focus on how I'm using them. In a real example, the widget \"core\" would be a hundred lines or something, the animated properties would not be so simple, and we'd have multiple handlers and other functions defined. Assume I'm doing something not handled by one of the implicit widgets (not hard since other than AnimatedContainer, they are extremely single-purpose).\nThe point is that when building something like this, builders don't work great, as they stick you in a readability (and writability) hole to begin with, as such they are well suited for simple use cases, they do no \"compose\" well. Compose being the composition of 2 or more more things.",
                "createdAt": "2020-08-10T21:53:39Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Don't focus on how I'm using them. In a real example, ...\n\n...and back to square one. Why don't you bring a real example?",
                "createdAt": "2020-08-10T21:59:44Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "You need a real example of using complex animations?\nhttps://github.com/gskinnerTeam/flutter_vignettes\nShowing some arbitrary complex animation would do nothing but obfuscate the example. Sufficed to say, there are plenty of use cases for using multiple animators (or any other stateful object you can imagine) inside some widget",
                "createdAt": "2020-08-10T22:02:15Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Of course. The example here is to utilize 3 animations in some widget to do \"X\". The X is intentionally simplified in the example to highlight the amount of boilerplate.\n\n\nthe widget \"core\" would be a hundred lines or something\n\nIn another post you posted an example with boilerplate that obscures the \"core\", but now you tell us that the core would be hundreds of lines? So in reality, the boilerplate would be minuscule compared to the core?  You can;t have it both ways.\nYou are constantly changing your arguments.",
                "createdAt": "2020-08-10T22:05:23Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Don't focus on how I'm using them. In a real example, ...\n\n...and back to square one. Why don't you bring a real example?\n\nProbably because it takes a lot of time to create a real example when just playing around with various idea. The intent is for the reader to imagine how it could be used in a real situation, not mention that there are ways around it. Of course one can use an animated container, but what if they couldn't? What if it were too complex to make with just an animated container.\nNow, that the writers do not use truly real examples, that can be shown to be either good or bad, I have no opinion on that, I'm only commenting on the tendency in this thread to bring up ameliorations to problems which do not fully solve the problem at hand. This seems to be a major source of confusion between hooks proponents and opponents, as each seem to be talking past another to some extent, so I support Hixie's proposal to create some real apps such that an opponent cannot say that a \"real\" example was not shown and a proponent cannot say that one should merely imagine a real world scenario.",
                "createdAt": "2020-08-10T22:07:20Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think I said was it would be silly to have class that is 100lines, where half of it is boilerplate. Which is exactly what I'm describing here. The core, however large, should not be obfuscated by a bunch of noise, which it certainly is when using multiple builders.\nAnd the reason is scan-ability, readability and maintenance across a large codebase. Its not the writing of the lines, although writing in builders is a productivity loser imo due to the tendancy to get into curly bracket hell.",
                "createdAt": "2020-08-10T22:07:29Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "In another post you posted an example with boilerplate that obscures the \"core\", but now you tell us that the core would be hundreds of lines? So in reality, the boilerplate would be minuscule compared to the core? You can;t have it both ways.\nYou are constantly changing your arguments.\n\nAgain, this issue is not about boilerplate but readability and reusability.\nIt doesn't matter if we have 100 lines.\nWhat matters is how readable/maintainable/reusable these lines are.",
                "createdAt": "2020-08-10T22:07:49Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Even if the argument were about boilerplate, why should I, the user, tolerate such boilerplate in any case, given a sufficiently equivalent way of expressing the same thing? Programming is all about creating abstractions and automating labor, I don't really see the point of redoing the same thing over and over again in various classes and files.",
                "createdAt": "2020-08-10T22:11:20Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "You need a real example of using complex animations?\nhttps://github.com/gskinnerTeam/flutter_vignettes\n\nSurely, you can't expect me to dig through your whole project. Which file exactly should I look at?\n\nShowing some arbitrary complex animation would do nothing but obfuscate the example.\n\nThe exact opposite. Showing some arbitrary complex animation that cannot be solved by any existing solution would be the example, and that's what Hixie keeps asking, I believe.",
                "createdAt": "2020-08-10T22:12:46Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Just scan the gifs and begin to imagine how you might build some of that stuff. That repo is actually 17 standalone apps. You also can't expect me to write you some arbitrary animation just to prove to you that complex animations can exist. I've been building them for 20 years starting in Flash, every single one different than the last. And it's not specific to Animations anyways, they are just the simplest most familiar API to illustrate a larger point.\nLike you know how, when you use an animator, there's like 6 things you need to do everytime, but it also needs lifecycle hooks?? Ok, so now extend that to ANYTHING that has 6 steps you have to do everytime... And you need to use it in 2 places. Or you need to use 3 of them at once.  It's so obviously an issue on it's face, I don't know what else I can add to explain it.",
                "createdAt": "2020-08-10T22:15:53Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Programming is all about creating abstractions and automating labor, I don't really see the point of redoing the same thing over and over again in various classes and files.\n\nAll? So performance, maintainability is not relevant?\nThere comes a point when \"automating\" a labor and \"doing\" a labor is the same.",
                "createdAt": "2020-08-10T22:19:06Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Folks, it's fine if you don't have the time or inclination to create real examples, but please, if you are not interested in creating examples to explain the problem, you should also not expect people to then feel compelled to solve the problem (which is a lot more work than creating examples to show the problem). Nobody here is required to do anything for anyone, it's an open source project where we're all trying to help each other.\n@TimWhiting would you mind putting a license file in your https://github.com/TimWhiting/local_widget_state_approaches repo? Some people are unable to contribute without an applicable license (BSD, MIT, or similar ideally).",
                "createdAt": "2020-08-10T22:22:42Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "why should I, the user, tolerate such boilerplate in any case, given a sufficiently equivalent way of expressing the same thing?\n\nYes, maintainability and performance do matter of course. I mean when there is an equivalent solution, we should pick the one that has less boilerplate, is easier to read, is more reusable, and so on. That is not to say that hooks are the answer, as I have not measured their performance for example, but they are more maintainable in my experience. I am still unsure about your argument as to how it affects your work if a hook-like construct were put into the Flutter core.",
                "createdAt": "2020-08-10T22:22:50Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Just scan the gifs and begin to imagine how you might build some of that stuff.\n\nI scanned the gifs. I wouldn't use builder widgets.\nMany of the animations are so complex that if I knew you implemented them using the higher level builders, I probably wouldn't use your package.",
                "createdAt": "2020-08-10T22:23:04Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Anyway this discussion seems to be getting out of hand with more personal disagreements. We should focus on the main task at hand. I am not sure how hook proponents can show smaller examples if opponents will, as I said earlier, find ameliorations that don't truly solve the problem posed. I think we should contribute to @TimWhiting's repository for now.",
                "createdAt": "2020-08-10T22:24:53Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Showing some arbitrary complex animation that cannot be solved by any existing solution would be the example, and that's what Hixie keeps asking, I believe.\n\nShowing examples of something that is not possible today is out of the scope of this issue.\nThis issue is about improving the syntax of what is already feasible, not unblocking some things that are not possible today.\nAny request at providing something that is not possible today is off-topic.",
                "createdAt": "2020-08-10T22:25:18Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@TimWhiting would you mind putting a license file in your https://github.com/TimWhiting/local_widget_state_approaches repo? Some people are unable to contribute without an applicable license (BSD, MIT, or similar ideally).\n\nDone. Sorry, I haven't had much time to work on the examples, but I'll probably get to that sometime this week.",
                "createdAt": "2020-08-10T22:28:33Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "Showing some arbitrary complex animation that cannot be solved by any existing solution would be the example, and that's what Hixie keeps asking, I believe.\n\nShowing examples of something that is not possible today is out of the scope of this issue.\nThis issue is about improving the syntax of what is already feasible, not unblocking some things that are not possible today.\nAny request at providing something that is not possible today is off-topic.\n\nLet me rephrase what I said.\n\nShowing some arbitrary complex use case involving animations, states, etc that are difficult to write and that can be improved significanlty without impacting performance would be the example, and that's what Hixie keeps asking, I believe.\n\nI understand the push for less boilerplate, more reusability, more magic. I like having to write less code too, and the language/framework doing more work is quite appetizing.\nUntil now none of the examples/solution combos presented here would drastically improve code. That is, if we care about more than just how many lines of codes we have to write.",
                "createdAt": "2020-08-10T22:38:44Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Folks, it's fine if you don't have the time or inclination to create real examples, but please, if you are not interested in creating examples to explain the problem, you should also not expect people to then feel compelled to solve the problem (which is a lot more work than creating examples to show the problem). Nobody here is required to do anything for anyone, it's an open source project where we're all trying to help each other.\n@TimWhiting would you mind putting a license file in your https://github.com/TimWhiting/local_widget_state_approaches repo? Some people are unable to contribute without an applicable license (BSD, MIT, or similar ideally).\n\nI spent about 6 hours creating these various examples and code snippets. But I see really no point in providing concrete examples of complex animations just to prove that they can exist.\nThe request is to basically turn this into something that can not be handled by AnimatedContainer:\nContainer(margin: EdgeInsets.symmetric(vertical: value2 * 20, horizontal: value3 * 30), color: Colors.red.withOpacity(value1));\n\nThis is so trivial to the point of being almost intentionally obtuse to the issue. Is it so hard to imagine I might have a couple pulsing buttons, some particles moving, maybe a few text fields that fade in while scaling, or some cards that flip? Maybe I'm making a soundbar with 15 independant bars, maybe I'm sliding a menu in but also need the ability to slide individual items back out. And on, and on, and on. And this is just for Animations. It applies to any use case that is burdensome in the context of a widget.\nI think I provided excellent cananonical examples of the problem with both builders, and vanilla state-reuse:\n#51752 (comment)\n#51752 (comment)\nYou simply have to imagine many of these instances (pick your poison), spread far and wide across a project of 1000+ class files, and you get the perfect picture of the readability and maintainability issues we're trying to avoid.",
                "createdAt": "2020-08-10T22:42:00Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Would the example images that @esDotDev provided, showing how the nesting makes code harder to read, not be sufficient for you, @Rudiksz ? What is lacking from them? I suppose there are no performance metrics there but @rrousselGit sure they're not less performant than builders.",
                "createdAt": "2020-08-10T22:44:46Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@esDotDev I think the point is to have a singular canonical example from which all life cycle management solutions can be compared against (not just hooks but others in the future as well). It's the same principle as TodoMVC, you wouldn't necessarily point to various other  implementations in React, Vue, Svelte, etc as showing the difference between them, you'd want them all to be implementing the same application, then you can compare.",
                "createdAt": "2020-08-10T22:48:52Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "That makes sense to me, but I don't understand why it needs to be any bigger than a single page.\nManaging multiple animations is the perfect example of something that is common, requires a bunch of boilerplate, is error prone, and has no good solution currently. If that's not making the point, if people are going to say that they don't even understand how animations can be complex, then clearly any use-case will get knocked down for the context of the use case, and not the architectural issue we're trying to illustrate.",
                "createdAt": "2020-08-10T22:53:40Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Sure, the repository from @TimWhiting doesn't have a full blown app, it has singular pages as examples as you say, if you can make a canonical example of animation for that repository from which others could implement their solution, that would work.\nI also don't think we need a huge app or anything, but there should be sufficient complexity similar to that of TodoMVC. Basically it needs to be enough such that your opponents couldn't be able to say \"well I could do this better in such and such way\".",
                "createdAt": "2020-08-10T22:56:53Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Hixie The request for real apps to compare approaches is flawed.\nThere are two flaws:\n\nWe don't yet agree on the problem, as you said yourself you do not understand it\nWe cannot implement examples in real production conditions, as we will have missing pieces.\n\nFor example, we can't write an application using:\nfinal snapshot = keyword StreamBuilder();\nas this is not implemented.\nWe can't judge performances either, as this is comparing a POC vs production code.\nWe can't evaluate if something like \"hooks can't be called conditionally\" is error-prone either, as there is no compiler integration to point out errors when there is a misuse.",
                "createdAt": "2020-08-10T23:08:38Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Judging performance of designs, evaluating API usability, implementing things before we have implementations... those are all part of API design. Welcome to my job. :-) (Flutter trivia: did you know that the first few thousand lines of RenderObject and RenderBox et al were implemented before we created dart:ui?)",
                "createdAt": "2020-08-10T23:13:44Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "That does not change the fact that you are requesting the impossible.\nSome of the proposals made here are part of the language or the analyzer. It is impossible for the community to implement that.",
                "createdAt": "2020-08-10T23:17:35Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I'm not so sure, other frameworks and languages do API design all the time, I don't think it's too different here, or that Flutter has some overwhelming differences or difficulties for API design than other languages. As in, they do it without having compiler or analyzer support, they're just proofs of concept.",
                "createdAt": "2020-08-11T00:32:32Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I've put together an example of a 'complex' animation scenario that makes good use of 3 animations and it fairly loaded with boilerplate and cruft.\nImportant to note that I could have just done any animation that needs a hard snap back to starting position (eliminating all implicit widgets), or rotation on z axis, or scale on a single axis, or any other use case not covered by IW's. I worried those might not be taken seriously (though my designers will hand me this stuff all day long) so I built something more 'real world'.\nSo here is a simple scaffold, it has 3 panels that slide open and closed. It uses 3 animators with discrete states. In this case I don't really need the full control of AnimatorController, TweenAnimationBuilder would do ok, but the resulting nesting in my tree would be very undesireable. I can't nest the TAB's down the tree, as the panels have dependancies on eachothers values. AnimatedContainer is no option here as each panel needs to slide off screen, they do not \"squish\".\nhttps://i.imgur.com/BW6M3uM.gif\n\nclass _SlidingPanelViewState extends State<SlidingPanelView> with TickerProviderStateMixin {\n  AnimationController leftMenuAnim;\n  AnimationController btmMenuAnim;\n  AnimationController rightMenuAnim;\n\n  @override\n  void initState() {\n    // Here I have to pass vsync to AnimationController, so I have to include a SingleTickerProviderMixin and somewhat magically pass 'this' as vsync.\n    leftMenuAnim = AnimationController(duration: widget.slideDuration, vsync: this);\n    btmMenuAnim = AnimationController(duration: widget.slideDuration, vsync: this);\n    rightMenuAnim = AnimationController(duration: widget.slideDuration, vsync: this);\n    // Here I have to call forward 3 times, cause there's no way to automate this common setup behavior\n    leftMenuAnim.forward();\n    btmMenuAnim.forward();\n    rightMenuAnim.forward();\n    // Here I have to manually bind to build, cause there is encapsulate this common setup behavior\n    leftMenuAnim.addListener(() => setState(() {}));\n    btmMenuAnim.addListener(() => setState(() {}));\n    rightMenuAnim.addListener(() => setState(() {}));\n    super.initState();\n  }\n\n  // Following 2 fxn are a blind spot as far as compiler is concerned.\n  // Things may, or may not be implemented correctly, no warnings, no errors.\n  @override\n  void dispose() {\n    btmMenuAnim.dispose();\n    leftMenuAnim.dispose();\n    rightMenuAnim.dispose();\n    super.dispose();\n  }\n\n  @override\n  void didUpdateWidget(SlidingPanelView oldWidget) {\n    if (leftMenuAnim.duration != widget.slideDuration) {\n      leftMenuAnim.duration = widget.slideDuration;\n      btmMenuAnim.duration = widget.slideDuration;\n      rightMenuAnim.duration = widget.slideDuration;\n    }\n    super.didUpdateWidget(oldWidget);\n  }\n\n  // End error-prone blind spot without a single line of unique code\n  // ~50 lines in we can start to see some unique code\n\n  void _toggleMenu(AnimationController anim) {\n    bool isOpen = anim.status == AnimationStatus.forward || anim.value == 1;\n    isOpen ? anim.reverse() : anim.forward();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    double leftPanelSize = 320;\n    double leftPanelPos = -leftPanelSize * (1 - leftMenuAnim.value);\n    double rightPanelSize = 230;\n    double rightPanelPos = -rightPanelSize * (1 - rightMenuAnim.value);\n    double bottomPanelSize = 80;\n    double bottomPanelPos = -bottomPanelSize * (1 - btmMenuAnim.value);\n    return Stack(\n      children: [\n        //Bg\n        Container(color: Colors.white),\n        //Content Panel\n        Positioned(\n          top: 0,\n          left: leftPanelPos + leftPanelSize,\n          bottom: bottomPanelPos + bottomPanelSize,\n          right: rightPanelPos + rightPanelSize,\n          child: ChannelInfoView(),\n        ),\n        //Left Panel\n        Positioned(\n          top: 0,\n          left: leftPanelPos,\n          bottom: bottomPanelPos + bottomPanelSize,\n          width: leftPanelSize,\n          child: ChannelMenu(),\n        ),\n        //Bottom Panel\n        Positioned(\n          left: 0,\n          right: 0,\n          bottom: bottomPanelPos,\n          height: bottomPanelSize,\n          child: NotificationsBar(),\n        ),\n        //Right Panel\n        Positioned(\n          top: 0,\n          right: rightPanelPos,\n          bottom: bottomPanelPos + bottomPanelSize,\n          width: rightPanelSize,\n          child: SettingsMenu(),\n        ),\n        // Buttons\n        Row(\n          children: [\n            Button(\"left\", ()=>_toggleMenu(leftMenuAnim)),\n            Button(\"btm\", ()=>_toggleMenu(btmMenuAnim)),\n            Button(\"right\", ()=>_toggleMenu(rightMenuAnim)),\n          ],\n        )\n      ],\n    );\n  }\n}\n\n//Demo helpers\nWidget Button(String lbl, VoidCallback action) => FlatButton(child: Text(lbl), onPressed: action, color: Colors.grey);\nWidget ChannelInfoView() => _buildPanel(Colors.red);\nWidget ChannelMenu() => _buildPanel(Colors.pink);\nWidget SettingsMenu() => _buildPanel(Colors.blue);\nWidget NotificationsBar() => _buildPanel(Colors.grey);\nWidget _buildPanel(Color c) => Container(color: c, child: Container(color: Colors.white.withOpacity(.5)), padding: EdgeInsets.all(10));\n\nSo, of the 100 lines or so in that body, roughly 40% or so is pure boilerplate. 15 lines in particular, where anything missing or mis-typed, could cause hard-to-spot bugs.\nIf we use something like StatefulProperty, it would reduce the boilerplate to 15% or so (saves about 25 lines). Critically, this would completely resolve the issue of sneaky bugs and duplicate business logic, but it's still a little verbose especially as it requires StatefulWidget, which is a 10line hit right off the top.\nIf we use something like 'keyword' we reduce the boilerplate lines to essentially 0%. The entire focus of the class could be on the (unique) business logic and the visual tree elements. We make usage of StatefulWIdgets much more rare in general, the vast majority of the views become 10 or 20% less verbose and more focused.",
                "createdAt": "2020-08-11T02:38:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Also, worth noting that the Panel scenario above is real world, and in real world obviously this approach is really not nice, so we didn't use it, and you would not see it in the code base. Nor would we use nested builders, cause those look gross so you won't see that either.\nWe built a dedicated SlidingPanel widget, which takes an IsOpen property, and opens and closes itself. This is generally the solution in every single one of these use cases where you need some specific behavior, you move the stateful logic down into some ultra-specific widget, and you use that. You basically write your own ImplicitlyAnimatedWidget.\nThis does generally work ok, but it's still time and effort, and literally the ONLY reason it exists is because using Animations is so hard (which exists cause re-using stateful components in general is so hard). In Unity or AIR for example, I would not create a dedicate class simply to move a panel on a single axis, it would just be a single line of code to open or close, there would be nothing for a dedicated-widget to do. In Flutter we have to create a dedicated widget, cause it's literally the only reasonable way to encapsulate the bootstraping and teardown of AnimatorController (unless we want to nest,nest,nest with TAB)\nMy main point here is this type of thing is why real-world examples are so hard to find. As developers we can't let these things exist in our codebases too much, so we work around them with less-than-ideal-but-effective workarounds. Then when you look at the codebase, you just see these workarounds in effect and everything seems fine, but it might not be what the team wanted to make, it may have taken them 20% longer to get there, it may have been a total pain to debug, none of this is evident glancing at code.",
                "createdAt": "2020-08-11T02:48:55Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "For completeness, here is the same use case, made with builders.  Line count is heavily reduced, there is no chance for bugs, no need to learn foreign concept RE TickerProviderMixin...but that nesting is sadness, and the way the various variables are sprinkled throughout the tree (dynamic end values, value1, value2 etc) makes the business logic much harder to read than it needs to be.\nclass _SlidingPanelViewState extends State<SlidingPanelView> {\n  bool isLeftMenuOpen = true;\n  bool isRightMenuOpen = true;\n  bool isBtmMenuOpen = true;\n\n  @override\n  Widget build(BuildContext context) {\n    return TweenAnimationBuilder<double>(\n      tween: Tween(begin: 0, end: isLeftMenuOpen ? 1 : 0),\n      duration: widget.slideDuration,\n      builder: (_, leftAnimValue, __) {\n        return TweenAnimationBuilder<double>(\n          tween: Tween(begin: 0, end: isRightMenuOpen ? 1 : 0),\n          duration: widget.slideDuration,\n          builder: (_, rightAnimValue, __) {\n            return TweenAnimationBuilder<double>(\n              tween: Tween(begin: 0, end: isBtmMenuOpen ? 1 : 0),\n              duration: widget.slideDuration,\n              builder: (_, btmAnimValue, __) {\n                double leftPanelSize = 320;\n                double leftPanelPos = -leftPanelSize * (1 - leftAnimValue);\n                double rightPanelSize = 230;\n                double rightPanelPos = -rightPanelSize * (1 - rightAnimValue);\n                double bottomPanelSize = 80;\n                double bottomPanelPos = -bottomPanelSize * (1 - btmAnimValue);\n                return Stack(\n                  children: [\n                    //Bg\n                    Container(color: Colors.white),\n                    //Main content area\n                    Positioned(\n                      top: 0,\n                      left: leftPanelPos + leftPanelSize,\n                      bottom: bottomPanelPos + bottomPanelSize,\n                      right: rightPanelPos + rightPanelSize,\n                      child: ChannelInfoView(),\n                    ),\n                    //Left Panel\n                    Positioned(\n                      top: 0,\n                      left: leftPanelPos,\n                      bottom: bottomPanelPos + bottomPanelSize,\n                      width: leftPanelSize,\n                      child: ChannelMenu(),\n                    ),\n                    //Bottom Panel\n                    Positioned(\n                      left: 0,\n                      right: 0,\n                      bottom: bottomPanelPos,\n                      height: bottomPanelSize,\n                      child: NotificationsBar(),\n                    ),\n                    //Right Panel\n                    Positioned(\n                      top: 0,\n                      right: rightPanelPos,\n                      bottom: bottomPanelPos + bottomPanelSize,\n                      width: rightPanelSize,\n                      child: SettingsMenu(),\n                    ),\n                    // Buttons\n                    Row(\n                      children: [\n                        Button(\"left\", () => setState(() => isLeftMenuOpen = !isLeftMenuOpen)),\n                        Button(\"btm\", () => setState(() => isBtmMenuOpen = !isBtmMenuOpen)),\n                        Button(\"right\", () => setState(() => isRightMenuOpen = !isRightMenuOpen)),\n                      ],\n                    )\n                  ],\n                );\n              },\n            );\n          },\n        );\n      },\n    );\n  }\n}",
                "createdAt": "2020-08-11T03:23:06Z"
            },
            {
                "author": "Hixie",
                "bodyText": "That last one is interesting... I originally was going to suggest that the builders should be around the Positioned widgets rather than the Stack (and I would still suggest that for the left and right panels) but then I realised that the bottom one affects all three, and I realised that the builder just giving you one child argument actually isn't enough, because you really want to keep both the Container and the Row constant across builds. I suppose you can just create them above the first builder.",
                "createdAt": "2020-08-11T04:13:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "My main point here is this type of thing is why real-world examples are so hard to find. As developers we can't let these things exist in our codebases too much, so we work around them with less-than-ideal-but-effective workarounds. Then when you look at the codebase, you just see these workarounds in effect and everything seems fine, but it might not be what the team wanted to make, it may have taken them 20% longer to get there, it may have been a total pain to debug, none of this is evident glancing at code.\n\nFor the record, this is not an accident. This is very much by design. Having these widgets be their own widgets improves performance. We very much intended for this to be how people used Flutter. This is what I was referring to above when I mentioned \"a big part of Flutter's design philosophy is to guide people towards the right choice\".",
                "createdAt": "2020-08-11T04:17:00Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I originally was going to suggest that the builders should be around the Positioned widgets rather than the Stack (and I would still suggest that for the left and right panels)\n\nI actually ommitted it for the sake of succintness, but normally I would likely want a Content container here, and it would use the sizes from all 3 menus to define it's own position. Meaning all 3 need to be at the top of the tree, and if any rebuild, I need the entire view to rebuild, no getting around it. This is basically your classic desktop-style scaffold.\nOf course we could begin tearing apart the tree, always an option, we use it a lot for larger widgets, but I've never once seen that actually improve grokability at a glance, there's an extra cognitive step the reader needs to do at that point. The second you break the tree apart, I am suddenly following a bread crumb trail of variable assignments to figure out what is being passed here and how the whole thing fits together becomes occluded. Presenting the tree as a digestible tree is always easier to reason about from my experience.",
                "createdAt": "2020-08-11T04:40:05Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Probably a good use case for a dedicated RenderObject.",
                "createdAt": "2020-08-11T04:44:03Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Or 3 easily managed AnimatorObjects that can hook themselves into the widget lifecycle :D",
                "createdAt": "2020-08-11T04:44:31Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Having these widgets be their own widgets improves performance.\n\nSince we getting concrete here: In this case because this is a scaffold, every sub-view is already it's own widget, this guy is responsible for just laying out and translating children. The childen would be BottomMenu(), ChannelMenu(), SettingsView(), MainContent() etc\nIn this case we are wrapping a bunch of self-contained widgets, with another layer of self-contained widgets, simply to manage the boilerplate around moving them. I don't believe this is a performance win? In this case we are being pushed into what the framework thinks we want to do, and not what we actually want to do, which is to write an equally performant view in a more succint and coherent way.\n[Edit] I'll update the examples to add this context",
                "createdAt": "2020-08-11T05:03:03Z"
            },
            {
                "author": "Hixie",
                "bodyText": "The reason I suggest a dedicated RenderObject is that it would make the layout better. I agree that the animation aspect would be in a stateful widget, it would just pass down the three 0..1 doubles (value1, value2, value3) down to the render object instead of having the Stack math. But that's mostly a sideshow for this discussion; at the point where you're doing this, you'd still want to do the simplification afforded by Hooks or something similar in that stateful widget.\nOn a more relevant note, I had a crack at creating a demo for @TimWhiting's project: TimWhiting/local_widget_state_approaches#1\nI'm curious what a Hooks version would look like. I'm not sure I can see a good way to make it simpler, especially maintaining the performance characteristics (or improving them; there's a comment in there showing a place where it's currently suboptimal).",
                "createdAt": "2020-08-11T05:12:32Z"
            },
            {
                "author": "Hixie",
                "bodyText": "(I'm also very curious if this is the kind of thing where if we found a way to simplify it, we would be done here, or if it's missing critical things that we would need to solve before we were done.)",
                "createdAt": "2020-08-11T05:14:57Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Is the restoration stuff critical to this example? I'm having a hard time following because of it, and do not really know what RestorationMixin even does. I assume it is... going to take a bit to understand this for me. I'm sure Remi will crank out the hooks version in 4 seconds flat :)",
                "createdAt": "2020-08-11T05:58:13Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Using the restoration API using HookWidget rather than StatefulHookWidget is not supported at the moment.\nIdeally we should be able to change\nfinal value = useState(42);\ninto:\nfinal value = useRestorableInt(42);\nBut it needs some thinking, as the current restoration API wasn't really designed with hooks in mind.",
                "createdAt": "2020-08-11T10:33:02Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "As a side note, React hooks comes with a \"key\" feature, usually used like so:\nint userId;\n\nFuture<User> user = useMemo(() => fetchUser(id), [id]);\nwhere this code means \"cache the result of the callback, and re-evaluate the callback whenever anything inside the array changes\"\nFlutter_hooks have made a 1to1 reimplementation of this (as it's just a port), but I don't think that's what we would want to do for a Flutter optimized code.\nWe'd probably want:\nint userId;\n\nFuture<User> user = useMemo1(id, (id) => fetchUser(id));\nwhich would do the same thing, but remove the memory pressure by avoiding a list allocation and using a function tear-off\nIt's not critical at this stage, but worth mentioning if we're planning to use flutter_hooks for examples.",
                "createdAt": "2020-08-11T11:15:19Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Hixie I ported your animation example to hooks\nIt was an interesting example, kudos for thinking about it!\nIt's a good example in that, by default, the implementation of \"active\" and \"duration\" is all over the place (and depend on each other at that).\nTo the point were there are numerous \"if (active)\" / \"controller.repeat\" calls\nWhereas with hooks, all the logic is handled declaratively and concentrated in a single place, with no duplicate.\nThe example also shows how hooks can be used to easily cache objects \u2014 which fixed the issue of ExpensiveWidget rebuilding too often.\nWe get the benefits of const constructors, but it works with dynamic parameters.\nWe also get a better hot-reload. We can change the Timer.periodic duration for the background color and immediately see the changes in effect.",
                "createdAt": "2020-08-11T13:47:59Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@rrousselGit do you have a link? I didn't see anything new in @TimWhiting's repository.",
                "createdAt": "2020-08-11T16:56:13Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Using the restoration API using HookWidget rather than StatefulHookWidget is not supported at the moment.\n\nWhatever solution we come up with, we need to make sure it doesn't need to know about every last mixin. If someone wants to use our solution in combination with some other package that introduces a mixin just like TickerProviderStateMixin or RestorationMixin, they should be able to do so.",
                "createdAt": "2020-08-11T17:56:31Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "TimWhiting/local_widget_state_approaches#3\nAgreed, but I'm not worried about that. useAnimationController doesn't require users to care about SingleTickerProvider for example.\nAutomaritKeepAlive could benefit from the same treatment.\nOne of the thing I was thinking is to have a \"useKeepAlive(bool)\" hook\nThat avoids both the mixin and the \"super.build(context)\" (the latter being quite confusing)",
                "createdAt": "2020-08-11T21:47:00Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Another interesting point is the changes required during refactoring.\nFor example, we can compare the diff between the changes necessary to implement TickerMode for the raw approach vs hooks:\n\nStatefulWidget TimWhiting/local_widget_state_approaches@0cb7bf6\nhooks TimWhiting/local_widget_state_approaches@b955aab\n\nSome other things are mixed up in the diff, but we can see from it that:\n\nStatefulWidget required to move the logic to a completely different life-cycle\nHooks changes are purely additive. Existing lines were not edited/moved.",
                "createdAt": "2020-08-11T22:40:57Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Imo this is very important and a key win from this style of self contained state objects. Having everything based on nested contexts in a tree is fundamentally harder and more convoluted to refactor and change, which over the course of a project has an invisible but definite effect on the end quality of the codebase.",
                "createdAt": "2020-08-11T23:57:54Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Agreed!\nThat also makes code-reviews a lot easier to read:\nfinal value = useSomething();\n+ final value2 = useSomethingElse();\n\nreturn Container(\n  color: value.color,\n-  child: Text('${value.name}'),\n+  child: Text('${value.name} $value2'),\n);\nvs:\nreturn SomethingBuilder(\n  builder: (context, value) {\n-    return Container(\n-      color: value.color,\n-      child: Text('$value'),\n+    return SomethingElseBuilder(\n+      builder: (context, value2) {\n+        return Container(\n+          color: value.color,\n+          child: Text('${value.name} $value2'),\n+        );\n+      }\n    );\n  },\n);\nIt's not clear in the second diff that Container is unchanged and that only the Text changed",
                "createdAt": "2020-08-12T00:15:16Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@rrousselGit Do you think it makes sense to try and do a version representing how it could look with keyword support? Is it substantially similar to hooks with just a dedicated 'use' keyword, or does it become even easier to follow? Its hard to compare the hook approach on a even footing cause it has so many foreign concepts like useEffect, useMemo etc which I think make it look more magical than it is?",
                "createdAt": "2020-08-12T00:21:07Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another thing to note, is that where this all really would hit home, is if you had multiple widgets, that all needed to share this 'color-stepping' logic, but used the resulting color in totally different ways. With hooks-style approach, we just bundle up whatever logic makes sense to re-use, and we simply use it. There are no architectural corners we are forced into, it's truly agnostic and flexible.\nIn the Stateful approach, we are forced into\n\ncopy and pasting the logic (very un-maintainable)\nusing a builder (not super readable, especially when using nesting)\nmixing (doesn't compose well, very easy for different mixins to conflict in their shared state)\n\nThe key thing I think is that in the latter, you are immediately have an architectural problem, where should I put this in my tree, how can I best encapsulate this, should it be a builder, or maybe a custom widget? With the former the only decision is in which file to save this chunk of re-used logic, there is no impact to your tree at all. This is very nice architecturally when you want to use a few of these logic encapsulations together, move them up and down in your hierarchy or move to a sibling widget, etc",
                "createdAt": "2020-08-12T02:49:21Z"
            },
            {
                "author": "dt-ap",
                "bodyText": "I am, by no means, an expert developer. But this new style of reusing logic and write it in one place is really handy.\nI haven't use Vue.js in a long time, but they even have their own API (inspired from Hooks) for their next version, it might be worth to take a look.\n\nVue 3 Composition Api\nVue 3 Composition API comparison with React Hooks\n\nAnd CMIIW, I think the rules of react hooks (do not use conditional), does not apply with Composition API. So, you do not need to use linter to enforce the rules.",
                "createdAt": "2020-08-13T07:03:22Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Again the motivation section strongly reinforces the OP here:\n\nMOTIVATION\nThe code of complex components become harder to reason about as features grow over time. This happens particularly when developers are reading code they did not write themselves.\n[There was a] Lack of a clean and cost-free mechanism for extracting and reusing logic between multiple components.\n\nThe key words there being \"clean\" and \"cost free\". Mixins are cost-free but they are not clean. Builders are clean, but they are not cost-free in the readability sense, nor in the widget architectural sense as they're harder to move around the tree and reason about in terms of hierarchy.\nI also think this is important to note in the readability discussion: \"happens particularly when developers are reading code they did not write\". Of course your nested builder might be easy to read, you know whats there and can comfortably skip over it, it's reading someone else code, like you do on any larger project, or your own code from weeks/mths ago, when it becomes quite annoying/hard to parse & refactor these things.\nSome other especially relevant sections.\nWhy simply having components is not enough:\n\nCreating ... components allows us to extract repeatable parts of the interface coupled with its functionality into reusable pieces of code. This alone can get our application pretty far in terms of maintainability and flexibility. However, our collective experience has proved that this alone might not be enough, especially when your application is getting really big \u2013 think several hundreds of components. When dealing with such large applications, sharing and reusing code becomes especially important.\n\nOn why reducing logical fragmentation and encapsulating things more strongly is a win:\n\nfragmentation is what makes it difficult to understand and maintain a complex component. The separation of options obscures the underlying logical concerns. In addition, when working on a single logical concern, we have to constantly \"jump\" around option blocks for the relevant code. It would be much nicer if we could collocate code related to the same logical concern.",
                "createdAt": "2020-08-13T15:27:51Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I'm curious if there are other proposals for canonical examples that we're trying to improve other than the one I submitted.\nIf it's the starting point that people want to use then that's great. However, I would say the biggest problem with it right now is verbosity; there's not much code to reuse in that example. So it's not clear to me if it's a good representation of the problem as described in the OP.\nI've been thinking some more about how to express the characteristics that I personally would look for in a solution, and it made me realise one of the big problems that I see with the current Hooks proposal, which is one reason I wouldn't want to merge it into the Flutter framework: Locality and Encapsulation, or rather, the lack thereof. The design of Hooks uses global state (e.g. the static to track which widget is currently being built). IMHO this is a design characteristic that we should avoid. In general we try to make APIs self-contained, so if you call a function with one parameter, you should be confident that it won't be able to do anything with values outside of that parameter (this is why we pass the BuildContext around, rather than having the equivalent of useContext). I'm not saying this is a characteristic that everyone would necessarily want; and of course people can use Hooks if that's not a problem for them. Just that it's something I'd like to avoid doing more in Flutter. Every time we've had global state (e.g. in the bindings) we've ended up regretting it.",
                "createdAt": "2020-08-16T19:28:27Z"
            },
            {
                "author": "szotp",
                "bodyText": "Hooks could probably be methods on context (I think they were in early version), but honestly, I don't see much value in merging them as they currently are. Merge would need to have some adventages to separate package, like increased performance or hook specific debugging tools. Otherwise they would only add to the confusion, for example you would have 3 official ways of listening a listenable: AnimatedBuilder, StatefulWidget & useListenable.\nSo to me, the way to go is improving code generation - I have proposed some changes: #63323\nIf these suggestions were actually implemented, people who wanted magical SwiftUI-like solutions in their app could just make a package and not bother anyone else.",
                "createdAt": "2020-08-16T20:36:12Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Discussing the validity of hooks is kind of off-topic at this stage, as we still do not agree on the problem as far I as know.\nAs stated a few times in this issue, there are many other solutions, multiple of which are language features.\nHooks are merely a port of an existing solution from another tech that is relatively cheap to implement in its most basic form.\nThis feature could take a path completely different from hooks, such as what SwiftUI or Jetpack Compose do; the \"named mixin\" proposal, or the syntax sugar for Builders proposal.",
                "createdAt": "2020-08-17T10:39:24Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I insist on the fact that this issue at its core is asking for a simplification of patterns like StreamBuilder:\n\nStreamBuilder has a bad readability/writability due to its nesting\nMixins and functions are not a possible alternative to StreamBuilder\nCopy-pasting the implementation of StreamBuilder in all StatefulWidgets all over is not reasonable\n\nAll the comments so far mentioned alternatives of StreamBuilder, both for different behaviors (creating a disposable object, making HTTP requests, ...) or proposing different syntaxes.\nI'm not sure what else there is to say, so I don't see how we can progress any further.\nWhat is this that you do not understand/disagree with in this statement @Hixie?",
                "createdAt": "2020-08-17T10:48:08Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@rrousselGit Could you create a demo app that shows this? I tried to create a demo app that showed what I understood to be the issue, but apparently I did not get that right. (I'm not sure what the difference is between \"patterns like StreamBuilder\" and what I did in the demo app.)",
                "createdAt": "2020-08-17T17:46:27Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "StreamBuilder has a bad readability/writability due to its nesting\n\n\nYou already said verbosity is not the issue. Nesting is just another aspect of being verbose. If nesting is really an issue we should go after the Padding, Expanded, Flexible, Center, SizedBox and all other widgets that add nesting for no real reason. But nesting can be easily solved by splitting up monolithic widgets.\n\nCopy-pasting the implementation of StreamBuilder in all StatefulWidgets all over is not reasonable\n\nYou mean copy-pasting the lines of code that create and dispose the streams that the StatefulWidgets need to create and dispose? Yes, it's absolutely reasonable.\nIf you have 10's or god forbid hundreds of different custom StatefulWidgets that need to create/dispose their own streams - \"use\" in the hooks terminology-, you have bigger problems to worry about than \"\"logic\" reuse or nesting. I would worry about why my app has to create so many different streams in the first place.",
                "createdAt": "2020-08-17T17:47:07Z"
            },
            {
                "author": "Hixie",
                "bodyText": "To be fair, I think it's fine for someone to think a particular pattern isn't reasonable in their app. (That doesn't necessarily mean that the framework has to support that natively, but it would be good to at least allow a package to solve it.) If someone doesn't want to either use stream.listen or StreamBuilder(stream), that's their right, and maybe as a result we can find a pattern that is better for everyone.",
                "createdAt": "2020-08-17T18:01:21Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "To be fair, I think it's fine for someone to think a particular pattern isn't reasonable in their app.\n\nI am 100% on the same page as you.\nSure, people can do what whatever they want in their apps. What I'm trying to get at is that all the problems and difficulties described in this thread are result of bad programming habits, and in fact have very little to do with Dart or Flutter. That's like, just my opinion, but I'd say if anybody is writing an app that creates dozens of streams all over the place should maybe review their app design before asking the framework to be \"improved\".\nFor example, the hook implementation that made it in to the example repo.\n  @override\n  Widget build(BuildContext context) {\n    final value = useAnimation(animation);\n\n    final screenHeight = MediaQuery.of(context).size.height;\n    final textHeight =\n        useMemoized(() => math.sqrt(screenHeight), [screenHeight]);\n\n    return Text(\n      'Change Duration',\n      style: TextStyle(fontSize: 10.0 + value * textHeight),\n    );\n  }\n\nI have a bad feeling about this, so I did check some of the internals, and added some debug prints to check what's going on.\nYou can see from the output below that the Listenable hook checks weather it has been updated on every animation tick. As in, was the widget which \"uses\" that listenable updated? Was the duration changed? Was the instance replaced?\nThe memoized hook,I don't even know what is the deal with that.  It's probably meant to cache an object, yet on every single build the widget checks if the object changed? What? Why? Of course, because it's used inside a stateful widget and some other widget up the tree might change the value so we need to poll for changes. This is literal polling behaviour is the exact opposite of \"reactive\" programming.\nWhat's worse, the \"new\" and \"old\" hooks both have the same instance type, both have the same values, and yet the function iterates over the values to check if they changed. On every single animation tick.\nThis is the output I get, ad infinitum.\n/flutter (28121): Use hook:_ListenableHook\nI/flutter (28121): Is this the current hook:false\nI/flutter (28121): 1: --- inside shouldPreserveState ----\nI/flutter (28121): Hook1:Instance of '_ListenableHook'\nI/flutter (28121): Hook1 keys:null\nI/flutter (28121): Hook2 :Instance of '_ListenableHook'\nI/flutter (28121): Hook2 keys:null\nI/flutter (28121): 2. Shoud we preserve the  state of _ListenableHook:true\nI/flutter (28121): 3: --------------\nI/flutter (28121): checking if the listenable did change\nI/flutter (28121): Did the listenable change?false\nI/flutter (28121): Use hook:_MemoizedHook<double>\nI/flutter (28121): Is this the current hook:false\nI/flutter (28121): 1: --- inside shouldPreserveState ----\nI/flutter (28121): Hook1:Instance of '_MemoizedHook<double>'\nI/flutter (28121): Hook1 keys:[1232.0]\nI/flutter (28121): Hook2 :Instance of '_MemoizedHook<double>'\nI/flutter (28121): Hook2 keys:[1232.0]\nI/flutter (28121): iterating over the hooks keys\nI/flutter (28121): 2. Shoud we preserve the  state of _MemoizedHook<double>:true\nI/flutter (28121): Use hook:_ListenableHook\nI/flutter (28121): Is this the current hook:false\nI/flutter (28121): 1: --- inside shouldPreserveState ----\nI/flutter (28121): Hook1:Instance of '_ListenableHook'\nI/flutter (28121): Hook1 keys:null\nI/flutter (28121): Hook2 :Instance of '_ListenableHook'\nI/flutter (28121): Hook2 keys:null\nI/flutter (28121): 2. Shoud we preserve the  state of _ListenableHook:true\n\n\nAll this work is done on every single animation tick. If I add another hook like \"final color = useAnimation(animationColor);\", to animate the color too, now the widget checks two times if it was updated.\nI'm sitting here watching a text animate back and forth with no change in the app state or any of the widgets or the widget tree, and still the hooks are constantly checking if the tree/widgets were updated. Having every widget that \"uses\" these particular hooks do this polling behaviour is bad.\nHandling initialization/update/disposal logic of state objects inside the build method is just bad design. No amount of improvements gained in reusability, hotreload or cognitive load, justifies the impact on performance.\nAgain, in my opinion. Hooks being a package, anybody can use them if they think the gains justify the overhead.\nAlso I don't think any amount of language features, compiler magic or abstraction can prevent such unnecessary checks, if we start trying to abstract away everything inside the build process. So we are left with alternatives like extending the StatefulWidget. Something that can already be done, and was dismissed countless times.",
                "createdAt": "2020-08-17T19:20:39Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Hixie you haven't answered the question. What is it that you do not understand/agree with in the bullet list listed above?\nI can't make an example without knowing what you want me to demonstrate.",
                "createdAt": "2020-08-17T19:35:22Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@Rudiksz For sure any solution we would actually consider would need to be profiled and benchmarked to make sure it's not making things worse. Part of the way I constructed the demo app I submitted to @TimWhiting is intended to cover exactly the kinds of patterns that can be easy to mess up. (And, as noted earlier, it does leave room for improvement, see the TODO in the code.)\n@rrousselGit I didn't really want to get into the weeds on this because it's so subjective but since you ask:\n\nFirst, I would avoid using Streams in general. ValueListenable is IMHO a much better pattern for more or less the same use cases.\nI don't think StreamBuilder is particularly hard to read or write; but, as @satvikpendem commented earlier, my history is with deeply nested trees in HTML, and I've been staring at Flutter trees for 4 years now (I've said before that Flutter's core competency is how to efficiently walk giant trees), so I probably have a higher tolerance than most people, and my opinion here isn't really relevant.\nAs to whether mixins and functions might be a possible alternative to StreamBuilder, I think Hooks demonstrates pretty well that you can definitely use functions to listen to streams, and mixins can clearly do anything classes can do here so I don't see why they wouldn't be a solution either.\nFinally, regarding copy-pasting implementations, that's a subjective matter. I don't personally copy and paste the logic in initState/didUpdateWidget/dispose/build, I write it anew each time, and it seems mostly fine. When it gets \"out of control\" I factor it out into a widget like StreamBuilder. So again my opinion probably isn't relevant here.\n\nAs a general rule, whether I experience the problem you're seeing or not isn't relevant. Your experience is valid regardless of my opinion. I'm happy to work on finding solutions to the problems you experience, even if I don't feel those problems. The only effect of my not experiencing the problem myself is that it is harder for me to understand the problem well, as we have seen in this discussion.\nWhat I would like you to demonstrate is the coding pattern that you think is unacceptable, in a demo that is significant enough that when someone creates a solution, you would not dismiss it by saying that it may get difficult to use when in a different situation (i.e. include all the relevant situations, for example, make sure to include \"update\" parts or whatever other parts you think are important to handle), or saying that the solution works in one case but not in the general case (e.g. to take your earlier feedback, making sure that parameters are coming from multiple places and updating in multiple situations so that it's obvious that a solution like Property above wouldn't factor out otherwise common code).",
                "createdAt": "2020-08-17T20:33:51Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The issue is, you are asking examples for something that is in the domain of \"obvious\" to me.\nI do not mind making some examples, but I have no idea what you are expecting, since I don't understand what you don't understand.\nI have already said everything I had to say.\nThe only thing I can do without understanding what you don't understand is to repeat myself.\nI can make some of the snippets here run, but that's equivalent to repeating myself.\nIf the snippet wasn't useful, I don't see why being able to run it would change anything.\n\nAs to whether mixins and functions might be a possible alternative to StreamBuilder, I think Hooks demonstrates pretty well that you can definitely use functions to listen to streams, and mixins can clearly do anything classes can do here so I don't see why they wouldn't be a solution either.\n\nHooks should not be considered as functions.\nThey are a new language construct akin to Iterable/Stream\nFunctions cannot do what hooks do \u2014 the do not have a State or the capability to cause widgets to rebuild.\nThe problem with mixins is demonstrated in the OP. TL;DR: Name clash on variables and it is impossible to reuse the same mixin multiple times.",
                "createdAt": "2020-08-17T21:12:20Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@rrousselGit Well, since you don't mind making some examples, and since the examples I'm asking for are obvious, let's start with some of these obvious examples and iterate from there.",
                "createdAt": "2020-08-17T21:24:04Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I didn't say the examples are obvious, but the problem is.\nWhat I meant is, I cannot create new examples. Everything I have to say is already in this thread:\n\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n#51752 (comment)\n\nI can't think of anything to add to these examples.\nBut FWIW I'm working on an open-source weather app using Riverpod. I'll link it here when it's done.\n\nI've made a poll on twitter asking a few questions about Builders related to the problems discussed here:\nhttps://twitter.com/remi_rousselet/status/1295453683640078336\nThe poll is still pending, but here are the current numbers:\n\nThe fact that 86% of 200 people wish for a way to write Builders that do not involve nesting speaks for itself.",
                "createdAt": "2020-08-18T06:36:30Z"
            },
            {
                "author": "Hixie",
                "bodyText": "To be clear, I've never suggested that we should not address this issue. If I thought we should not address it, the issue would be closed.\nI guess I'll try to make an example that uses the snippets you linked to.",
                "createdAt": "2020-08-18T06:48:39Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I can help you make examples based on the snippets linked, but I need to know why these snippets were not good enough\nOtherwise, the only thing I can do is make these snippets compile, but I doubt that's what you want.\nFor example, here's a gist about the numerous ValueListenableBuilder+TweenAnimationBuilder https://gist.github.com/rrousselGit/a48f541ffaaafe257994c6f98992fa73",
                "createdAt": "2020-08-18T07:44:07Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "For example, here's a gist about the numerous ValueListenableBuilder+TweenAnimationBuilder https://gist.github.com/rrousselGit/a48f541ffaaafe257994c6f98992fa73\n\nFWIW, this one particular example can be more easily implemented in mobx.\nIt's actually shorter than your hooks implementation.\nMobx's observables are  ValueNotifiers on steroids and its Observer widget is the evolution of Flutter's ValueListenableBuilder - it can listen to more than one ValueNotifier.\nBeing a drop-in replacement for ValueNotifier/ValueListenableBuilder combo, means that you still write idiomatic Flutter code, which is actually an important factor.\nSince it still uses Flutter's built in Tween builder here's no need to learn/implement new widgets/hooks (in other words it needs no new features) and it has none of the performance hits of hooks.\nimport 'package:flutter/material.dart';\nimport 'package:flutter_mobx/flutter_mobx.dart';\nimport 'counters.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Home1(),\n    );\n  }\n}\n\nvar counters = Counters();\n\nclass Home1 extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: [\n            Observer(\n              builder: (context) => TweenAnimationBuilder<int>(\n                duration: const Duration(seconds: 5),\n                curve: Curves.easeOut,\n                tween: IntTween(end: counters.firstCounter),\n                builder: (context, value, child) {\n                  return Text('$value');\n                },\n              ),\n            ),\n            RaisedButton(\n              onPressed: () => counters.firstCounter += 100,\n              child: Text('+'),\n            ),\n            // Both counters have voluntarily a different Curve and duration\n            Observer(\n              builder: (context) => TweenAnimationBuilder<int>(\n                duration: const Duration(seconds: 2),\n                curve: Curves.easeInOut,\n                tween: IntTween(end: counters.secondCounter),\n                builder: (context, value, child) {\n                  return Text('$value');\n                },\n              ),\n            ),\n            RaisedButton(\n              onPressed: () => counters.secondCounter += 100,\n              child: Text('+'),\n            ),\n            const Text('total:'),\n            // The total must take into account the animation of both counters\n            Observer(\n              builder: (context) => TweenAnimationBuilder<int>(\n                duration: const Duration(seconds: 5),\n                curve: Curves.easeOut,\n                tween: IntTween(\n                    end: counters.firstCounter + counters.secondCounter),\n                builder: (context, value, child) {\n                  return Text('$value');\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n\nCounters.dart being as simple as...\npart 'counters.g.dart';\n\nclass Counters = _Counters with _$Counters;\nabstract class _Counters with Store {\n  @observable\n  int firstCounter = 0;\n\n  @observable\n  int secondCounter = 0;\n}\n\nHere's another implementation that doesn't even need animationbuilders. The widget's build method is as pure as it can be, almost like a semantic html file ... like a template.\nhttps://gist.github.com/Rudiksz/cede1a5fe88e992b158ee3bf15858bd9",
                "createdAt": "2020-08-18T12:16:37Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Rudiksz The behavior of the \"total\" field is broken in your snippet. It doesn't match the example, where both counters may animate together but finish animating at different times and with different curves.\nSimilarly, I am not sure what this example adds to the ValueListenableBuilder variant.\nAs for your last gist, TickerProvider is broken as it does not support TickerMode \u2013 nor are listeners removed or controllers disposed of.\nAnd Mobx is likely off-topic. We aren't discussing how to implement ambient state /  ValueListenable vs Stores vs Streams, but rather how to deal with local state / nested Builders \u2013 which Mobx does not solve in any way\n\u2013\u2013\u2013\u2013\nAlso, bear in mind that in the hooks example, useAnimatedInt could/should be extracted into a package and that there is no duplicate of the duration/curve between the individual text animation and the total.\nAs for performances, with Hooks we are rebuilding only a single Element, whereas with Builders with are rebuilding 2-4 Builders.\nSo Hooks could very well be faster.",
                "createdAt": "2020-08-18T12:39:33Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "The behavior of the \"total\" field is broken in your snippet. It doesn't match the example, where both counters may animate together but finish animating at different times and with different curves.\n\nYou clearly didn't even try to run the exmple. It behaves exactly like your code.\n\nAs for your last gist, TickerProvider is broken as it does not support TickerMode.\n\nI don't know what you mean by this. I refactored your example, which does not use TickerMode. You again are changing the requirements.\n\nAs for performances, with Hooks we are rebuilding only a single Element, whereas with Builders with are rebuilding 2-4 Builders. So Hooks could very well be faster.\n\nNo just no. Your hook widgets constantly poll for changes on every single build. Builders based on valuelistenables are \"reactive\".\n\nSimilarly, I am not sure what this example adds to the ValueListenableBuilder variant.\n\n\nAnd Mobx is likely off-topic. We aren't discussing how to implement ambient state / ValueListenable vs Stores vs Streams, but rather how to deal with local state / nested Builders \u2013 which Mobx does not solve in any way\n\nYou must be kidding.  I took your example and \"dealt\" with nested ValueListenableBuilders *and tween builders?! A point you specifically brought up as an issue.\nBut this sentence here, describes your whole attitude towards this discussion. If it's not hooks it's \"off-topic\", but you say that you don't care if it's hooks that will be used as a solution.\nGive me a break.",
                "createdAt": "2020-08-18T12:56:33Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "You clearly didn't even try to run the exmple. It behaves exactly like your code.\n\nIt doesn't. The first counter animates over 5 seconds, and the second over 2 seconds \u2013 and both uses a different Curve too.\nWith both snippets I gave, you could increment both counters at the same time, and during every single frame of the animation, the \"total\" would be correct. Even when the second counter stops animating while the first counter is still animating\nOn the other hand, your implementation does not consider this case, because it merged the 2 TweenAnimationBuilders into one.\nTo fix it, we would have to write:\nObserver(\n  builder: (context) {\n    return TweenAnimationBuilder<int>(\n      duration: const Duration(seconds: 5),\n      curve: Curves.easeOut,\n      tween: IntTween(end: counters.firstCounter),\n      builder: (context) {\n        return Observer(\n          valueListenable: secondCounter,\n          builder: (context, value2, child) {\n            return TweenAnimationBuilder<int>(\n              duration: const Duration(seconds: 2),\n              curve: Curves.easeInOut,\n              tween: IntTween(end: counters.secondCounter),\n              builder: (context, value2, child) {\n                return Text('${value + value2}');\n              },\n            );\n          },\n        );\n      },\n    );\n  },\n)\nThe two TweenAnimationBuilders are necessary to respect the fact that both counters can animate individually. And the two Observer are necessary because the first Observer cannot observe counters.secondCounter\n\n\nNo just no. Your hook widgets constantly poll for changes on every single build. Builders based on valuelistenables are \"reactive\".\n\nYou are ignoring what Element does, which happens to be the same thing than what hooks do: comparing runtimeType and keys, and deciding whether to create a new Element or update the existing one\n\nI took your example and \"dealt\" with nested ValueListenableBuilders *and tween builders\n\nAssuming that the issue with the total count is fixed, what nesting was removed?\nObserver(\n  builder: (context) => TweenAnimationBuilder<int>(\n    duration: const Duration(seconds: 5),\n    curve: Curves.easeOut,\n    tween: IntTween(end: counters.firstCounter),\n    builder: (context, value, child) {\n      return Text('$value');\n    },\n  ),\n),\nis no different from:\nValueListenableBuilder<int>(\n  valueListenable: firstCounter,\n  builder: (context, value, child) => TweenAnimationBuilder<int>(\n    duration: const Duration(seconds: 5),\n    curve: Curves.easeOut,\n    tween: IntTween(end: value),\n    builder: (context, value, child) {\n      return Text('$value');\n    },\n  ),\n),\nin terms of nesting.\nIf you are referring to your gist, then as I mentioned before, this approach breaks TickerProvider/TickerMode. The vsync needs to be obtained using SingleTickerProviderClientStateMixin or it otherwise does not support the muting logic, which can cause performance issues.\nI've explained this in an article of mine: https://dash-overflow.net/articles/why_vsync/\nAnd with this approach, we have to reimplement the Tween logic in every location that would originally want a TweenAnimationBuilder. That leads to a significant duplicate, especially considering the logic is not so trivial",
                "createdAt": "2020-08-18T13:18:59Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "With both snippets I gave, you could increment both counters at the same time, and during every single frame of the animation, the \"total\" would be correct. Even when the second counter stops animating while the first counter is still animating\n\n\nOn the other hand, your implementation does not consider this case, because it merged the 2 TweenAnimationBuilders into one.\n\nYes, that's a trade-off I was willing to make. I could easily imagine a case where the animation would be just a visual feedback for change happening and the accurancy is not important. It all depends on the requirements.\nI suspected you would object though, hence the second version which solves this exact problem, while making the code even cleaner.\n\nIf you are referring to your gist, then as I mentioned before, this approach breaks TickerProvider/TickerMode. The vsync needs to be obtained using SingleTickerProviderClientStateMixin or it otherwise does not support the muting logic, which can cause performance issues.\n\nSo you create the tickerprovider in the widget and pass it to the Counters. I also didn't dispose of the animation controllers either. These details are so trivial to implement I didn't feel like they would add anything to the example. But here we are nitpicking on them.\nI implemented the Counter() class to do what your example does and nothing more.",
                "createdAt": "2020-08-18T13:43:12Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "And with this approach, we have to reimplement the Tween logic in every location that would originally want a TweenAnimationBuilder. That leads to a significant duplicate, especially considering the logic is not so trivial\n\nWhat? why? Pleasae explain, why I couldn't create more than one instance of the Counter class and use them in various widgets?",
                "createdAt": "2020-08-18T13:44:52Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@Rudiksz I am not sure your solutions are actually solving the problems set forth. You say\n\nI implemented the Counter() class to do what your example does and nothing more.\n\nand yet\n\nYes, that's a trade-off I was willing to make. I could easily imagine a case where the animation would be just a visual feedback for change happening and the accurancy is not important. It all depends on the requirements.\n\n\nSo you create the tickerprovider in the widget and pass it to the Counters. I also didn't dispose of the animation controllers either. These details are so trivial to implement I didn't feel like they would add anything to the example. But here we are nitpicking on them.\n\nYou provided code that is only ostensibly equivalent to @rrousselGit's hook version, yet it is not actually equivalent, as you leave out parts that the hook version includes. In that case, they are not really comparable, right? If you would like to compare your solution to the suggested one, it would be best to make it match the requirements exactly instead of talking about why you did not include them. This is something that is the reason for making @TimWhiting's repository. You can submit your solution there if you think you have covered all of the requirements.\n\nYou clearly didn't even try to run the exmple. It behaves exactly like your code.\n\n\nNo just no.\n\n\nYou must be kidding. I took your example and \"dealt\" with nested ValueListenableBuilders *and tween builders\n\nPlease refrain from accusations like these, they only serve to make this thread vitriolic without solving the underlying problems. You can make your points without being accusatory, derogatory to, or angry at the other party, which is the effect of the comments I see in this thread, I don't see such behavior from others towards you. I'm also not sure what the effect is to emoji-react to your own post.",
                "createdAt": "2020-08-18T14:42:31Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@rrousselGit\n\nI can help you make examples based on the snippets linked, but I need to know why these snippets were not good enough\nOtherwise, the only thing I can do is make these snippets compile, but I doubt that's what you want.\n\nThe reason I'm asking for a more elaborate app than just a snippet is that when I posted an example that handled one of your snippets, you said that that wasn't good enough because it didn't also handle some other case that wasn't in your snippet (e.g. didn't handle didUpdateWidget, or didn't handle having two of these snippets side by side, or other perfectly reasonable things that you would like handled). I'm hoping with a more elaborate app we can get it elaborate enough that once we have a solution, there's no \"gotcha\" moment where some new problem is brought out that needs handling as well. Obviously it's still possible that we'll all miss something that needs handling, but the idea is to minimize the chance.\nRegarding the recent less-than-entirely-welcoming posts, please folks, let's just focus on creating examples on @TimWhiting's repo rather than fighting back and forth with small examples. As we've already discussed, small examples will never be elaborate enough to be sufficiently representative to prove an alternative actually works well.",
                "createdAt": "2020-08-18T17:46:58Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "You can submit your solution there if you think you have covered all of the requirements.\n\nThe requirements were changed after the fact. I provided two solutions. One that makes a compromise (a very reasonable one) and one that implements the exact behavour the example provided.\n\nYou provided code that is only ostensibly equivalent to @rrousselGit's hook version, yet it is not actually equivalent,\n\nI didn't implement the \"hooks solution\", I implemented the ValueListenableBuilder example, specifically focusing on the \"nesting issue\". It doesn't do every single thing hooks do, I simply showcased how one item in the bullet list of grievances can be simplified using an alternative solution.\nIf you are allowed to bring in external packages into the discussion, than so am I.\nReusability: take a look at the example in the repo below\nhttps://github.com/Rudiksz/cbl_example\nNote:\n\nit's meant as a showcase of how you can encapsulate \"logic\" outside widgets and have widgets that are lean, almost html looking\nit does not cover everything hooks cover. That's not the point. I thought we are discussing alternatives to the stock Flutter framework, and not the hooks package.\nIt does not cover every use case every marketing team can come up\nbut, the Counter object itself is pretty flexible, it can be used standalone (see the AppBar title), as part of a complex widget that needs to calculate totals of different counters, be made reactive, or respond to user inputs.\nIt's up to the consuming widgets to customize the amount, initial value, duration, animation type of the counters they want to use.\nthe details of the way animations are handled may have downsides. If the Flutter team says that yes, using Animation controllers and tweens outside the widgets, somehow breaks the framework, I will reconsider. There are definitely things to improve. Replacing the custom tickerprovider I use with one created by the consuming widget's mixin is trivial. I haven't done it.\nThis is just one more alternative solution to the \"Builder\" pattern. If you say you need or want to use Builders, then none of this applies.\nStill, fact is that there are ways to simplify code, without extra features. If you don't like it, don't buy it. I'm not advocating any of this to make it into the framework.\n\nEdit: This example has a bug, if you initiate an \"increment\" while the change is animated, the counter is reset and is incremented from the current value. I didn't fix it on purpose, because I don't know the exact requirements you might have for these \"counters\".  Again it's trivial to change the increment/decrement methods, to fix this issue.\nThat is all.",
                "createdAt": "2020-08-18T17:58:10Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@Hixie Should I interpret your comment as a way of saying that my example (https://github.com/TimWhiting/local_widget_state_approaches/blob/master/lib/hooks/animated_counter.dart) is not good enough?\nAlso, could we have a Zoom/Google meet call?",
                "createdAt": "2020-08-18T18:51:51Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "I'm also not sure what the effect is to emoji-react to your own post.\n\nNothing. It's totally irrelevant to anything. Why did you bring it up?",
                "createdAt": "2020-08-18T18:52:49Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@rrousselGit Only you can know if it's good enough. If we find a way to refactor that example so that it's clean and short and has no duplicate code, will you be satisfied? Or are there things you think we should support that aren't handled by that example that we need to handle to satisfy this bug?",
                "createdAt": "2020-08-18T19:20:29Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Only you can know if it's good enough\n\nI cannot be the judge of that. To begin with, I do not believe that we can capture the problem using a finite set of applications.\nI don't mind working like you want me to, but I need guidance as I do not understand how that will make us progress.",
                "createdAt": "2020-08-18T20:59:54Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think we've provided a ton of code snippets that show the problem from our perspective. I really dont think will become more clear through more code examples, if the ones shown are not doing it.\nFor example, if seeing multiple nested builders that are horrible to read, or 50 lines of pure boilerplate that has many opportunities for bugs, does not demonstrate the issue strongly enough, there is nowhere to go.\nIt's very strange to proffer mixins and functions are a solution here, when the entire ask is encapsulated state, that is re-usable. Functions can not maintain state. Mixins are not encapsulated. This suggestion misses the entire point of all of the examples and rationale provided and still shows a deep misunderstanding of the ask.\nTo me, I think we've beaten 2 points into the earth, and I don't think can seriously argue with either.\n\nNested builders are inherently hard to read\nOther than nested builders there is no way to encapsulate and share state that has widget lifecycle hooks.\n\nAs stated many times, and even in Remi's poll, simply put: We want to capabilities of builder, without the verbosity and nested closures of builder. Does that not completely sum it up? I'm totally confused why is a further code example required to proceed here.\nRemi's poll shows us that a ~80% of Flutter dev's would prefer some sort of ability to avoid nested builders in their code when possible. This really does speak for itself imo. You don't need to take it from us in this thread, when community sentiment is so clear.\nFrom my perspective, the issues are clear, and they are made even more clear when you look at competing frameworks that dedicate paragraphs to describing the rationale here. Vue, React, Flutter they are all cousins, they all are derived from React, and they all face this issue with re-using state that has to tie into widget lifecycle. They all describe why they have implemented something like this in detail. It's all right there. It's all relevant.",
                "createdAt": "2020-08-18T23:20:09Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@rrousselGit could you make an example of having many multiple hooks? For example, I am making an animation with possibly dozens of AnimationControllers. With regular Flutter, I can do:\nList<AnimationController> controllers = [];\nint numAnimationControllers = 50;\n\n@override\nvoid initState() {\n    for (int i = 0; i < numAnimationControllers; i++)\n        controllers.add(AnimationController(...));\n}\n\n@override\nvoid dispose() {\n    for (int i = 0; i < numAnimationControllers; i++)\n        controllers[i].dispose();\n}\nBut with hooks I cannot call useAnimationController in a loop. I suppose this is a trivial example but I couldn't really find the solution anywhere for this type of use case.",
                "createdAt": "2020-08-18T23:22:24Z"
            },
            {
                "author": "sahandevs",
                "bodyText": "@satvikpendem\nfew examples from my apps that are in production (some of the hooks like sending request with pagination can merge/refactor into a single hook but that's irrelevant here):\nsimple data fetching with pagination:\n    final selectedTab = useState(SelectedTab.Wallet);\n    final isDrawerOpen = useValueNotifier(false);\n    final pageNo = useValueNotifier(0);\n    final generalData = useValueNotifier(initialData);\n    final services = useXApi();\n    final isLoading = useValueNotifier(false);\n    final waybillData = useValueNotifier<List<WaybillResponseModel>>([]);\n    final theme = useTheme();\n    final router = useRouter();\n\n    fetchNextPage() async {\n      if (isLoading.value || selectedTab.value != SelectedTab.Wallet) return;\n      isLoading.value = true;\n      final request = WaybillRequestModel()..pageNo = pageNo.value;\n      final result = await services.waybillGetList(model: request);\n      if (result.isOk && result.data.length > 0) {\n        pageNo.value += 1;\n        waybillData.value = [...waybillData.value, ...result.data];\n      }\n      isLoading.value = false;\n    }\n\n    // first fetch\n    useEffect(() {\n      fetchNextPage();\n      return () {};\n    }, []);\nform logic (login form with phone number verification and resend timer):\n    final theme = useTheme();\n    final loginState = useValueNotifier(LoginState.EnteringNumber);\n    final error = useValueNotifier<String>(null);\n    final phoneNumberController = useTextEditingController(text: \"\");\n    final phoneNumberFocusNode = useMemoized(() => FocusNode(), []);\n    final otpFocusNode = useMemoized(() => FocusNode(), []);\n    final otpController = useTextEditingController(text: \"\");\n    final appState = Provider.of<AppStateController>(context);\n    final services = useXApi();\n    final router = useRouter();\n    final resendTimerValue = useValueNotifier(0);\n    useEffect(() {\n      var timer = Timer.periodic(Duration(seconds: 1), (t) async {\n        if (resendTimerValue.value > 0) resendTimerValue.value--;\n      });\n      return () => timer.cancel();\n    }, []);\n\n    final doLogin = () async {\n      // login\n      loginState.value = LoginState.LoggingIn;\n      final loginResult = await services.authLoginOrRegister(\n        mobileNumber: phoneNumberController.text,\n      );\n      if (loginResult.isOk) {\n        loginState.value = LoginState.EnteringOtpCode;\n        WidgetsBinding.instance.addPostFrameCallback((_) {\n          FocusScope.of(context).requestFocus(otpFocusNode);\n        });\n        resendTimerValue.value = 30;\n      } else {\n        error.value = loginResult.errorMessage;\n        loginState.value = LoginState.EnteringNumber;\n        WidgetsBinding.instance.addPostFrameCallback((_) {\n          FocusScope.of(context).requestFocus(phoneNumberFocusNode);\n        });\n      }\n    };\nfor animation, I think @rrousselGit already provided enough example.\nI don't want to talk about how composable nature of hooks can make refactoring above code much easier, reusable and cleaner but if you want I can post refactored versions too.",
                "createdAt": "2020-08-19T00:00:32Z"
            },
            {
                "author": "Rudiksz",
                "bodyText": "As stated many times, and even in Remi's poll, simply put: We want to capabilities of builder, without the verbosity and nested closures of builder. Does that not completely sum it up? I'm totally confused why is a further code example required to proceed here.\n\nI literally provided examples of how you can reduce verbosity and avoid nestedness of builders using an example Remi provided.\nI took his code stuck it into my app, ran it and rewrote it. The end result as far as functinality is concerned was nearly identical - as much as I could glean from just running the code, because the code didn't come with requirements. Sure we can discuss the edge cases and potential problems, but instead it was called off-topic.\nFor simple use cases I use Builders, for complex use cases I don't use Builders. The argument here is that without using Builders there's no easy way to write concise, reusable code. Implicitly, that's also means that Builders are a must have, and the only way to develop Flutter apps. That is demonstrably false.\nI just showed a working, proof of concept code that demonstrates it. It didn't use Builders or hooks, and it does not cover 100% of the \"infinite set of problems\" that this particular github issue seems to want to solve. It was called off-topic.\nSidenote, it's also very efficient, even without any benchmark I would guess even beats the Builder widgets. I'm happy to change my mind if proven wrong, and if I ever find Mobx to become a performance bottleneck I will ditch Mobx and switch to vanilla builders in a heartbeat.\nHixie works for Google, he has to be patient and polite with you and can't call you out on your lack of engagment. The best he can do is to push for more examples.\nI didn't call anybody names, or bring in personal attacks. I only ever reacted to the arguments presented here, shared my opinion\n(which I know is unpopular and in the minority) and even tried to present actual counter examples with code. I could do more, I'm willing to discuss where my examples fall short and see ways we can improve them, but yeah, being called off-topic is kind of off-putting.\nI have nothing to lose, other than maybe being banned, so I don't really care calling you out.\nIt is evident that you two are dead set that hooks are the only solution (\"because React does it\") to whatver the problems you experience and that unless an alternative  fullfills 100% of the \"infinite set of problems\" that you are imagining, you won't even consider engaging.\nThat is not reasonable, and shows lack of desire to truly engage.\n\nOf course, everything above \"is just my opinion\".",
                "createdAt": "2020-08-19T00:06:22Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I see the usefulness of hooks in that example but I guess I don't understand how it'd work in my case where it seems like you would want to initialize many objects at once, in this case AnimationControllers but in reality it could be anything. How do hooks handle this case?\nBasically is there a hooks way of turning this\nvar x1 = useState(1);\nvar x2 = useState(2);\nvar x3 = useState(3);\nInto\nvar xs = []\nfor (int i = 0; i < 3; i++)\n     xs[i] = useState(i);\nWithout violating hook rules? Because I listed the equivalent in normal Flutter. I'm not too experienced with hooks in Flutter so bear with me there.\nI want to simply create an array of hook objects (AnimationControllers for example) on demand with all of its initState and dispose already instantiated, I'm just unsure how it works in hooks.",
                "createdAt": "2020-08-19T00:54:13Z"
            },
            {
                "author": "sahandevs",
                "bodyText": "@satvikpendem think about hooks like properties on a class. do you define them in a loop or manually naming them one by one?\nin your example defining like this\nvar x1 = useState(1);\nvar x2 = useState(2);\nvar x3 = useState(3);\nis useful for this usecase:\nvar isLoading = useState(1);\nvar selectedTab = useState(2);\nvar username = useState(3); // text field\ndo you see how each useState is related to a named part of your state logic? (like isLoading's useState is connected to when app is in loading state)\nin your second snippet you are calling useState in a loop. your are thinking of useState as a value holder not part of your state logic. is this list needed for showing bunch of items in a ListView? if yes then you should think of every item in the list as a state not individually.\nfinal listData = useState([]);\nthis is just for the useState and I can see some use cases (which I think they are very rare) for calling some hooks in a condition or in a loop. for those kind of hooks there should be another hook for handling list of data instead of one. for example:\nvar single = useTest(\"data\");\nvar list = useTests([\"data1\", \"data2\"]);\n// which is equivalent to\nvar single1 = useTest(\"data1\");\nvar single2 = useTest(\"data2\");",
                "createdAt": "2020-08-19T01:20:35Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I see, so with hooks it looks like we need to create a separate hook to handle cases with an array of items, such as multiple AnimationControllers.\nThis is what I had initially which doesn't seem to work:\n  final animationControllers = useState<List<AnimationController>>([]);\n\n  animationControllers.value = List<AnimationController>.generate(\n    50,\n    (_) => useAnimationController(),\n  );\nbut I suppose if I write my own hook to handle multiple items, this should work, right?\nclass _MultipleAnimationControllerHook extends Hook<MultipleAnimationController> {\n  const _MultipleAnimationControllerHook({\n    this.numControllers,\n    this.duration,\n    this.debugLabel,\n    this.initialValue,\n    this.lowerBound,\n    this.upperBound,\n    this.vsync,\n    this.animationBehavior,\n    List<Object> keys,\n  }) : super(keys: keys);\n\n  /// Take in number of controllers wanted\n  /// This hook assumes all `AnimationController`s will have the same parameters\n  final int numControllers; \n\n  final Duration duration;\n  final String debugLabel;\n  final double initialValue;\n  final double lowerBound;\n  final double upperBound;\n  final TickerProvider vsync;\n  final AnimationBehavior animationBehavior;\n\n  @override\n  _AnimationControllerHookState createState() =>\n      _AnimationControllerHookState();\n}\n\nclass _AnimationControllerHookState\n    extends HookState<AnimationController, _AnimationControllerHook> {\n  List<AnimationController> _multipleAnimationController; // return a list instead of a singular item\n\n  @override\n  void initHook() {\n    super.initHook();\n    for (int i = 0; i < hook.numControllers) // just added loops \n        _multipleAnimationController[i] = AnimationController(\n          vsync: hook.vsync,\n          duration: hook.duration,\n          debugLabel: hook.debugLabel,\n          lowerBound: hook.lowerBound,\n          upperBound: hook.upperBound,\n          animationBehavior: hook.animationBehavior,\n          value: hook.initialValue,\n        );\n  }\n\n  @override\n  void didUpdateHook(_AnimationControllerHook oldHook) {\n      for (int i = 0; i < numControllers; i++) {\n        if (hook.vsync != oldHook[i].vsync) {\n           _multipleAnimationController[i].resync(hook.vsync);\n        }\n\n        if (hook.duration != oldHook[i].duration) {\n          _multipleAnimationController[i].duration = hook.duration;\n        }\n      }\n  }\n\n  @override\n  MultipleAnimationController build(BuildContext context) {\n    return _multipleAnimationController;\n  }\n\n  @override\n  void dispose() {\n    _multipleAnimationController.map((e) => e.dispose());\n  }\n}\nDoes this mean that if we have a singular version of a hook, we simply can't use it for a version with multiple items and instead have to rewrite the logic? Or is there a better way of doing this?\nIf anyone also wants to give a non-hooks example I would like to know as well, I've been wondering about this piece of the reusability puzzle. Maybe there's a way to encapsulate this behavior in a class, which has its own AnimationController field, but if that's created inside a loop, then the hook would be too, breaking the rules. Perhaps we could consider how Vue does it, which is unaffected by conditionals and loops for its hooks implementation.",
                "createdAt": "2020-08-19T02:01:04Z"
            },
            {
                "author": "sahandevs",
                "bodyText": "@satvikpendem\nI don't think my statement is valid for AnimationController or useAnimationController\nbecause although you may have more than one AnimationController but you don't necessarily store them in an array to use them in the class method. for example:\nuseSingleTickProvider();\nfinal animation1 = useAnimationController();\nfinal animation2 = useAnimationController();\nfinal animation3 = useAnimationController();\n// ...\nuseEffect(() async {\n  await animation1.forward();\n  await Future.sleep(100);\n  await animation1.reverse();\n  await animation2.forward();\n  await animation3.forward();\n}, []);\n(you don't create a list and reference them like animation[0])\nhonestly in my experience in react and flutter with hooks I rarely needed calling some kind of hooks in a loop. even then the solution was straight forward and easy to implement. now I think about it, it definitely could be solved in a better way like creating a Component(widget) for each one of them which is IMO is the \"cleaner\" solution.\nto answer your question if there is an easier way to handle multiple AnimationController, yes there is:\nfinal ticker = useTickerProvider();\nfinal controllers = useMemo(() => [AnimationController(ticker), AnimationController(ticker)], []);\n\nuseEffect(() {\n  controllers.forEach(x => x.resync(ticker));\n  return () => controllers.forEach(x => x.dispose());\n}, [ticker, controllers]);\n\n\nyou can also use useState if AnimationControllers are dynamic.\n\n(it also re syncs when ticker is changed)",
                "createdAt": "2020-08-19T02:26:59Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@rrousselGit could you make an example of having many multiple hooks? For example, I am making an animation with possibly dozens of AnimationControllers. With regular Flutter, I can do:\nList<AnimationController> controllers = [];\nint numAnimationControllers = 50;\n\n@override\nvoid initState() {\n    for (int i = 0; i < numAnimationControllers; i++)\n        controllers.add(AnimationController(...));\n}\n\n@override\nvoid dispose() {\n    for (int i = 0; i < numAnimationControllers; i++)\n        controllers[i].dispose();\n}\nBut with hooks I cannot call useAnimationController in a loop. I suppose this is a trivial example but I couldn't really find the solution anywhere for this type of use case.\n\nHooks do that differently.\nWe don't create a List of controllers anymore, rather we move the controller logic down to the item:\nWidget build(context) {\n  return ListView(\n    children: [\n      for (var i = 0; i < 50; i++)\n        HookBuilder(\n          builder: (context) {\n            final controller = useAnimationController();\n          },\n        ),\n    ],\n  );\n}\nWe still made our 50 animation controllers, but they are owned by a different widget.\nMaybe you could share an example of why you needed that, and we could try and convert to hooks and add it to Tim's repo?",
                "createdAt": "2020-08-19T03:54:16Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Hixie works for Google, he has to be patient and polite with you and can't call you out on your lack of engagment. The best he can do is to push for more examples.\n\n@Hixie, if that is how you feel, please say so (either here or contact me privately).\n\nI literally provided examples of how you can reduce verbosity and avoid nestedness of builders using an example Remi provided.\n\nThanks, but it is unclear to me how you would extract a common pattern from this code as apply this logic to different use-cases.\nIn the OP, I mentioned that currently, we have 3 choices:\n\nuse Builders and have nested code\ndon't factorize the code whatsoever, which does not scale to more complex state logic (I would argue that StreamBuilder and its AsyncSnapshot is a complex state logic).\ntry and make up some architecture using mixins/oop/..., but end up with a solution too specific to the problem that it any use-case that is a tiny bit different will require a rewrite.\n\nIt appears to me that you used the 3rd choice (which is in the same category as early iterations of the Property or addDispose proposals).\nI previously made an evaluation grid to judge the pattern:\n\n#51752 (comment)\n#51752 (comment)\n\nCould you run your variant on this? Especially the second comment about implementing all the features of StreamBuilder without code duplicate if used multiple times.",
                "createdAt": "2020-08-19T04:12:42Z"
            },
            {
                "author": "Hixie",
                "bodyText": "My plan at this point on this bug is:\n\nTake the examples from #51752 (comment) and create an app using pure Flutter that shows those various use cases together.\nTry to design a solution that enables code reuse for those examples that satisfies the various key requirements that have been discussed here and that fits within our design principles.\n\nIf anyone would like to help with either of these I'm definitely happy to have help. I'm unlikely to get to this soon because I'm working on the NNBD transition first.",
                "createdAt": "2020-08-19T04:25:44Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@rrousselGit Sure, I'm making an app where many Widgets may move around the screen (let's call them Boxes), and they should be able to move independently of each other (so there needs to be at least one AnimationController for each Box). Here's one version I made with just one AnimationController shared among the multiple Widgets, but in the future I may animate each Widget independently, for example to do complicated Transforms such as to implement a CupertinoPicker, with its custom scroll wheel effect.\nThere are three boxes in a Stack that move up and down when you click a FloatingActionButton.\nimport 'package:flutter/material.dart';\nimport 'package:flutter_hooks/flutter_hooks.dart';\n\nvoid main(List<String> args) => runApp(const App());\n\nclass App extends HookWidget {\n  const App({Key key});\n\n  static const Duration duration = Duration(milliseconds: 500);\n  static const Curve curve = Curves.easeOutBack;\n\n  @override\n  Widget build(BuildContext context) {\n    final AnimationController controller =\n        useAnimationController(duration: duration);\n    final Animation<double> animation = Tween<double>(\n      begin: 0,\n      end: 300,\n    )\n        .chain(\n          CurveTween(\n            curve: curve,\n          ),\n        )\n        .animate(controller);\n    final ValueNotifier<bool> isDown = useState<bool>(false);\n    final ValueNotifier<int> numBoxes = useState<int>(3);\n    \n    return MaterialApp(\n      home: SafeArea(\n        child: Scaffold(\n          floatingActionButton: FloatingActionButton(\n            onPressed: () {\n              if (!isDown.value) {\n                controller.forward();\n                isDown.value = true;\n              } else {\n                controller.reverse();\n                isDown.value = false;\n              }\n            },\n          ),\n          body: AnimatedBuilder(\n            animation: animation,\n            builder: (_, __) => Boxes(\n              numBoxes: numBoxes.value,\n              animation: animation,\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass Boxes extends StatelessWidget {\n  Boxes({\n    @required this.numBoxes,\n    @required this.animation,\n  });\n\n  final int numBoxes;\n  final Animation<double> animation;\n\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: List<Widget>.generate(\n        numBoxes,\n        (int index) => Positioned(\n          top: (animation.value) + (index * (100 + 10)),\n          left: (MediaQuery.of(context).size.width - 100) / 2,\n          child: Container(\n            width: 100,\n            height: 100,\n            color: Colors.blue,\n          ),\n        ),\n      ),\n      // ],\n    );\n  }\n}\nIn this case, each box moves in unison, but one can imagine a more complex scenario such as creating a visualization for a sorting function for example, or moving elements in an animated list around, where the parent widget knows the data about where each Box should be and it should be able to animate each one as it sees fit.\nThe problem appears to be that the AnimationControllers and the Boxes that use them to drive their movement are not in the same class, so one would either need to pass through the AnimationController by keeping an array of them to use in a Builder, or have each Box maintain its own AnimationController.\nWith hooks, given that the Boxes and the parent widget are not in the same class, how would I make a list of AnimationControllers for the first case where each Box is passed in an AnimationController? This seems not needed based on your answer above with HookBuilder, but then if I move down the state into the child Widget as you say, and choose to make each Box have its own AnimationController via useAnimationController, I run into another problem: how would I expose the created AnimationController to the parent class for it to coordinate and run the independent animations for each child?\nIn Vue you can emit an event back to the parent via the emit pattern, so in Flutter do I need some higher state management solution like Riverpod or Rx where the parent updates the global state and the child listens to the global state? It seems that I shouldn't, at least for a simple example like this. Thanks for clearing up my confusions.",
                "createdAt": "2020-08-20T00:17:06Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@satvikpendem Sorry I wasn't clear. Could you show how you would do it without hooks, rather than the issue where you are blocking with hooks?\nI want to have a clear understanding of what you are trying to do rather than where you are getting stuck\nBut as a quick guess, I think you are looking for the Interval  curve instead, and have a single animation controller.",
                "createdAt": "2020-08-20T00:26:59Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@rrousselGit Sure, here it is\nimport 'package:flutter/material.dart';\n\nvoid main(List<String> args) => runApp(const App());\n\nclass Animator {\n  Animator({this.controller, this.animation});\n  AnimationController controller;\n  Animation<double> animation;\n}\n\nclass App extends StatefulWidget {\n  const App({Key key});\n\n  static const Duration duration = Duration(milliseconds: 500);\n  static const Curve curve = Curves.easeOutBack;\n\n  @override\n  _AppState createState() => _AppState();\n}\n\nclass _AppState extends State<App> with TickerProviderStateMixin {\n  List<Animator> animators = [];\n  bool isDown = false;\n  int numBoxes = 3;\n\n  @override\n  void initState() {\n    for (int i = 0; i < numBoxes; i++) {\n      final AnimationController c = AnimationController(\n        duration: App.duration,\n        vsync: this,\n      );\n      animators.add(\n        Animator(\n          controller: c,\n          animation: Tween<double>(\n            begin: 0,\n            end: 300,\n          )\n              .chain(\n                CurveTween(\n                  curve: App.curve,\n                ),\n              )\n              .animate(c),\n        ),\n      );\n    }\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    for (int i = 0; i < numBoxes; i++) {\n      animators[i].controller.dispose();\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: SafeArea(\n        child: Scaffold(\n          floatingActionButton: FloatingActionButton(\n            onPressed: () {\n              if (!isDown) {\n                for (final Animator animator in animators) {\n                  animator.controller.forward();\n                }\n                setState(() {\n                  isDown = true;\n                });\n              } else {\n                for (final Animator animator in animators) {\n                  animator.controller.reverse();\n                }\n                setState(() {\n                  isDown = false;\n                });\n              }\n            },\n          ),\n          body: Stack(\n            children: List<Box>.generate(\n              numBoxes,\n              (int index) => Box(\n                index: index,\n                animation: animators[index].animation,\n              ),\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}\n\nclass Box extends StatelessWidget {\n  Box({\n    @required this.animation,\n    @required this.index,\n  });\n\n  final int index;\n  final Animation<double> animation;\n\n  @override\n  Widget build(BuildContext context) {\n    return Positioned(\n      top: (animation.value) + (index * (100 + 10)),\n      left: (MediaQuery.of(context).size.width - 100) / 2,\n      child: Container(\n        width: 100,\n        height: 100,\n        color: Colors.blue,\n      ),\n    );\n  }\n}\nI actually do want multiple animation controllers, one for each widget, as they can move independently of each other, with their own durations, curves, etc. Note that the above code seems to have a bug that I couldn't figure out, where it should animate cleanly, but basically it should animate 3 boxes up and down on a button click. We can imagine a scenario where instead of them each having the same curve, I give each of them a different curve, or I make 100 boxes, each with a duration longer or shorter than the previous one, or I make the even ones go up and the odd ones go down, and so on.\nWith normal Flutter, initState and dispose can both have loops but not so it seems with hooks, so I'm just wondering how one can combat that. As well, I don't want to put the Box class inside the parent widget, as I don't want to tightly encapsulate them both; I should be able to keep the parent logic the same but swap out Box with Box2 for example.",
                "createdAt": "2020-08-20T01:04:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Thanks!\nI've pushed your example to @TimWhiting's repo, with a hook equivalent\nTL;DR, with hooks (or builders), we think declaratively instead of imperatively. So rather than having a list of controllers on one widget, then driving them imperatively \u2013 which move the controller to the item and implement an implicit animation.",
                "createdAt": "2020-08-20T08:23:20Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Thanks @rrousselGit! I was struggling with this type of implementation for a little while after starting to use hooks but I understand now how it works. I just opened a PR for a version with a different target for each animation controller as that might be more compelling to understand why hooks are useful as I had said above:\n\nWe can imagine a scenario where instead of them each having the same curve, I give each of them a different curve, or I make 100 boxes, each with a duration longer or shorter than the previous one, or I make the even ones go up and the odd ones go down, and so on.\n\nI had been trying to make the declarative version but I suppose what I didn't understand was the didUpdateWidget/Hook lifecycle method, so I didn't know how to drive the animation when a child prop is changed from the parent, but your code cleared it up.",
                "createdAt": "2020-08-20T16:32:47Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Came across a real-world example in my code base today, so thought I might as well share it.\nSo in this scenario, I'm working with Firestore, and have some boilerplate I want to perform with each StreamBuilder, so I made my own custom builder. I also need to work with a ValueListenable which allows the user to re-order the list. For monetary-cost reasons related to Firestore, this requires a very specific implementation (each item can't store it's own order, instead the list must save it as a field of concatenated id's), this is because firestore charges for each write, so you can potentially save a lot of money this way. It ends up reading something like this:\nreturn ClipRRect(\n      borderRadius: BorderRadius.circular(CornerStyles.dialog),\n      child: Scaffold(\n        backgroundColor: state.theme.scaffoldBackgroundColor,\n        body: FamilyStreamBuilder<DocumentSnapshot>(\n          stream: state.listRef.snapshots(),\n          builder: (context, AsyncSnapshot<DocumentSnapshot> documentSnapshot) {\n            //When a list is updated, we need to update the listOrder\n            state.updateListOrderFromSnapshot(documentSnapshot);\n            return FamilyStreamBuilder<QuerySnapshot>(\n                stream: state.itemsCollection.snapshots(),\n                builder: (_, AsyncSnapshot<QuerySnapshot> itemsSnapshot) {\n                  //Sort the list items by the idField on the list-doc\n                  List<DocumentSnapshot> items = itemsSnapshot.data.documents;\n                  state.handleDocsSync(items);\n                  return ValueListenableBuilder(\n                    valueListenable: state.listOrderNotifier,\n                    builder: (_, List<String> listOrder, __) {\n                      List<DocumentSnapshot> ordered = state.sortItems(items, listOrder);\n                     //Set the firstCompleted item if we have one\n                      state.firstCompletedItem = ordered\n                          ?.firstWhere((element) => element.data[FireParams.kIsComplete] == true, orElse: () => null)\n                          ?.documentID;\n                      return _buildItemList(items, ordered);\n                    },\n                  );\n                });\n          },\n        ),\n      ),\n    );\nIt feels like it would be much easier to reason about, if I could write it more like:\n    DocumentSnapshot list = useFamilyStream(state.listRef.snapshots());\n    List<DocumentSnapshot> items = useFamilyStream(state.itemsCollection.snapshots()).data.documents;\n    List<String> listOrder = useValueListenable(state.listOrderNotifier);\n\n    //When a list is updated, we need to update the listOrder\n    state.updateListOrderFromSnapshot(list);\n\n   //Sort the list items by the idField on the list-doc\n    state.handleDocsSync(items);\n    List<DocumentSnapshot> ordered = state.sortItems(items, listOrder);\n\n    //Set the firstCompleted item if we have one\n    state.firstCompletedItem = ordered\n        ?.firstWhere((element) => element.data[FireParams.kIsComplete] == true, orElse: () => null)\n        ?.documentID;\n\n    return ClipRRect(\n      borderRadius: BorderRadius.circular(CornerStyles.dialog),\n      child: Scaffold(\n          backgroundColor: state.theme.scaffoldBackgroundColor,\n          body: _buildItemList(items, ordered)\n      ));\nThis does lose the optimization regarding granular rebuilds, but that wouldn't make any different IRL since all the visual elements are at the bottom-most leaf node, all the wrappers are pure state.\nAs with many real world scenario, the advise of \"Just don't use X\" is not realistic, as Firebase has just one method of connection which is Streams, and any time I want this socket-like behavior I have no choice but to use a Stream. C'est la vie.",
                "createdAt": "2020-08-20T16:44:13Z"
            },
            {
                "author": "Hixie",
                "bodyText": "This does lose the optimization regarding granular rebuilds, but that wouldn't make any different IRL since all the visual elements are at the bottom-most leaf node, all the wrappers are pure state.\n\nIt still makes a difference. Whether a node is visual or not does not affect whether it costs something to rebuild.\nI would probably factor that example out into different widgets (the IDEs have one-click refactoring tools to make that really easy). _buildItemList should probably be a widget, as should the part rooted at FamilyStreamBuilder.",
                "createdAt": "2020-08-20T16:55:07Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "We don't really lose the granular rebuild.\nIn fact hooks improve that aspect, by allowing to easily cache the widget instance using useMemoized.\nThere are a few examples on Tim's repo that do that.",
                "createdAt": "2020-08-20T16:57:50Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I would probably factor that example out into different widgets (the IDEs have one-click refactoring tools to make that really easy). _buildItemList should probably be a widget, as should the part rooted at FamilyStreamBuilder.\n\nThing is, I don't really want to do this, because I have no performance concerns at all in this view. So 100% of the time I will favor code locality and coherence over micro-optimization like this. This view only rebuilds when the user initiates action (~avg once per 10 seconds), or when the backend data changes and they are staring at an open list (almost never happens). It also happens to just be a simple view that is primarily a list, and the list has a ton of it's own optimizations going on internally. I realize build() can technically fire any time, but in practice any random rebuilds are quite rare.\nimo it's significantly easier to work on and debug this view if all this logic is grouped in one widget, mainly as an effort to make my life easier when I come back to it in the future :)",
                "createdAt": "2020-08-20T17:03:59Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another thing to note is that the nesting basically \"forced me out\" of the build method, as there was no way I could begin to construct my tree inside of 3 closures and 16 spaces in the hole.\nAnd yes, you could say it makes sense to then just move to a separate widget. But why not just stay in the build method? If we could reduce the boilerplate to what it really needs to be, then there's no need to have the readability and maintenance hassle of of splitting things across 2 files. (Assuming performance is not a concern, which it often just isn't)\nRemember in this scenario I already created a custom widget to handle my Stream Builder. Now I would need to make another one to handle the composition of these builders?? Seems a bit over the top.",
                "createdAt": "2020-08-20T17:10:14Z"
            },
            {
                "author": "Hixie",
                "bodyText": "because I have no performance concerns at all in this view\n\nOh I wouldn't refactor it into widgets for performance, the builders should take care of that already. I would refactor it for readability and reusability. I'm not saying that's the \"right\" way to do it, just saying how I would structure the code. Anyway, that's neither here nor there.\n\nno way I could begin to construct my tree inside of 3 closures and 16 spaces in the hole\n\nI may just have a wider monitor than you... :-/\n\nthen there's no need to have the readability and maintenance hassle of of splitting things across 2 files\n\nI would put the widgets in the same file, FWIW.\nAnyway, it's a fine example, and I believe you that you would rather use one widget with a different syntax than using more widgets.",
                "createdAt": "2020-08-20T17:14:51Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I may just have a wider monitor than you... :-/\n\nI have an ultrawide :D, but dartfmt obviously limits us all to 80. So losing 16 is significant. The main issue is the end of my statement is this },);});},),),); not really fun when something gets messed up. I have to be extremely careful anytime I edit this heirarchy, and common IDE helpers like swap with parent stop working.\n\nI would put the widgets in the same file, FWIW.\n\n100%, but I still find that jumping around vertically in a single file is tougher to maintain. Unavoidable of course, but we try to reduce when possible and 'keep things together'.",
                "createdAt": "2020-08-20T17:17:59Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Crucially though, even if I do refactor the main list into it's own widget (which I agree, is more readable than a nested build method), it's still way more readable without the nesting in the parent widget. I can come in, understand all the logic at a quick glance, see the _MyListView() widget clearly, and jump right into it, confident I understand the surrounding context. I can also add/remove additional dependencies with relative ease, so it scales very well.",
                "createdAt": "2020-08-20T17:54:59Z"
            },
            {
                "author": "Hixie",
                "bodyText": "dartfmt obviously limits us all to 80\n\nI mean, that's one reason I don't generally use dartfmt, and when I do I set it to 120 or 180 characters...\nYour experience here is totally valid.",
                "createdAt": "2020-08-20T18:17:49Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Me too actually, 120 all day :) But pub.dev actively down-rates plugins that are not formatted at 80, and I get the impression that I (we) are in the minority when we change this value.",
                "createdAt": "2020-08-20T19:14:48Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Well that's absurd, we should fix that.",
                "createdAt": "2020-08-20T19:20:17Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "pub.dev doesn't not down-rate plugins that do not respect dartfmt. It only shows a comment in the score page, but the score is unimpacted\nBut arguably, there are more problems with dartfmt than just the line-length.\nA too big line-length leads to things that are more readable in multiple lines to be in a single line, such as:\nobject\n  ..method()\n  ..method2();\nwhich may become:\nobject..method()..method2();",
                "createdAt": "2020-08-20T19:24:40Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I'm seeing this?\n\nPackage in question: https://pub.dev/packages/sized_context/score",
                "createdAt": "2020-08-20T19:31:49Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Interesting \u2013 it definitely wasn't like that before, as provider didn't use dartfmt for a while.\nI stand corrected.",
                "createdAt": "2020-08-20T19:51:04Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Yup it definitely is new behavior, when I originally published last spring I made sure I was ticking all the boxes, and dartfmt was not required.",
                "createdAt": "2020-08-20T19:56:25Z"
            },
            {
                "author": "HKhademian",
                "bodyText": "After all these discussions, I hope we see native support for hook like solution in flutter. either useHook or use Hook or anything that flutter team can feel their feature is not like React \ud83d\ude01\ud83e\udd37\u200d\u2642\ufe0f",
                "createdAt": "2020-08-24T08:33:51Z"
            },
            {
                "author": "HKhademian",
                "bodyText": "we use hooks in a way like final controller = useAnimationController(duration: Duration(milliseconds: 800));\nIs it not better to use Darts new program feature Extension copied from kotlin/swift to beautifully that syntax?\nsomething like:  final controller = AnimationController.use(duration: Duration(milliseconds: 800));\nwith this approach, when flutter/dart team decides to  add use Hook instead of currently available syntax useHook, I think a Annotation to that extension function made it read to use as\nfinal controller = use AnimationController(duration: Duration(milliseconds: 800));\nalso it's understandable/meaningful to have use keyword used like const and new:\nnew Something\nconst Something\nuse Something",
                "createdAt": "2020-08-24T08:52:04Z"
            },
            {
                "author": "HKhademian",
                "bodyText": "as a bonus to that recommendation, I thing at last even constructor/generator functions can use/benefit from that proposed Annotation. then dart compiler with some customization converts it to support use keyword.\nSo beautiful and flutter/dart specific feature \ud83d\ude09",
                "createdAt": "2020-08-24T08:55:17Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Am I correct in assuming that the examples in https://github.com/TimWhiting/local_widget_state_approaches/tree/master/lib/stateful are now representative of the issues people want resolved?",
                "createdAt": "2020-09-26T17:36:41Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "I'm not sure how everyone else feels, but I think that the problems are somewhat represented there (meaning I can't be sure because someone might point out something that isn't represented).\nI have attempted a middle-ground solution in that repository. It is composable like hooks, but not dependent on ordering of function calls or not allowing for loops etc. It uses StatefulWidgets directly. It involves a mixin, as well as stateful properties that are uniquely identified by keys. I'm not trying to promote this as the ultimate solution, but as a middle ground between the two approaches.\nI've called it the lifecycleMixin approach, it is very close to the LateProperty approach that was discussed here, but the main difference is it has more lifecycles implemented, and it can easily compose. (on the lifecycles part, I haven't used widget lifecycles other than initState and dispose much, so I might have totally messed up there).\nI like this approach because:\n\nIt has very little runtime penalty.\nThere is no logic / functions creating or managing state in the build path (builds can be pure - only fetching state).\nLifecycle management is more clear when optimizing rebuilds via a builder. (But you don't sacrifice on reusability and composability of small bits of state).\nSince you can reuse creation of bits of state, a library can be made of common bits of state that should be created and disposed of in certain manners, so there is less boilerplate in your own code.\n\nI don't like this approach (compared to hooks) for the following reasons:\n\nI don't know if it covers everything hooks can do.\nYou have to use keys for uniquely identifying the properties. (So when composing the pieces of logic that build up some state you have to append to the key to uniquely identify each portion of state -- making the key a required positional parameter helps, but I'd love a language level solution to accessing a unique id for a variable).\nIt heavily uses extensions for creating reusable functions to create common bits of state. And extensions cannot be auto-imported by the IDEs.\nYou can mess yourself up if you mix lifecycles of different widgets / access them between widgets without explicitly managing them correctly.\nThe builder syntax is a bit weird so that the created state is in the scope of the build function, but leaving the build function pure.\nI haven't yet implemented all of the examples, so there might be a use-case that I cannot cover.\n\nSimple counter example.\nAnimated counters example\nframework\ncommon bits of reusable state composing logic\nI'm not sure how much time I have, graduate studies are always keeping me busy, but I'd love some feedback. @rrousselGit How close is this to hooks, can you see some obvious holes in reusability or composability?\nI'm not trying to promote my solution, so much as encourage positive discussion on a middle ground. If we can agree about what is missing or what this solution gives us, I think we will be making good forward progress.",
                "createdAt": "2020-09-27T02:38:47Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@TimWhiting The main issue I have with this approach is the lack of robustness. A big driver here is the need for the reliability of builders, in a succinct form. The magic id, and the ability to clash on lifecycle, both create new vectors for bugs to occur, and I would continue to recommend to my team they use builders, as despite being pretty nasty to read, at least we know that they are 100% bug-free.\nRegarding examples, I still think the perfect example is simply using a AnimationController, with a duration value tied to the widget. Keeps it simple and familiar. There is no need to get more esoteric than that, it's a perfect little use-case for re-usable boilerplate, it needs lifecycle hooks, and all solutions could easily be judged by their ability to use several animations succinctly.\nEverything else is just a variation of this same use 'Stateful Controller' use case. I want to do X in initState, and Y in dispose state, and update Z when my dependencies change. It doesn't matter what X, Y and Z are.\nI wonder if @rrousselGit could provide some insight here, or has any data on which hooks are currently most used. I'm guessing it's 80% Stream and Animations, but it would be nice to actually know what people are using most.\nRegarding rebuilding portions of the tree, builders are naturally suited to this task anyways, we should just let them do it. A stateful controller can easily be hooked into stateless renderers anyways if that is what you want (hello every Transition class).\nJust like we might do:\nvar anim = get AnimationController();\nreturn Column(\n  _someExpensiveBuildMethod(),\n  FadeTransition(opacity: anim, child: ...)\n)\n\nWe could always do:\nvar foo = get ComplicatedThingController();\nreturn Column(\n  _someExpensiveBuildMethod(),\n  ComplicatedThing(controller: foo, child: ...)\n)",
                "createdAt": "2020-09-27T05:13:47Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@esDotDev I agree, the keys, and builder syntax are the main drawback of the lifecycleMixin approach. I don't know if you can get around that except by using a hooks style approach with its associated restrictions, or a language change in being able to associate variable declarations with bits of state with lifecycles. This is why I will continue using hooks, and let others use stateful widgets, unless a better solution comes about. However, I do think it is an interesting alternative for those who don't like the restrictions of hooks, though it comes with restrictions of its own.",
                "createdAt": "2020-09-27T05:23:00Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Am I correct in assuming that the examples in https://github.com/TimWhiting/local_widget_state_approaches/tree/master/lib/stateful are now representative of the issues people want resolved?\n\nI'm honestly not sure.\nI would say yes. But that really depends on how you will interpret these examples.\nIn this thread, we have a history of not understanding each other, so I can't guarantee this won't happen again.\nThat's partly why I dislike using code examples and suggested to extract a set of rules instead.\nExamples are subjective and have multiple solutions, some of which may not solve the broader problem.\n\nI wonder if @rrousselGit could provide some insight here, or has any data on which hooks are currently most used. I'm guessing it's 80% Stream and Animations, but it would be nice to actually know what people are using most.\n\nI think it's very homogenous.\nAlthough if anything, useStream and Animations are likely the least used:\n\nuseStream usually has a better equivalent depending on your architecture. Could use  context.watch, useBloc, useProvider, ...\nfew people take the time to make animations. That's rarely the priority, and TweenAnimationBuilder other implicitly animated widgets cover a big part of the need.\nMaybe that would change if I added my useImplicitlyAnimatedInt hooks in flutter_hooks.",
                "createdAt": "2020-09-27T13:33:25Z"
            },
            {
                "author": "TimWhiting",
                "bodyText": "@esDotDev Just removed the need for keys/ids in the lifecycleMixin approach. It's still a bit awkward in the builder syntax. But possibly that could be helped eventually too. The one issue that I'm running into is with the type system. It tries to cast things in certain ways that aren't working. But it probably just needs some careful casting or type system mastery. As far as mixing lifecycles I think that could be improved by throwing some reasonable exceptions when a particular piece of state you try to access is not accessible by that widget's lifecycle. Or a lint that within a lifecyclebuilder you should only access the builder's lifecycle.",
                "createdAt": "2020-09-27T14:00:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Thanks Remi, that surprises me, I would think people would useAnimation very frequently to drive the large collection of Transition widgets in the core, but I guess most people just use the various Implicit's, as they are quite nice to read and do not have nesting.\nStill despite AnimatorController being very well served with a suite of Implicit and Explicit widgets, I still think it's a great example of a 'thing that needs to maintain state, and tie into widget params & lifecycle`. And serves as a perfect little example of the problem to be solved (the fact is is totally solved in Flutter w/ like a dozen widgets notwithstanding), that we can all discuss and stay focused on the architecture and not the content.\nFor example, consider how, if var anim = AnimationController.use(context, duration: widget.duration ?? _duration); were a first class citizen, virtually none of these implicit or explicit animations really need to exist. It renders them redundant since they are all created to manage the core problem: easily compositing a stateful thing (AnimationController) within the context of a widget. TAB becomes pretty close to pointless, since you can do the same thing with AnimatedBuilder + AnimatorController.use().\nIt really illustrates the need for the general use case if you look at the huge mass of widgets that have sprung up around animations. Precisely because it is so cumbersome/bug-prone to re-use the core setup/teardown logic, we have 15+ widgets all handling very specific things, but the majority of each of them are repeating the same animation boilerplate with only a handful of unique lines of code in many cases.\nIt serves to show, that yes we could also do this thing to re-use our own stateful logic: make a widget for every single permutation of usage. But what a hassle and maintenance head-ache! So much nicer to just have an easy way to compose little stateful objects, with lifceycle hooks, and if we want to make dedicated widgets for rendering, or a re-usable builder, we can easily just layer those on top.",
                "createdAt": "2020-09-27T16:52:04Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "For what it's worth, I use something like useAnimation heavily in my app rather than the normal animation widgets. This is because I'm using a SpringAnimation which isn't well supported with widgets like AnimatedContainer for example; they all assume a time-based animation, with curve and duration rather than simulation-based animation, which would accept a Simulation argument.\nI made an abstraction over useAnimationbut with springs, so I called it useSpringAnimation. The wrapper widget I used this hook with is similar to an AnimatedContainer but it was much easier to make because I could reuse all the animation code as you say @esDotDev, as much of the logic is the same. I could even make my own version of all of the animated widgets by again using useSpringAnimation but I didn't necessarily need to for my project. This once again shows the power of life cycle logic reuse that hooks provide.\n\nFor example, consider how, if var anim = AnimationController.use(context, duration: widget.duration ?? _duration); were a first class citizen, virtually none of these implicit or explicit animations really need to exist. It renders them redundant since they are all created to manage the core problem: easily compositing a stateful thing (AnimationController) within the context of a widget. TAB becomes pretty close to pointless, since you can do the same thing with AnimatedBuilder + AnimatorController.use().\n\nReading my comments above, this seems to be basically exactly what I did with my spring animation hook. I encapsulated the logic and then simply used AnimatedBuilder. To make them implicit, so that when I changed the prop as one does on AnimatedContainer, it would animate, I just added the didUpdateWidget (called didUpdateHook in flutter_hooks) method to run the animation from the old value to the new value.",
                "createdAt": "2020-10-04T07:33:31Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Am I correct in assuming that the examples in https://github.com/TimWhiting/local_widget_state_approaches/tree/master/lib/stateful are now representative of the issues people want resolved?\n\nI'm honestly not sure.\nI would say yes. But that really depends on how you will interpret these examples.\nIn this thread, we have a history of not understanding each other, so I can't guarantee this won't happen again.\nThat's partly why I dislike using code examples and suggested to extract a set of rules instead.\nExamples are subjective and have multiple solutions, some of which may not solve the broader problem.\n\nI would also say that we should include all of the code samples in this issue that were discussed, I think there's a list above somewhere that @rrousselGit made. I could make a PR adding them to the local_state repository but they aren't all complete code examples so they might not all actually compile and run. But they show the potential problems at least.",
                "createdAt": "2020-10-04T07:42:01Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I could make a PR adding them to the local_state repository\n\nThat would be very useful.",
                "createdAt": "2020-10-04T08:39:58Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "I'd like to point out that this thread has not defined reuse or what reuse looks like. I think we should be painfully specific in defining that, lest the conversation lose focus.\nWe've only shown what reuse isn't as it pertains to Flutter.",
                "createdAt": "2020-10-12T03:36:49Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "There has been quite a few usage examples, and hooks clearly provides a total example of widget-state re-use. I'm not sure where the confusion stems from as it seems straightforward on it's face.\nRe-use can simply be defined as: Anything a builder-widget can do.\nThe ask is for some stateful object that can exist inside any widget, that:\n\nEncapsulates it's own state\nCan setup/teardown itself according to initState/dispose calls\nCan react when dependencies change in the widget\n\nAnd does so in a nice succinct easy to ready, boilerplate-free way, like:\nAnimationController anim = AnimationController.stateful(duration: widget.duration);\nIf this works in Stateless and Stateful widgets. If it rebuilds when widget.something changes, if it can run it's own init() and dispose(), then you basically have a winner and I'm sure everyone would appreciate it.",
                "createdAt": "2020-10-12T14:50:54Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The main thing I'm struggling with is how to do this in an efficient way. For example, ValueListenableBuilder takes a child argument that can be used to measurably improve performance. I don't see a way to do that with the Property approach.\n\nI'm pretty sure this is a non-issue. We would do this the same way that the XTransition widgets work now. If I have some complex state, and I wanted it to have some expensive child, I would just make a small wrapper Widget for it. Just like we might make:\nFadeTransition(opacity: anim, child: someChild)\nWe can just as easily do that with any thing that we want rendered, by passing the 'thing' into a Widget to re-render it.\nMyThingRenderer(value: thing, child: someChild)\n\nThis doesn't require nesting like builder does, but it optionally supports it (.child could be a build fxn)\nIt retains the ability to be used directly without a wrapping widget\nWe can always make a builder and use this syntax within the builder to keep it cleaner. It also opens the door to multiple types of builder, built around the same core object, that does not involve copy pasted code all over the place.",
                "createdAt": "2020-10-12T15:15:13Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Agreed with @esDotDev. As I mentioned previously, an alternate title for this would be \"Syntax sugar for Builders\".\n\n\nThe main thing I'm struggling with is how to do this in an efficient way. For example, ValueListenableBuilder takes a child argument that can be used to measurably improve performance. I don't see a way to do that with the Property approach.\n\nI'm pretty sure this is a non-issue. We would do this the same way that the XTransition widgets work now. If I have some complex state, and I wanted it to have some expensive child, I would just make a small wrapper Widget for it. Just like we might make:\n\nThere is no need for that.\nOne of the benefits of this feature is, we can have a state-logic that is \"cache the widget instance if its parameters didn't change\".\nWith hooks, that would be useMemo in React:\n<insert whatever>\nfinal myWidget = useMemo(() => MyWidget(pameter: value), [value]);\nWith this code, myWidget will rebuild only when value changes. Even if the widget that calls useMemo rebuilds for other reasons.\nThat's similar to a const constructor for widgets, but allows dynamic parameters.\nThere's an example doing that in Tim's repo.",
                "createdAt": "2020-10-12T15:24:18Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "The ask is for some stateful object that can exist inside any widget, that:\n\nEncapsulates it's own state\nCan setup/teardown itself according to initState/dispose calls\nCan react when dependencies change in the widget\n\n\nI guess I have a hard time seeing why by those parameters, StatefulWidget doesn't do the job better than it does. Which is why I've asked the question on what we're really after here in a solution. As someone that uses flutter_hooks I find them to be more fun to work with than StatefulWidget, but that's just to avoid verbosity-- not because I think in terms of hooks. I actually find reasoning about UI updates difficult with hooks compared to Widgets.\n\n\nCan react when dependencies change in the widget\n\n\nYou mean a dependency that was created/acquired inside the widget? Or a dependency far below the widget in the tree?\nI'm not denying that there is a problem that causes verbosity/confusion in Flutter, I'm just hesitant to rely on everyone actually having the same mental model of what \"reuse\" is. I'm very thankful for the explanation; and when people have different models, they create different solutions.",
                "createdAt": "2020-10-12T18:08:02Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Because using a SW to do this is fine for a specific use case, but not good for abstracting the reusable logic of the use-case across many SW's. Take the setup/teardown for Animation as example. This is not a SW itself, it's something we want to use across them. Without first-class support for sharing encapsulated state, you end up having to make a builder, ie TweenAnimationBuilder, or make a ton of specific Widgets, ie AnimatedContainer etc. Really much more elegant if you can just bundle that logic up and re-use it any way you want inside a tree.\nIn terms of Widget dependency, I just mean if widget.foo changes, the stateful-thing gets an opportunity to do any updated it needs to do. In case of stateful AnimationController, it would check if duration changed, and if it did, update it's internal AnimatorController instance. This saves every implementer of the Animation from having to handle the property change.",
                "createdAt": "2020-10-13T01:00:17Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "<insert whatever>\nfinal myWidget = useMemo(() => MyWidget(pameter: value), [value]);\nWith this code, myWidget will rebuild only when value changes. Even if the widget that calls useMemo rebuilds for other reasons.\n\nAh I see, Memoized returns a Widget itself, and then you pass in [value] as the rebuild trigger, neat!",
                "createdAt": "2020-10-13T02:56:21Z"
            },
            {
                "author": "Hixie",
                "bodyText": "The key about AnimatedOpacity is neither the parent nor the child rebuild. In fact, when you trigger an animation using AnimatedOpacity literally nothing rebuilds after the first frame where you trigger the animation. We skip the build phase entirely and do it all in the render object (and in the render tree, it's only repaint, not relayout, and in fact it uses a Layer so even the paint is pretty minimal). It makes a significant difference to the performance and battery usage. Whatever solution we come up with here needs to be able to maintain that kind of performance if we are to build it into the core framework.",
                "createdAt": "2020-10-18T07:49:09Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "Unfortunately I haven't had time to collate the examples in this issue into the local state repo, my bad. I may not be able to get to it within the near term so if anyone else wants to pick that up I'd be fine with that.\nWith regards to performance of having hooks defined inside the build/render method (which I think someone mentioned earlier in this issue), I was reading through the React docs and saw this FAQ, might be useful. Basically it asks if hooks are slow due to creating functions in every render, and they say no due to a few reasons, one of which is being able to memoize functions using a hook like useMemo or useCallback.\nhttps://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render",
                "createdAt": "2020-10-20T17:03:11Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Basically it asks if hooks are slow due to creating functions in every render, and they say no due to a few reasons, one of which is being able to memoize functions using a hook like useMemo or useCallback.\n\nThe worry isn't about the cost of creating closures, those are indeed relatively cheap. It's the difference between running any code at all and not running any code at all that is key to the performance Flutter exhibits in optimal cases today. We've spent a lot of effort making algorithms that literally avoid running certain code paths at all (e.g. the build phase being skipped entirely for AnimatedOpacity, or the way we avoid walking the tree to perform updates but instead just target the affected nodes).",
                "createdAt": "2020-10-20T17:13:02Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I agree. I'm not too well versed on Flutter internals nor on hook internals but you're right that hooks will need to (if they don't already) figure out when they should run vs not, and performance must not regress.",
                "createdAt": "2020-10-20T17:19:50Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "It's the difference between running any code at all and not running any code at all that is key to the performance Flutter exhibits in optimal cases today\n\nAs mentioned previously a few times, hooks improve that.\nThe animated example on Tim's repo is proof of that. The hooks variant rebuilds less often than the StatefulWidget variant thanks to useMemo",
                "createdAt": "2020-10-20T17:23:32Z"
            },
            {
                "author": "pedromassangocode",
                "bodyText": "Since it is being discussed about solutions for this issue somewhere in this thread, I'm labelling it as proposal as well.",
                "createdAt": "2020-10-22T11:48:18Z"
            },
            {
                "author": "lemusthelroy",
                "bodyText": "I really would like to see hooks incorporated into flutter as was done with react. I look at state in flutter the same way I used to when I first used react. Since using hooks I would personally never go back.\nIt is so much more readable IMO. Currently you have to declare two classes with a stateful widget versus hooks where you just drop in usestate.\nIt would also bring some familiarity to flutter that react developers often don't have when they look at flutter code. Obviously comparing flutter with react is a dangerous path to go down, but I really think my developer experience with hooks is better than my experience without them.\nI'm not hating on flutter btw, it's actually my favourite framework but I think this is a really good opportunity to increase readability and dev experience.",
                "createdAt": "2020-10-25T13:42:31Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think there is definitely an opportunity to improve the naming conventions and make them more flutter like.\nThings like UseMemoized and UseEffect sound quite foreign, and it sounds like we want some way to not have to run the init() code in the build fxn.\nCurrently initializing with hooks is like this (I think?):\nWidget build(){\n   useEffect(\n      (){\n          // Do init stuff\n         return (){  //Do dispose stuff };\n      }, [ ] ) //<-- pass an empty list of rebuild triggers, so this can only fire once. Passing null here would let it fire every time.\n   );\n}\n\nI appreciate the brevity of this code, but it's certainly far less than ideal from a readability and \"self documenting code\" standpoint. There's a lot of implicit magic going on here. Ideally we have something that is explicit about it's init/dispose hooks, and doesn't force itself into build when used with a Stateless Widget.\nThings like useMemoized and useEffect could maybe be better named more explicitly  hook ComputedValue() and hook  SideEffect()\nWidget build(BuildContext context){\n   List<int> volumes = hook ComputedValue(\n        execute: ()=>_getVolumeFromAudioSamples(widget.bytes), \n        dependencies: [ widget.bytes ]);\n\n   hook SideEffect(\n       execute: ()=>_recordSongChangedAnalytics()\n       dependencies: [ widget.songUrl ]);\n   )\n\n   return SongVisualizer(volumes: volumes);\n}",
                "createdAt": "2020-11-02T09:43:12Z"
            },
            {
                "author": "estephinson",
                "bodyText": "I like that, not sure how I feel about the use of the hook keyword though, and I don't think it solves the issue of foreign concepts. Introducing new keywords doesn't feel like the best approach in my mind, withSideEffect or withComputedValue? I'm no language designer so my words are worthless.\nI do feel like hook-like functionality in flutter will be a great help in smoothing the learning curve for React developers, which is really the target audience when companies are making the decision between ReactNative and Flutter.\nEchoing @lemusthelroy , Flutter is by far my favourite framework and I'm beyond excited to see the directions it takes. But I feel functional-programming concepts could be a great help in growing the framework in an as yet relatively unexplored direction. I think some people are dismissing the idea in an aim to distance from React, which is unfortunate, but understandable.",
                "createdAt": "2020-11-03T14:15:42Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Ya there's two sides to that coin I think. A new keyword is a major event, so knowledge propagation would be very swift, but the other side is certainly that it's now something new to everyone. If it's possible without that's cool too! Just not sure it is... at least not as elegantly.",
                "createdAt": "2020-11-03T17:11:47Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "Opinion: The community inclination to name hooks as the de-facto solution to this problem roots from a bias for functions. Functions are simpler to compose than objects, especially in a statically-typed language. I think the mental model of Widgets for many developers is effectively just the build method.\nI think if you frame the problem in terms of the basics, you're more likely to design a solution that works well in the rest of the library.\nAs for the hook keyword in terms of the basics; one could look at it as both declaring and defining a function from some kind of template (a macro), and the hook prefix is really just calling out that the built-function has internal state (c-style statics.)\nI wonder if there isn't some kind of prior-art in Swift FunctionBuilders.\nWhile we're dreaming, I'll clarify my guess at what would be the necessary code:\nHook SideEffect(void Function() execute, List<Object> dependencies) {\n  // Whatever happens each build.\n}\n\nWidget build(BuildContext context){\n   List<int> volumes = hook ComputedValue(\n        execute: ()=>_getVolumeFromAudioSamples(widget.bytes), \n        dependencies: [ widget.bytes ]);\n\n   SideEffect(\n       execute: ()=>_recordSongChangedAnalytics()\n       dependencies: [ widget.songUrl ]);\n   )\n\n   return SongVisualizer(volumes: volumes);\n}\nWhere Hook is a type-system level hack that helps statically analyze that the resulting hook was called in accordance with what hook-familiar developers know as hook laws. As that kind of a thing, the Hook-type can be documented as something that's a lot like a function, but has static internal mutable state.\nI cringe a bit as I write this because it's such an oddity from a language perspective. Then again, Dart is the language born for writing user interfaces. If this kind of an oddity should exist anywhere, perhaps this is the place. Just not this oddity in particular.",
                "createdAt": "2020-11-04T01:37:23Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "Opinion: The community inclination to name hooks as the de-facto solution to this problem roots from a bias for functions. Functions are simpler to compose than objects, especially in a statically-typed language. I think the mental model of Widgets for many developers is effectively just the build method.\n\nI'm not sure what you wanna say with that. The hook approach that I also use with my get_it_mixin just makes the widget tree easier to read than using a Builder.",
                "createdAt": "2020-11-04T09:11:02Z"
            },
            {
                "author": "karthickr95",
                "bodyText": "Interesting article about React hooks",
                "createdAt": "2020-11-05T07:08:09Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "@nt4f04uNd All of your points were addressed previously, including performance, why it needs to be a core feature, functional vs class style widgets, and why things other than hooks don't seem to work. I suggest you read through the whole conversation to understand the various points.",
                "createdAt": "2020-11-11T19:10:01Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "I suggest you read through the whole conversation to understand the various points.\n\nThis is fair to say considering they didn't read the whole thread, but I'm not sure it makes things any more clear to read the rest of the thread. There are folks whose priority it is to keep Widgets as they are, and another group who wants to do something else entirely or make Widgets more modular.",
                "createdAt": "2020-11-11T19:30:29Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "While that may be true, this issue shows that there are problems which cannot be solved with widgets as they are currently, so if we want to solve the problems, we have no choice but to make something new. This is the same concept as having Futures and later introducing async/await syntax, the latter makes things possible that simply weren't possible without new syntax.",
                "createdAt": "2020-11-11T19:38:26Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "People are suggesting that we make it part of the framework, however. React can't add new syntax to Javascript because it's not the only framework available (well, it can through Babel transforms), but Dart is specifically designed to work with Flutter (Dart 2 at least, not the original version) so we have a lot more of an ability to make hooks work together with the underlying language. React, for example, needs Babel for JSX, and it has to use a linter for useEffect errors, while we could make it a compile time error. Having a package makes adoption a lot harder, as you could imagine the traction that React hooks would(n't) have gotten had it been a third party package.\nEdit: looks like the previous poster deleted their comments",
                "createdAt": "2020-11-11T22:53:49Z"
            },
            {
                "author": "deadsoul44",
                "bodyText": "There would be no problem if there could be a third type of widget, i.e. HookWidget, besides current Stateless and Stateful widgets. Let the community decide which one to use. There is already a package from Remi but it has limitations inevitably. I tried it and it significantly reduced boilerplate but I had to drop it unfornutanetly due to limitations. I have to create stateful widgets for only to use init method. There could be additional great benefits if it is part of the core framework with the language support. Besides, a HookWidget can enable community to create more optimum and more performant apps.",
                "createdAt": "2020-11-12T06:44:15Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I have to create stateful widgets for only to use init method.\n\nYou don't actually have to do this, useEffect() is capable of doing the initCall inside build. The docs make no effort at all to explain this tho, and basically assume you are a React dev who already knows how hooks work.",
                "createdAt": "2020-11-12T15:08:04Z"
            },
            {
                "author": "deadsoul44",
                "bodyText": "I was using that way but I had some other problems with the limitations of the package and I don't remember exactly what were them.",
                "createdAt": "2020-11-12T15:22:06Z"
            },
            {
                "author": "bouraine",
                "bodyText": "Working with stateful widgets is really painfull in Flutter. Everytime i add a state, i have to transform my widget to a statefullWidget, if later i decide to remove it, i have to recreate my stateless widget.\nOtherwise, I often have to split my code between declaration, initState, debug and dispose. there is no way to extract the state and its logic together.\nAn example would be: The state and the logic of a Multiselect. If i can extract it, i could use the same code for all my multiCheckboxes, multiSelects ...etc.  I write it and test it once and reuse it everywhere. The same applies for Modals, animations, keyboard interactions, FieldControllers ..etc\nMany packages try to solve this issue but they are creating others (flutter_hooks, GetX). i avoid to use them because i don't want to rely on them for something so central as the widget lifecycle.\nThe community is trying hard to reduce the Flutter boilerplate and the lack of state reusability but the core team seem not concerned much about this.\nin React, SwiftUI, Maui every state is one line of code. it's easy to write, read and maintain.\nSwiftUI\nstruct PlayerView: View {\n    var episode: Episode\n    @State private var isPlaying: Bool = false\n\n    var body: some View {\n        VStack {\n            Text(episode.title)\n            Text(episode.showTitle)\n            PlayButton(isPlaying: $isPlaying)\n        }\n    }\n}\n\nReact typescript\ninterface Props {\n    episode: Episode;\n}\n\nconst PlayerView: React.FC<Props> = ({episode}) => {\n    const [isPlaying, setIsPlaying] = React.useState<boolean>(false);\n\n    return <div>\n        <p>{episode.title}</p>\n        <p>{episode.showTime}</p>\n        <PlayButton isPlaying={isPlaying} />\n    </div>\n};\n\nFlutter\nclass PlayerView extends StatefulWidget {\n  final Episode episode;\n\n  const PlayerView({Key? key, required this.episode}) : super(key: key);\n\n  @override\n  _PlayerViewState createState() => _PlayerViewState();\n}\n\nclass _PlayerViewState extends State<PlayerView> {\n  var isPlaying = false;\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(children: [\n      Text(widget.episode.title),\n      Text(widget.episode.showTime),\n      PlayButton(isPlaying: isPlaying),\n    ]);\n  }\n}",
                "createdAt": "2020-12-20T00:45:57Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "Hooks work in Flutter, and maybe any graphical application.\nBelow is the simplest form of an interactive graphical application. Almost all of them look this way under the abstractions.\nfor (;;) {\n  readInput();\n  changeState();\n  drawState();\n}\nThere is still a great fondness for this way of writing GUIs, as made evident by the pervasive use of imgui in rendering-enthusiast groups like game-engine authors. It is simply the best way of getting things done quickly. (The feature is done fast, and the feature runs fast on the machine)\nOur problem with this is that we're running as fast as that for loop. We only need to work as fast as a user can create events for us to process, any extra work is wasteful. Especially when the device is battery-powered.\nWhen people talk \"state management\" they only do so by that name in these reactive GUI frameworks. They do that because state management is just the work required to get our business logic on-screen in it's most up-to-date form without hogging the system resources.\nSo how do hooks fit into this? Incidentally, hooks are choosing to avoid \"state management\" as part of the framework. Hooks are an escape-hatch into immediate-mode graphics from within a Reactive UI framework. Consider Rules of Hooks, it is not a coincidence that hooks should always be called each render. This one assumption (abstraction) allows us to think of individual components as their own immediate-mode applications!\nThe following Widget...\nbool shouldCallAgain;\n\nWidget build(BuildContext context) {\n  final request = useMemoized(() => makeNetworkRequest, [shouldCallAgain]); // the dependencies array is state-management\n  final snapshot = useFuture(request);\n\n  return Text(snapshot.hasData ? \"Cool!\" : \"Crap!\");\n}\n...is a more compact way to model the following immediate-mode code...\nbool shouldCallAgain = true; // The first render should start a request.\n\nfor (;;) {\n  shouldCallAgain = shouldCallAgain && readInput(); // only check if the user wants a request if one isn't running.\n  \n  var snapshot;\n  if (shouldCallAgain) {\n    snapshot = AsyncSnapshot.waiting(makeNetworkRequest()); // pretend this works out asynchronously\n    shouldCallAgain = false; // <-------------------------------------- Here's the \"state management\"\n  }\n\n  renderText(snapshot.hasData ? \"Cool!\" : \"Crap!\");\n}\n... if we take that immediate-mode code, and define our hooks back in, you'll see that the render-loop is now identical to the build method in the Widget example.\nList<dynamic> _requestDependencies;\ndynamic _cachedRequest;\ndynamic useMemoized(dynamic Function() buildValue, List<dynamic> dependencies) {\n  if (_requestDependencies notDeeplyEqual dependencies) {\n    _requestDependencies = dependencies;\n    _cachedRequest = buildValue()\n  }\n  return _request;\n}\n\nbool shouldCallAgain;\n\nfor (;;) {\n  final request = useMemoized(() => makeNetworkRequest, [shouldCallAgain]); // the dependencies array is state-management\n  final snapshot = useFuture(request);\n\n  renderText(snapshot.hasData ? \"Cool!\" : \"Crap!\");\n}\nTL;DR: My argument is effectively that hooks at least work in Flutter because they appear to be a fine way to organize an immediate-mode application, while proving capable of respecting power-constrained platforms. Being a fine way to structure immediate-mode apps is valuable because they are the common denominator, perhaps as simple as it gets. (Granted, that doesn't make using hooks simple.)\nDoes Flutter need to do anything to support \"hooks\" beyond making sure the build method is called?",
                "createdAt": "2020-12-21T06:58:45Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Thanks for the great viewpoint, it really made me see hooks in a new light, it really is what we are trying to do is make the reactive programming model, as simple to use as the immediate, without the performance penalty. And in that context, this focus on 'everything is build()` and not tieing to lifecycles, makes sense.\nI see a couple weakpoints with hooks as is though, in addition to the order-of-operations issues:\n\nuseEffect is overloaded, and init() is not really as readable/clear as they should be. useEffect({},null) and useEffect({},[]) mean drastically different things. I understand the idea of trying not to think in terms of lifecycles, but init() especially is too important to pretend it doesn't exist. All this does is hurt readability.\nIt forces everything inside a giant function to maintain scope, this hurts readability in large files, and creates boilerplate when you want to split a widget into smaller pieces for organizational sake. Even your subBuild() methods need to be inside the build() method to maintain scope. Maybe this is something you get used to, but having 3 or 4 private widgets that share the same State seems like better way to organize the code, than one gigantic function, and at least lets me cleanly separate my view and controller logic\nIt doesn't have any support for using builders internally. For example, I want to make a useMouseOver hook, normally I would just wrap the MouseRegion builder, with a bit of state, and return that state value. But I don't think that's possible with hooks.",
                "createdAt": "2020-12-22T20:58:22Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "By way of example, here is the code I would love to write, but it really does require some sort of Builder-unrolling, so we can piggyback on the existing Widgets Flutter provides:\nvoid build(BuildContext context){\n    double opacity = builder TweenAnimationBuilder<double>(duration: 1.second, tween: Tween(begin: 0, end: 0));//\n    Offset mousePos = builder MousePosBuilder(); // Light wrapper over MouseRegion\n    bool isMouseDown = builder MouseDownBuilder(); // Light wrapper over MouseRegion\n    //Do stuff\n}\n\nInstead, currently, you'd need to write this which is about 30 lines of boilerplate, and it forces us into a Stateful widget which is another 9 lines, which builder unrolling would not. More important than typing lines though, the intent of the class is already getting overwhelmed by boilerplate and nesting.\nclass _MyState extends State<MyView> {\n\n  bool _isMouseOver;\n  Offset _mousePos;\n\n  void _handleMouseHover(Offset pos){\n    setState(() => _mousePos = pos);\n  }\n\n  void _handleMouseEnter(){\n    setState(() => _isMouseOver = true);\n  }\n\n  void _handleMouseExit(){\n    setState(() => _isMouseOver = false);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return TweenAnimationBuilder<double>(\n      tween: Tween(begin: 0, end: 1),\n      duration: Duration(seconds: 1),\n      builder: (_, value, __){\n        return MouseRegion(\n          onEnter: (d)=> _handleMouseEnter(),\n          onExit: (d)=> _handleMouseExit(),\n          onHover: (d)=> _handleMouseHover(d.position),\n          child: // Do Stuff,\n        );\n      }\n    );\n  }\n}\n\nI don't think hooks, or vanilla flutter, can do anything like that currently.",
                "createdAt": "2020-12-22T21:14:57Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I've evolved my StatefulProperties idea into something I think is pretty cool... it plays extremely nicely with Restoration, and allows nesting of arbitrary builders.\nRather than run from StatefulWidget, this approach leans into them. I don't think the extremely functional approach of React hooks is really where we want to head with Flutter.\nPros:\n\nClearly declared fields and initState() call\nEncapsulates arbitrary init/didUpdate/dispose behavior in 'StatefulProperty' objects\nSupports restoration API very nicely\nMinimal boilerplate, no nesting\nUses classic State/initState metaphor, no \"magic\" here\n\nCons:\n\nStill more boilerplate than hooks\nNot as composable as hooks, not highly composable at all really... but they can use widgets, which helps a lot.\nRequires a replacement of build, currently buildStateful\nRequires StatefulWidget (but this can also be seen as a plus, as State can be shared, and it's more familiar)\nNot sure how well it will work with DidChangeDependancy/Provider\n\nWe could start with usage first. This shows using some complex controller, that is tied into the value of from the widget. It will update internally when didUpdateWidget is fired:\nclass _FooViewState extends State<FooView> with StatefulPropertyMixin<FooView> {\n  StatefulAnimationController anim1;\n\n  void initState() {\n    anim1 = registerProperty(create: (w){\n        return StatefulAnimationController(duration: (w as FooView).duration, autoBuild: true));\n    }\n    anim1.controller.forward();\n  }\n\n  Widget statefulBuild(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      color: Colors.black.withOpacity(anim1.controller.value)\n    );\n  }\n}\n\nAnother example, shows how we could nest some existing builder to give us mouse-coords with minimal boilerplate:\nclass _FooViewState extends State<FooView> with StatefulPropertyMixin<FooView> {\n  StatefulMouseRegion mouseRegion;\n\n  void initState() {\n    mouseRegion = registerProperty(create: (_) => \n         StatefulMouseRegion(onEnter: (_) => print(\"Roll over!!\")));\n  }\n\n  Widget statefulBuild(BuildContext context) {\n    return Container(\n      alignment: Alignment.center,\n      child: Text(\"${mouseRegion.position}\"),\n    );\n  }\n}\n\nIt works off the idea that if we give the Mixin a Property builder(Widget w) for each Property, it can do the rest of the work internally by overriding didUpdateWidget.\n// This can be run once to create the thing, but also re-run when widget changes, to compare new and old\nregisterProperty(create: (Widget w) => MyProperty(value: (w as MyWidget).someValue))\n\nIf Widget is ever changed, the Mixin can just run this create builder again, and ask the thing to update it's internal state to match:\nclass StatefulAnimationController extends StatefulProperty<StatefulAnimationController> implements TickerProvider {\n  ...\n  void didUpdate(StatefulAnimationController newProp) {\n    if (duration != newProp.duration) {\n      duration = newProp.duration;\n      _controller.duration = duration;\n    }\n    if (vsync != newProp.vsync) {\n      vsync = newProp.vsync;\n      _controller.resync(vsync);\n    }\n  ...\n}\n\nThe nice thing is that the Mixin can handle all the registerForRestoration calls itself, filling in one of the 2 required methods for RestorationMixin. This can be everything from simple values, to complex states. All the implementing view needs to do is provide ids.\nFor example, a StatefulInt, might exist only to be restored automatically. This allows devs to consolidate all primitives and complex objects in their mind, as a StatefulProperty, register them with the StatefulPropertyMixin, and forget about it.\nclass StatefulInt extends StatefulProperty<StatefulInt> {\n  StatefulInt(int defaultValue) {\n    _restorableValue = RestorableInt(defaultValue);\n  }\n  RestorableInt _restorableValue;\n\n  int get value => _restorableValue.value;\n  set value(int value) => _restorableValue.value = value;\n\n  @override\n  void restoreState(void Function(RestorableProperty<Object> property, String restorationId) register) {\n    register(_restorableValue, restoreId);\n  }\n}\n\nUsage, we just need to provide an Id for the view, and another id for the property. Everything else is managed.\nclass _FooState extends State<Foo> with StatefulPropertyMixin<FooView>, RestorationMixin {\n   StatefulInt someInt;\n \n  @override\n  String get restorationId => \"FooView\";\n  \n  void initState() {\n    someInt = registerProperty(create: (_) => StatefulInt(0), restoreId: \"someInt\");\n    super.initState();\n  }\n\nShould be easy to extrapolate that to AnimationControllers, or any other controller. For example, AnimController could save multiple RestorablePrimitives, by suffixing on it's main id, like \"anim1-value\", \"anim1-direction\", etc.\nIt also supports wrapping of Widgets, and callbacks, this is the full StatefulMouseRegion from above:\nclass StatefulMouseRegion extends StatefulProperty<StatefulMouseRegion> {\n  StatefulMouseRegion({this.onHover, this.onEnter, this.onExit});\n  final void Function(PointerHoverEvent event) onHover;\n  final void Function(PointerEnterEvent event) onEnter;\n  final void Function(PointerExitEvent event) onExit;\n\n  Offset _pos = Offset.zero;\n  Offset _localPos = Offset.zero;\n  bool _isHovered = false;\n\n  Offset get position => _pos;\n  Offset get localPosition => _localPos;\n  bool get isHovered => _isHovered;\n\n  @override\n  Widget addWidgets(Widget child) {\n    return MouseRegion(\n      onEnter: (m) {\n        _updateMouse(isDown: true, position: m.position, localPosition: m.localPosition);\n        onEnter?.call(m);\n      },\n      onExit: (m) {\n        _updateMouse(isDown: false, position: m.position, localPosition: m.localPosition);\n        onExit?.call(m);\n      },\n      onHover: (m) {\n        _updateMouse(isDown: true, position: m.position, localPosition: m.localPosition);\n        onHover?.call(m);\n      },\n      child: child,\n    );\n  }\n\n  void _updateMouse({bool isDown, Offset position, Offset localPosition}) {\n    _isHovered = isDown;\n    _pos = position ?? _pos;\n    _localPos = localPosition ?? _localPos;\n    setState(() {});\n  }\n}\n\nBest part is, the entire core, is 98 lines! :D",
                "createdAt": "2020-12-23T04:25:31Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another cool use case with this technique, you can inline something that is pure events, like a GestureDetector, you don't even need to keep a handle to it, but it keeps it out of the tree.\nCombining Animation, Mouse and Gesture detector, pretty cool demo for about 30 lines, sans comments.\nclass _FooViewState extends State<FooView> with StatefulPropertyManagerMixin<FooView> {\n  StatefulAnimationController anim1;\n  StatefulMouseRegion mouseRegion;\n\n  void initState() {\n    // Controlled animation, auto-disposes and didUpdate with widget deps\n    anim1 = initProperty((w) => StatefulAnimationController(duration: widget.duration));\n    // mouseRegion to track mouse coordinates\n    mouseRegion = initProperty((_) => StatefulMouseRegion(onEnter: (_) => print(\"Roll over!!\")));\n    // Gesture detector for entire widget, don't bother keeping a reference, we only care about callbacks here\n    initProperty((w) => StatefulGestureDetector(onTap: _handleTap));\n    super.initState();\n  }\n\n  void _handleTap() => anim1.controller.forward(from: 0);\n\n  Widget statefulBuild(BuildContext context) {\n    print(\"Build!\");\n    // Border changes color according to mousePos\n    double normalizedMouseX = mouseRegion.normalizedPosition.dx;\n    Color borderColor = Colors.black.withOpacity(normalizedMouseX);\n    // Fill changes color based on animController, which can be controlled via tap.\n    Color fillColor = Colors.black.withOpacity(.5 - anim1.controller.value * .5);\n    // TextColor changes if mouse is over the application\n    Color textColor = mouseRegion.isHovered ? Colors.blue.shade800 : Colors.black;\n    // Label shows text position\n    String label = \"${mouseRegion.position}\";\n    return Container(\n      decoration: BoxDecoration(color: fillColor, border: Border.all(color: borderColor, width: 10)),\n      alignment: Alignment.center,\n      child: Text(\"$label\", style: TextStyle(color: textColor, fontWeight: FontWeight.bold, fontSize: 22)),\n    );\n  }\n}\n\n\n  \n    \n    \n\n    2020-12-23_00-12-14.mp4\n    \n  \n\n  \n\n  \n\n\nBtw, speaking of encapsulating problematic code, it's very nice to be able to attach this onto the stateful MouseRegion:\nOffset get normalizedPosition => Offset(\n        (position.dx / _viewSize.width).clamp(0.0, 1.0) as double,\n        (position.dy / _viewSize.height).clamp(0.0, 1.0) as double,\n      );\n\nMiss the as double and compiler complains, miss any of the .0's and runtime error :/",
                "createdAt": "2020-12-23T07:00:01Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Looks like it's quite easy to tie into Provider / InheritedWidget also. Just need to pass in the context to the initProperty callback:\nanim1 = initProperty((context, widget) {\n      return StatefulAnimationController(\n        duration: context.read<Duration>(),\n        vsync: (widget as FooView).vsync,\n      );\n    });\n\nThis will manage the animation lifecycle, and properly sync to the widget.vsync or provided Duration changing.",
                "createdAt": "2020-12-23T07:52:19Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "@esDotDev I really like this approach. Why do you need a special build function and why does it require a Stateful Widget? I guess you too could use the same trick that hooks aor my get_it_mixin uses.",
                "createdAt": "2020-12-23T10:21:12Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Thanks! Requires a StatefulWidget cause we need to put the state somewhere, so it's sitting in something like:\nList<StatefulProperty> _props. Maybe there is some other way I don't know of, I'll try and share the full code tomorrow.\nI could probably do something like Remi does with HookWidget, where it has internalState but feels like a Stateless, I just need to learn how :D\nI need the custom build(), so I can do something like this on the Child you return. Not sure if there's some other way to do it.\n // Hijack the main build function to wrap any helper widgets needed by the Stateful Props\n  @override\n  @protected\n  Widget build(BuildContext context) {\n    // Ask state to build\n    Widget child = statefulBuild(context);\n    // Wrap the returned tree with additional widgets as required\n    _props.forEach((prop) => child = prop.build(child));\n    return child;\n  }\n\nIn the example above, that would take a returned Column() and you'd end up with like GestureDetector(child: MouseRegion(child: Content())))\nI could avoid the custom build, but leaving it up to the user to make the call manually:\nWidget build(BuildContext context){\n   return buildProps(child: Scaffold(\n      ... \n   ));\n}\n\nBut this is more error prone if they forget to wrap the widgets. Maybe there is some other way.\nAnother example, a basic StatefulGestureDetector, it's nothing but callbacks, doesn't even have any state. All it does is implement StatefulProperty.build() and wraps a child widget:\nclass StatefulGestureDetector extends StatefulProperty<StatefulGestureDetector> {\n  final void Function() onTap;\n\n  StatefulGestureDetector({this.onTap});\n  @override\n  Widget build(Widget child) {\n    return GestureDetector(\n      onTap: () => onTap?.call(),\n      // TODO: Add all other GT handlers\n      child: child,\n    );\n  }\n}",
                "createdAt": "2020-12-23T10:43:28Z"
            },
            {
                "author": "escamoteur",
                "bodyText": "@esDotDev check out how my get_it_mixin is done.",
                "createdAt": "2020-12-23T10:48:17Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Ah, very cool, so you can have state in a Stateless Widget :)\nBut I still don't see how I could do it without some sort of key, or index/call-order based system like Hooks uses.\nbuild(){\n    final anim1 = getProperty(\"anim1\", (c, w) => StatefulAnimationController(duration: Duration(seconds: 1)));\n    ... build\n}\n\nWhich I guess is not horrible, I hate those magic strings tho :(\nThis is where nameof could be nice:\nfinal anim1 = getProperty(nameof(anim1), (c,w){});",
                "createdAt": "2020-12-23T16:50:56Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "String-based keys are very bad for composition. When trying to compose things, on larger widgets you would get a name clash\nConsidering this issue is about state composition without nesting, I don't think strings are a good alternative to using the index.",
                "createdAt": "2020-12-23T17:17:10Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Ya that's why nameof would be nice, cause they guarantee a string is unique within the scope it's used. In this case the Props don't define their name, the using view would.\nIt's too bad Dart didn't have private enum support, something like this could be nice:\nclass MyClass extends PropsWidget {\n  enum Props { anim1, anim2, textController1 }\n\n  Widget build(){\n      StatefulAnimatorController anim1 = getProperty(Props.anim1, (c, w)=>{ ... })\n   }\n}\n\nBut this is kinda why I just landed back at state. So many of these hacks are just trying to recreate the concept of member variables, why not just use em :p",
                "createdAt": "2020-12-23T17:33:18Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Ya that's why nameof would be nice, cause they guarantee a string is unique within the scope it's used\n\nThe problem is with composition\nIf you extract some logic into a reusable function, you'd get name clash\nYou can't do the following for example:\nAnimationController reusableLogic() {\n  final controller = getProperty(#controller, ...)\n  getProperty(...); // Do some composition\n  return controller;\n}\n\n\n@override\nWidget build(context) {\n  final first = reusableLogic();\n  final controller = getProperty(#controller, ...); // error - name clash between `build` and `reusableLogic`\n\n}",
                "createdAt": "2020-12-23T17:54:49Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Yes for sure, nameof() is not reliable when used in multiple Scopes, and it would all fall apart then. Definitely not ideal, but if you were to keep them all at the top of build, which you tend to do with variable declarations anyways, it might be ok. This pattern does not nest at all like Hooks does, it's much flatter, and relies on Widgets for much of it's behavior.\nHooks is very atomic, bigger things wrap smaller things, which wrap even smaller things, for composite behavior. This is more top-down, where we wrap a bigger thing, to extract some smaller behavior.\nBut ya we agree, it's not a good solution, and nameof doesn't exist anyways :)  The enum idea is not too horrible... but having to put the Enums outside the class kinda ruins it for me. Sad how Dart has crippled  its Enum's in so many ways :(\nI guess this might not be the worst thing in the world:\nenum MyClassProps { anim1, anim2, textController1 }\nclass MyClass extends PropsWidget {  \n  Widget build(){\n      StatefulAnimatorController anim1 = getProperty(Props.anim1, (c, w)=>{ ... })\n   }\n}",
                "createdAt": "2020-12-23T17:59:28Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "Excluding name clash, another issue with String keys is performance\nAccessing the state using an index is fast. On the other hand, using a Map<String, dynamic> is very slow. If not for that, we could use the Stacktrace.",
                "createdAt": "2020-12-23T18:08:26Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I see, thanks Remi. Ya the C# developer inside me cringes everytime I see all these strings inside build() but somehow Dart manages :D Of course it must have some effect though, regardless of how fast Dart itself is.\nSo do you think if there was an internal enum call for each id, that would be prohibitive?\nI am always wary of these \"performance is bad\" claims without measurements. We may very well be talking about a cpl microseconds here. I mean how many of these stateful props would ever exist on Screen at once, 10 or 20? Probably not hundreds. I would love to see some real benchmarks around any of this, but have never managed to find some.\nTo be clear, I'm not advocating the string approach at all, but the enum version could be neat. Although they are so neutered in Dart, I might not be able to make it work... so crazy how little you can do with enums, no int values, no string values, no easy conversions, can't be internal, what a waste.",
                "createdAt": "2020-12-23T18:12:22Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Finding lots of nice wins here. Because everything is stateful, it's just very easy to add syntactic sugar and the code is very familiar.\nFor example, if I add a couple small methods to the AnimationProp:\n  Animation<T> addTween<T>(Tween<T> tween, {Curve curve: Curves.linear}) {\n    return tween.animate(CurvedAnimation(parent: _controller, curve: curve));\n  }\n  \n  Animation<double> tweenDouble({double begin: 0.0, double end: 1.0, Curve curve: Curves.linear}) =>\n      addTween(Tween<double>(begin: begin, end: end), curve: curve);\n\n  Animation<int> tweenInt({int begin: 0, int end: 100, Curve curve: Curves.linear}) =>\n      addTween(IntTween(begin: begin, end: end), curve: curve);\n\nThen I can write some pretty tight animation code, all off the back of the one AnimationController:\nclass _SimpleAnimatedBtnState extends State<SimpleAnimatedBtn> with StatefulPropManagerMixin<SimpleAnimatedBtn> {\n  Animation<double> fadeTween;\n  Animation<int> countTween;\n  Animation<Color> colorTween;\n\n  void initState() {\n    // Core anim that drives everything\n    AnimationProp tapAnim = initProperty((widget, context){\n      return AnimationProp(\n         duration: (widget as SimpleAnimatedBtn).duration, \n         vsync: context.read<TickerProvider>());\n    });\n    // Use syntactic sugar to easily add some tween curves and settings\n    fadeTween = tapAnim.tweenDouble(curve: Curves.easeOut, begin: .2, end: 1);\n    countTween = tapAnim.tweenInt(curve: Curves.easeOut, begin: 90, end: 100);\n    colorTween = tapAnim.addTween(ColorTween(begin: Colors.red, end: Colors.green));\n    // Add gesture tap-detector in one line\n    initProperty((_, __) => GestureProp(onTap: () => tapAnim.controller.forward(from: 0)));\n    super.initState();\n  }\n\n  // Our build method is sparkling clean, it's actually just view code and layout logic (yay!)\n  Widget statefulBuild(BuildContext context) {\n    print(\"Build\");\n    String label = \"${countTween.value}\";\n    Color fillColor = colorTween.value.withOpacity(fadeTween.value);\n    return Container(\n      decoration: BoxDecoration(color: fillColor),\n      alignment: Alignment.center,\n      child: Text(\"$label\", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 22)),\n    );\n  }\n}\n\n\n  \n    \n    \n\n    2020-12-23_13-08-20.mp4\n    \n  \n\n  \n\n  \n\n\nIf enums weren't so limited it would be easy to do something cool in a Stateless-like widget, but this is a bit of a non-starter :'(\nSomeEnum.values.indexOf(SomeEnum.One). Unless we can somehow pass a generic enum...\nIt would still be limited in it's use cases though, like not sure how we could do something like the multiple tweens that persists between builds. Once you go Stateless, it's hard to do better than Hooks tbh, I just keep ending up back at the same spot when you need index-call-based keys.\nAs example, here is the same view as above, implemented with vanilla state, the core body goes from 30lines to 55, and both didUpdateWidget and dispose() are hotspots for bugs here.\nclass _SimpleAnimatedBtnState extends State<SimpleAnimatedBtn> with SingleTickerProviderStateMixin {\n  Animation<double> fadeTween;\n  Animation<int> countTween;\n  Animation<Color> colorTween;\n  AnimationController tapAnim;\n  TickerProvider _vsync;\n\n  void initState() {\n    _vsync = context.read<TickerProvider>();\n    tapAnim = AnimationController( vsync: _vsync, duration: widget.duration );\n    tapAnim.forward();\n\n    fadeTween = Tween<double>(begin: .2, end: 1).animate(CurvedAnimation(parent: tapAnim, curve: Curves.easeOut));\n    countTween = IntTween(begin: 90, end: 10).animate(CurvedAnimation(parent: tapAnim, curve: Curves.easeOut));\n    colorTween = ColorTween(begin: Colors.red, end: Colors.green).animate(tapAnim);\n  }\n\n  @override\n  void didUpdateWidget(covariant SimpleAnimatedBtn oldWidget) {\n    if (oldWidget.duration != widget.duration) {\n      tapAnim.duration = widget.duration;\n    }\n    TickerProvider vsync = context.read();\n    if (vsync != this._vsync) {\n      tapAnim.resync(vsync);\n    }\n    super.didUpdateWidget(oldWidget);\n  }\n\n  @override\n  void dispose() {\n    tapAnim?.dispose();\n    super.dispose();\n  }\n\n  void _handleTap() => tapAnim.forward(from: 0);\n\n  Widget build(BuildContext context) {\n    String label = \"${countTween.value}\";\n    Color fillColor = colorTween.value.withOpacity(fadeTween.value);\n\n    return GestureDetector(\n      onTap: _handleTap,\n      child: Container(\n        decoration: BoxDecoration(color: fillColor),\n        alignment: Alignment.center,\n        child: Text(\"$label\", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 22)),\n      ),\n    );\n  }",
                "createdAt": "2020-12-23T20:14:20Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "This approach actually does support composition quite well. You could imagine having a core GestureProp that had the full suite of handlers available:\n// Core GestureDetector Property\nclass GestureProp extends StatefulProp<GestureProp> {\n  GestureProp({this.onTap});\n  final void Function() onTap;\n  @override\n  Widget build(Widget child) {\n    return GestureDetector(\n      onTap: () => onTap?.call(),\n      // TODO: Implement all the other 20+ callbacks for gestrueDetector\n      child: child,\n    );\n  }\n}\n// Usage: \ncreateProp(GestureProp(onTapDown: _handleTap, onTapUp: ..., etc));\n\nThen you can very easily make a sub-set of that, but just wrapping it:\n// TapProp, just for taps:\nclass TapProp extends StatefulProp<TapProp> {\n  TapProp(this.onTap);\n  final void Function() onTap;\n\n  @override\n  Widget build(Widget child) => GestureProp(onTap: onTap).build(child);\n}\n// Usage: \ncreateProp(TapProp(_handleTap));",
                "createdAt": "2020-12-23T21:27:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Inspired by the idea in React that is is all about syncronization. I think I've settled on something like:\n\naddProp(foo()), and\nsyncProp((c, w)=>foo())\n\nIf a item has a dependancy (widget, or context), you can use syncProp(). If not, just use addProp() for nicer syntax and clearer intent.\nvoid initState(){\n  tapAnim = addProp(AnimationProp(Duration(seconds: 1)), restorationId: \"tapAnim1\");\n  tapAnim2 = syncProp((c, w) => \n        AnimationProp((w as  MyView).duration, vsync: c.read<TickerProvider>()), \n        restorationId: \"tapAnim2\");\n  addProp(TapProp(_handleTap));\n}\n\nSorry for all the posts, I'll stop now! just think this is kinda exciting. The similarities between this and restoration API are hard to overlook as well. There is some definite synergy here.",
                "createdAt": "2020-12-23T23:46:11Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Sorry, one more. @escamoteur  this is psuedo-code now, but I do think this could work with some sort of stateless mixin(!!), assuming we can stash a bit of state, which I think we can.\nclass StatelessExampleState extends StatefulPropsWidget {\n  static UniqueKey node1 = UniqueKey();\n  static UniqueKey node2 = UniqueKey();\n\n  StatelessExampleState(this.onFocusChanged);\n  final void Function(bool) onFocusChanged;\n\n  @override\n  void initState() {\n    addProp(node1, FocusNodeProp(onChanged: (value) => print(\"Node1 selected: $value\")));\n    syncProp(node2, (w) => FocusNodeProp(onChanged: w.onFocusChanged));\n  }\n\n  @override\n  Widget buildWithProps(BuildContext context) {\n    return Column(\n      children: [\n        SizedBox(height: 100),\n        TextFormField(focusNode: getProp(node1)),\n        TextFormField(focusNode: getProp(node2)),\n      ],\n    );\n  }\n}\n\nIt's not much less verbose than a StatefulWidget, but hey, we get those 5 lines back! And to be honest, I think it's significantly more readable than the hooks version, but maybe that's just the OOP dev in me.",
                "createdAt": "2020-12-24T03:31:36Z"
            },
            {
                "author": "bouraine",
                "bodyText": "@esDotDev could you please provide a pseudo code for FocusNodeProp ?",
                "createdAt": "2020-12-25T16:44:33Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I can do better than pseudocode! I've implemented it :) Good pick, this is one of the biggest ones. And also has the syntactic sugar callback we all want: onChange(bool value)\nclass FocusNodeProp extends StatefulProp<FocusNodeProp> {\n  FocusNodeProp(\n      {this.debugLabel,\n      this.onKey,\n      this.skipTraversal: false,\n      this.canRequestFocus: true,\n      this.descendantsAreFocusable: true,\n      this.onChanged});\n  String debugLabel;\n  FocusOnKeyCallback onKey;\n  bool skipTraversal;\n  bool canRequestFocus;\n  bool descendantsAreFocusable;\n\n  // Callbacks\n  void Function(bool value) onChanged;\n\n  // Helper methods\n  FocusNode get node => _node;\n\n  // Internal state\n  FocusNode _node;\n\n  @override\n  void init() {\n    _node = FocusNode(\n        debugLabel: debugLabel,\n        onKey: onKey,\n        skipTraversal: skipTraversal,\n        canRequestFocus: canRequestFocus,\n        descendantsAreFocusable: descendantsAreFocusable);\n    _node.addListener(_handleFocusChanged);\n  }\n\n  @override\n  void update(FocusNodeProp newProp) {\n    if (didChange(debugLabel, newProp.debugLabel)) {\n      _node.debugLabel = debugLabel = newProp.debugLabel;\n    }\n    if (didChange(skipTraversal, newProp.skipTraversal)) {\n      skipTraversal = _node.skipTraversal = newProp.skipTraversal;\n    }\n    if (didChange(canRequestFocus, newProp.canRequestFocus)) {\n      canRequestFocus = _node.canRequestFocus = newProp.canRequestFocus;\n    }\n    if (didChange(canRequestFocus, newProp.descendantsAreFocusable)) {\n      descendantsAreFocusable = _node.descendantsAreFocusable = newProp.descendantsAreFocusable;\n    }\n    onChanged = newProp.onChanged ?? onChanged;\n  }\n\n  @override\n  void dispose() => _node.dispose();\n\n  void _handleFocusChanged() => onChanged?.call(_node.hasFocus);\n}\n\nI've been trying to refrain from any more updates until it's done. but pretty sure I've basically fully deprecated StatefulWidget (though this will still work great with it for larger components). Something like:\nclass MyView extends StatefulPropsWidget {\n   static Prop<BoolProp> _isLoading = (_, __) => false;\n  \n  void _handleRefresh(){\n     useProp(_isLoading).value = true;\n     //Do stuff\n     useProp(_isLoading).value = false;\n  }\n\n   @override\n   Widget buildWithProps(Context context){\n      BoolProp isLoading = useProp(_isLoading);\n      // Build tree... \n   } \n\n}\n\nThis will be my xmas present to everyone if I can get it working right :D",
                "createdAt": "2020-12-25T17:57:42Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The stateful version is considerably more verbose, but still pretty sweet:\nclass MyView extends StatefulWidget {\n  @override\n  _MyViewState createState() => _MyViewState ();\n}\n\nclass _MyViewState extends State<MyView> with StatefulPropsMixin {\n   BoolProp isLoading;\n   \n  @override\n  void initProps(){\n     isLoading = addProp(BoolProp(false), restorationId: \"isLoading\");\n  }\n\n  void _handleRefresh(){\n      isLoading.value = true;\n      //Do stuff\n      isLoading.value = false;\n   }\n\n   @override\n   Widget buildWithProps(Context context){\n      print(isLoading.value);\n      // Build tree... \n   } \n}\n\nIn this case obviously you could handle the bool yourself, but you could still get restoration for free here, and you get the nice implicit rebuild when changing values. Then obviously, way better value proposition with AnimationController, TextEditingController, FocusNode, LayoutBuilder, GestureDetector, MouseRegion, PageController, RawKeyboardListener etc",
                "createdAt": "2020-12-25T18:12:38Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another example, a widget 2-ways.\nRequirements: Animate background opacity and alignment of some child. Restart Animation when widget is tapped. Swap content when animation is not playing.\nStateful:\n(+ 4 Lines ^)\nclass _BasicAnimatorExampleState extends State<BasicAnimatorExample> with StatefulPropsMixin {\n  AnimationControllerProp anim;\n  Animation<double> alignTween;\n\n  @override\n  void initProps() {\n    anim = addProp(AnimationControllerProp(Duration(seconds: 1), autoStart: true));\n    alignTween = anim.tweenDouble(begin: -1, curve: Curves.easeOut);\n    addProp(TapProp(() => anim.controller.forward(from: 0)));\n  }\n\n  @override\n  Widget buildWithProps(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(100),\n      alignment: Alignment(0, alignTween.value),\n      color: Colors.green.withOpacity(anim.value),\n      child: Text(anim.isComplete ? \"Done! Click to animate\" : \"Wait for it...\"),\n    );\n  }\n}\n\nStateless aka StatefulPropsWidget (psuedo-code / target implementation).\nclass BasicAnimatorExample extends StatefulPropsWidget {\n  static Prop<AnimationControllerProp> _anim = (_, __) => AnimationControllerProp(.5, autoStart: true);\n  static Prop<TapProp> _tap= (_, w) => TapProp((w as BasicAnimatorExample)._handleTap);\n\n  void _handleTap()=> useProp(anim).controller.forward(from: 0);\n\n  @override\n  Widget buildWithProps(BuildContext context) {\n    useProp(_tap); // Tap handler needs to be called in the tree in order to be registered. Could be done in `initProps()` instead.\n    Animation<double> alignTween = useProp(_anim).drive(begin: -1, curve: Curves.easeOut);\n    return Container(\n      padding: EdgeInsets.all(100),\n      alignment: Alignment(0, alignTween.value),\n      color: Colors.green.withOpacity(useProp(_anim).value),\n      child: Text(useProp(_anim).isComplete ? \"Done! Click to animate\" : \"Wait for it...\"),\n    );\n  }\n}\n\nThe inline cast of w as BasicAnimatorExample us not ideal here, it works. I think it's better than requiring a 2nd type on every Prop, but maybe the new covariance keyword can help me here(?). Ideally could cast it in the callback definition itself:\nstatic Prop<TapProp> _anim = (_, BasicAnimatorExample w) => TapProp(w._handleTap); or, as an optional 2nd generic: static Prop<TapProp, BasicAnimatorExample> _anim = (_, w) => TapProp(w._handleTap);",
                "createdAt": "2020-12-25T19:11:16Z"
            },
            {
                "author": "kiesman99",
                "bodyText": "Hey @esDotDev, I really like the approach you've suggested here! (I still have to try it out for myself tho. Currently, I am just reading your code)\nPersonally I'd like to see a 2nd generic, because I think it'd be annoying if you always have to cast the w as the widget.\nIf you only have one parameter in your base widget class it's okay to cast, but having 2 or more parameters will lead to multiple casts which promotes boilerplate code that could've been prevented with a single 2nd generic.",
                "createdAt": "2020-12-26T21:58:21Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I have a working solution that involves just passing the view type in the class declaration :D\nclass MyView extends PropsWidget<MyView>{}\n\nSo all the casting is gone and it works like a charm. Super excited to share, but my brain is toast!\nWhere I've landed with basic syntax, for stateless widget, is:\nclass MyView extends PropsWidget<MyView>{\n  MyView(this.duration);\n  final Duration duration;\n\n  static PropRef<BoolProp> _bool1 = PropRef();\n  static PropRef<AnimatorControllerProp> _anim1 = PropRef();\n\n  @override\n  void initProps(){\n    addProp(_bool1, false);\n    syncProp(_anim1, (c, w) => AnimatorControllerProp(duration: w.duration, vsync: c.read<TickerProvider>()));\n  }\n\n @override\n  void buildWithProps(){\n      // Setting `useRef(_bool1).value = true` would rebuild the view  automatically \n    return FadeTransition(opacity: useProp(_anim1).controller, child: Text(\"${useProp(_bool1).value}\"));\n  }\n}\n\nIf everyone likes this approach, I can really use some help writing tests which is very much not in my wheelhouse.\nThe nice thing about it is 98% of the code is shared for both Stateless and Stateful, and the Props themselves are identical. The entire core is only about 120 lines. And another 100 lines or so of lifecycle boilerplate wiring for the custom StatelessElement  and the StatefulMixin. Thanks @escamoteur for the sneaky trick :D (DUH!)",
                "createdAt": "2020-12-27T05:15:55Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another nice thing about this, is how simple it is to switch from stateless to stateful, for example, if you have a very large widget, and are sick of calling useRef, you could switch over the above very easily:\n(+4 lines ^)\nclass _MyViewState extends State<MyView> with StatefulPropsMixin {\n  MyView(this.duration);\n  final Duration duration;\n\n  BoolProp _bool1;\n  AnimatorControllerProp _anim1;\n\n  @override\n  void initProps(){\n    _bool1 = addProp(false);\n    _anim1 = syncProp((c, w) => AnimatorControllerProp(\n        duration: w.duration, vsync: c.read<TickerProvider>())); //Notice the external deps, no need for didChange diff\n  }\n\n @override\n  void buildWithProps(){\n      // Setting `_bool1.value = true` would rebuild the view  automatically, \n      // Set to `false` (currentValue), and rebuild is skipped, prop optimizes internally\n    return FadeTransition(opacity: _anim1.controller, child: Text(\"${_bool1.value}\"));\n  }\n}",
                "createdAt": "2020-12-27T05:26:43Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "2020-12-27_02-11-44.mp4\n    \n  \n\n  \n\n  \n\n\nShared code:\nclass _AnimatedContent extends StatelessWidget {\n  const _AnimatedContent(this.anim1, this.color, {Key key}) : super(key: key);\n  final AnimationControllerProp anim1;\n  final Color color;\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.all(100),\n      alignment: Alignment(0, anim1.value),\n      color: color.withOpacity(anim1.value),\n      child: Text(anim1.isComplete ? \"Done! Click to animate\" : \"Wait for it...\"),\n    );\n  }\n}\n\nThere's 2 main weak-spots with this Stateless implementation, but I think a linter could catch them both:\n\nIf static is ommitted from the Key declaration, props will be lost when widget is changed\nIf the Key is left null, we have to use an assert to catch.\n\nstatic PropKey key = Prop(); // This is good\nfinal PropKey key = Prop(); // This should fail, not static\nstatic PropKey key; // This should fail, key not initialized\n\nSeems like a linter based on final PropKey and static PropKey should be able to  catch it. Then it's pretty much compile safe end to end. There are a couple other smaller issue, like calling use(ref) before calling add/sync(ref), but I think this should be quite rare, and we can provide a nice assert when it happens.\nHere's another shot with the classic example thrown in. This isn't even a bad use case either, if we had context and widget deps, 'Classic' would be a lot longer and more error prone, this is essentially best case comparison for classic style:\n\n\n  \n    \n    \n\n    2020-12-27_03-15-14.mp4",
                "createdAt": "2020-12-27T09:14:42Z"
            },
            {
                "author": "bouraine",
                "bodyText": "The only annoying thing i see with this approach is that you have to spread the \"Prop\" thing all over the code. You will not use the native types like AnimationController, TextEditingController, FocusNode anymore but the equivalent AnimationControllerProp, TextEditingControllerProp, FocusNodeProp  which could lead to more complex code to read.\nI'll take this solution if it is the only option i have but if we can found something that extends instead of wrapping types, it would simplify the adoption and reduce the need to split all the types.\nWe have 4 concept to deal with in 3 lines of code (PropKey, addProd, useProd and static).\nstatic PropKey<AnimationControllerProp> _anim = PropKey();\naddProp(_anim, ...)\nuseProp(_anim, ...)\n\n\nWhile in react we would just write one line of code with one concept to understand:\nfinal controller = useAnimationController(duration: duration);\nWe are moving away from the initial dream @esDotDev :\ndouble opacity = builder TweenAnimationBuilder<double>(duration: 1.second, tween: Tween(begin: 0, end: 0));//\nOffset mousePos = builder MousePosBuilder(); // Light wrapper over MouseRegion\nbool isMouseDown = builder MouseDownBuilder(); // Light wrapper over MouseRegion",
                "createdAt": "2020-12-27T11:30:20Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I would add that one of the main motivations behind this issue is state-composition, but as mentioned previously, this approach isn't composable\nBeing able to combine multiple low-level state-logics into a higher-level logic is a critical part of this issue, which is what all the proposals so far (Property, addDispose, ...) excluding hooks fail to solve.",
                "createdAt": "2020-12-27T11:37:06Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think I spoke to soon on that, these are actually highly composable. I've gone through all the hooks libs, and I don't see anything that would be hard. They actually have some benefits over hooks:\n\nUse order doesn't matter, you can conditionally use() whatever you want, everything is declared in init(), so this issue goes away\nProps supports both atomic composition or de-composition of a complex item like a Widget because it can wrap the view in additional Widgets.\n\nAlso since they are classes, they support all the classic styles of code re-use. Inheritence, implementation, composition.\nFor example, this is the entire TapProp, it just extends GestureDetectorProp which is itself just a wrapper around GestureDetector\nclass TapProp extends GestureDetectorProp {\n  TapProp(VoidCallback onTap) : super(onTap: onTap);\n}\n\nYou can do basic memo like this:\nValueProp<MyThing> thing;\nonInit(){\n   thing = addProp((_, w) => ValueProp(MyThing()));\n}\nonPressed() => thing.value = getNewThing(); //View rebuilds\n\nIn this case the ValueProp is encapsulating the common low level logic of optimizing builds if nothing has changed. This is the entire Prop:\nclass ValueProp<T> extends StatefulProp<ValueProp<T>> {\n  ValueProp(this._value);\n  T _value;\n  T get value => _value;\n  set value(T value) {\n    if (value == _value) return;\n    setState(() =>_value = value;);\n  }}\n\nThen all my primitive types can just extend that one Prop:\nclass IntProp extends ValueProp<int> {\n  IntProp([int defaultValue = 0]) : super(defaultValue);\n}\n\nclass BoolProp extends ValueProp<bool> {\n  BoolProp([bool defaultValue = false]) : super(defaultValue);\n\n  void toggle() => value = !value;\n}\n\nclass DoubleProp extends ValueProp<double> {\n  DoubleProp([double defaultValue = 0]) : super(defaultValue);\n}\n\n\nThe last step would be to inject the .addProp and .syncProp methods to the Props. Then they could truly compose eachother:\nclass PropA extends StatefulProp<PropA> {\n  \n  @override\n  void init() {\n    _propB = addProp(PropB());\n  }\n}\n\nThe Tap handler above could then be written with composition over inheritance, as:\nclass TapProp extends StatefulProp<TapProp> {\n  TapProp(this.onTap);\n  final VoidCallback onTap;\n  @override\n  void init() {\n    addProp(GestureDetectorProp(onTap: onTap));\n  }\n}\n\nBecause the a Prop is just a simple class with a few callbacks, there's really no limit to what you can do, or how you can compose them together. It just gets the benefit of also having a override Widget build(Widget child){  // Wrap Widgets Here! } so the Props can tie into the RenderTree as well.",
                "createdAt": "2020-12-27T18:15:53Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The only annoying thing i see with this approach is that you have to spread the \"Prop\" thing all over the code. You will not use the native types like AnimationController, TextEditingController, FocusNode anymore but the equivalent AnimationControllerProp, TextEditingControllerProp, FocusNodeProp which could lead to more complex code to read.\n\nInteresting idea, it think would be more like a custom typedef that each prop could make, something like:\nAnimationControllerKey _anim = PropKey() I think that could actually work...\nAdd ambiguity to the code, but is nicer to read for sure.\n\nWe are moving away from the initial dream @esDotDev :\n\nImportant to remember, you just need to take 5 mores lines, and you can move to Stateful, and all the use() and Prop<> stuff goes away. This is just to enable simple use cases in Stateless style, but the Stateful is still there if you want the more straightforward setup/usage.\nBut ya, we can only go so far with dart, I hit a lot of walls with dart trying to implement this. Weak enum support, no reflection, etc really add up to a lot of dead ends architecturally.\nIt certainly would be nice to have some state keyword ot something, that went from this:\nclass MyView extends PropsWidget<MyView>{\n  MyView(this.duration);\n  final Duration duration;\n\n  static PropRef<BoolProp> _bool1 = PropRef();\n  static PropRef<AnimatorControllerProp> _anim1 = PropRef();\n\n  @override\n  void initProps(){\n    addProp(_bool1, false);\n    syncProp(_anim1, (c, w) => AnimatorControllerProp(duration: w.duration, vsync: c.read<TickerProvider>()));\n  }\n\n @override\n  void buildWithProps(){\n      // Setting `useRef(_bool1).value = true` would rebuild the view  automatically \n    return FadeTransition(opacity: useProp(_anim1).controller, child: Text(\"${useProp(_bool1).value}\"));\n  }\n}\n\nTo This:\nclass MyView extends PropsWidget<MyView>{\n  MyView(this.duration);\n  final Duration duration;\n\n state BoolProp _bool1 = addProp( false);\n state AnimatorControllerProp _anim1 = syncProp(\n     (c, w) => AnimatorControllerProp(duration: w.duration, vsync: c.read<TickerProvider>()));\n\n @override\n  void buildWithProps(){\n    return FadeTransition(opacity: anim1.controller, child: Text(\"${_bool1.value}\"));\n  }\n}\n\nIf that state keyword were introduced, I believe StatelessWidget would be fully deprecated. As is it still has a place because of the slightly cludgy stateless usage.\nBut now we're into verbosity, which we all agreed off the top was not the primary need here. This certainly addresses the core issue of code-reuse across widgets.",
                "createdAt": "2020-12-27T18:30:28Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "If dart's enum support wasn't so limited, we could have some interesting convention like:\nclass MyView extends PropsWidget {\n  enum p { isLoading , fadeAnim,  scrollAnim}\n  \n  initProps(){\n    addProp(p.isLoading, BoolProp(false));\n    addProp(p.fadeAnim, AnimationControllerProp(Duration(seconds: 1)));\n    syncProp(p.scrollAnim, (c, w) => AnimationControllerProp(Duration(seconds: w.duration)))\n  }\n  \n  buildWithProps(){\n     print(use(p.isLoading).value);\n  }\n  void restartFade() => use(p.fadeAnim).controller.forward(from: 0);\n  set isLoading(value) => use(p.isLoading).value = value; //View would rebuild\n}\n\nThis doesn't rely on using static keys, and comes in at very low line-count.\nDownside is I don't see how you make it compile safe. need each item to have it's own T\nclass MyView extends PropsWidget {\n  enum _P { \n    isLoading<BoolProp>, \n    anim1<AnimationControllerProp>, \n    anim2<AnimationControllerProp>   }\n  ... ?\n}",
                "createdAt": "2020-12-27T19:52:42Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The only annoying thing i see with this approach is that you have to spread the \"Prop\" thing all over the code.\n\nThanks for the idea, based on that I've simplified it a bit. This should be doable:\n  Foo(this.f);\n  final bool f;\n\n  static final _anim1 = AnimPropRef();\n  static final _isLoading = BoolPropRef();\n\n  void initProps() {\n    syncProp(_anim1, (c, w) => AnimProp(c, w.f));\n    addProp(_isLoading, BoolProp(false));\n  }\n\n  Widget buildWithProps(BuildContext context) {\n    AnimProp fadeAnim = use(_anim1);\n    BoolProp isLoading = use(_isLoading);\n    // Build Tree\n  }\n\nWhich I think is pretty good, but it's really not much better than just using the State, and living with the extra lines:\nFoo(this.f);\nfinal bool f;\n\nAnimProp _anim1;\nBoolProp _isLoading;\n\nvoid initProps() {\n  _anim1 = syncProp((c, w) => AnimProp(c, w.f));\n  _isLoading = addProp(BoolProp(false));\n}\n\nWidget buildWithProps(BuildContext context) { \n  //Build tree \n}\n\nKinda funny how this all comes back to Dart's weak Generic support in a way. In c#, you could get rid of most of the entire StatefulWidget widget body using where T : new() and new T()  and our stateful widgets would just look like:\nclass MyView extends StatelessWidget<_MyViewState>{}\nclass _MyVewState extends State<MyView>{\n\n}\n\nThen pretty much the entire readability hit from Stateful's would be gone (I really do find the multiple class bodies hard to read through)",
                "createdAt": "2020-12-27T23:46:51Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "It does feel like the Stateless approach here is not enough of a difference to warrant the extra boilerplate required to use it.\nI wonder if we could get even closer to hooks, and group the sync/init code together, getting rid of init() alltogether, but with a more clear syntax (instead of useEffect everywhere). Something like:\n{\n\tfinal static _prop1 = SomePropRef(sync, { init, initWithDispose } );\n\t\n\tWidget build(){\n\t\tSomeProp prop1 = use(_prop1);\n\t\t//Construct tree\n\t}\n}\n\nIn more concrete terms, it might look like this:\n{\n\tfinal static _fadeAnim = AnimPropRef<MyView>(\n\t\t(c, __) => AnimProp(0.5, vsync: c.read<double>()), \n\t\tinit: (w) => w.use(_fadeAnim).controller.forward()\n\t);\n\tfinal static _tap = TapPropRef<MyView>((_, w)=> TapProp(w._handleTap));\n\tfinal static _isLoading = BoolPropRef((_, __) => BoolProp(false));\n\n\tvoid _handleTap() => print(\"tap\");\n\n\tWidget build(){\n\t    use(_tap); // Everything would need at least 1 use call before it would start working\n\t    BoolProp isLoading = use(_isLoading);\n\t    AnimProp fadeAnim = use(_fadeAnimProp);\n\t\t//Construct tree\n\t}\n}\n\nI've managed to get this compiling, little more verbose that I'd hoped, but pretty close to the pseudocode above!\n  static final AnimPropRef<MyView> _fadeAnim = AnimPropRef(\n    (c, w) => AnimProp(w.duration, vsync: c.read<TickerProvider>()),\n    init: (_, w) => w.use(_fadeAnim).controller.forward(),\n  );\n  static final BoolPropRef<MyView> _isLoading = BoolPropRef((_, __) => BoolProp(false));\n  static final TapPropRef<MyView> _tap = TapPropRef((_, w) => TapProp(w._handleTap));\n\n  void _handleTap() => print(\"tap\");\n\n  Widget buildWithProps(BuildContext context) {\n    use(_tap); \n    BoolProp isLoading = use(_isLoading);\n    AnimProp fadeAnim = use(_fadeAnim);\n    return Container();\n  }\n\nThis might have some potential! But when compared to Stateful, there's just something comforting and straightforward about this:\n  AnimProp _fadeAnim;\n  BoolProp _isLoading;\n\n  @override\n  void initProps(){\n     addProp(TapProp(_handleTap));\n    _isLoading = addProp(BoolProp(false));\n    _fadeAnim = syncProp((c, w) => AnimProp(0.5, vsync: c.read<TickerProvider>()));\n  }\n\n  void _handleTap() => print(\"tap\");\n\n  Widget buildWithProps(BuildContext context) {\n    return Container();\n  }\n\nI think I'll pause on the Stateless version, there's no way to get it as succinct as it needs to be, without some sorta of extra language keyword or feature, there's just way too much typing. And the improvements to Stateful are fairly dramatic as is.",
                "createdAt": "2020-12-28T02:16:25Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think I'll pause on the Stateless version, there's no way to get it as succinct as it needs to be, without some sorta of extra language keyword or feature, there's just way too much typing. And the improvements to Stateful are fairly dramatic as is.\nDisplayScript (inspired hooks), has a really cool state keyword. If we just had this, inside StatelessWidgets, and could basically just have a List<State> that is managed by the framework, we could do everything we need with StatelessWidget + List<State>,\n\nstate BoolProp isLoading would tell the compiler to create an instance of BoolProp, and attach behind the scenes to the context/element, and call lifecycle methods on it. This would be amazingly flexible and succinct.\nUnlike hooks, everything does not have to be a function, which opens the door to other code reuse strategies other that composition, and they would have no issues with call-order.\nYou could express the above widget in:\n state AnimProp _fadeAnim = (c, w) => AnimProp(0.5, vsync: c.read<TickerProvider>());\n state BoolProp _isLoading = (_, __) => BoolProp(false);\n state TapProp _tap = (_, __) => TapProp(_handleTap);\n \nvoid _handleTap() => _fadeAnim.controller.forward(from: 0);\n\nWidget build(BuildContext context) {\n    return Text(\"${_fadeAnim.value}, ${_isLoading.value}\");\n}",
                "createdAt": "2020-12-28T05:22:34Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I got proper builders working :D Required a slightApi change, where each prop returns a ()=>build() closure, we collect them all, and run them top-down, which gets the behavior we need.\nSimple demo, showing FutureBuilder and LayoutBuilder, reduced to 2 lines and no nesting (with a bonus -3 lines and -1 nesting for the Tap gesture):\n  LayoutProp layout;\n  FutureProp<int> someFuture;\n\n  @override\n  void initProps() {\n    layout = addProp(LayoutProp());\n    someFuture = addProp(FutureProp(_loadData()));\n    addProp(TapProp(() => someFuture.future = _loadData()));\n  }\n\n  // Wait 1 second, return random Integer\n  Future<int> _loadData() => Future.delayed(Duration(seconds: 1), () => Random().nextInt(999));\n\n  @override\n  Widget buildWithProps(BuildContext context) {\n    bool hasLoaded = !someFuture.isWaiting; //syntax-sugar for _snapshot?.connectionState == ConnectionState.waiting\n    int loadedValue = someFuture.value; // syntax-sugar for .snapshot<T>.value\n    double maxWidth = layout.constraints.maxWidth; //Layout can be accessed without nesting (yay!)\n    return Container(\n      alignment: Alignment.center,\n      child: Text(\"${maxWidth}, future=${hasLoaded ? loadedValue : \"Loading...\"}\"),\n    );\n  }\n\nA look at the LayoutProp src shows how simple a simple builder wrap can be (probably needs a key param , I know):\nclass LayoutProp extends StatefulProp<LayoutProp> {\nBoxConstraints _constraints = BoxConstraints();\nBoxConstraints get constraints => _constraints;\n\n@override\nWidget Function() getBuilder(Widget Function() childBuilder) {\n  return () => LayoutBuilder(\n        builder: (_, constraints) {\n          _constraints = constraints;\n          return childBuilder();\n        },\n      );\n}\n}\n\n@rrousselGit, in the src for FutureProp, you can see some composition in action, we'll use a ValueProp here inside the FutureBuilder, to save a cpl lines:\nclass FutureProp<T> extends StatefulProp<FutureProp<T>> {\n  FutureProp(this._initialFuture) {}\n\n  //Internal State\n  Future<T> _initialFuture;\n  AsyncSnapshot<T> _snapshot;\n  ValueProp<Future<T>> futureValue;\n\n  // Helper methods\n  AsyncSnapshot<T> get snapshot => _snapshot;\n  T get value => _snapshot.data ?? null;\n  bool get isWaiting => _snapshot?.connectionState == ConnectionState.waiting;\n\n  Future<T> get future => futureValue?.value;\n  set future(Future<T> value) => futureValue?.value = value;\n\n  @override\n  void init() {\n    // Shows composition, as we'll use a ValueProp to handle our 'if-did-change-then-rebuild' check\n    // This is the same addProp/syncProp method the main State calls, it is simply injected into the props as a callback \n    // Order does not matter, as long as you only call add/sync once\n    futureValue = addProp.call(ValueProp(_initialFuture));\n  }\n\n  @override\n  Widget Function() getBuilder(Widget Function() childBuilder) {\n    return () => FutureBuilder<T>(\n          future: futureValue.value,\n          builder: (BuildContext context, AsyncSnapshot<T> snapshot) {\n            _snapshot = snapshot;\n            return childBuilder();\n          },\n        );\n  }\n}\n\nThis is a nice visual to show the issue as it pertains to nesting and readability. In this example, there are not many prevented bugs, (since the builders encapsulate the same logic as the Props), but the readability boost alone is massive. I know which one I'd want to maintain! And this is a favorable example for the builders, gets much worse when you sandwich a few lines here and there between the levels.",
                "createdAt": "2020-12-28T08:54:17Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another visual, this shows the savings in bugs & boilerplate.\nHere we have a couple of animControllers, than can be re-run with a tap. They have context and widget deps, so the widget becomes extremely full of boilerplate and potential bugs. The one on the right, is close to bulletproof and \"just works\"\n\nAnd a comparison of Stateful and non-Stateful approaches, with \"class declarations\" taken into account:\n\n\n  \n    \n    \n\n    2020-12-28_18-47-50.mp4",
                "createdAt": "2020-12-28T21:30:47Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Working on a TimerProp shows a nice use case.\nIf I want to delay something, but the user navigates away before the delay has expired:\n// This will blow up, unless I put some hacky check inside the closure, or null out the controller and add?null?checks.\nFuture.delayed(Duration(seconds: 1), () => controller.forward());\n\n// This will blow up, unless I keep a handle around, and remember to override dispose() (+4-6 lines and/or potential bug)\nTimer(Duration(seconds: 1), () => controller.forward());\n\n// This is completely safe, cause the prop just kills it's timer when widget is unmounted. \naddProp(TimerProp(1, (_) => controller.forward()));\n\nThe entire TimerProp is 20 lines, and no Widget ever again has to worry about this issue:\nclass TimerProp extends StatefulProp<TimerProp> {\n  TimerProp(this.seconds, this.callback, {this.periodic = false}) {\n    restart(seconds, callback, periodic: periodic);\n  }\n  final double seconds;\n  final void Function(Timer) callback;\n  final bool periodic;\n\n  // Helper methods\n  Timer get timer => _timer;\n  void cancel() => _timer?.cancel();\n  void restart(double seconds, void Function(Timer) callback, {bool periodic = false}) {\n    cancel();\n    _timer = periodic ? Timer.periodic(seconds.duration, callback) : Timer(seconds.duration, () => callback(timer));\n  }\n\n  //Internal state\n  Timer _timer;\n\n  @override\n  void dispose() => cancel();\n}",
                "createdAt": "2020-12-29T07:56:54Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Finally ready to share! Hopefully you guys like, I think it could be a real paradigm shift in how we build Widgets, without being as alienating as hooks. It allows functional composition just like hooks would, but it also supports all OOP patterns within Dart and access to the Widget tree:\nhttps://pub.dev/packages/stateful_props\n(^ Readme is not totally done, examples are rough, but the idea is there)\nIt would be amazing if something like this could make it's way into core, if even for the only reason to make example code drastically more readable and understandable.\nThe core manager is only about 90 lines sans comments, and then there's a skinny abstract class for the props:\nhttps://github.com/gskinnerTeam/flutter-stateful-props/blob/master/lib/stateful_props_manager.dart\nTo make it work, is a couple boilerplate wrappers around StatelessElement and State:\nhttps://github.com/gskinnerTeam/flutter-stateful-props/blob/master/lib/stateful_props_mixin.dart\nhttps://github.com/gskinnerTeam/flutter-stateful-props/blob/master/lib/stateful_props_widget.dart\nThe PropsWidget is a little more complex, but still mostly just wiring/boilerplate, the manager does pretty much all the work.\nAs I mentioned earlier, this also has Restoration written all over it. Once you have a list of instances, all hooked into lifecycle, giving them an id, and letting them register their own state is like 3 lines away.\nFor info on making custom Props: https://pub.dev/packages/stateful_props#creating-your-own-props",
                "createdAt": "2020-12-30T08:52:39Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "The primitives class is a really nice look at how we can kill a few birds with one stone here,\nhttps://github.com/gskinnerTeam/flutter-stateful-props/blob/master/lib/props/primitive_props.dart\n\nUses 1 Prop to form the foundation for a bunch of others\nAll primitives get onChange(old,new) for free, by extending ValueProp\nAll primitives get diff-checked setState call for free, by extending ValueProp\nWe can easily tack on extra behavior, BoolProp.toggle(), IntProp.increment, DoubleProp.toInt, StringProp.isEmptyOrNull  as needed\nI'm guessing we can implement Restoration on the base ValueProp, and handle it for all natively supported types in one place (need to learn more here)\nAny other Prop is free to compose or extend these primitives\n\nWhen creating your own Props, this is the simple set of methods you can override. They are all optional, no super() calls needed.\nabstract class StatefulProp<T> {\n\n  @protected\n  void init() {}\n\n  @protected\n  ChildBuilder getBuilder(ChildBuilder childBuild) => childBuild;\n\n  @protected\n  void update(T newProp) {}\n\n  @protected\n  void dispose() {}\n\n  @protected\n  void restoreState(void Function(RestorableProperty<Object> property, String restorationId) register) {}\n}\n\nThe following set of callbacks/references are available for all Props to use if they need:\n  BuildContext context;\n  void Function(VoidCallback) setState;\n  String restoreId;\n  //Callbacks to the manager allows composition of other Props from inside `init()`\n  T2 addProp<T2>(T2) \n  T2 syncProp<T2>(T2 (c, w){})",
                "createdAt": "2020-12-30T20:50:14Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Working on optimized rebuilds. By simply making the base ValueProp a ChangeNotifier, we can do something like:\n  void initProps() {\n    _counter = addProp(IntProp(autoBuild: false));\n    _toggle = addProp(BoolProp(autoBuild: false));\n  }\n  \nreturn Column(\n    children: [\n      OutlineButton(onPressed: () => _toggle.toggle(), child: Text(\"bool.toggle()\")),\n      OutlineButton(onPressed: () => _counter.increment(), child: Text(\"int.increment()\")),\n      // We can nest a build anywhere in the tree, tied to one or more ChangeNotifiers\n      NotifiersBuilder(\n        [_counter, _toggle],\n        // Provide a cached child\n        child: RandomColoredBox(child: SizedBox(width: 100, height: 100)),\n        builder: (_, cachedChild) {\n          String content = \"counter: ${_counter.value}, isToggled: ${_toggle.value}\";\n          return Column(children: [\n            RandomColoredBox(child: Text(content)),\n            cachedChild,\n          ]);},)]));\nWhen either of the btns are pressed here, the only thing that rebuilds is the RandomColoredBox(child: Text(content)) leaf-node.",
                "createdAt": "2020-12-30T23:33:51Z"
            },
            {
                "author": "DanHarman",
                "bodyText": "I don\u2019t really see what this props approach gets us that hooks doesn\u2019t do more concisely?\nAdditionally, this assumption that initialisation has to only occur in the initState life cycle method presumes that life cycle methods are the correct paradigm, whereas there is a bigger leap to be made by taking the other step React has made, which is to offer functional components as primitives. This sweeps aside whole categories of errors around correctly managing lifecycle in UI components.\nI\u2019m probably showing my age here but it reminds me of people disliking ref counted pointers in c++ because of the performance hit, and how it\u2019s super obvious to remember to delete your objects. Experience shows that isn\u2019t the case! One could make the same argument for manual life cycle.\nWhat would be an improvement on the react implementation of hooks would be:\n\nremove the order constraint on them so they could go in conditional statements.\nHandle async better. UseEffect has a big foot gun where you can trigger an async operation that invokes a closure after the state it mutates has already been cleaned up. There are work around with helper hooks (yay for hook composition) or putting manual guards in place, but surely this could be done better.\nprevent unnecessary updates due to ease of generating non-referentially equal output. This is maybe more of a react/js level problem as typically I see this when callbacks handlers defined as lambdas are recreated on each invocation of render and trigger redraw. Ideally they should be refentially equal unless the variables they close over have changed. Obviously with callback handlers defined as class members this isn\u2019t an issue and one of the main challenges I see when colleagues migrate to functional components. Of course this is a known issue which is why useCallback exists in react, but a compiler could surely do it better.",
                "createdAt": "2021-01-02T20:24:52Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I guess for me the concision is an issue. It's not a performance concern but a readability and extensibility one.\nHooks basically devolves into many useEffect calls, with ambiguous syntax(keys: [] vs keys: null specifically), and it renders it hard to read and quite \"non-declarative\". useEffect supports like 5 lifecycle methods (mount, unmount, render, build-with-deps, skipFirst), people use [] to do init/dispose anyways, so I don't see what we gain by keeping it so terse and overloaded.\nI get the elegance of this from an architectural standpoint, but readability wise it's really a step backwards imo. It makes sense in JS where you have other constraints like lack of great Class support or compiler but it doesn't fit correctly with Flutter. It moves very far from normal OOP practice and for what, so we can pretend that init doesn't exist, but then use it all the time anyways in some ambigous way?\nFor example, useAnimator provides no way to auto-start the anim, so right off the top I would be forced to hack in useEffect(...., keys: []) (which is highly non-readable as the init call), or wrap useAnimator in some other hook, which is already forcing complexity and more code into the codebase, for common use cases. You can already see readability heading south... add some more complexity and it doesn't take long until it's just a blob of useEffect and useState and terse key arrays.\nI think it makes sense to at least split it and say, yes, there is an init() phase, you often want custom behavior here, then there is some sync/update call that can access deps, and that's really all that's needed from the Widget POV.\nHooks are also fundamentally limited by their functional approach. There's nothing a function can do that a class can not, but the inverse is not true. By using proper classes, you can use functional composition if you want, but it is not your only tool like it is with hooks. You can define interfaces, abstract implementations, use mixins, whatever helps write the most readable and maintainable code.",
                "createdAt": "2021-01-02T21:23:18Z"
            },
            {
                "author": "bouraine",
                "bodyText": "I am a big fan of Hooks in React but hooks solves the state problem in functional components. Hooks plays nice with functions but in Flutter functional widgets are not recommended because the framework is optimised only for class widgets (discussion about functional components).\nEven in React, no one uses Hooks with Class Components because they are redundant with the class life cycle hooks.\nSo imo, 2 choices are presented to us (Flutter team):\n\nFunctional widget + functional Hooks\nor\nClass widget + valueProps (or equivalent)\n\nI don't see the Flutter team going the functional way because of the overall architecture of the framework. BuildContext, InheritedWidget, keys, const constructors, Context api, debugFillProperties, hot reload ..etc would be really challenging to reimplement with functions especially without a DSL (DSX). but i guess i am wrong  (maybe an easy solution is possible by generating classes from functions at compile time) :)\nWe would like to hear some enlightenment from the Flutter core team about what direction they want Flutter to take :)",
                "createdAt": "2021-01-02T22:11:06Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "@esDotDev  That's nit-picking\nIf you don't like how useEffect reads or miss some functionality on useAnimationController, you can fix that yourself.\nHooks aren't a final API. Hooks are a way for you to create your own API by providing an easy way for people to compose logic. useEffect and useAnimationController are primitives made to be composed to achieve what you want\nIf you want a \"readable\" init or want an \"auto play\", you can:\nvoid useInit(VoidCallback cb) => useEffect(cb, const []);\n\nAnimationController useAutoAnimatedAnimationController(Duration duration) {\n  final controller = useAnimationController(duration: duration);\n  useInit(controller.forward);\n\n  return controller;\n}\n\nThere's nothing a function can do that a class can not, but the inverse is not true. By using proper classes, you can use functional composition if you want, but it is not your only tool like it is with hooks. You can define interfaces, abstract implementations, use mixins, whatever helps write the most readable and maintainable code.\n\nI will disagree.\nFunctional programming can achieve everything that OOP can.\nNot using subclass and mixins is a feature too. They are known to cause issues.\n@bouraine :\n\nHooks plays nice with functions but in Flutter functional widgets are not recommended because the framework is optimised only for class widgets (discussion about functional components).\n\nThe issue you linked is unrelated to this discussion\nThis issue is not trying to promote writing StatelessWidgets as static functions. It's mostly focusing on syntax sugar for builders.",
                "createdAt": "2021-01-02T22:30:10Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Not using subclass and mixins is a feature too\n\nIn the context of mixing many mixins that share scope, which is what the React team where referring to, that's 100% true. We're talking about small discrete objects with enclosed scope. Making a mixin, to be shared by several Props, or a abstract class, would not in any way be dangerous and could have very nice applications.  I'm a big fan of Composition like 90% of the time, but thinking it's the only way to build things, and that other approaches have no value at all, throws the baby out with the bathwater.\n\nFunctional programming can achieve everything that OOP can.\n\nWith the same readability and maintainability? On very large code bases? Not sure about that... I don't see a lot of Games (which are extremely complex) being built without OOP practices. Interfaces, abstract classes, mixins all have valid use cases that either reduce boilerplate / complexity vs functional, or keep things more maintainable by enforcing contracts across multiple sets of code.",
                "createdAt": "2021-01-03T00:00:13Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "With the same readability and maintainability? On very large code bases? Not sure about that... I don't see a lot of Games (which are extremely complex) being built without OOP practices. Interfaces, abstract classes, mixins all have valid use cases that either reduce boilerplate / complexity vs functional, or keep things more maintainable by enforcing contracts across multiple sets of code.\n\nThis is only true for newer game engines. Many of the heavy hitters in games, like Mike Acton (recently hired to tune Unity), decry OOP in games.\nHere is a talk covering the positive results gained by undoing most OOP in the Chromium browser.\nBut I suppose we can't afford to turn this into a this-paradigm vs that-paradigm discussion. It continues to be a trend that the bottom of these frameworks has a short object-hierarchy that does the heavy-lifting and Flutter already has Widgets. If we want to compare to games, Unity has MonoBehaviour.\nI would like to see something like Unreal Engine's visual-scripting for Flutter. I realize that's pretty far out of the box of this conversation, but it's one of the only high-level constructs that has been proven to work for non-technical people working on games. Making Flutter apps easier to build in this fashion may be an easier and more rewarding problem to solve than reducing lines of code needed to write a Widget.",
                "createdAt": "2021-01-03T19:06:46Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Fair point about the direction highly performant code is heading in, but a counter-point to that would be to look at the uptake of the DOTS system among Unity devs. It's virtually non-existent, after 3 yrs of pushing it hard, the majority is happy working with OOP principles heavy on composition.\nBut I totally agree it can be, and usually is over-used and that this debate is out of scope. I think hopefully we can just agree there is some value to having the ability to use OOP techniques where it makes sense, and  a blanket statement that they have no value at all is not really true.\nIf you look at the rationale for Hooks, a lot of it was around devs having to \"learn classes\" in Javascript; Scope was a total mess. That made no sense over in JS, so they did something logical and just got rid of it.\nNone of that applies to us though, we would have to essentially \"unlearn classes\", and change mindsets to a functional only approach. Scope is no issue for us. We have great compiler support for various architectures we would like to keep. I don't see a strong argument for throwing that all out... the strongest pillars of that argument from React just don't apply here.",
                "createdAt": "2021-01-03T22:21:19Z"
            },
            {
                "author": "leecommamichael",
                "bodyText": "Fair point about the direction highly performant code is heading in, but...\n\nMy point was not specific to highly performant code (which we shouldn't be excluding ourselves from), it's about the benefits of limiting your number of abstractions. Flutter already has Widgets, when we deliberately add \"another kind of thing\", it turns every problem into 2 problems.\nLet's imagine the Props idea catches on, and someone is having an issue. The developer needs to think: Did I make a \"Widgets\" level misunderstanding, or a \"Props\" level misunderstanding? As the art of writing PropsWidgets expands, there is more material on all the mistakes you can make with it, so their search results are that much more dense and specialized. They'll click on a bunch of links that look like their problem, but the accepted answer on StackOverflow didn't mention PropsWidgets so they're not confident it works for them. Now they have to try solutions that may not apply to them.\n\u261dIt's this little story that we need to watch out for. Is there an improvement we can make that unambiguously benefits people new to Flutter?\nRight now, the culture in these reactive UI frameworks is to pick a state-management solution and run with it before even trying vanilla. People get really confused by that because now there are 2 unknowns at-play (Flutter and whatever state-management thing), there are so many StackOverflow questions about how to get XyzRxMobviderPod to rebuild the UI when they're just missing a Key on a list item.\nWhatever is done, we really can't afford for it to feel like \"another thing\". I'm starting to think this is strictly on Dart to skinny up the syntax, but I'm not sure if there's actually any \"noise\" beyond what is going away when Dart gets default constructors.\nSolving reuse matters, and I'll probably end up using whatever comes of this conversation, but we might make a bigger problem with that solution.",
                "createdAt": "2021-01-03T23:01:06Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Right, ya I don't really disagree with any of that. Hooks is certainly not exempt from that \"one more thing\" issue as well. And you're right about most people jumping straight into abstractions, so more layers on layers is never good.\nI do think this idea of StatefulProps (whether it's my lib, or someother, I don't care), seems like the correct direction to go in. It's what we want, little self-contained hunks of state, that can cling onto the Widget lifecycle. I don't know how else you get there if not for something along those lines... or some index-based 'everything goes in render' count like hooks. Unless, as you say, we get some more language support, or a special builder keyword or something.\nAlso, it is worth noting there are a lot of simplicities that come from having single clear level of abstraction at the right spot. Right now things are getting quite messy with the Restoration API, disposal, didUpdateWidget, it is spiraling...\nFor example, look at a developer who want to implement some long lived Animation, and the Restoration API, and they want to use Provider or some sort of Widget dep. With a nicely encapsulated State wrapper, they can just use the thing they need, and a bunch of boring implementation stuff gets taken care of, it's tested, it's solid they can just use. In the other scenario, they have to learn, and correctly implement 3 different things, all error prone, all boilerplate, and almost definitely create bugs.\nI do think if you have some ability for StatefulWidget to have List<StateProp> somehow that hook into lifecycle, it very greatly improves the lives of new Flutter devs fwiw. It makes the code what it should be, elegant, robust, concise.",
                "createdAt": "2021-01-03T23:21:33Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Here is a talk covering the positive results gained by undoing most OOP in the Chromium browser.\n\nVery cool talk just got around to fully watching it. Fwiw, he states near the end that OOP still has it's place, his title is a joke, and that Data-Oriented design does not mean Class-less, it's about putting data first, and using classic patterns from a new angle with a functional data-in data-out, no-branching perspective. Not throwing the baby out with the bathwater, but plucking the best of both worlds, which was what I was trying to advocate.",
                "createdAt": "2021-01-04T03:51:16Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "I feel like we're getting a little too into the weeds about implementation details, ie FP vs OOP, which might be off topic for this issue. For hooks, does anyone have proposals which address the points made here?\n\nWhat would be an improvement on the react implementation of hooks would be:\n\n\nremove the order constraint on them so they could go in conditional statements.\n\n\nHandle async better. UseEffect has a big foot gun where you can trigger an async operation that invokes a closure after the state it mutates has already been cleaned up. There are work around with helper hooks (yay for hook composition) or putting manual guards in place, but surely this could be done better.\n\n\nprevent unnecessary updates due to ease of generating non-referentially equal output. This is maybe more of a react/js level problem as typically I see this when callbacks handlers defined as lambdas are recreated on each invocation of render and trigger redraw. Ideally they should be refentially equal unless the variables they close over have changed. Obviously with callback handlers defined as class members this isn\u2019t an issue and one of the main challenges I see when colleagues migrate to functional components. Of course this is a known issue which is why useCallback exists in react, but a compiler could surely do it better.\n\n\n\nI do agree with these, I think hooks are fine but there are some semantic footguns, not just syntactic ones such as useEffect's [].\nThe Vue version of hooks doesn't have the flaw of the order constraint, but it might have others, I haven't looked too deeply into it. It looks like this:\nimport { ref, watch } from \"vue\";\nexport default {\n  props: [\"divRef\"],\n  setup(props, context) {\n    const currentNote = ref(\"\");\n    const handleNoteInput = e => {\n      const val = e.target.value && e.target.value.toUpperCase()[0];\n      const validNotes = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"];\n      currentNote.value = validNotes.includes(val) ? val : \"\";\n    };\n    const handleSubmit = e => {\n      context.emit(\"note-sent\", currentNote.value);\n      currentNote.value = \"\";\n      e.preventDefault();\n    };\n\n    return {\n      currentNote,\n      handleNoteInput,\n      handleSubmit,\n    };\n  }\n};\n\nSince the setup method will only run once, we can make use of the different functions that are part of the Composition API (reactive, ref, computed, watch, lifecycle hooks, etc.) as part of loops or conditional statements. However, the if statement will also only run once, so it won't react to changes to name unless we include it inside of the watch callback:\n\nwatch(function persistForm() => {\n  if(name.value !== '') {\n    localStorage.setItem('formData', name.value);\n  }\n});",
                "createdAt": "2021-01-04T04:06:50Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "https://github.com/dart-lang/language/blob/898e538a8d0749dce922de06b92d9bcaf32f315b/working/static%20metaprogramming/intro.md\n^ This is amazing. Not only would be be able to get our single-line builders but it hits so many other pain-pts squarely on the head:\n\nLack of reflection, makes me sad at least once a week as an end user of dart\nCode-gen is unreliable and annoying, we'd love to never have to do it again\n1st class support for immutable data would make Dart and Flutter a better match (flutter wants immutable data, dart stinks at working with it)\nStatefulWidgets could be written in a more succinct way and other common use cases encapsulated\nSerialization would no longer be a pain point\n\nAll taken together it would really be a game-changer.",
                "createdAt": "2021-02-13T04:32:58Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "This seems to be an alternative to hooks api https://pub.dev/packages/reactives",
                "createdAt": "2021-07-18T07:27:31Z"
            },
            {
                "author": "deadsoul44",
                "bodyText": "This seems to be an alternative to hooks api https://pub.dev/packages/reactives\n\nThis seems better than flutter_hooks package. Thanks for bringing it up. I had to drop flutter_hooks due to drawbacks. Is there any disadvantage/drawback of this package?",
                "createdAt": "2021-07-18T07:55:40Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "I have tried it and it worked for me so far. None that I have particularly encountered. The source code is also relatively small.",
                "createdAt": "2021-07-18T08:58:30Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "This seems to be an alternative to hooks api https://pub.dev/packages/reactives\n\nThis seems better than flutter_hooks package. Thanks for bringing it up. I had to drop flutter_hooks due to drawbacks. Is there any disadvantage/drawback of this package?\n\nI've been using this lately and I like it a lot. It's simple, light, and solves most of the problem with state reuse that I have on a day to day basis. The reactives take care of setup/teardown, you can still use initState to kick off first-run behavior in a clear and obvious way.\nclass _MyViewState extends State<MyView> with ReactiveHostMixin {\n  late final _scaleAnim = ReactiveAnimationController(this);\n\n  @override\n  Widget build(_) \n           => Transform.scale(scale: _scaleAnim.ctrl.value, ... );\n}\nDownsides? There's a few nits:\n\nIt doesn't work with StatelessWidget (doesn't really bother me),\nIt doesn't seem to be super well maintained\nNo tests\n\nA further evolution of this, might be something like ReactiveWidget that is a single-class, but provides a stateful context for the reactives to bind to.",
                "createdAt": "2022-02-10T16:57:37Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The approach taken by reactives has been suggested in this thread before and it was argued that it didn't solve the problem.\nHooks are significantly more than a setup+teardown. It all boils down to composition and handling the Hook's input updates.\nFor example the following implements basic pagination using hooks:\n// A custom hook that fetches a paginated API\n// It can be reused multiple times. Including multiple times within the same widget if necessary\nAsyncSnapshot<List<Item>> usePaginatedItems({required int page}) {\n  // fetch a list of items from the page index. \n  // Will automatically re-fetch when the page index changes, yet if the page index does not change, then\n  // the API will not be fetched again.\n  Future<List<Item>> itemsFuture = useMemoized(() => fetchItems(page: page), [page]);\n\n  // listens to the future like with FutureBuilder\n  AsyncSnapshot<List<Item>> items = useFuture(itemsFuture);\n  return items;\n}\n\n\n// usage example\nWidget build(context) {\n  // the current page index.\n  // Could be coming from anywhere, including from the widget constructor or an InheritedWidget\n  final page = useState(0);\n  final items = usePaginatedItems(page: page.value);\n\n  return Column(\n    children: [\n      Expanded(\n        child: ListView.builder(\n          itemCount: items.data?.length ?? 0,\n          itemBuilder: (context, index) {\n            final item = items.requireData[index];\n            return Text(item.name);\n          },\n        ),\n        ElevatedButton(\n          // increment page index, will automatically fetch the next page too\n          onPressed: () => page.value++,\n          child: Text('next'),\n        ),\n      ),\n    ],\n  );\n}\nThere's no equivalent to this using reactives or other approaches suggested in this thread",
                "createdAt": "2022-02-11T01:44:29Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Pretty sure you can encapsulate the core logic here with something like this, and it could also come from a inherited widget or widget config:\nfinal _pager = ReactiveItemsPager(this);\nint _pageIndex = 0;\n\nWidget build(){\n   final items = _pager.getPage(_pageIndex); // pageIndex can come from anywhere, _pager can memoize internally if it wants\n   ...\n}",
                "createdAt": "2022-02-11T02:16:37Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "How does that logic looks like exactly?\nDo note that the hook example has a single code path and never need things like \"if (newPage!= previousPage)\"",
                "createdAt": "2022-02-11T02:24:15Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "But who cares? The reactive pager would encapsulate that check anyways, if it needs it. Not sure how it would look, but seems pretty straightforward, it simply caches the result of a query, and doesn't query again, until index changes. Any mutable class can do this.\nAre you making  a perf argument here? If so I'd be surprised if hooks wins out in performance in the end, considering how much it overloads build(), re-declaring methods, and defaults every single tick. But I'm sure either way, it doesn't make any real-world difference.",
                "createdAt": "2022-02-11T02:27:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "The example I made showcases custom hooks, built by composition of other hooks.\nYour example bypassed this bit. You showed how the controller is used, not how it works.\nThe way your controller works is critical to the example.",
                "createdAt": "2022-02-11T02:33:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Composition is quite elegant with this pattern:\nhttps://lit.dev/docs/composition/controllers/#building-controllers-from-other-controllers\nThere is already a ReactiveFuture which you could compose, so I think you are basically just asking if a ReactiveMemo could be created, and then the two of those be used inside of a ReactivePager, and the answer is I think is an easy yes.\nI'll try and put some time in tmrw and create a concrete example, I'm still pretty new to this lib.\nfwiw though, at this pt, we're nit picking about terseness. The core design problems are largely solved by either approach.",
                "createdAt": "2022-02-11T02:36:52Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I disagree.\nComposition is probably one of the biggest problems that hooks are solving.\nAlso to come back to your example:\nI personally don't mind your example, but wasn't one of the goal of not using hooks to extract the logic out of the build method?\nWith getPage being called within the build method, the same argument could be made here.",
                "createdAt": "2022-02-11T02:51:11Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Disagree with what? I totally agree composition is key, it's quite easy with props as they are just classes. Not only can they be composed, but they support mixins and extends as well, so they're actually more capable in some ways.\n\nWith getPage being called within the build method, the same argument could be made here.\n\nWhat is the important difference between?\nfinal items = usePaginatedItems(page: value);\nand\nfinal items = _pager.getItems(page: value);",
                "createdAt": "2022-02-11T02:57:07Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "I think I know what you're getting at... if I had for example animation.duration, coming in from outside, I would need to add something like this to keep it synced:\nWidget build(_){\n  _anim.ctrl.duration = widget.duration;\n}\nOr use some closure, as has been explored above (in my own StatefulProps, and Hixies approach)\nSo yes, there is an edge to hooks when it comes to simplifying deps via didChangeDependencies and didUpdateWidget. Props pattern does have a solution for this, but it's a little more cludgy / error prone.",
                "createdAt": "2022-02-11T03:11:24Z"
            },
            {
                "author": "satvikpendem",
                "bodyText": "And if you had many of those types of animations or other controllers for example, it would balloon up the number of props you need to pass. In a way, the hooks themselves are the closure you're talking about.",
                "createdAt": "2022-02-11T03:13:57Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "I think I know what you're getting at... if I had for example animation.duration, coming in from outside, I would need to add something like this to keep it synced:\n\nIndeed! Happy to see that you understood, and sorry for having issues explaining it.\nThat concept feels unexpectedly difficult to communicate.\nI place quite a bit of importance in that case. I personally view that case as more important than being able to pass the State instance or reading the hooks within methods.",
                "createdAt": "2022-02-11T03:32:37Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "So... about that builder keyword :p",
                "createdAt": "2022-02-11T03:33:39Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "And if you had many of those types of animations or other controllers for example, it would balloon up the number of props you need to pass. In a way, the hooks themselves are the closure you're talking about.\n\nYa, I get that there is this level of extreme flexibility here, but I just question the actual utility of it all.\n\nMany api's can be naturally called in build anyways, so there ends up being no real functional difference useFoo([1,2,3]) vs foo.use(1,2,3), hooks gets a bit for free here in it's \"automatic diff\" approach, but not a ton, since props can do a similar thing internally.\nMany other api's only care about initial values, so they do not need to sync by design\n\nThat just makes it like a once a month kinda thing where I find this situation where I have some stateful thing, that needs to sync external props. And of course even rarer where I find myself repeatedly doing it across different widgets.",
                "createdAt": "2022-02-11T03:45:04Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "@esDotDev @rrousselGit\nAn example of how it would be done using reactives\nclass PaginatedFetcher extends Reactive {\n  ReactiveFuture<List<Item>> _future;\n  int _currentPage;\n  AsyncSnapshot<List<Item>> get items => _future.snapshot;\n\n  PaginatedFetcher(ReactiveHost host, {required int page})\n      : _currentPage = page,\n        _future = ReactiveFuture(host, fetchItems(page)),\n        super(host);\n\n  void nextPage() {\n    gotoPage(_currentPage++);\n  }\n\n  void previousPage() {\n    gotoPage(_currentPage--);\n  }\n\n  void gotoPage(int page) {\n    _future = ReactiveFuture(host, fetchItems(page));\n  }\n}\n\nclass ItemsPage extends StatefulWidget {\n  const ItemsPage({Key? key}) : super(key: key);\n\n  @override\n  _ItemsPageState createState() => _ItemsPageState();\n}\n\nclass _ItemsPageState extends State<ItemsPage> with ReactiveHostMixin {\n  late final paginator = PaginatedFetcher(this, page: 1);\n  @override\n  Widget build(BuildContext context) {\n    final items = paginator.items;\n    return Column(\n      children: [\n        Expanded(\n          child: ListView.builder(\n            itemCount: items.data?.length ?? 0,\n            itemBuilder: (context, index) {\n              final item = items.requireData[index];\n              return Text(item.name);\n            },\n          ),\n        ),\n        ElevatedButton(\n          // increment page index, will automatically fetch the next page too\n          onPressed: paginator.nextPage,\n          child: const Text('next'),\n        ),\n      ],\n    );\n  }\n}",
                "createdAt": "2022-02-11T03:49:17Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "@esDotDev\nExample that addresses props,\nabstract class PaginatorProps {\n  int get page;\n}\n\nclass PaginatedFetcher extends Reactive {\n  ReactiveFuture<List<Item>> _future;\n  int _currentPage;\n  AsyncSnapshot<List<Item>> get items => _future.snapshot;\n\n  PaginatedFetcher(ReactiveHost host, {required int page})\n      : _currentPage = page,\n        _future = ReactiveFuture(host, fetchItems(page)),\n        super(host);\n\n  @override\n  void didUpdateWidget(covariant StatefulWidget oldWidget) {\n    if (host.widget is PaginatorProps) {\n      final newPage = (host.widget as PaginatorProps).page;\n      final oldPage = (oldWidget as PaginatorProps).page;\n      if (newPage != oldPage) {\n        gotoPage(newPage);\n      }\n    }\n    super.didUpdateWidget(oldWidget);\n  }\n\n  void nextPage() {\n    gotoPage(_currentPage++);\n  }\n\n  void previousPage() {\n    gotoPage(_currentPage--);\n  }\n\n  void gotoPage(int page) {\n    _future = ReactiveFuture(host, fetchItems(page));\n  }\n}",
                "createdAt": "2022-02-11T04:11:47Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "Final ItemsPage\nclass ItemsPage extends StatefulWidget implements PaginatorProps {\n  @override\n  final int page;\n  const ItemsPage({Key? key, required this.page}) : super(key: key);\n\n  @override\n  _ItemsPageState createState() => _ItemsPageState();\n}\n\nclass _ItemsPageState extends State<ItemsPage> with ReactiveHostMixin {\n  late final paginator = PaginatedFetcher(this, page: widget.page);\n  @override\n  Widget build(BuildContext context) {\n    final items = paginator.items;\n    return Column(\n      children: [\n        Expanded(\n          child: ListView.builder(\n            itemCount: items.data?.length ?? 0,\n            itemBuilder: (context, index) {\n              final item = items.requireData[index];\n              return Text(item.name);\n            },\n          ),\n        ),\n        ElevatedButton(\n          // increment page index, will automatically fetch the next page too\n          onPressed: paginator.nextPage,\n          child: const Text('next'),\n        ),\n      ],\n    );\n  }\n}",
                "createdAt": "2022-02-11T04:17:52Z"
            },
            {
                "author": "srikrsna",
                "bodyText": "I understand that hooks are on the fly composable. reactives are composable within a reactive and are more explicit (PaginatorProps) but I think this explicit nature helps in the case of Dart.\n@rrousselGit would be interested in knowing what you think of this approach. Thanks for all your awesome work so far.",
                "createdAt": "2022-02-11T04:22:30Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "As argued before, the controller should not know where the page is coming from.\nThe controller shouldn't have to differentiate between didUpdateWidget vs didChangeDependencies vs internal setState\nWe are also trying to avoid the \"if previousPage!= newPage\". One goal is to have a single code path",
                "createdAt": "2022-02-11T04:26:26Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Ya, the widgets only real job is to pass along the dep, which ideally the prop doesn't know/care about. I would think it's something like:\nWidget build() {\n  _animProp.sync(duration: context.watch<Duration>());\n}\n\nIn the fetch example, it would work itself out naturally, as we can pass the dep in via a the get call:\n  final _items = _pagerProp.getPage(widget.pageIndex);\n\ntbh, I don't get the single code path thing or why that matters. Seems like the remaining problem-set is getting quite tiny at that pt.",
                "createdAt": "2022-02-11T08:03:14Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "@rrousselGit I took a stab at crafting something like your example with reactives, this seems to work great. I used a lib to do the memoize (memo1 method):\nclass ReactivePaginator extends Reactive {\n  ReactivePaginator(ReactiveHost host) : super(host);\n\n  late final _memoizeFuture = memo1((int index) => ReactiveFuture(host, fetchItems(index)));\n\n  AsyncSnapshot<List<String>> getPage(int index) => _memoizeFuture(index).snapshot;\n}\nUsage:\nclass _PageViewState extends State<PageView> with ReactiveHostMixin {\n  int _index = 0;\n  late final pager = ReactivePaginator(this);\n\n  @override\n  Widget build(BuildContext context) {\n    final items = pager.getItems(_index).data ?? [];\n    return Column(\n      children: [\n        Text('${items.length}'),\n        TextButton(onPressed: () => setState(() => _index++), child: Text('-->>')),\n      ],\n    );\n  }\n}\nIt uses the existing ReactiveFuture so demonstrates composition nicely. Curiously, ReactiveFuture is not actually exported in the current version of the lib, but it exists.\nTo be more flexible, I'd more likely make the entire pager mechanism generic, and then just pass in a method:\nlate final pager = ReactivePaginator(this, (index) => fetchUsers(page: index));",
                "createdAt": "2022-02-13T05:57:35Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Another nice example of composition, here shows how you can combine two ReactiveTextEditingController, and a ReactiveBool to encapsulate some login-form behavior, leaving only pure UI code in the widget:\nclass ReactiveLoginLogic extends Reactive {\n  ReactiveLoginLogic(ReactiveHost host) : super(host);\n  late final ReactiveTextEditingController _email = ReactiveTextEditingController(host);\n  late final ReactiveTextEditingController _password = ReactiveTextEditingController(host);\n  late final ReactiveBool _showPasswordReactive = ReactiveBool(host); // rebuilds when changed\n\n  TextEditingController get emailCtrl => _email.ctrl;\n  TextEditingController get passwordCtrl => _password.ctrl;\n  bool get showPassword => _showPasswordReactive.value;\n\n  // Login logic\n  void submit() {}\n\n  void toggleShowPassword() => _showPasswordReactive.value = !showPassword;\n}\nUsage:\nclass _LoginViewState extends State<LoginView> with ReactiveHostMixin {\n  late final _login = ReactiveLoginLogic(this);\n\n  @override\n  Widget build(BuildContext context) {\n     // _login.emailCtrl\n     //     .passwordCtrl,\n     //     .showPassword\n     //     .toggleShowPassword()\n     //     .submit()\n     ...\n  }\n}\nNow we're getting into some pretty interesting stuff, as not only can we make these little classes to manage lifecycle hooks for us and encapsulate common logic, but they naturally make excellent \"bloc\" objects / view controllers and are inherently portable since they act similarly to mixins but with a dedicated scope.\nThis pattern would make code maintenance quite nice too, as all methods and business logic would naturally be hoisted outside of the _State class, which could then focus entirely on UI.\nNow add on to this, that we can quite easily tack on Restoration onto something like ReactiveBool and things get even more interesting imo.",
                "createdAt": "2022-02-13T07:52:14Z"
            },
            {
                "author": "szotp",
                "bodyText": "Here is something different, similiar to reactives (super confusing name btw), but from a different angle:\nclass _PageViewState extends State<PageView> with HostMixin {\n  // createComponent is a generic method provided by HostMixin\n  // that will allow us to create the Paginator and configure stuff around it\n  late final _paginator = createComponent(Paginator(), (x) {\n    // x is of type AttachedComponent<Paginator, PageView>\n    // you can easily add extension to this class for your own helpers\n\n    // this closure will be called once, just before _paginator has been set\n    // to allow us a chance of configuring what we want to configure\n\n    // we can't use _paginator here because it's not initialized yet\n    // but Dart is kind enough to give us an error (sadly, only when infering the type)\n\n    // if widget.page changed, call setPage on paginator\n    x.onWidgetUpdate((widget) => widget.page, x.instance.setPage);\n\n    // if Paginator is Listenable, call setState on every change\n    x.setStateOnChange();\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    return Text(\"${_paginator.data}\");\n  }\n}\nBasically you can use createComponent method to specify how paginator in this example interacts with widget and with state.\nThe core of this approach is x declared in closure, which has various methods for adding callbacks into State methods, that HostMixin will ensure to call.\nIf anyone is interested I can provide a running example.",
                "createdAt": "2022-02-13T09:52:32Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "Interesting! How would you do an AnimationController that syncs both duration and vsync? Multiple calls to  x.onWidgetUpdate?",
                "createdAt": "2022-02-13T18:12:42Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "What I like is the optionality here, and the way it serves the common use case nicely. In most cases, you don't need to sync, so you could just have\n// renamed Component to Prop, just for fun\nlate final _anim = addProp(AnimationProp(duration: 1.seconds, vsync: this));\nAnd this will take care of setup/teardown/rebuilds (the 90% use cases, ymmv).\nBut then if you do need hooks, you can wire them in:\nlate final _anim = addProp(AnimationProp(duration: widget.duration, vsync: widget.vsync), (prop){\n  prop.onWidgetUpdate((w) => w.duration, prop.instance.duration); // register duration sync\n  prop.onWidgetUpdate((w) => w.vsync, prop.instance.vsync); // register vsync sync\n  // etc\n});\nI guess onWidgetUpdate would already be memoizing it's inputs?\nIt's not as bullet-proof as hooks in terms of always rebuilding when a dep changes, you still do have to manually add one line, for each external prop, lest it get stale. But it brings other benefits,\n\nimproved readability, more dart-like and familiar\nyou can keep initState and StatefulWidgets\nmore robust, there are not really any \"rules\" to follow\naccess to oop composition/inheritence patterns (as opposed to pure functional)\n\nTake all together, definitely a significant step up from current approach of manually overriding 2 different methods as well as managing setup, teardown, and rebuilds all within the State. And seems fairly non-invasive from an architectural standpoint.",
                "createdAt": "2022-02-13T18:36:26Z"
            },
            {
                "author": "MisterLight",
                "bodyText": "Any news about this?",
                "createdAt": "2022-07-06T18:08:24Z"
            },
            {
                "author": "Hixie",
                "bodyText": "This is one of the main motivators for the long-term Dart static metaprogramming macros effort. dart-lang/language#1482",
                "createdAt": "2022-07-06T18:33:29Z"
            },
            {
                "author": "jyardin",
                "bodyText": "I was playing a bit with this subject, and found a somewhat hacky way to have a smoother syntax for chaining builders.\nYou could override an operator (let's say >>) that accept a lambda as its argument. That would kind of mimic the Kotlin's trailing lambda syntax.\nThis makes chaining builders a bit simpler, with less nesting.\nThe first post example could be rewriten like this:\nclass SimpleExample extends StatelessWidget {\n  @override\n  Widget build(BuildContext context)\n    => withTextEditingController() >> (context, controller1)\n    => withTextEditingController() >> (context, controller2) {\n      return Column(\n        children: <Widget>[\n          TextField(controller: controller1),\n          TextField(controller: controller2),\n        ],\n      );\n    };\n}\nOf course, it's a custom formatting, as dart formatter would add more indent.\nThis is not a suggestion for a lib or a new syntax as it's a bit hacky, I just found it interesting and I thought it might fuel the discussion here.\nFull example is here.",
                "createdAt": "2022-07-06T19:05:31Z"
            },
            {
                "author": "rrousselGit",
                "bodyText": "This is one of the main motivators for the long-term Dart static metaprogramming macros effort. dart-lang/language#1482\n\nBut expression macros  dart-lang/language#1874 (which would be needed for this) are not part of the scope of the static metaprogramming proposal\nSo the current static metaprogramming proposal doesn't solve this problem",
                "createdAt": "2022-07-06T19:17:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "One step at a time. :-)",
                "createdAt": "2022-07-06T19:35:58Z"
            },
            {
                "author": "gaaclarke",
                "bodyText": "If I may suggest something I don't think has been suggested.  Adding one more extra layer of indirection by making a State that can manage multiple states at runtime can remove the duplication:\nclass MyBuilderDecorator<T> {\n  MyBuilderDecorator({required this.name, required this.init, required this.dispose});\n  final String name;\n  final T Function() init;\n  final void Function(T) dispose;\n}\n\nclass MyBuilder extends StatefulWidget {\n  const MyBuilder({Key? key, required this.builder, required this.decorators})\n      : super(key: key);\n\n  final Widget Function(BuildContext, Map<String, Object>) builder;\n  final List<MyBuilderDecorator> decorators;\n\n  @override\n  MyBuilderState createState() => MyBuilderState();\n}\n\nclass MyBuilderState extends State<MyBuilder> {\n  late TextEditingController textEditingController;\n  Map<String, Object> resources = {};\n\n  @override\n  void initState() {\n    super.initState();\n    for (MyBuilderDecorator decorator in widget.decorators) {\n      resources[decorator.name] = decorator.init();\n    }\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    for (MyBuilderDecorator decorator in widget.decorators) {\n      properties\n          .add(DiagnosticsProperty(decorator.name, resources[decorator.name]));\n    }\n  }\n\n  @override\n  void dispose() {\n    for (MyBuilderDecorator decorator in widget.decorators) {\n      decorator.dispose(resources[decorator.name]!);\n    }\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return widget.builder(context, resources);\n  }\n}\n\nclass Example extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MyBuilder(\n      decorators: [\n        MyBuilderDecorator(\n            name: 'controller1',\n            init: () => TextEditingController(text: 'Hello world'),\n            dispose: (x) => x.dispose()),\n        MyBuilderDecorator(\n            name: 'controller2',\n            init: () => TextEditingController(text: 'Hello world'),\n            dispose: (x) => x.dispose()),\n      ],\n      builder: (context, resources) {\n        return Column(\n          children: <Widget>[\n            TextField(\n                controller: resources['controller1'] as TextEditingController),\n            TextField(\n                controller: resources['controller2'] as TextEditingController),\n          ],\n        );\n      },\n    );\n  }\n}\nThe drawback is that there is information that would be nice to validate at compile-time but we are validating it at runtime (the names of the resources must match creation and retrieval and the type of the resource).  The benefit is that you aren't bloating the State and Element trees, you are removing the duplication and you don't have crazy levels of indentation.\nYou could even remove the duplication even further by factoring out functions that return MyBuilderDecorator instances as well.",
                "createdAt": "2022-07-22T18:02:11Z"
            },
            {
                "author": "bouraine",
                "bodyText": "This is one of the main motivators for the long-term Dart static metaprogramming macros effort. dart-lang/language#1482\n\nIn which way do you thing static meta programming will solve elegantly this issue ?",
                "createdAt": "2022-09-27T01:00:35Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@bouraine That remains to be seen. In general though the goal is to allow for something that's a cross between Lisp templates and code generation, which would potentially enable some interesting ways to reduce the boilerplate.",
                "createdAt": "2022-10-20T21:25:26Z"
            },
            {
                "author": "esDotDev",
                "bodyText": "fwiw, my stateful_props is at 1.0 and addresses some of these problems.\nhttps://pub.dev/packages/stateful_props\nIt doesn't deal with changing dependencies as well as hooks, but it does mostly solve the issue with redundant logic across state. I ended up taking a similar approach to reactives which seems to have been discontinued.",
                "createdAt": "2022-12-05T02:59:10Z"
            }
        ],
        "commentCount": 512
    },
    {
        "number": 100522,
        "title": "Screen flickering on iOS since Flutter 2.10.0",
        "author": "Jamesholy",
        "state": "CLOSED",
        "createdAt": "2022-03-22T02:41:25Z",
        "closedAt": "2023-03-21T15:50:42Z",
        "comments": [
            {
                "author": "danagbemava-nc",
                "bodyText": "Hi @sy5075391, can you upgrade to stable 2.10.3 to see if you still experience this issue?\nIf you do, please provide the updated flutter doctor -v as well as a complete minimal reproducible code sample that we can use to replicate this.\nThank you",
                "createdAt": "2022-03-22T07:33:49Z"
            },
            {
                "author": "fbcouch",
                "bodyText": "@sy5075391 If you have a reproducible example of this, I would love to take a look at it. We have a handful of reports of a similar flickering in our production app. Unfortunately, I haven't been able to reproduce it myself, and we've only gotten like 4 reports over the course of 2 months. Still, it would be nice to figure out. Here's what it looks like for us (very similar\u2013I added the black box just to obscure personal details from the user):\n\n\n  \nWe're still on a 2.10.2-based version, so I'll see about updating to 2.10.3 as well (we have a few extra crash fixes and undo support built in). This PR in 2.10.3 seems like the most likely thing to be relevant: flutter/engine#31656\nWe've only seen this on iOS (15.2.1 and 15.3.1), but not iPadOS.\nHere's the flutter doctor -v from our build agent:\n[\u2713] Flutter (Channel feature/scribble+2.10.2, 2.10.3-0.0.pre.1, on macOS 11.6.3 20G415 darwin-x64, locale en-US)\n    \u2022 Flutter version 2.10.3-0.0.pre.1 at /Users/build/flutter\n    \u2022 Upstream repository git@github.com:twinsunllc/flutter.git\n    \u2022 Framework revision 197aeac420 (3 months ago), 2021-12-14 16:29:34 -0600\n    \u2022 Engine revision a83ed0e5e3\n    \u2022 Dart version 2.16.1\n    \u2022 DevTools version 2.9.2\n\n[!] Android toolchain - develop for Android devices (Android SDK version 30.0.2)\n    \u2022 Android SDK at /Users/build/Library/Android/sdk\n    \u2717 cmdline-tools component is missing\n      Run `path/to/sdkmanager --install \"cmdline-tools;latest\"`\n      See https://developer.android.com/studio/command-line for more details.\n    \u2717 Android license status unknown.\n      Run `flutter doctor --android-licenses` to accept the SDK licenses.\n      See https://flutter.dev/docs/get-started/install/macos#android-setup for more details.\n\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.2)\n    \u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n    \u2022 CocoaPods version 1.11.2\n\n[\u2713] Chrome - develop for the web\n    \u2022 Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome\n\n[\u2713] Android Studio (version 2020.3)\n    \u2022 Android Studio at /Applications/Android Studio.app/Contents\n    \u2022 Flutter plugin can be installed from:\n      \ud83d\udd28 https://plugins.jetbrains.com/plugin/9212-flutter\n    \u2022 Dart plugin can be installed from:\n      \ud83d\udd28 https://plugins.jetbrains.com/plugin/6351-dart\n    \u2022 Java version OpenJDK Runtime Environment (build 11.0.10+0-b96-7281165)\n\n[\u2713] Connected device (1 available)\n    \u2022 Chrome (web) \u2022 chrome \u2022 web-javascript \u2022 Google Chrome 99.0.4844.83\n\n[\u2713] HTTP Host Availability\n    \u2022 All required HTTP hosts are available\n\nOur current engine version (3 commits ahead of 2.10.2): https://github.com/twinsunllc/engine/commits/2.10.2+fixes",
                "createdAt": "2022-03-24T18:46:51Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Facing same issue on iOS v15.2.1. Getting similar flickering consistently while using app.\n[\u2713] Flutter (Channel stable, 2.10.3, on macOS 12.0.1 21A559 darwin-arm, locale en-IN)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.2)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.3)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.1)\n[\u2713] IntelliJ IDEA Ultimate Edition (version 2020.3.3)\n[\u2713] Connected device (2 available)\n[\u2713] HTTP Host Availability",
                "createdAt": "2022-03-31T11:09:26Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Hi @abdulrehmank7, can you provide a complete minimal reproducible code sample?",
                "createdAt": "2022-03-31T11:10:29Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Hi @abdulrehmank7, can you provide a complete minimal reproducible code sample?\n\nThe issue happens randomly. We cannot isolate and replicate the bug.\nMy hunch is that, this is related to latest Xcode release. In that update we were forced to disable Bitcode as the app was crashing on iOS v13 device. In Xcode official changelog, they said to disable Bitcode to fix the bug. After disabling Bitcode we are seeing the flickering issue regularly.",
                "createdAt": "2022-03-31T11:40:19Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Without a reproducible sample, it's going to be difficult for us to act on this issue",
                "createdAt": "2022-03-31T12:13:27Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Without a reproducible sample, it's going to be difficult for us to act on this issue\n\nNot sure how can help you here. But definitely more people will report this issue soon.",
                "createdAt": "2022-03-31T12:22:15Z"
            },
            {
                "author": "fbcouch",
                "bodyText": "@abdulrehmank7 That's interesting...we also have bitcode disabled...I tried to enable it recently and had issues linking with our custom engine, unfortunately. That would be really strange if that's the issue, but who knows...\nI assume your app is not open source, so I can't test it out myself, but are you able to see the issue yourself with any reasonable frequency? (We've only had reports from customers, unfortunately, haven't been able to see the issue ourselves).\nI'm hopeful that it will kinda just go away in a future release...if you're able to make it happen at all, it might be worth testing out the beta and master branches...my hunch is that it's a skia issue (or related to flutter and skia interacting). I just patched in a skia commit to our latest custom engine build to fix a relatively infrequent crash down in the GrMtlCommandBuffer when there's an error submitting the buffer or something...I'm hoping that just fixes the flashing issue too \ud83e\udd37\u200d\u2642\ufe0f",
                "createdAt": "2022-03-31T14:44:19Z"
            },
            {
                "author": "fbcouch",
                "bodyText": "An update here \u2013 unfortunately we're still having reports of the issue on our latest build (based on flutter 2.10.4)",
                "createdAt": "2022-04-01T20:55:50Z"
            },
            {
                "author": "akindone",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3. The issue happens randomly. the device is iOS 15.0.1. This page has a webview which is not flickering, but the appbar is flickering",
                "createdAt": "2022-04-06T09:54:28Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Hi @akindone, can you provide a small sample that reproduces the issue?",
                "createdAt": "2022-04-06T10:05:47Z"
            },
            {
                "author": "akindone",
                "bodyText": "Hi @akindone, can you provide a small sample that reproduces the issue?\n\nI will provide a sample if I can reproduce this issue",
                "createdAt": "2022-04-06T10:11:19Z"
            },
            {
                "author": "henrychiu",
                "bodyText": "I have experienced the same problem (both IOS and Android) in two of my apps since the upgrade from 2.8 to 2.10.  But the issue happens randomly. so far I cannot isolate and replicate the bug. It happens when the screen either has a lot of images or playing video.",
                "createdAt": "2022-04-12T09:32:32Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "If anyone else is experiencing this issue, kindly upvote the initial comment on this issue. We would also appreciate it if any\nof you experiencing this issue can provide a sample so that we can verify this.\nKeeping this issue open to track future reports of the same issue.\nBased on what I've gathered:\n\nThis issue is on both android and iOS #100522 (comment)\nIt doesn't seem to affect platform views #100522 (comment)\nIts occurrence is sporadic and there isn't a clear way to isolate the issue\nAll reports seem to indicate this happening after upgrading to flutter 2.10\n\nOnce again, if anyone is able to reproduce and isolate the cause, kindly provide a sample so that we can investigate this.\nLabeling for visibilty",
                "createdAt": "2022-04-12T13:30:17Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@knopp @iskakaushik does this look related to DRM?",
                "createdAt": "2022-04-13T21:51:58Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Removing priority so that this will surface in Engine triage.",
                "createdAt": "2022-04-13T21:52:18Z"
            },
            {
                "author": "knopp",
                "bodyText": "I looks like it might be related to partial repaint (one of the back buffers seem to be having invalid content), but it's also quite strange that most of these videos are showing static scene without any animation and yet the screen keeps repainting.\nA reproducible example would be great to have.\nAlso, if it happens, does it get fixed by scrolling (or similar action that triggers repaint of large portion of screen)?",
                "createdAt": "2022-04-13T22:21:55Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "I looks like it might be related to partial repaint (one of the back buffers seem to be having invalid content), but it's also quite strange that most of these videos are showing static scene without any animation and yet the screen keeps repainting.\nA reproducible example would be great to have.\nAlso, if it happens, does it get fixed by scrolling (or similar action that triggers repaint of large portion of screen)?\n\nI reported this flicker above for our app. The screen is having video player and even on changing tabs and scrolling, the issue persists.",
                "createdAt": "2022-04-14T09:03:38Z"
            },
            {
                "author": "jveryspace",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3 (IOS)",
                "createdAt": "2022-04-15T11:13:09Z"
            },
            {
                "author": "knopp",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3 (IOS)\n\nDo you have any video player in your app? (or anything else using external textures)?",
                "createdAt": "2022-04-15T11:17:11Z"
            },
            {
                "author": "jveryspace",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3 (IOS)\n\nDo you have any video player in your app? (or anything else using external textures)?\n\nHave a WebView with size(0, 0)",
                "createdAt": "2022-04-15T11:21:51Z"
            },
            {
                "author": "knopp",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3 (IOS)\n\nDo you have any video player in your app? (or anything else using external textures)?\n\nHave a WebView with size(0, 0)\n\nIs it consistently reproducible? Also partial repaint should be disable with platform views present.",
                "createdAt": "2022-04-15T11:24:25Z"
            },
            {
                "author": "jveryspace",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3 (IOS)\n\nDo you have any video player in your app? (or anything else using external textures)?\n\nHave a WebView with size(0, 0)\n\nIs it consistently reproducible? Also partial repaint should be disable with platform views present.\n\nThe issue happens randomly. Thank you.",
                "createdAt": "2022-04-15T11:34:22Z"
            },
            {
                "author": "EArminjon",
                "bodyText": "Need reproductible code. Got a similar problem but was code related.",
                "createdAt": "2022-04-18T07:15:50Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "Since there is no sample reproducible test case yet, perhaps we need a flag exposed to toggle partial repaint. Even if its on a branch off of 2.10.3, we could build custom engines to see if users can reproduce this issue.\nMarking this as a P2 as the regression seems pretty serious.",
                "createdAt": "2022-04-18T17:42:14Z"
            },
            {
                "author": "akindone",
                "bodyText": "Hi @akindone, can you provide a small sample that reproduces the issue?\n\nthis flutter_flickering_issue_sample reproduces this issue.",
                "createdAt": "2022-04-19T07:32:28Z"
            },
            {
                "author": "knopp",
                "bodyText": "@akindone, thank you for the sample! I've been able to reproduce this on stable, but not on master, which would seem that maybe some of the PRs were not cherry-picked.",
                "createdAt": "2022-04-19T08:27:21Z"
            },
            {
                "author": "intelryzen",
                "bodyText": "The symptom is an occasional issue and occurred when I swiped the iPhone home bar up. If symptoms occur, the app must be forced to shut down.",
                "createdAt": "2022-04-20T10:28:24Z"
            },
            {
                "author": "knopp",
                "bodyText": "@intelryzen, can you reproduce this with current master?",
                "createdAt": "2022-04-20T10:45:38Z"
            },
            {
                "author": "fbcouch",
                "bodyText": "Hi @akindone, can you provide a small sample that reproduces the issue?\n\nthis flutter_flickering_issue_sample reproduces this issue.\nRPReplay_Final1650350856.MP4\n\nThanks for providing this...that definitely looks like an issue...how sure are you that this is the same issue as the others? The flickering there seems far less pronounced than in the other videos posted where the entire screen flickers between completely black and normal painting. That said, I am definitely hopeful that it's the same, so that it will be fixed from changes already on master \ud83d\ude04",
                "createdAt": "2022-04-20T14:46:51Z"
            },
            {
                "author": "akindone",
                "bodyText": "Hi @akindone, can you provide a small sample that reproduces the issue?\n\nthis flutter_flickering_issue_sample reproduces this issue.\nRPReplay_Final1650350856.MP4\n\nThanks for providing this...that definitely looks like an issue...how sure are you that this is the same issue as the others? The flickering there seems far less pronounced than in the other videos posted where the entire screen flickers between completely black and normal painting. That said, I am definitely hopeful that it's the same, so that it will be fixed from changes already on master \ud83d\ude04\n\nI am not sure actually. If I can reproduce the entire screen flickers issue, I will post sample code here.",
                "createdAt": "2022-04-21T06:42:09Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "I believe @akindone s issues is unrelated to the full screen flickering reported here.\nPerhaps we can also get timeline traces of instances where the flickering happens. Not sure we dump partial repaint related trace events to the timeline but those might be good to add anyway.",
                "createdAt": "2022-04-25T17:46:54Z"
            },
            {
                "author": "Szymon-Gesicki",
                "bodyText": "Hi, I have the same problem and I managed to catch it in debug. When apllication enters the \"flickering\" state I started getting thousands of logs:\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n7666\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nflutter: FLUTTER_LOGGER DEBUG - Session synchronization tick\n1574\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n1848\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n5951\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n3199\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n\nI use flutter 2.10.5",
                "createdAt": "2022-04-26T11:38:04Z"
            },
            {
                "author": "knopp",
                "bodyText": "This doesn't seem to be related to partial repaint, at least not directly. But if even one frame fails to rasterize like this it will cause flicker when flipping buffers since one of the buffers will have stale data.",
                "createdAt": "2022-04-26T11:45:46Z"
            },
            {
                "author": "cijianzy",
                "bodyText": "when flickering, there is some logs maybe can help deal with this problem.\nI use flutter 2.10\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)",
                "createdAt": "2022-04-29T13:19:13Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@knopp Is there a more graceful way to recover if a frame fails to render?",
                "createdAt": "2022-04-29T14:48:59Z"
            },
            {
                "author": "knopp",
                "bodyText": "I'm not sure, but why does it matter? Are these errors to be expected?",
                "createdAt": "2022-04-29T17:13:52Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "I agree with @knopp that the errors are not expected. We recently wired up enhanced command buffer debugger in a different renderer. I wonder if the Skia renderer command buffers have similar instrumentation in place. Usually, by the time you see \"for causing prior/excessive GPU errors\" in the logs the instigating failure has happened a long time ago and we need the first instance of the failure.",
                "createdAt": "2022-05-02T17:43:57Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "@knopp What made use suspect it was partial repaint was that this happening on both iOS and Android. But it could totally be something rendering related on all backends.",
                "createdAt": "2022-05-02T17:45:01Z"
            },
            {
                "author": "mateusfccp",
                "bodyText": "Some clients also reported this in our production app, but we couldn't reproduce it locally. Until now, we only got occurrences from iOS.",
                "createdAt": "2022-05-04T13:08:46Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "Are any of these issues happening only on an iPhone 13 (with ProMotion displays) and/or with a platform view in the scene? We still need additional information about how and when this happens. The following would be good to know:\n\nDoes this happen on iOS or Android or both?\nDoes the application have a platform view in the scene when this happens?\nDoes this happen on devices with higher refresh rates?",
                "createdAt": "2022-05-09T17:49:15Z"
            },
            {
                "author": "intelryzen",
                "bodyText": "In my case, it only happened on the iPhone. This has happened not only in debugging but also in released apps. My iPhone model is iPhone XS MAX and it occurs from the flutter version 2.10.0 or higher. It always happens suddenly when the iPhone home bar is swiped upward. I'm sorry, but I can't provide you with the video. It also occurs too in static app (pages), regardless of whether the app is refreshed or not.",
                "createdAt": "2022-05-09T21:13:12Z"
            },
            {
                "author": "feinstein",
                "bodyText": "We just got one report about this, on an iPhone 12 mini. The screen didn't have a platform view.",
                "createdAt": "2022-05-09T23:18:44Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "I\u2019m also facing this issue randomly. We\u2019re still on the beta-testing phase but this only happens on iOS. We had reports happening on iPhone 12 so no ProMotion.\nI\u2019m not able to reproduce it but it seems it starts when trying to exit the app when dragging the white bar.\nWhen the app enters on this flickering state it\u2019s unresponsive and you have to force quit.",
                "createdAt": "2022-05-10T07:07:08Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Are any of these issues happening only on an iPhone 13 (with ProMotion displays) and/or with a platform view in the scene? We still need additional information about how and when this happens. The following would be good to know:\n\nDoes this happen on iOS or Android or both?\n\n\nAFAIK only iOS\n\n\nDoes the application have a platform view in the scene when this happens?\n\n\nNo\n\n\nDoes this happen on devices with higher refresh rates?\n\n\nNo, in fact we didn\u2019t have any report from users with ProMotion displays.",
                "createdAt": "2022-05-10T07:29:10Z"
            },
            {
                "author": "Cellaryllis",
                "bodyText": "Does this happen on iOS or Android or both?\nWe only have reports on IOS.\nDoes the application have a platform view in the scene when this happens?\nIf you mean native widgets, no not that we're aware of.\nDoes this happen on devices with higher refresh rates?\nI can't confirm as we're not sure which devices it appears on. Only device we have confirmed is iPhone 11.\n\n\nWe have two videos of it happenening on our public bug tracker:\nhttps://apparyllis.atlassian.net/browse/SP-2292\nhttps://apparyllis.atlassian.net/browse/SP-2307\nVideo urls: https://cdn.discordapp.com/attachments/812607019504500736/969226148380831834/RPReplay_Final1651151902.mp4\nhttps://cdn.discordapp.com/attachments/861623218481397761/954466867123212308/RPReplay_Final1647632965.mp4\nWe can get more information on the affected users if wanted, and possibly more videos.",
                "createdAt": "2022-05-10T08:10:02Z"
            },
            {
                "author": "skindhu",
                "bodyText": "mark",
                "createdAt": "2022-05-10T12:07:43Z"
            },
            {
                "author": "lvfen",
                "bodyText": "mark",
                "createdAt": "2022-05-10T12:09:50Z"
            },
            {
                "author": "feinstein",
                "bodyText": "I\u2019m also facing this issue randomly. We\u2019re still on the beta-testing phase but this only happens on iOS. We had reports happening on iPhone 12 so no ProMotion.\nI\u2019m not able to reproduce it but it seems it starts when trying to exit the app when dragging the white bar.\nWhen the app enters on this flickering state it\u2019s unresponsive and you have to force quit.\n\nThe user (an executive director of the company unfortunately) reported that he tried to swipe up the home bar to exit the app, but it didn't work, the whole screen was unresponsive.",
                "createdAt": "2022-05-10T13:42:45Z"
            },
            {
                "author": "fbcouch",
                "bodyText": "Does this happen on iOS or Android or both?\n\n\nSo far, we only have reports on iOS, for the following devices:\niPhone10,3 (iPhone X)\niPhone10,6 (iPhone X)\niPhone12,5 (iPhone 11 Pro Max)\nI think there was one report further up this thread on Android. So far, we haven't seen it there, but our userbase is highly slanted toward iOS.\n\n\nDoes the application have a platform view in the scene when this happens?\n\n\nNot that I'm aware of.",
                "createdAt": "2022-05-10T14:28:10Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Don't know if this helps, but my Android Crashlytics reports 99.9% stability, while the iOS is at 96%.\nThe reports are usually very low level, indicating pthreads or kernel errors, if you want I can try to post some here, I don't know if they are related with this issue though.\nAll my native code is shared with other apps that have much higher iOS stability metrics and don't use Flutter, so I don't think the reports are related with our native code.\nSince we updated Flutter lots of iOS issues disappeared from Crashlytics, but others, like the one reported here, surfaced.\nLet me know if we can help with something else.",
                "createdAt": "2022-05-10T14:48:28Z"
            },
            {
                "author": "zanderso",
                "bodyText": "The reports are usually very low level, indicating pthreads or kernel errors, if you want I can try to post some here, I don't know if they are related with this issue though.\n\nCrash reports from the field are usually not actionable by the team without an example that can be run locally to reproduce the crash. They'd also go in a new issue so we can triage them separately.\n\nreported that he tried to swipe up the home bar to exit the app.\n\nThanks for this. We'll try to repro, but it would also be useful to know what was happening in the app at the time. Was there anything animating, or were there any platform views on the screen, etc.?",
                "createdAt": "2022-05-10T16:03:56Z"
            },
            {
                "author": "Cellaryllis",
                "bodyText": "Would it be beneficial if all of us, who are experiencing users with crashes, to list all installed packages? Perhaps we all have a common package that does have native widgets somewhere?",
                "createdAt": "2022-05-10T16:31:47Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Would it be beneficial if all of us, who are experiencing users with crashes, to list all installed packages? Perhaps we all have a common package that does have native widgets somewhere?\n\nWe recently added AdMob library to our app. Is that the case with all the user here?",
                "createdAt": "2022-05-11T05:20:20Z"
            },
            {
                "author": "Manuito83",
                "bodyText": "Nope. In my case I didn't change a single package when this started happening, and I don't use AdMob. I'm being reported the exactly the same behaviour by some users on iOS, to the point that the app becomes unusable. Sadly, I've also been unable to reproduce this locally or to identify why it's only happening to some specific users.",
                "createdAt": "2022-05-11T06:22:41Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Thanks for this. We'll try to repro, but it would also be useful to know what was happening in the app at the time. Was there anything animating, or were there any platform views on the screen, etc.?\n\nMy app is a stock trading app, so we make heavy use of websockets (and I suspect that's where some of the other crashes are coming from). The screen that presented the flickering is the first screen we open after login, which shows the user's balance, gains/losses and stock portfolio in real time.\nThere are no platform views, but we have some animations. There are loading animations using the shimmer package and also the text animates as the values change, like changes in text color (green to red and vice versa).\nIt's good to mention that in this screen we have a bottom navigation bar with 3 other screens. They are behind the portfolio screen, not visible but active, so it's really fast for the users to switch screens. They would have text, custom paint, images, slivers, animated widgets and styles, but no platform views.\nAlso, we don't use AdMob in the app.",
                "createdAt": "2022-05-12T00:24:04Z"
            },
            {
                "author": "intelryzen",
                "bodyText": "Thanks for this. We'll try to repro, but it would also be useful to know what was happening in the app at the time. Was there anything animating, or were there any platform views on the screen, etc.?\n\nMy app is a stock trading app, so we make heavy use of websockets (and I suspect that's where some of the other crashes are coming from). The screen that presented the flickering is the first screen we open after login, which shows the user's balance, gains/losses and stock portfolio in real time.\nThere are no platform views, but we have some animations. There are loading animations using the shimmer package and also the text animates as the values change, like changes in text color (green to red and vice versa).\nIt's good to mention that in this screen we have a bottom navigation bar with 3 other screens. They are behind the portfolio screen, not visible but active, so it's really fast for the users to switch screens. They would have text, custom paint, images, slivers, animated widgets and styles, but no platform views.\nAlso, we don't use AdMob in the app.\n\nI had this bug several times a day in Flutter 2.10.3. However, this problem no longer appeared after I updated Flutter to 3.0.",
                "createdAt": "2022-05-16T15:22:56Z"
            },
            {
                "author": "boichuk-oleh",
                "bodyText": "In my case, this bug is reproduced in Flutter 3.0.0 (iOS).\nLog: Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)",
                "createdAt": "2022-05-17T12:04:23Z"
            },
            {
                "author": "zanderso",
                "bodyText": "At triage @chinmaygarde mentioned going over the reports to try to find common elements, so assigning this to him.",
                "createdAt": "2022-05-17T23:07:41Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "\u5c31\u6211\u800c\u8a00\uff0c\u8fd9\u4e2a\u9519\u8bef\u5728 Flutter 3.0.0 (iOS) \u4e2d\u91cd\u73b0\u3002 \u65e5\u5fd7\uff1a\u7531\u4e8e\u6267\u884c\u8fc7\u7a0b\u4e2d\u7684\u9519\u8bef\uff0c\u547d\u4ee4\u7f13\u51b2\u533a\u7684\u6267\u884c\u88ab\u4e2d\u6b62\u3002\u5ffd\u7565\uff08\u7528\u4e8e\u5bfc\u81f4\u5148\u524d/\u8fc7\u591a\u7684 GPU \u9519\u8bef\uff09\uff0800000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored\uff09\n\nHas it happened many times? I haven't dared to upgrade. It's still 2.5.3.",
                "createdAt": "2022-05-18T00:22:21Z"
            },
            {
                "author": "Albert221",
                "bodyText": "Also happens in our app (Flutter 2.10.5). Whole Flutter screen is blinking/flickering/strobing.\nThe native overlay (like time, battery and native push notification popup) don't flicker and responds to gestures normally.\nSome of the affected devices were:\n\niPhone 12, iOS 15.5\niPhone 12 mini, iOS 15.4.1",
                "createdAt": "2022-05-18T10:56:16Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Got the same on iPhone 13 pro max, ios 15.4.1, Flutter 2.10.5, Xcode 13.4\nOnly saw it once installed from TestFlight, never saw during development, even in release builds.\nWe are using platform views on this screen. Not sure if it's related.\n[\u2713] Flutter (Channel stable, 2.10.5, on macOS 12.0.1 21A559 darwin-arm, locale en-US) [\u2713] Android toolchain - develop for Android devices (Android SDK version 31.0.0) [\u2713] Xcode - develop for iOS and macOS (Xcode 13.4) [\u2713] Chrome - develop for the web [\u2713] Android Studio (version 2021.1) [\u2713] IntelliJ IDEA Ultimate Edition (version 2021.3) [\u2713] VS Code (version 1.67.2) [\u2713] Connected device (4 available) [\u2713] HTTP Host Availability",
                "createdAt": "2022-05-20T15:44:10Z"
            },
            {
                "author": "zanderso",
                "bodyText": "We have not been able to reproduce this locally. Trying to summarize what is known so far:\n\nStarted in 2.10.0, and still occurs in 3.0.0\nSeveral iOS 15 versions\nA range of iPhone devices\nSeems to be triggered by swiping up\nPlatform views do not flicker\nSome reports that having bitcode disabled may be relevant\n\nIf anyone who is able to reproduce this locally would be willing to bisect on the flutter/flutter commits in 2.10.0, that would be very helpful. The flutter/flutter commit range is from: fb1f8b0 to 95e5553 on the master branch.\n$ git log --oneline fb1f8b0e38c9c34d6a1c4072288d1ea45af2bc50..95e555344dc746ad46ada9de9cc475042c63ec55 | wc -l\n621\n\nso there should be no more than 10 versions to try. If that narrows things down to an Engine roll, we can then bisect on the Engine commits in the roll or just eyeball it.\n@fbcouch @abdulrehmank7 (and anyone else) - If you haven't already, could you file a separate issue about the trouble you encountered with bitcode and cc me and @jmagman?",
                "createdAt": "2022-05-20T16:06:32Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "@zanderso I'd add that this is only on production builds. Archive, upload to TestFlight, install. Never saw it installing from xcode or flutter run, even in release.",
                "createdAt": "2022-05-20T16:27:07Z"
            },
            {
                "author": "feinstein",
                "bodyText": "@zanderso I got more details from the user. He said he was using the app normally and then he blocked the screen. 10 minutes later the unlocked the phone and the app was frozen, unresponsive, he couldn't do anything.\nThen he tried several gestures and got to minimize the app. When he came back to the app, the app was flickering.\nHe's using our release version from the App Store, not TestFlight.",
                "createdAt": "2022-05-20T17:31:22Z"
            },
            {
                "author": "Brazol",
                "bodyText": "Also happened in our app multiple times (Flutter version 2.10.x, iPhones 12 and 13). It's hard to reproduce, it's definitely not deterministic, but I did manage to repro it locally.\nThis one is from prod build and as you can see it happened when typing, the app thinks the keyboard is there (there is space for it and the app behaves like it is shown) but it's not visible.\n\n\n  \nThis one happened locally and it checks that platform views don't flicker (those are iframes in WebView). Generally, the app is not responding when it happens but this time I could scroll, kind of. I got lots of Execution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error iOS native errors on console then.\n\n\n  \nAlso in some cases after a few seconds of the flickering app just crashes.",
                "createdAt": "2022-05-23T14:57:42Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@Brazol if you are able to reproduce this issue with a locally built app, then it would be very helpful if you could bisect on the new commits in the 2.10.0 release. The commits on the master channel are given above in #100522 (comment). Thanks!",
                "createdAt": "2022-05-23T15:31:40Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Hope to get attention, this is very important to us",
                "createdAt": "2022-05-23T23:46:16Z"
            },
            {
                "author": "feinstein",
                "bodyText": "The Flutter team prioritizes based on how many  thumbs up (\ud83d\udc4d\ud83c\udffb) the issue has (the first comment).\nComments like \"me too\" don't add information and just pollute the thread, if you want this to get more attention, just give the first comment a \"\ud83d\udc4d\ud83c\udffb\" (although it hardly will as this is already very high priority).",
                "createdAt": "2022-05-24T00:16:48Z"
            },
            {
                "author": "mazzonem",
                "bodyText": "If it helps, I can confirm this is happening with Flutter 3.0.1 too. Same as above, production builds.",
                "createdAt": "2022-05-24T09:12:43Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi all. Since we haven't been able to reproduce this locally, we really, really need more help with this one. Please get in touch with me on discord either if this happens for you locally on flutter run and you can help do a bisect, or if this happens from TestFlight and you can patch/build your own Engine. Thanks!",
                "createdAt": "2022-05-24T23:25:14Z"
            },
            {
                "author": "karelric",
                "bodyText": "I am having same issue with Flutter 2.10.3 and an iPhone 12 PRO Max.",
                "createdAt": "2022-05-25T11:58:51Z"
            },
            {
                "author": "feinstein",
                "bodyText": "The same user reported he saw the flickering again after opening the app and receiving a notification. But he wasn't 100% sure.",
                "createdAt": "2022-05-25T15:48:55Z"
            },
            {
                "author": "wupengbigMarker",
                "bodyText": "I got this issue on iPhone 11, iOS 15.4.1 with Flutter 2.10.5 too. It happens when app stays in background for a long time without terminate, then you open the app, it will show the flickering screen. After clicked the page, it will be normal. Actually, I reproduced this issue on iOS simulator when I ran code on it and just close my laptop . After serval hours, I opened the laptop. The simulator will happened like this. Here is basic info of flutter doctor:\n[\u2713] Flutter (Channel stable, 2.10.5, on macOS 11.6 20G165 darwin-x64, locale zh-Hans-CN)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.2.1)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 4.2)\n[\u2713] VS Code (version 1.67.2)",
                "createdAt": "2022-05-26T13:00:45Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Can you reproduce it regularly if you wait an amount of time in the background?",
                "createdAt": "2022-05-26T14:23:22Z"
            },
            {
                "author": "wangxiaodong1995",
                "bodyText": "App screen flickers and freezes, when I restart it, it goes away. it doesn't always happen.\nFacing same issue on iOS v15.4.1. Getting similar flickering consistently while using app.\n[\u2713] Flutter (Channel stable, 2.10.5, on macOS 12.3.1 21E258 darwin-x64, locale\nzh-Hans-CN)\n[!] Android toolchain - develop for Android devices (Android SDK version\n32.1.0-rc1)\n! Some Android licenses not accepted. To resolve this, run: flutter doctor\n--android-licenses\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.1)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.1)\n[\u2713] VS Code (version 1.51.0)\n[\u2713] Connected device (1 available)\n[\u2713] HTTP Host Availability",
                "createdAt": "2022-05-27T02:28:33Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Can you follow @zanderso comment above to help us narrow down when the bug was first introduced?",
                "createdAt": "2022-05-27T02:30:34Z"
            },
            {
                "author": "wupengbigMarker",
                "bodyText": "Can you reproduce it regularly if you wait an amount of time in the background?\n\nrandomly...",
                "createdAt": "2022-05-27T07:54:44Z"
            },
            {
                "author": "jonataslaw",
                "bodyText": "Update to Flutter 3, this problem is probably already solved, but it is present in version 2.10",
                "createdAt": "2022-05-27T13:16:31Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Update to Flutter 3, this problem is probably already solved, but it is present in version 2.10\n\nNo, I have also faced this in Flutter 3. It has the same behavior, it randomly pops up, and we are not able to use the app. We are able to see multiple screen overlapped while the screen is flickering.",
                "createdAt": "2022-05-27T13:31:37Z"
            },
            {
                "author": "tczesiu",
                "bodyText": "I have faced a new aspect of this issue. On production build, on iPhone, but from Test Flight my screen have started blinking but not all the widgets. The one that has not been not effected were \u201calive\u201d. I managed to tap or slide on it and blinking effect vanish on other widgets. No app restart have been required. iOS 15.5, iPhone 12 Pro.",
                "createdAt": "2022-05-29T06:31:18Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Were the widgets that didn't flicker Platform Views?",
                "createdAt": "2022-05-29T13:17:05Z"
            },
            {
                "author": "tczesiu",
                "bodyText": "Were the widgets that didn't flicker Platform Views?\n\nNo. I consider it is a flutter view, not a specyfic, native from  platform, view.",
                "createdAt": "2022-05-29T13:25:36Z"
            },
            {
                "author": "rivella50",
                "bodyText": "Update to Flutter 3, this problem is probably already solved, but it is present in version 2.10\n\nNo, I have also faced this in Flutter 3. It has the same behavior, it randomly pops up, and we are not able to use the app. We are able to see multiple screen overlapped while the screen is flickering.\n\nIt also happens here with Flutter 3.0.1",
                "createdAt": "2022-06-01T13:19:33Z"
            },
            {
                "author": "feinstein",
                "bodyText": "I think this issue's title should be updated since it's not related to a particular version anymore",
                "createdAt": "2022-06-01T15:46:37Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi all, we would love to work on fixing this, but we really need your help. Please see my comment here #100522 (comment).",
                "createdAt": "2022-06-01T16:11:15Z"
            },
            {
                "author": "wupengbigMarker",
                "bodyText": "Does anyone have any idea about how to fix this issue? My clients complaint this to me for serval times...",
                "createdAt": "2022-06-06T15:23:37Z"
            },
            {
                "author": "rivella50",
                "bodyText": "Does anyone have any idea about how to fix this issue? My clients complaint this to me for serval times...\n\nIf your clients can see a pattern (seems to happen quite often there) when flickering happens post it here so that the Flutter team can reproduce it and start working on this issue.",
                "createdAt": "2022-06-06T15:38:21Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Removed the waiting label as this issue is still active and we do not want the bot to close it",
                "createdAt": "2022-06-07T06:11:00Z"
            },
            {
                "author": "khang-dev",
                "bodyText": "I also got this issue on iPhone SE 2, iOS 15.5 with Flutter 2.10.5. It happens when app stays in background and then opening the app. My home screen mainly contain an IndexedStack and 4 children views inside (4 tabs).\n[\u2713]  Flutter (Channel stable, 2.10.5, on macOS 12.4 21F79 darwin-arm, locale en-VN)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.3)\n[\u2713] Android Studio (version 2021.2)\n[\u2713] VS Code (version 1.67.2)",
                "createdAt": "2022-06-15T11:49:42Z"
            },
            {
                "author": "ryzizub",
                "bodyText": "We faced same issue on Flutter 2.10.5, our home screen is mostly sliver lists with app bar. We have updated few days back to Flutter 3.0.2 and havent encoutered same issue yet. But it happens so randomly that I can't say it's thank to the update",
                "createdAt": "2022-06-15T11:56:11Z"
            },
            {
                "author": "rivella50",
                "bodyText": "We faced same issue on Flutter 2.10.5, our home screen is mostly sliver lists with app bar. We have updated few days back to Flutter 3.0.2 and havent encoutered same issue yet. But it happens so randomly that I can't say it's thank to the update\n\nWhen i check the release notes for version 3.0.2 i don't see any fix that could be in favor of getting rid of these flickerings. And in version 3.0.1 we still have seen that effect.",
                "createdAt": "2022-06-15T12:00:59Z"
            },
            {
                "author": "ShahyarTaheri",
                "bodyText": "This issue occurs only on iOS for me after the swipe up gesture from the bottom of the screen for switching the app. It results in the following error:\n\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\n\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n\n\nflutter doctor output:\n[\u2713] Flutter (Channel stable, 3.0.2, on macOS 12.2.1 21D62 darwin-arm, locale en-US)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4.1)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.1)\n[\u2713] VS Code (version 1.68.0)",
                "createdAt": "2022-06-16T19:54:40Z"
            },
            {
                "author": "marnberg",
                "bodyText": "Could this be related to #97910?",
                "createdAt": "2022-06-16T20:00:40Z"
            },
            {
                "author": "ShahyarTaheri",
                "bodyText": "#97910\n\nIt is related. The issue occurs quite often but the frequency is nonlinear. With the same sequence of interactions with the app, sometime it happens two times in a row and sometimes not at all. The flickering effect when screen freezes is similar to the videos other users posted in this issue. Once the UI freezes and flickering starts, I am still able to perform a hot reload which does not result in any UI updates. The resolution is always to restart the app.",
                "createdAt": "2022-06-16T20:11:51Z"
            },
            {
                "author": "chenqiang-ola",
                "bodyText": "We have multiple users reporting similar issues. In production builds, only on iPhone. It affects the user experience very much and we couldn't find a useful way to fix it. Currently ,only downgraded the flutter  to 2.2.3 and build to users.\nflutter doctor output:\n[\u2713] Flutter (Channel unknown, 2.10.5, on macOS 12.4 21F79 darwin-arm, locale\n    zh-Hans-CN)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 29.0.2)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.2)\n[\u2713] IntelliJ IDEA Community Edition (version 2020.2.3)\n[\u2713] VS Code (version 1.67.2)\n[\u2713] Connected device (1 available)\n\nUser-provided videos :",
                "createdAt": "2022-06-19T02:39:56Z"
            },
            {
                "author": "feinstein",
                "bodyText": "#97910\n\nIt is related. The issue occurs quite often but the frequency is nonlinear. With the same sequence of interactions with the app, sometime it happens two times in a row and sometimes not at all. The flickering effect when screen freezes is similar to the videos other users posted in this issue. Once the UI freezes and flickering starts, I am still able to perform a hot reload which does not result in any UI updates. The resolution is always to restart the app.\n\n@ShahyarTaheri since you can reproduce this regularly, could you help the Flutter team narrowing down which version of the engine that introduced this problem?\nIf yes, please take a look at this comment: #100522 (comment)",
                "createdAt": "2022-06-19T04:23:29Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Many of our user get this flickering when the app is in opened state and is in background.\nWhen they open the app from clicking notification, or they go back to the app manually, they see this flickering. Once flickering start the app is not responsive, it gets stuck, and we have to restart the app to fix the flickering.",
                "createdAt": "2022-06-19T09:20:03Z"
            },
            {
                "author": "knopp",
                "bodyText": "It would be immensely helpful if anyone could provide a sample project that can be used to reproduce this. It seems to be happening with a very specific circumstances and I so far was unable to reproduce the problem. Also please try posting detailed information about your app. Are there any platform views, video players (can you reproduce this without)? Are there images being loaded? Does this happen during scrolling / animation or also with completely static application? Are you using any native plugins?",
                "createdAt": "2022-06-19T13:36:58Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Many of our user get this flickering when the app is in opened state and is in background.\nWhen they open the app from clicking notification, or they go back to the app manually, they see this flickering. Once flickering start the app is not responsive, it gets stuck, and we have to restart the app to fix the flickering.\nRecordIt-1655561719.mp4\n\nMore and more customer are reporting this issue now. We are receiving 3-4 reports on daily basis. The issue mostly happens in release builds.\n\n\n  \nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel stable, 3.0.2, on macOS 12.0.1 21A559 darwin-arm, locale en-IN)                                                                                                     Checking Android licenses is taking an unexpectedly long time...[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.2)\n[!] Xcode - develop for iOS and macOS (Xcode 13.3.1)\n    ! CocoaPods 1.10.2 out of date (1.11.0 is recommended).\n        CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to your plugin usage on the Dart side.\n        Without CocoaPods, plugins will not work on iOS or macOS.\n        For more info, see https://flutter.dev/platform-plugins\n      To upgrade see https://guides.cocoapods.org/using/getting-started.html#installation for instructions.\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.2)\n[\u2713] IntelliJ IDEA Ultimate Edition (version 2020.3.3)\n[\u2713] Connected device (3 available)\n[\u2713] HTTP Host Availability",
                "createdAt": "2022-06-22T09:30:26Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Hi @abdulrehmank7, can you provide a reduced test case so that we can investigate this?",
                "createdAt": "2022-06-22T09:58:23Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "@abdulrehmank7 s issue looks different from the theme in this thread where there are Metal errors. That looks more like only a part of the screen updating (possibly due to dirty region management).",
                "createdAt": "2022-06-22T17:44:23Z"
            },
            {
                "author": "knopp",
                "bodyText": "@abdulrehmank7 s issue looks different from the theme in this thread where there are Metal errors. That looks more like only a part of the screen updating (possibly due to dirty region management).\n\nThe one video before from @abdulrehmank7 does look like it belongs here though. Also frame failing to rasterize (due to metal errors) and then sucessfully rasterizing modified part (the images that faded in) would look just like on video.\nSo maybe resterizing whole page (all thumbnails) resulted in metal errors, but then drawing only the 4 animated thumbnails didn't.",
                "createdAt": "2022-06-22T18:49:01Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "We have not been able to reproduce this locally. Trying to summarize what is known so far:\n\nStarted in 2.10.0, and still occurs in 3.0.0\nSeveral iOS 15 versions\nA range of iPhone devices\nSeems to be triggered by swiping up\nPlatform views do not flicker\nSome reports that having bitcode disabled may be relevant\n\nIf anyone who is able to reproduce this locally would be willing to bisect on the flutter/flutter commits in 2.10.0, that would be very helpful. The flutter/flutter commit range is from: fb1f8b0 to 95e5553 on the master branch.\n$ git log --oneline fb1f8b0e38c9c34d6a1c4072288d1ea45af2bc50..95e555344dc746ad46ada9de9cc475042c63ec55 | wc -l\n621\n\nso there should be no more than 10 versions to try. If that narrows things down to an Engine roll, we can then bisect on the Engine commits in the roll or just eyeball it.\n@fbcouch @abdulrehmank7 (and anyone else) - If you haven't already, could you file a separate issue about the trouble you encountered with bitcode and cc me and @jmagman?\n\nAlso, the issue is not related to bitcode status. Previously, we had bitcode disabled for our app. But now we have enabled it back and still we are facing the issue.",
                "createdAt": "2022-06-23T04:56:06Z"
            },
            {
                "author": "alexeylopukh-aloteq",
                "bodyText": "@zanderso Any updates? Already 3 months have passed. This is very critical because it is dangerous for epileptics.",
                "createdAt": "2022-06-23T07:29:36Z"
            },
            {
                "author": "zanderso",
                "bodyText": "I'm very sorry for the trouble, but since we have not been able to reproduce this issue, we need one or more people who do have a local reproduction to share their project and/or follow the steps that I had @knopp have outlined above.",
                "createdAt": "2022-06-23T15:34:24Z"
            },
            {
                "author": "ArmandoJimenezOS",
                "bodyText": "This happens for me when I open my release app the first time, then I try to slide up in iOS and go home, the phone freezes for a second, and it goes to home, when I go back to the app the flickering starts. Happens randomly and can't reproduce.",
                "createdAt": "2022-06-23T17:56:53Z"
            },
            {
                "author": "rivella50",
                "bodyText": "Has someone tried connecting an app with Crashlytics in order to record an error when the flickering happens?",
                "createdAt": "2022-06-23T17:59:18Z"
            },
            {
                "author": "Brazol",
                "bodyText": "Hi team, happened to me again while debugging the app on the device (iPhone 12).\nFirst, the screen blinked a few times then turned black and was not responding, going from foreground to background and back just added a few lines on the console but the screen was still black, this is what was on the console:\n\nThen I restarted the app (without killing it) and the screen started flickering like crazy and it reflected in the console:\n\n\n  \nThis all happened when scrolling CupertinoDatePicker inside modal popup shown by showCupertinoModalPopup:\n\nI hope it helps in any way. Again, this is not reproducible easily. Happened to me first time in this project (personal pet project) and I couldn't make it happen again. So I don't see any chances of me testing it on various Flutter commits to pinpoint the issue :/",
                "createdAt": "2022-06-23T19:25:28Z"
            },
            {
                "author": "feinstein",
                "bodyText": "@zanderso any chance we could get some insight from Apple on what could be the cause of this?",
                "createdAt": "2022-06-23T22:35:23Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Also experiencing this issue randomly when opening app from background state.\nLogs:\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\n\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n\nIn our app, we have overlay created using BackdropFilter which we display for a few seconds when app is opened from background and hide it after. These actions are done inside didChangeAppLifecycleState.",
                "createdAt": "2022-06-24T07:14:20Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Also experiencing this issue randomly when opening app from background state.\nLogs:\n\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\n\n\n\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n\n\nIn our app, we have overlay created using BackdropFilter which we display for a few seconds when app is opened from background and hide it after. These actions are done inside didChangeAppLifecycleState.\n\nthis seems similar to our case.\nwe use platform views for camera preview. it's a surfaceview.\nand we initialize it on lifecycle changes. when returning from background...\nthe flickering was on return from background in our case also,  and the platform view(live camera preview) displayed ok, while other parts of the UI flickered and parts of the UI that is composed from Images failed to load.\nonly saw it once on a build installed from testflight.\nthe app is not released on the appstore yet, as am waiting to evaluate the stability of flutter.\nit is an update over existing native app though, and i have a feeling this might be a bigger issue if this gets to a million of users.",
                "createdAt": "2022-06-24T09:16:25Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "From Triage: @iskakaushik is going to add flags to disable compositor features speculatively to see if we can isolate the failures to specific subsystems.",
                "createdAt": "2022-06-27T17:48:24Z"
            },
            {
                "author": "zanderso",
                "bodyText": "GitHub was a little too eager in closing this based on the commit message in flutter/engine@0671bca",
                "createdAt": "2022-06-27T20:49:18Z"
            },
            {
                "author": "iskakaushik",
                "bodyText": "Hi all, flutter/engine#34328 PR has rolled into Flutter Framework master. If the following is added to Info.plist of the application, it will disable partial repaint:\n  <key>FLTDisablePartialRepaint</key>\n  <true/>\n\nIt would be great to know if disabling partial repaint resolves this issue. We are not yet sure if it will, but we think the severity of this issue and lack of reproducible case makes it worthwhile to try out a broad fix. It would be great if any of you experiencing this would be able to try out and post here about your findings.",
                "createdAt": "2022-06-28T15:03:28Z"
            },
            {
                "author": "mateusfccp",
                "bodyText": "@iskakaushik Do we have any potential downsides in disabling partial repaint?",
                "createdAt": "2022-06-28T18:17:11Z"
            },
            {
                "author": "iskakaushik",
                "bodyText": "@mateusfccp , there are some situations in which the performance of the application can regress in terms of the rasterization time. This would be most apparent in scenes where only a small part of the scene is changing. That being said, we would really appreciate if we can isolate this particular issue to partial repaint.",
                "createdAt": "2022-06-28T18:33:58Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "would be nice if this was possible to switch at runtime, so it can be\ncontrolled from an AB testing framework.\n\u2026\n @mateusfccp <https://github.com/mateusfccp> , there are some situations\n in which the performance of the application can regress in terms of the\n rasterization time. This would be most apparent in scenes where only a\n small part of the scene is changing. That being said, we would really\n appreciate if we can isolate this particular issue to partial repaint.",
                "createdAt": "2022-06-28T21:33:51Z"
            },
            {
                "author": "feinstein",
                "bodyText": "If someone adds this flag, please let us know here, so we can follow up later.",
                "createdAt": "2022-06-28T22:16:11Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "If someone adds this flag, please let us know here, so we can follow up later.\n\nFlag added - will write more once we get some feedback from our testers.\nAnother thing we did is removed BackdropFilter from our app life cycle logic and this version is without the flag, its been a few days, screen flickering did not appear on this version of our app, at least not yet.",
                "createdAt": "2022-06-29T09:18:07Z"
            },
            {
                "author": "q384264619",
                "bodyText": "My app online has the same bug.\nflutter version:3.0.3",
                "createdAt": "2022-06-30T00:40:34Z"
            },
            {
                "author": "willphonez",
                "bodyText": "If someone adds this flag, please let us know here, so we can follow up later.\n\nFlag added - will write more once we get some feedback from our testers.\nAnother thing we did is removed BackdropFilter from our app life cycle logic and this version is without the flag, its been a few days, screen flickering did not appear on this version of our app, at least not yet.\n\nWhat is your Flutter version?",
                "createdAt": "2022-07-01T09:22:47Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "If someone adds this flag, please let us know here, so we can follow up later.\n\nFlag added - will write more once we get some feedback from our testers.\nAnother thing we did is removed BackdropFilter from our app life cycle logic and this version is without the flag, its been a few days, screen flickering did not appear on this version of our app, at least not yet.\n\nWhat is your Flutter version?\n\nThe version where we added the flag is built with Flutter from master channel. The one where we removed BackdropFilter is stable channel 3.0.1/3.0.2 not entirely sure but one of those. However I forgot to mention that we are experiencing this issue for a long time probably since Flutter 2.10 as stated in this issue.",
                "createdAt": "2022-07-01T09:27:32Z"
            },
            {
                "author": "lan2000",
                "bodyText": "I also have this problem.\n[\u2713] Flutter (Channel stable, 2.10.5, on macOS 12.3 21E230 darwin-x64, locale zh-Hans-CN)\n\u2022 Flutter version 2.10.5 at /Users/admin/flutter\n\u2022 Upstream repository https://github.com/flutter/flutter/\n\u2022 Framework revision 5464c5b (2 months ago), 2022-04-18 09:55:37 -0700\n\u2022 Engine revision 57d3bac3dd\n\u2022 Dart version 2.16.2\n\u2022 DevTools version 2.9.2\n\u2022 Pub download mirror https://pub.flutter-io.cn\n\u2022 Flutter download mirror https://storage.flutter-io.cn\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.3)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 CocoaPods version 1.10.0\n[\u2713] Connected device (1 available)\n\u2022 xxx\u7684iPad (mobile) \u2022 xxx \u2022 ios \u2022 iOS 15.4.1 xxx",
                "createdAt": "2022-07-01T09:45:45Z"
            },
            {
                "author": "lan2000",
                "bodyText": "Execution of the command buffer was aborted due to an error during execution. Caused GPU Address Fault Error (0000000b:kIOGPUCommandBufferCallbackErrorPageFault)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Address Fault Error (0000000b:kIOGPUCommandBufferCallbackErrorPageFault)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nError submitting command buffer: Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)",
                "createdAt": "2022-07-01T10:14:03Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I wonder if it's because of the image loading causing insufficient memory",
                "createdAt": "2022-07-01T10:43:14Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Could be related to GPU not being accessible in the background on iOS. Maybe the app tried to access with the GPU while in background. But that usually causes a crash.",
                "createdAt": "2022-07-01T11:35:55Z"
            },
            {
                "author": "ingmferrer",
                "bodyText": "This is happening to me, while I don't have a way to reproduce it's definitely when the app is in background then going to foreground.\nI'll try disabling partial repaint later.",
                "createdAt": "2022-07-01T19:37:10Z"
            },
            {
                "author": "jing-pei",
                "bodyText": "@iskakaushik This problem still exists after the repair of version 2.10.5, whether the repair of version 2.10 is not supported\nModified as follows-->\nBuildAndRelease/engine@55aa2f5#diff-94f36bb03816803b4bdc61fa8e259251fd4bc86caa955396f487049eae89e78c",
                "createdAt": "2022-07-04T03:24:28Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "My app online has the same bug.\nflutter version:3.0.4",
                "createdAt": "2022-07-04T06:12:45Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Unfortunately same result\u2026 I upgraded to 3.0.3 and added the flag but after a few days the flickering was shown.\nI don\u2019t think it\u2019s relevant but it seems to happen more often when I open the app from a notification.",
                "createdAt": "2022-07-04T07:07:31Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Unfortunately same result\u2026 I upgraded to 3.0.3 and added the flag but after a few days the flickering was shown. I don\u2019t think it\u2019s relevant but it seems to happen more often when I open the app from a notification.\n\nIts been a week for us and we didnt get flickering since adding the flag... but ye I believe that is not the solution then... What I am 100% sure is that this issue is triggered by opening app from background state, do you by any chance use BackdropFilter in your app?",
                "createdAt": "2022-07-04T07:36:41Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Unfortunately same result\u2026 I upgraded to 3.0.3 and added the flag but after a few days the flickering was shown. I don\u2019t think it\u2019s relevant but it seems to happen more often when I open the app from a notification.\n\nNot sure of this made it to 3.0.3. Someone from flutter should confirm.",
                "createdAt": "2022-07-04T09:28:04Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Its been a week for us and we didnt get flickering since adding the flag... but ye I believe that is not the solution then... What I am 100% sure is that this issue is triggered by opening app from background state, do you by any chance use BackdropFilter in your app?\n\nActually, I do...",
                "createdAt": "2022-07-04T10:13:45Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Its been a week for us and we didnt get flickering since adding the flag... but ye I believe that is not the solution then... What I am 100% sure is that this issue is triggered by opening app from background state, do you by any chance use BackdropFilter in your app?\n\nActually, I do...\n\nMmm but it's not being used on iOS platform though...\nWidget build(BuildContext context) {\n    return Stack(\n      fit: StackFit.expand,\n      children: [\n        widget.child,\n        _isAppLocked && !Platform.isIOS ? \n          BackdropFilter(\n            filter: ImageFilter.blur(\n              sigmaX: 5,\n              sigmaY: 5,\n            ),\n            child: Container(\n              color: Colors.transparent,\n            )\n          )\n        : Container(),\n      ],\n    );\n  }",
                "createdAt": "2022-07-04T10:17:11Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Its been a week for us and we didnt get flickering since adding the flag... but ye I believe that is not the solution then... What I am 100% sure is that this issue is triggered by opening app from background state, do you by any chance use BackdropFilter in your app?\n\nActually, I do...\n\nMmm but it's not being used on iOS platform though...\nWidget build(BuildContext context) {\n    return Stack(\n      fit: StackFit.expand,\n      children: [\n        widget.child,\n        _isAppLocked && !Platform.isIOS ? \n          BackdropFilter(\n            filter: ImageFilter.blur(\n              sigmaX: 5,\n              sigmaY: 5,\n            ),\n            child: Container(\n              color: Colors.transparent,\n            )\n          )\n        : Container(),\n      ],\n    );\n  }\n\n\nWeird, if its not being used on iOS then it shouldn't have an impact. But out of curiosity, is this BackdropFilter (in Android case) triggered on app lifecycle state? For example, in our banking app we use BackdropFilter for screen blocking purposes user opens app from background state while his session is alive -> screen is blurred using the BackdropFilter until user passes local authentication -> on successful authentication we hide the BackdropFilter.",
                "createdAt": "2022-07-04T10:22:51Z"
            },
            {
                "author": "jing-pei",
                "bodyText": "Is it now determined that it is caused by BackdropFilter?",
                "createdAt": "2022-07-04T11:30:25Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Is it now determined that it is caused by BackdropFilter?\n\nI wouldn't say it's \"determined\" just discussing all the possibilities. I would like us to give as much info as possible instead of just commenting \"this is not working\". So I am just suggesting that if more of us are using BackdropFilter in the same manner, maybe it's related to the issue.",
                "createdAt": "2022-07-04T11:32:31Z"
            },
            {
                "author": "NikosTsesmelis",
                "bodyText": "Is it now determined that it is caused by BackdropFilter?\n\nI wouldn't say it's \"determined\" just discussing all the possibilities. I would like us to give as much info as possible instead of just commenting \"this is not working\". So I am just suggesting that if more of us are using BackdropFilter in the same manner, maybe it's related to the issue.\n\nWe are not using BackdropFilter and still encounter this issue.",
                "createdAt": "2022-07-04T11:49:42Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Just be aware that even though you might not be using a BackdropFilter, another widget from a third party may be using it internally.",
                "createdAt": "2022-07-04T11:50:50Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Ok we can dismiss whole BackdropFilter theory, just got a feedback that flickering occurred in version of our app with BackdropFilter overlay removed.",
                "createdAt": "2022-07-04T12:26:30Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Could be related to GPU not being accessible in the background on iOS. Maybe the app tried to access with the GPU while in background. But that usually causes a crash.\n\nThis somehow got lost in the comments, I think its a good guess maybe someone with more experience on this topic could elaborate.",
                "createdAt": "2022-07-04T12:30:52Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I'll try to remove everything about BackdropFilter, post a version to see if it still happens, in a few days, I'll post the final result here",
                "createdAt": "2022-07-05T00:50:36Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "idea for a workaround. restart the flutter engine after coming from the background. should not be a big deal with proper state restoration.",
                "createdAt": "2022-07-05T00:59:46Z"
            },
            {
                "author": "xhw0525",
                "bodyText": "Frequent switching to the foreground and background, easy to reproduce",
                "createdAt": "2022-07-05T08:12:34Z"
            },
            {
                "author": "abdulrehmank7",
                "bodyText": "Constantly switching from foreground and background is the culprit here. Users also reported same behavior.",
                "createdAt": "2022-07-05T08:54:33Z"
            },
            {
                "author": "feinstein",
                "bodyText": "I tried going back and forth from background but I can't reproduce on my iPhone 12 Max Pro.\nSince you can reproduce it so easily, could you please try the steps the Flutter team posted?\nSince they can't reproduce, they can't fix it. Or maybe can you send them your code?",
                "createdAt": "2022-07-05T11:40:34Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I'll try to remove everything about BackdropFilter, post a version to see if it still happens, in a few days, I'll post the final result here\n\n\n\nI removed all about BackdropFilter, It doesn't seem to be that often,but it still happens, it seems that it has nothing to do with BackdropFilter, we can consider whether it is caused by GPU,",
                "createdAt": "2022-07-08T01:08:00Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Some news, with repainting flag we still got screen flickering.",
                "createdAt": "2022-07-11T09:03:24Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Some news, with repainting flag we still got screen flickering.\n\nwhich flutter version?",
                "createdAt": "2022-07-11T09:24:37Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "sorry dont remember the exact version, its built with flutter master channel from 12 days ago.",
                "createdAt": "2022-07-11T09:27:50Z"
            },
            {
                "author": "knopp",
                "bodyText": "Frequent switching to the foreground and background, easy to reproduce\n\nIt seems to be reproducible only with certain applications. I haven't been able to reproduce it yet.",
                "createdAt": "2022-07-11T09:58:22Z"
            },
            {
                "author": "zewsummer",
                "bodyText": "I have encountered on android, on version 3.0.2, can anyone come up with a solution and this issue has seriously affected our flutter upgrade",
                "createdAt": "2022-07-17T11:09:54Z"
            },
            {
                "author": "Hixie",
                "bodyText": "We continue to have not been able to reproduce this. Without a reproduction test case, it will be very hard for us to actually help. If you experience this and can reproduce it (even if it's not reliable, frankly) it would be infinitely helpful if you could attach a test case of demo app to this issue, with steps to reproduce, devices needed to reproduce, etc.",
                "createdAt": "2022-07-19T23:21:57Z"
            },
            {
                "author": "maxlapides",
                "bodyText": "Hey @Hixie, our app also has this issue and we're eager to help the team troubleshoot this issue. But, although I work on this app full-time, I have only been able to reproduce the issue myself one time, completely by accident. I have heard reports from at least four other users that they have also observed the issue, though. The only consistency between these reports is that the user brought the app from the background to the foreground immediately before the issue occurred. Force-quitting and restarting the app resolves the issue. At first, I thought this issue might be related to the video player, but then we saw the issue occur on a screen that doesn't have video.\nYou can download our app directly from the iOS App Store: https://apps.apple.com/us/app/tonal/id1437460744. The current production version of the app is built with Flutter 3.0.4. Feel free to make a new test account within our app. Or, if you want an account with more data so you can access more screens and functionality, please feel free to send me an email at max dot lapides [at] tonal dot com. I'm also happy to share source code or answer any other questions that may help track this down!\nHere are some videos I've collected of this issue:",
                "createdAt": "2022-07-19T23:55:24Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "Seams to be related to platforms view. Scrolling through the comments superficially.\nI've seen video players, camera preview, webview. All using platform views.\nIn my case it was a camera preview. Which was the only part of the screen not flickering.",
                "createdAt": "2022-07-20T09:21:18Z"
            },
            {
                "author": "mateusfccp",
                "bodyText": "Seams to be related to platforms view. Scrolling through the comments superficially.\nI've seen video players, camera preview, webview. All using platform views.\nIn my case it was a camera preview. Which was the only part of the screen not flickering.\n\nIn our case, it happened in our login screen, which has nothing related to platform view.",
                "createdAt": "2022-07-20T11:17:17Z"
            },
            {
                "author": "maxlapides",
                "bodyText": "Yep, same here in our app. I thought it was related to platform views as well, but I think we've ruled it out at this point.",
                "createdAt": "2022-07-20T20:10:04Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Has anyone seen it on an app that doesn't have platform views at all? (As opposed to an app that has platform views on one screen, but then seeing it on a different screen where the platform views should be gone, but, you know, in software sometimes bugs mean that things linger longer than you expect...)\nAlso, has anyone seen this happen on a screen where there was definitely no animation happening, where no frames were being pumped? Or is it always happening when a frame is pumped? (I notice in some of the videos that there's often nothing apparently happening, but I don't know if that means nothing is being painted, or if maybe there's still some setState going on that might be triggering a new frame even if it's identical to the previous one.)",
                "createdAt": "2022-07-20T20:22:46Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Also can I just confirm that multiple people have seen this on both iOS and Android? The comments above have been a bit ambiguous about this. (Whether it's platform-specific or not is a good hint as to where to look.)",
                "createdAt": "2022-07-20T20:24:45Z"
            },
            {
                "author": "maxlapides",
                "bodyText": "@Hixie I have not observed this issue on an app that has no platform views, but I only really work on one app.\nAll of the screen videos I posted above show the flickering issue occurring on screens that do have some sort of animation or moving content. In the first example, you can see there's a video playing. In the second example, you can't see it in the screen video, but there is an animation at the top of the screen that runs continuously. And in the third example, you can't see it in the screen video, but there's also a video playing on this screen.\nI have only observed this issue on iOS. I can't confirm for certain that it doesn't occur on Android, though.",
                "createdAt": "2022-07-20T20:32:06Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Has anyone seen it on an app that doesn't have platform views at all? (As opposed to an app that has platform views on one screen, but then seeing it on a different screen where the platform views should be gone, but, you know, in software sometimes bugs mean that things linger longer than you expect...)\nAlso, has anyone seen this happen on a screen where there was definitely no animation happening, where no frames were being pumped? Or is it always happening when a frame is pumped? (I notice in some of the videos that there's often nothing apparently happening, but I don't know if that means nothing is being painted, or if maybe there's still some setState going on that might be triggering a new frame even if it's identical to the previous one.)\n\nThis happens only on iOS as far as I know. I work on a banking app so the case is next:\n\napp in background\nopen the app\nscreen is blurred with BackdropFilter\nwe offer local authentication\nuser authorizes\nremove BackdropFilter using setState inside didChangeAppLifecycleState\nflickering happens\n\nIt does not happen always, it happens randomly, for example I myself couldnt reproduce it no matter how much I tried, colleague did. Not sure if this is related to platform views - but we do use local authentication which is platform view I think.\nSo far what we did is, stopped using BackdropFilter and setState to show / hide it. We moved the blur to native Swift and we control it with native method channel... so far flickering has not appear YET.",
                "createdAt": "2022-07-20T20:42:37Z"
            },
            {
                "author": "feinstein",
                "bodyText": "@Hixie this is a long shot, but does the Flutter team have some sort of contact with Apple?\nMaybe one of their engineers can take a look at the videos and remember previous cases where this happened before, like if someone abused the GPU buffers while the app is in some sort of sleep state.",
                "createdAt": "2022-07-20T20:53:30Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Has anyone seen it on an app that doesn't have platform views at all? (As opposed to an app that has platform views on one screen, but then seeing it on a different screen where the platform views should be gone, but, you know, in software sometimes bugs mean that things linger longer than you expect...)\nAlso, has anyone seen this happen on a screen where there was definitely no animation happening, where no frames were being pumped? Or is it always happening when a frame is pumped? (I notice in some of the videos that there's often nothing apparently happening, but I don't know if that means nothing is being painted, or if maybe there's still some setState going on that might be triggering a new frame even if it's identical to the previous one.)\n\nIn our case this only happen on iOS, the behavior is the same as #100522 (comment) but we\u2019re not using BackdropFilter on iOS (we do it on the swift side) and we DON\u2019T have Platform Views\u2026",
                "createdAt": "2022-07-20T20:54:55Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Could be related to GPU not being accessible in the background on iOS. Maybe the app tried to access with the GPU while in background. But that usually causes a crash.\n\n@zanderso @feinstein\nI tried removing all pictures and videos, sent a version to a few users and they told me it never happened, I think GPU or memory has something to do with it",
                "createdAt": "2022-07-20T23:11:25Z"
            },
            {
                "author": "moffatman",
                "bodyText": "I have seen this in my app with a PlatformView, but there are two interesting things:\n\nThe PlatformView is part of a widget which expands up from the bottom tab bar, so right now it's being built but is clipped by a zero-height Stack and should not be visible\nThe PlatformView itself shouldn't draw anything (UIView with no subviews and backgroundColor = UIColor.clear), it's just used as a rectangle to receive drag-and-dropped files.\n\nDespite that, starting at 0:15 in the following video, it starts showing up as the white rectangle in the bottom-right. That's the correct position and size, but it's not being clipped.\n\n\n  \nCan't remember if there is BackdropFilter here but for sure a large part of the screen is within ImageFiltered with a no-op filter.",
                "createdAt": "2022-07-21T01:58:55Z"
            },
            {
                "author": "Bilalmukhtiar",
                "bodyText": "Actually currently i will working on a project and face the same issue i will add this code and the problem was solved                                       await new Future.delayed(new Duration(days:99999));",
                "createdAt": "2022-07-21T14:09:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@jmagman @chinmaygarde #108161 may have information that can help",
                "createdAt": "2022-07-24T19:38:39Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Could be related to GPU not being accessible in the background on iOS. Maybe the app tried to access with the GPU while in background. But that usually causes a crash.\n\n\nI tried removing all pictures and videos, sent a version to a few users and they told me it never happened, I think GPU or memory has something to do with it\n@jmagman @chinmaygarde\n#106945    #108161   may have information that can help",
                "createdAt": "2022-07-24T23:01:55Z"
            },
            {
                "author": "reamal",
                "bodyText": "I also encountered this problem with flutter 3.0.5",
                "createdAt": "2022-07-27T11:43:35Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi all, I'm sorry to report that we have not yet been able to reproduce this issue locally. However, we are currently working with the Skia team on including more debugging code around Metal command buffer encoding, which will hopefully result in getting more actionable information in the device logs when the flickering occurs. When the debugging code is available on Flutter's master channel, I will update this thread. Thanks for your patience, and apologies for the troubles this issue is causing.",
                "createdAt": "2022-07-27T18:23:46Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "Hi everyone! I'm not sure if this is good or bad news... A few days ago happened something to me that leads me to think that this issue may not be related to Flutter itself but that it may happen \"a lot\" in Flutter because of its GPU rendering.\nSo, I was browsing my pictures on the Photos app of the iPhone and started to browse the \"For You\" tab where you see the generated \"Memories\". So I closed the app and after a while I opened it again, so the app was launched from the background state and when I slide up to go back the app freezes SHOWING EXACTLY THE SAME BEHAVIOR WHEN THIS ISSUE HAPPENED ON MY FLUTTER APP. The Photos app freezes for a few seconds and then it went back to the Springboard. I opened it again and no flickering BUT all the memories View was pink, look at this video:\n\n\n  \nSo, somehow the GPU View was crashed following the same behavior as on Flutter except for the flickering... Unfortunately I was on my holidays and I couldn't hook it up to a Mac to get the logs...",
                "createdAt": "2022-07-28T10:16:32Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@acalatrava Could you share what version of iPhone and iOS you saw this on? Thanks!",
                "createdAt": "2022-07-28T14:25:29Z"
            },
            {
                "author": "acalatrava",
                "bodyText": "@acalatrava Could you share what version of iPhone and iOS you saw this on? Thanks!\n\nThis is an iPhone 12 with iOS 15.5",
                "createdAt": "2022-07-28T14:59:42Z"
            },
            {
                "author": "ingmferrer",
                "bodyText": "@zanderso So, today was the second time that this bug happened to the same tester user in the last two months.\nSadly, neither the tester user nor I can reproduce it and I can't share the commercial app code with you guys but I think something it's related to the google map widget.\nThe tester user have an iPhone 11 Pro with iOS 15.5, when this happened the user was interacting with a screen of sliver widgets that have a mini map using google_maps_flutter, the map just have a pin marker for a store, then the user tried to open the search page and this bug ocurred. https://user-images.githubusercontent.com/6753534/181614991-3624af42-e516-4f0c-bf70-2cef3f4fccc3.MP4\nI think it's related to the map widget because it's the only widget that redraws and output logs, everything else is static. Note that when the user opens the search page, the previous page with the map widget is not removed from the stack, the user can go back after searching, so the map widget is not disposed at that moment. Also, this map widget was also present the first time this ocurred. While maybe is not directly related to google map, the fact that the widget redraws and output logs because it's doing things, can be related to the bug.\nI tried to reproduce the bug doing the exact same thing with an iPhone 13 Pro without luck but I noticed that the navigation transition animation from this page with the map widget visible to the search page feels very laggy compared to another page that doesn't have the map widget to the search page which feels fluid.\nI'll keep an eye and maybe either optimize the map or remove it and see what happens.\nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.3.1 21E258 darwin-x64, locale\n    en-US)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version\n    32.1.0-rc1)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.3.1)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.2)\n[\u2713] Connected device (3 available)\n[\u2713] HTTP Host Availability\n\n\u2022 No issues found!\n\nFlutter 3.0.5 \u2022 channel stable \u2022 https://github.com/flutter/flutter.git\nFramework \u2022 revision f1875d570e (2 weeks ago) \u2022 2022-07-13 11:24:16 -0700\nEngine \u2022 revision e85ea0e79c\nTools \u2022 Dart 2.17.6 \u2022 DevTools 2.12.2",
                "createdAt": "2022-07-28T19:06:41Z"
            },
            {
                "author": "sy5075391",
                "bodyText": "\u5982\u679c\u5176\u4ed6\u4eba\u9047\u5230\u6b64\u95ee\u9898\uff0c\u8bf7\u652f\u6301\u5bf9\u6b64\u95ee\u9898\u7684\u521d\u6b65\u8bc4\u8bba\u3002\u5982\u679c \u60a8\u9047\u5230\u6b64\u95ee\u9898\u7684\u4efb\u4f55\u4eba\u90fd\u53ef\u4ee5\u63d0\u4f9b\u6837\u672c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u884c\u9a8c\u8bc1\uff0c\u6211\u4eec\u4e5f\u5c06\u4e0d\u80dc\u611f\u6fc0\u3002\n\u4fdd\u6301\u6b64\u95ee\u9898\u5f00\u653e\u4ee5\u8ddf\u8e2a\u540c\u4e00\u95ee\u9898\u7684\u672a\u6765\u62a5\u544a\u3002\n\u6839\u636e\u6211\u6536\u96c6\u5230\u7684\u4fe1\u606f\uff1a\n\n\u00a0\u81ea Flutter 2.10.0 #100522 (comment)\u4ee5\u6765\uff0ciOS \u4e0a\u7684 Android \u548c iOS\u5c4f\u5e55\u95ea\u70c1\u90fd\u5b58\u5728\u6b64\u95ee\u9898\n\u4ece Flutter 2.10.0 \u00a0#100522\u5f00\u59cb\uff0c\u5b83\u4f3c\u4e4e\u4e0d\u5f71\u54cd\u5e73\u53f0\u89c6\u56feiOS \u4e0a\u7684\u5c4f\u5e55\u95ea\u70c1\uff08\u8bc4\u8bba\uff09\n\u5b83\u7684\u53d1\u751f\u662f\u96f6\u661f\u7684\uff0c\u6ca1\u6709\u660e\u786e\u7684\u65b9\u6cd5\u6765\u9694\u79bb\u95ee\u9898\n\u6240\u6709\u62a5\u544a\u4f3c\u4e4e\u90fd\u8868\u660e\u5728\u5347\u7ea7\u5230\u98a4\u632f 2.10 \u540e\u53d1\u751f\u4e86\u8fd9\u79cd\u60c5\u51b5\n\n\u518d\u6b21\uff0c\u5982\u679c\u6709\u4eba\u80fd\u591f\u91cd\u73b0\u5e76\u627e\u51fa\u539f\u56e0\uff0c\u8bf7\u63d0\u4f9b\u6837\u672c\u4ee5\u4fbf\u6211\u4eec\u8fdb\u884c\u8c03\u67e5\u3002\n\u53ef\u89c1\u6027\u6807\u7b7e\n\nWhen I debug\uff08iphoneXR , iOS15.4.1 , flutter2.10.0\uff09, the freeze screen  occurs when the app returns to the foreground\uff0c Here is the output\uff1a\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)",
                "createdAt": "2022-08-02T08:53:06Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "I accidentally reproduced this while I was looking into another issue.\nThe app was no longer connected to the debugger so I couldn't capture any logs.\nThe simulator was running in the background, while I was checking the issue, so I don't know when it started. Just thought I'd share the code sample.\nI'll also leave the simulator for a period of time to see if it reproduces again.\n\nvideo\n\n\n  \n\n\ncode sample\nimport 'package:flutter/material.dart';\nimport 'package:video_player/video_player.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({Key? key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: const VideoPlayerWidget(),\n    );\n  }\n}\n\nclass VideoPlayerWidget extends StatefulWidget {\n  const VideoPlayerWidget({super.key});\n\n  @override\n  State<VideoPlayerWidget> createState() => _VideoPlayerWidgetState();\n}\n\nclass _VideoPlayerWidgetState extends State<VideoPlayerWidget> {\n  late VideoPlayerController _controller;\n\n  final url = \"https://amssamples.streaming.mediaservices.windows.net/634cd01c-6822-4630-8444-8dd6279f94c6/CaminandesLlamaDrama4K.ism/manifest(format=m3u8-aapl)\";\n  // final url = \"http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8\";\n  // final url = \"https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8\";\n  // final url = \"https://flutter.github.io/assets-for-api-docs/assets/videos/bee.mp4\";\n\n  @override\n  void initState() {\n    super.initState();\n    _controller = VideoPlayerController.network(\n      url,\n      formatHint: VideoFormat.hls,\n      videoPlayerOptions: VideoPlayerOptions(mixWithOthers: true),\n    );\n\n    _controller.addListener(() {\n      if (_controller.value.isInitialized && _controller.value.position == _controller.value.duration) {\n        print('Video Ended');\n      }\n    });\n\n    _controller.initialize().then((value) {\n      _controller.play();\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: SingleChildScrollView(\n        child: Column(\n          children: <Widget>[\n            Container(padding: const EdgeInsets.only(top: 20.0)),\n            const Text('With remote mp4'),\n            Container(\n              padding: const EdgeInsets.all(20),\n              child: AspectRatio(\n                aspectRatio: _controller.value.aspectRatio,\n                child: Stack(\n                  alignment: Alignment.bottomCenter,\n                  children: <Widget>[\n                    VideoPlayer(_controller),\n                    VideoProgressIndicator(_controller, allowScrubbing: true),\n                  ],\n                ),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n  }\n}\n\n\n\nflutter doctor -v\n[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.4 21F79 darwin-arm, locale en-GB)\n    \u2022 Flutter version 3.0.5 at /Users/nexus/dev/sdks/flutter\n    \u2022 Upstream repository https://github.com/flutter/flutter.git\n    \u2022 Framework revision f1875d570e (3 weeks ago), 2022-07-13 11:24:16 -0700\n    \u2022 Engine revision e85ea0e79c\n    \u2022 Dart version 2.17.6\n    \u2022 DevTools version 2.12.2\n\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 33.0.0)\n    \u2022 Android SDK at /Users/nexus/Library/Android/sdk\n    \u2022 Platform android-33, build-tools 33.0.0\n    \u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/Contents/Home/bin/java\n    \u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n    \u2022 All Android licenses accepted.\n\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4.1)\n    \u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n    \u2022 CocoaPods version 1.11.3\n\n[\u2713] Chrome - develop for the web\n    \u2022 Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome\n\n[\u2713] Android Studio (version 2021.2)\n    \u2022 Android Studio at /Applications/Android Studio.app/Contents\n    \u2022 Flutter plugin can be installed from:\n      \ud83d\udd28 https://plugins.jetbrains.com/plugin/9212-flutter\n    \u2022 Dart plugin can be installed from:\n      \ud83d\udd28 https://plugins.jetbrains.com/plugin/6351-dart\n    \u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n\n[\u2713] VS Code (version 1.69.2)\n    \u2022 VS Code at /Applications/Visual Studio Code.app/Contents\n    \u2022 Flutter extension version 3.46.0\n\n[\u2713] Connected device (4 available)\n    \u2022 sdk gphone64 arm64 (mobile) \u2022 emulator-5554                        \u2022 android-arm64  \u2022 Android 13 (API 33) (emulator)\n    \u2022 iPhone 13 Pro (mobile)      \u2022 6E074BA5-191C-47D4-892F-FD96AFC34148 \u2022 ios            \u2022 com.apple.CoreSimulator.SimRuntime.iOS-15-5 (simulator)\n    \u2022 macOS (desktop)             \u2022 macos                                \u2022 darwin-arm64   \u2022 macOS 12.4 21F79 darwin-arm\n    \u2022 Chrome (web)                \u2022 chrome                               \u2022 web-javascript \u2022 Google Chrome 104.0.5112.79\n\n[\u2713] HTTP Host Availability\n    \u2022 All required HTTP hosts are available\n\n\u2022 No issues found!",
                "createdAt": "2022-08-03T09:57:44Z"
            },
            {
                "author": "sy5075391",
                "bodyText": "\u5927\u5bb6\u597d\uff0c\u5f88\u9057\u61be\u5730\u62a5\u544a\u6211\u4eec\u5c1a\u672a\u80fd\u591f\u5728\u672c\u5730\u91cd\u73b0\u6b64\u95ee\u9898\u3002\u4f46\u662f\uff0c\u6211\u4eec\u76ee\u524d\u6b63\u5728\u4e0e Skia \u56e2\u961f\u5408\u4f5c\uff0c\u5305\u62ec\u66f4\u591a\u5173\u4e8e Metal \u547d\u4ee4\u7f13\u51b2\u533a\u7f16\u7801\u7684\u8c03\u8bd5\u4ee3\u7801\uff0c\u8fd9\u6709\u671b\u5728\u53d1\u751f\u95ea\u70c1\u65f6\u5728\u8bbe\u5907\u65e5\u5fd7\u4e2d\u83b7\u5f97\u66f4\u591a\u53ef\u64cd\u4f5c\u7684\u4fe1\u606f\u3002\u5f53 Flutter \u7684\u4e3b\u9891\u9053\u6709\u8c03\u8bd5\u4ee3\u7801\u53ef\u7528\u65f6\uff0c\u6211\u4f1a\u66f4\u65b0\u8fd9\u4e2a\u7ebf\u7a0b\u3002\u611f\u8c22\u60a8\u7684\u8010\u5fc3\u7b49\u5f85\uff0c\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\u9020\u6210\u7684\u9ebb\u70e6\uff0c\u6211\u4eec\u6df1\u8868\u6b49\u610f\u3002\n\nWhen I debug\uff08iphoneXR , iOS15.4.1 , flutter2.10.0\uff09, the freeze screen  occurs when the app returns to the foreground\uff0c Here is the output\uff1a\nExecution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)",
                "createdAt": "2022-08-04T02:08:34Z"
            },
            {
                "author": "sherrychhabra51",
                "bodyText": "I am also able to reproduce it on flutter version 3.0.5 and this has started happening only after we upgrade it to 3.0.5. It is working fine on flutter version 2.10.5.\nFor me, this is happening as soon as we clear the navigation stack on logout button and relaunches login screen.\n`[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.0.1 21A559 darwin-x64, locale en-IN)\n\u2022 Flutter version 3.0.5 at /Users/sheeryshashi/Downloads/Softwares/flutter\n\u2022 Upstream repository https://github.com/flutter/flutter.git\n\u2022 Framework revision f1875d5 (3 weeks ago), 2022-07-13 11:24:16 -0700\n\u2022 Engine revision e85ea0e79c\n\u2022 Dart version 2.17.6\n\u2022 DevTools version 2.12.2\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 32.1.0-rc1)\n\u2022 Android SDK at /Users/sheeryshashi/Library/Android/sdk\n\u2022 Platform android-32, build-tools 32.1.0-rc1\n\u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/Contents/Home/bin/java\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n\u2022 All Android licenses accepted.\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.3)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 CocoaPods version 1.11.3\n[\u2713] Chrome - develop for the web\n\u2022 Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome\n[\u2713] Android Studio (version 2021.2)\n\u2022 Android Studio at /Applications/Android Studio.app/Contents\n\u2022 Flutter plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/9212-flutter\n\u2022 Dart plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/6351-dart\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n[\u2713] VS Code (version 1.69.2)\n\u2022 VS Code at /Users/sheeryshashi/Downloads/Softwares/Visual Studio Code.app/Contents\n\u2022 Flutter extension can be installed from:\n\ud83d\udd28 https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter\n[\u2713] Connected device (3 available)\n\u2022 Redmi Note 9 Pro (mobile) \u2022 9256b646 \u2022 android-arm64  \u2022 Android 11 (API 30)\n\u2022 macOS (desktop)           \u2022 macos    \u2022 darwin-x64     \u2022 macOS 12.0.1 21A559 darwin-x64\n\u2022 Chrome (web)              \u2022 chrome   \u2022 web-javascript \u2022 Google Chrome 103.0.5060.134\n[\u2713] HTTP Host Availability\n\u2022 All required HTTP hosts are available\n\u2022 No issues found!`",
                "createdAt": "2022-08-04T06:09:14Z"
            },
            {
                "author": "talarecc",
                "bodyText": "Hello,\nProblem encountered with on 3.0.5 on iOS (last stable). The thing is that I use a Webview with a isSecureTextEntry added in Swift to prevent screenshot... I don't knowif the problem can come from the webview OR/AND the securetextfield (I don't think so imho), but maybe that can help.\n`/Users/pierrelenoble/flutter/bin/flutter doctor --verbose\n[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.4 21F79 darwin-arm, locale en-FR)\n\u2022 Flutter version 3.0.5 at /Users/pierrelenoble/flutter\n\u2022 Upstream repository https://github.com/flutter/flutter.git\n\u2022 Framework revision f1875d5 (3 weeks ago), 2022-07-13 11:24:16 -0700\n\u2022 Engine revision e85ea0e79c\n\u2022 Dart version 2.17.6\n\u2022 DevTools version 2.12.2\n[!] Android toolchain - develop for Android devices (Android SDK version 32.1.0-rc1)\n\u2022 Android SDK at /Users/pierrelenoble/Library/Android/sdk\n\u2022 Platform android-32, build-tools 32.1.0-rc1\n\u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/Contents/Home/bin/java\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n! Some Android licenses not accepted.  To resolve this, run: flutter doctor --android-licenses\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 CocoaPods version 1.11.2\n[\u2717] Chrome - develop for the web (Cannot find Chrome executable at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome)\n! Cannot find Chrome. Try setting CHROME_EXECUTABLE to a Chrome executable.\n[\u2713] Android Studio (version 2021.2)\n\u2022 Android Studio at /Applications/Android Studio.app/Contents\n\u2022 Flutter plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/9212-flutter\n\u2022 Dart plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/6351-dart\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.12+0-b1504.28-7817840)\n[\u2713] Connected device (2 available)\n\u2022 Pierre\u2019s iPhone (mobile) \u2022 00008101-001C74213CA0001E \u2022 ios          \u2022 iOS 15.5 19F77\n\u2022 macOS (desktop)          \u2022 macos                     \u2022 darwin-arm64 \u2022 macOS 12.4 21F79 darwin-arm\n! Error: Pierre\u2019s iPhone is busy: Preparing the watch for development via Pierre\u2019s iPhone. Xcode will continue when Pierre\u2019s iPhone is finished. (code -10)\n[\u2713] HTTP Host Availability\n\u2022 All required HTTP hosts are available\n! Doctor found issues in 2 categories.\n`",
                "createdAt": "2022-08-04T10:21:10Z"
            },
            {
                "author": "neophob",
                "bodyText": "We observed the flickering too, hard to reproduce but it definitive happens. Tried all v3.0.x releases (up to v3.0.5) - all show the same flickering issue (using google play releases). On the video one flickering is visible - but all parts of the application can flicker.\n\n\n  \n[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.5 21G72 darwin-x64, locale de-CH)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4.1)\n[\u2713] Chrome - develop for the web\n[\u2713] Android Studio (version 2021.2)\n[\u2713] VS Code (version 1.68.1)\n[\u2713] Connected device (2 available)\n[\u2713] HTTP Host Availability",
                "createdAt": "2022-08-08T08:44:09Z"
            },
            {
                "author": "apkuhar",
                "bodyText": "We observed the flickering too, hard to reproduce but it definitive happens. Tried all v3.0.x releases (up to v3.0.5) - all show the same flickering issue (using google play releases). On the video one flickering is visible - but all parts of the application can flicker.\n\n\n  \n\n[\u2713] Flutter (Channel stable, 3.0.5, on macOS 12.5 21G72 darwin-x64, locale de-CH)\n\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 30.0.3)\n\n[\u2713] Xcode - develop for iOS and macOS (Xcode 13.4.1)\n\n[\u2713] Chrome - develop for the web\n\n[\u2713] Android Studio (version 2021.2)\n\n[\u2713] VS Code (version 1.68.1)\n\n[\u2713] Connected device (2 available)\n\n[\u2713] HTTP Host Availability\n\n\n\nyou issue is unrelated. the flickering in your case is due to fast changing text with different width glyphs.",
                "createdAt": "2022-08-08T10:27:56Z"
            },
            {
                "author": "neophob",
                "bodyText": "you issue is unrelated. the flickering in your case is due to fast changing text with different width glyphs.\n\nThe fast changing text is just one effect, sometimes the background color is flickering too. This happens rarely and after switching screens pause/resume app the issue gone.\nEdit: I update the code, I'm pretty sure Flutter shows for some reason and old buffer that contains an old time (using print and seconds in the time to trigger the issue much more). It is definitive triggered when I wake up my Android phone.\nEdit2: When I add key: UniqueKey() to the text widget, I cannot reproduce the error anymore!",
                "createdAt": "2022-08-08T12:56:48Z"
            },
            {
                "author": "neophob",
                "bodyText": "We use a custom MainActivity.java file, in the onCreate function we use this code to get a transparent background:\ngetIntent().putExtra(INTENT_EXTRA_BACKGROUND_MODE, transparent.toString());\n-> when we remove this line, no flickering is visible. does anyone else use a transparent background of the main window?",
                "createdAt": "2022-08-09T13:24:18Z"
            },
            {
                "author": "danagbemava-nc",
                "bodyText": "Hi @neophob, this issue is happening mainly on iOS. If you're experiencing an issue on android, kindly file a new issue.",
                "createdAt": "2022-08-09T13:26:55Z"
            },
            {
                "author": "wds1181977",
                "bodyText": "This is the Log when I reproduce  ios App Crash & Screen flickering Caused GPU Timeout #108161\n\nLog\n[connection] nw_resolver_start_query_timer_block_invoke [C32] Query fired: did not receive all answers in time for app-measurement.com:443\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\n\ncausing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\nExecution of the command buffer was aborted due to an error during execution. \nIgnored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n\n\n\n* thread #12, name = 'io.flutter.1.profiler', stop reason = EXC_BAD_ACCESS (code=1, address=0x10)\n    frame #0: 0x000000010a4536a0 Flutter`Dart_TimelineEvent + 500\nFlutter`Dart_TimelineEvent:\n->  0x10a4536a0 <+500>: str    x25, [x8, x24]\n    0x10a4536a4 <+504>: ldr    x8, [x23]\n    0x10a4536a8 <+508>: add    x8, x8, x24\n    0x10a4536ac <+512>: str    x0, [x8, #0x8]\nTarget 0: (Runner) stopped.\n\n/../third_party/dart/runtime/vm/object.cc: 19944: error: unreachable code\nversion=2.17.5 (stable) (Tue Jun 21 11:05:10 2022 +0200) on \"ios_arm64\"\npid=8553, thread=43267, isolate_group=main(0x14052a200), isolate=main(0x1403d5c00)\nisolate_instructions=10b84f8a0, vm_instructions=10b84f8a0\n  pc 0x000000010c1c77f8 fp 0x000000016b4a7620 Dart_DumpNativeStackTrace+0x18\n  pc 0x000000010bdb0dd4 fp 0x000000016b4a7640 dart::Assert::Fail(char const*, ...) const+0x30\n  pc 0x000000010be885bc fp 0x000000016b4a7660 dart::AbstractType::Equals(dart::Instance const&) const+0x0\n  pc 0x000000010bfbb86c fp 0x000000016b4a76a0 dart::SubtypeChecksForClass(dart::Zone*, dart::Type const&, dart::Class const&, dart::Class const&)+0x164\n  pc 0x000000010bfb91a4 fp 0x000000016b4a78f0 dart::TypeTestingStubGenerator::BuildOptimizedSubclassRangeCheckWithTypeArguments(dart::compiler::Assembler*, dart::HierarchyInfo*, dart::Type const&, dart::Class const&)+0x2f8\n  pc 0x000000010bfb7f08 fp 0x000000016b4a7a10 std::__1::__function::__func<dart::TypeTestingStubGenerator::BuildCodeForType(dart::Type const&)::$_0, std::__1::allocator<dart::TypeTestingStubGenerator::BuildCodeForType(dart::Type const&)::$_0>, dart::CodePtr (dart::compiler::Assembler&)>::operator()(dart::compiler::Assembler&)+0x2a0\n  pc 0x000000010bfb7ab8 fp 0x000000016b4a7c40 dart::RetryCompilationWithFarBranches(dart::Thread*, std::__1::function<dart::CodePtr (dart::compiler::Assembler&)>)+0x130\n  pc 0x000000010bfb75c0 fp 0x000000016b4a7d60 dart::TypeTestingStubGenerator::SpecializeStubFor(dart::Thread*, dart::AbstractType const&)+0x2b0\n  pc 0x000000010bf65f94 fp 0x000000016b4a7f20 dart::DRT_TypeCheck(dart::NativeArguments)+0x2ac\n  pc 0x000000010f082a4c fp 0x000000016b4a7f68 Unknown symbol\n  pc 0x000000010f0857d8 fp 0x000000016b4a7fc8 Unknown symbol\n  pc 0x000000011eb6ff50 fp 0x000000016b4a8008 Unknown symbol\n  pc 0x000000013c1c519c fp 0x000000016b4a8058 Unknown symbol\n  pc 0x000000011d9601fc fp 0x000000016b4a80e8 Unknown symbol\n  pc 0x0000000119a33acc fp 0x000000016b4a8130 Unknown symbol\n  pc 0x00000001431ea508 fp 0x000000016b4a81c8 Unknown symbol\n  pc 0x0000000119a3de7c fp 0x000000016b4a8230 Unknown symbol\n  pc 0x0000000119a3da24 fp 0x000000016b4a82c8 Unknown symbol\n  pc 0x0000000119a3343c fp 0x000000016b4a8318 Unknown symbol\n  pc 0x0000000119a3304c fp 0x000000016b4a8378 Unknown symbol\n  pc 0x0000000119a320f0 fp 0x000000016b4a83f8 Unknown symbol\n  pc 0x0000000119a36ac0 fp 0x000000016b4a8440 Unknown symbol\n  pc 0x0000000119a36794 fp 0x000000016b4a8480 Unknown symbol\n  pc 0x000000014c82f110 fp 0x000000016b4a8510 Unknown symbol\n  pc 0x000000010f1bfef4 fp 0x000000016b4a8570 Unknown symbol\n  pc 0x000000010f1bf60c fp 0x000000016b4a8600 Unknown symbol\n  pc 0x0000000119a22914 fp 0x000000016b4a8670 Unknown symbol\n  pc 0x0000000119a227c4 fp 0x000000016b4a86b0 Unknown symbol\n  pc 0x0000000119a224a4 fp 0x000000016b4a86f8 Unknown symbol\n  pc 0x0000000119a22034 fp 0x000000016b4a8738 Unknown symbol\n  pc 0x0000000119a21f2c fp 0x000000016b4a8760 Unknown symbol\n  pc 0x000000010f082fc8 fp 0x000000016b4a8830 Unknown symbol\n  pc 0x000000010be07660 fp 0x000000016b4a8cd0 dart::DartEntry::InvokeFunction(dart::Function const&, dart::Array const&, dart::Array const&, unsigned long)+0x2a4\n  pc 0x000000010c1c0bc4 fp 0x000000016b4a8df0 Dart_InvokeClosure+0x618\n  pc 0x000000010bc4d0e0 fp 0x000000016b4a8e80 tonic::DartMicrotaskQueue::RunMicrotasks()+0x8c\n  pc 0x000000010bb4e1e8 fp 0x000000016b4a8fd0 fml::MessageLoopImpl::FlushTasks(fml::FlushType)+0x80c\n  pc 0x000000010bb51b2c fp 0x000000016b4a8ff0 fml::MessageLoopDarwin::OnTimerFire(__CFRunLoopTimer*, fml::MessageLoopDarwin*)+0x20\n  pc 0x0000000193b9e678 fp 0x000000016b4a9000 <redacted>+0x20\n  pc 0xf17ae78193b22654 fp 0x000000016b4aa0d0 <redacted>+0xf17ae78000000428\n  pc 0x00762a0193b1ce00 fp 0x000000016b4aa130 <redacted>+0x762a0000000140\n  pc 0xec5ad70193afb4b0 fp 0x000000016b4aae90 <redacted>+0xec5ad70000000790\n  pc 0xf1493d0193b0ebc8 fp 0x000000016b4aaf40 CFRunLoopRunSpecific+0xf1493d0000000258\n  pc 0xe866d9810bb519fc fp 0x000000016b4aaf80 fml::MessageLoopDarwin::Run()+0xe866d98000000058\n  pc 0x000000010bb50ab8 fp 0x000000016b4aafc0 void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, fml::Thread::Thread(std::__1::function<void (fml::Thread::ThreadConfig const&)> const&, fml::Thread::ThreadConfig const&)::$_0> >(void*)+0xd0\n  pc 0x000000020544c9ac fp 0x000000016b4aafe0 _pthread_start+0x94\n-- End of DumpStackTrace\n  pc 0x0000000000000000 fp 0x000000016b4a7f68 sp 0x0000000000000000 [Stub] CallToRuntime\n  pc 0x000000010f0857d8 fp 0x000000016b4a7fc8 sp 0x000000016b4a7f78 [Stub] LazySpecializeTypeTest\n  pc 0x000000011eb6ff50 fp 0x000000016b4a8008 sp 0x000000016b4a7fd8 [Unoptimized] Stream.transform\n  pc 0x000000013c1c519c fp 0x000000016b4a8058 sp 0x000000016b4a8018 [Unoptimized] addProgress\n  pc 0x000000011d9601fc fp 0x000000016b4a80e8 sp 0x000000016b4a8068 [Unoptimized] _DioForNative&Object&DioMixin@3145406766._transformData@3134263083\n  pc 0x0000000119a33acc fp 0x000000016b4a8130 sp 0x000000016b4a80f8 [Unoptimized] _asyncThenWrapperHelper@4048458.thenWrapper\n  pc 0x00000001431ea508 fp 0x000000016b4a81c8 sp 0x000000016b4a8140 [Optimized] _rootRunUnary@4048458\n  pc 0x0000000119a3de7c fp 0x000000016b4a8230 sp 0x000000016b4a81d8 [Unoptimized] _rootRunUnary@4048458\n  pc 0x0000000119a3da24 fp 0x000000016b4a82c8 sp 0x000000016b4a8240 [Unoptimized] _CustomZone@4048458.runUnary\n  pc 0x0000000119a3343c fp 0x000000016b4a8318 sp 0x000000016b4a82d8 [Unoptimized] _FutureListener@4048458.handleValue\n  pc 0x0000000119a3304c fp 0x000000016b4a8378 sp 0x000000016b4a8328 [Unoptimized] _Future@4048458._propagateToListeners@4048458.handleValueCallback\n  pc 0x0000000119a320f0 fp 0x000000016b4a83f8 sp 0x000000016b4a8388 [Unoptimized] _Future@4048458._propagateToListeners@4048458\n  pc 0x0000000119a36ac0 fp 0x000000016b4a8440 sp 0x000000016b4a8408 [Unoptimized] _Future@4048458._completeWithValue@4048458\n  pc 0x0000000119a36794 fp 0x000000016b4a8480 sp 0x000000016b4a8450 [Unoptimized] _Future@4048458._asyncCompleteWithValue@4048458.<anonymous closure>\n  pc 0x000000014c82f110 fp 0x000000016b4a8510 sp 0x000000016b4a8490 [Optimized] _rootRun@4048458\n  pc 0x000000010f1bfef4 fp 0x000000016b4a8570 sp 0x000000016b4a8520 [Unoptimized] _rootRun@4048458\n  pc 0x000000010f1bf60c fp 0x000000016b4a8600 sp 0x000000016b4a8580 [Unoptimized] _CustomZone@4048458.run\n  pc 0x0000000119a22914 fp 0x000000016b4a8670 sp 0x000000016b4a8610 [Unoptimized] _CustomZone@4048458.runGuarded\n  pc 0x0000000119a227c4 fp 0x000000016b4a86b0 sp 0x000000016b4a8680 [Unoptimized] _CustomZone@4048458.bindCallbackGuarded.<anonymous closure>\n  pc 0x0000000119a224a4 fp 0x000000016b4a86f8 sp 0x000000016b4a86c0 [Unoptimized] _microtaskLoop@4048458\n  pc 0x0000000119a22034 fp 0x000000016b4a8738 sp 0x000000016b4a8708 [Unoptimized] _startMicrotaskLoop@4048458\n  pc 0x0000000119a21f2c fp 0x000000016b4a8760 sp 0x000000016b4a8748 [Unoptimized] _startMicrotaskLoop@4048458\n  pc 0x000000010f082fc8 fp 0x000000016b4a8830 sp 0x000000016b4a8770 [Stub] InvokeDartCode\n[log]  d | getListData\n* thread #8, name = 'io.flutter.1.ui', stop reason = signal SIGABRT\n    frame #0: 0x00000001cb71eb38 libsystem_kernel.dylib`__pthread_kill + 8\nlibsystem_kernel.dylib`__pthread_kill:\n->  0x1cb71eb38 <+8>:  b.lo   0x1cb71eb58               ; <+40>\n    0x1cb71eb3c <+12>: pacibsp \n    0x1cb71eb40 <+16>: stp    x29, x30, [sp, #-0x10]!\n    0x1cb71eb44 <+20>: mov    x29, sp\nTarget 0: (Runner) stopped.\n[log] null\n[log] null\n[log] null\n[log] null\n\n\n[Snapshotting] Snapshotting a view (0x1619d2e00, UIKeyboardImpl) that is not in a visible window requires afterScreenUpdates:YES.\n[connection] nw_resolver_start_query_timer_block_invoke [C140.1] Query fired: did not receive all answers in time for app-measurement.com:443\n[connection] nw_resolver_start_query_timer_block_invoke [C140.2] Query fired: did not receive all answers in time for app-measurement.com:443\n[Common] Snapshot request 0x2807d65b0 complete with error: <NSError: 0x2807df660; domain: BSActionErrorDomain; code: 6>\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\nExecution of the command buffer was aborted due to an error during execution. Caused GPU Timeout Error (00000002:kIOGPUCommandBufferCallbackErrorTimeout)\n[tcp] tcp_input [C140.2.1:3] flags=[R] seq=848682789, ack=0, win=0 state=TIME_WAIT rcv_nxt=848682789, snd_una=4190893457\n[tcp] tcp_input [C135.1.1:3] flags=[R] seq=4220942979, ack=1533235707, win=0 state=TIME_WAIT rcv_nxt=4220942979, snd_una=295170549\n[] nw_resolver_start_query_timer_block_invoke [R29] Query fired: did not receive all answers in time for thinkingdata.cn:0\nLost connection to device.",
                "createdAt": "2022-08-11T09:11:39Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Hi guys, I just want to confirm some behaviors we have seen before:\nAn user reported he opened the app from the background and then he tried to go to the iPhone's home screen swiping up, but then the app started to flicker and when the flickering stopped the app was frozen.\nIt seems to me that the key here is something happening when the app was back from background and then going back to background.",
                "createdAt": "2022-08-11T13:02:49Z"
            },
            {
                "author": "talarecc",
                "bodyText": "It seems to me that the key here is something happening when the app was back from background and then going back to background.\n\nI forgot to mention that but yes, from our side, we reproduced this issue only twice, and it was always when I goes back to my app from the background, and navigate a little bit before the flickering happens, every time on iOS.\nI tried to reproduce this bug in debug mode, with no success...",
                "createdAt": "2022-08-11T14:09:17Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Hi guys, I just want to confirm some behaviors we have seen before:\nAn user reported he opened the app from the background and then he tried to go to the iPhone's home screen swiping up, but then the app started to flicker and when the flickering stopped the app was frozen.\nIt seems to me that the key here is something happening when the app was back from background and then going back to background.\n\nThere are two situations on my side, which should be related to the ios version, 1. Open the app, swipe up, then get stuck, the app flicker, 2. Return to the app from the background and start flicker",
                "createdAt": "2022-08-11T14:29:32Z"
            },
            {
                "author": "562937459",
                "bodyText": "\u8fd9\u4e2a\u95ee\u9898\u6211\u4eec\u4e5f\u9047\u5230\u8fc7\u591a\u6b21\uff0c\u901a\u5e38\u662f\u5728\u5e94\u7528\u8fdb\u5165\u540e\u53f0\u540e\uff0c\u8fc7\u51e0\u5206\u949f\u518d\u5524\u9192\u8fc7\u51fa\u73b0\u7684\u3002\u6709\u4e00\u6b21\u662f\u8fde\u7740Xcode\u8c03\u8bd5\u65f6\u51fa\u73b0\u7684\uff0cXcode\u6253\u51fa\u7684\u9519\u8bef\u662fGPU\u5361\u6b7b\uff0c\u5e0c\u671b\u53ef\u4ee5\u5c3d\u5feb\u4fee\u590d\u3002",
                "createdAt": "2022-08-15T03:22:40Z"
            },
            {
                "author": "ostk0069",
                "bodyText": "This is the research summary of our app's flickering matter.\nThis summary is only from our developers team, not from users.\nSummary (last month):\n\n\n\nNumber of Repetitions\nDevices\niOS version\nXcode version\nFlutter version\n\n\n\n\n15\nin most iPhones\n15.x, 16\n13.4.1\n3.0.4 or more\n\n\n\nMatching of Device & iOS version:\n\n\n\nDevice\niOS version\n\n\n\n\niPhone 12 mini\n15.5\n\n\niPhone 13 Pro\n15.4.1\n\n\niPhone 12 Pro\n16\n\n\niPhone SE 2nd\n15.1\n\n\niPhone XR\n15.5\n\n\niPhone 12 pro\n15.4.1\n\n\niPhone 11\n15.6\n\n\n\nActions just before flickering occured:\n\n\n\nEvent\nNumber of Repetitions\n\n\n\n\nshowing webView by using flutter_inappwebview\n5\n\n\nlaunch app from background\n6\n\n\nother (just using app normally)\n4\n\n\nTotal\n15\n\n\n\nWe have not found exact way to reproduce the matter yet \ud83d\ude22\nPackage Dependency:\nalmost all firebase packages, video_player, audio_service, flutter_inappwebview, and more...\nConsole log when flickering happened:\nExecution of the command buffer was aborted due to an error during execution.\n\n\nlogs looks quite same with:\n#100522 (comment)\n#100522 (comment)\n#97910",
                "createdAt": "2022-08-15T08:12:29Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "We continue to have conversations with the Skia team on how to debug and fix this. After https://skia-review.googlesource.com/c/skia/+/566883, we should have more intelligence on what kind of command buffer errors are encountered. We are also reviewing the logic around backgrounding and interaction with command submission. In the meanwhile, I am going to review @ostk0069 s excellent summary to see if we can use use that information to add to what we know about this bug. More to come.",
                "createdAt": "2022-08-15T20:58:53Z"
            },
            {
                "author": "ostk0069",
                "bodyText": "Here is our additional Info about research\nWe've customized our app with high load on\n\nCPU\nRendering\nMemory\n\nand monkey test the app. However, any of them did not reproduce the flickering\ud83d\ude2d\nBy looking at our summary this is the high probability way to reproduce the flickering:\n\napp slowdowns for some reason\nfreeze\nmake the app to background\nmake the app to foreground\n\n\nWe are also reviewing the logic around backgrounding and interaction with command submission.\n\nJust notice that our app does not have any background logic except for audio_service.\nIf it is possible, we would like to share the instruments log when the flickering appeared.\nFrom a privacy point of view, could we send it by DM in twitter or something else?\nThis problem is the main cause of blocking our application release.\nIf theres anything we could do, please let us know.",
                "createdAt": "2022-08-16T04:53:36Z"
            },
            {
                "author": "ostk0069",
                "bodyText": "@chinmaygarde\nIs there any way to send event log or error when flickering occurred on customer's devices?\nWe would like to measure flickering occurrence probability if possible.",
                "createdAt": "2022-08-17T06:03:04Z"
            },
            {
                "author": "liu731",
                "bodyText": "Reproduced in 3.0.5(iOS 15.6.1 iPhone13 Pro Max), hard to trigger this bug.",
                "createdAt": "2022-08-31T11:58:17Z"
            },
            {
                "author": "b055man",
                "bodyText": "@chinmaygarde This issue reproduces fairly easily in our app when using an older iPhone (5s / 6), when playing back an HLS video (using the video_player package). The simplest trigger in our case is to switch between fullscreen/landscape a couple of times and back and wait for the show to start.. ;)\nHappens both with a version that was built using Flutter 2.10.5 and 3.0.5.\niPhone 5s, iOS 12.5.5\n[Edit] as others noted: the playback looks nice, it's everything but the player widget that flickers",
                "createdAt": "2022-08-31T17:31:24Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Can you provide a code sample? Maybe provide private access to your repo to some key persons in the Flutter team?",
                "createdAt": "2022-08-31T19:17:10Z"
            },
            {
                "author": "simplenotezy",
                "bodyText": "@chinmaygarde Is there any way to send event log or error when flickering occurred on customer's devices? We would like to measure flickering occurrence probability if possible.\n\nWe reviewed our Crashalytics logs for when it happened, an nothing was to be found in the logs, unfortunately.",
                "createdAt": "2022-09-04T22:30:11Z"
            },
            {
                "author": "demoYang",
                "bodyText": "how fix it ?",
                "createdAt": "2022-09-05T06:49:25Z"
            },
            {
                "author": "Albert221",
                "bodyText": "Hi, Flutter 3.3 no longer uses Skia but Impeller. Does this potentially mitigate the flickering? Has anyone reporting issues here faced the same on Flutter 3.3?",
                "createdAt": "2022-09-05T07:47:35Z"
            },
            {
                "author": "ryzizub",
                "bodyText": "Hi, Flutter 3.3 no longer uses Skia but Impeller. Does this potentially mitigate the flickering? Has anyone reporting issues here faced the same on Flutter 3.3?\n\nI was telling myself this morning same thing. We will be updating to 3.3 in production soon, hopefull that solves the issue",
                "createdAt": "2022-09-05T07:51:16Z"
            },
            {
                "author": "PiotrMitkowski",
                "bodyText": "Hi, Flutter 3.3 no longer uses Skia but Impeller. Does this potentially mitigate the flickering? Has anyone reporting issues here faced the same on Flutter 3.3?\n\nFlutter 3.3 still uses Skia by default, Impeller can be used only as a \"feature preview\", by setting some flags as mentioned here. Updating to 3.3 only didn't fix the issue in my project, but there's a possibility that enabling Impeller will do the thing.",
                "createdAt": "2022-09-05T07:56:01Z"
            },
            {
                "author": "akihisasengoku",
                "bodyText": "Updating to 3.3 only didn't fix the issue in my project\n\nHow did you check the issue doesn't occur in Flutter 3.3.0?\nWe also need to reproduce this issue locally to be sure it hasn't been fixed in 3.3. but we don't know how to reproduce or measure the issue.",
                "createdAt": "2022-09-05T10:29:20Z"
            },
            {
                "author": "PiotrMitkowski",
                "bodyText": "Updating to 3.3 only didn't fix the issue in my project\n\nHow did you check the issue doesn't occur in Flutter 3.3.0?\nWe also need to reproduce this issue locally to be sure it hasn't been fixed in 3.3. but we don't know how to reproduce or measure the issue.\n\nIn my case, it's a mobile application with a GoogleMap and it occasionally uses InAppWebView from this package. The flickering occurs on some iOS devices and in some cases if the user:\n\nopens the map\ngoes to menu (that is displayed over the map) and selects an option, that opens the webview\ncloses the webview\n\nI can try extracting a code sample from my app, but I won't be able to confirm if it allows reproducing the issue, because I can't reproduce it on my end.",
                "createdAt": "2022-09-05T10:35:49Z"
            },
            {
                "author": "b055man",
                "bodyText": "Can you provide a code sample? Maybe provide private access to your repo to some key persons in the Flutter team?\n\nI'll see what I can do.. no promises though, the team is fully loaded at the moment.",
                "createdAt": "2022-09-05T11:26:58Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Has anyone reporting issues here faced the same on Flutter 3.3?",
                "createdAt": "2022-09-06T01:39:26Z"
            },
            {
                "author": "talarecc",
                "bodyText": "A QA member of my team has reproduce the issue twice. Just to contextualize, we use a webview on part of our app, and here is what he does to get the flickering wonderful effect :\n\nLaunch a webview\nDrop the phone for at least 10 minutes without doing anything\nGrab the phone again, unlock, and go back to the app\n...and the phone starts the nightclub effect.\n\nHe was using an iPhone XR, iOS 15.6.1. I hope it can help you. Tomorrow, I'll try to trigger the bug with that scenario with the device plugged in with a debug session but I suppose there will be no log...",
                "createdAt": "2022-09-06T21:29:33Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@talarecc That's amazing! any chance you would be able to create a minimal test case (a program whose source you can upload here)? I understand if that's too much work. It would be hugely helpful in helping people track down the issue.",
                "createdAt": "2022-09-06T23:19:36Z"
            },
            {
                "author": "talarecc",
                "bodyText": "@Hixie Of course, I'll do that today or tomorrow but I need to double check before.\nUPDATE: We reproduced the problem a third time in the same way that I mentioned before. I'll try on a fresh project and upload it in a public repo if the scenario is verified.",
                "createdAt": "2022-09-07T05:16:56Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi all,\nThere are a couple of changes to Skia that are now available on the master channel, and which we expect to be in the 3.4 beta of Flutter.\nhttps://skia-review.googlesource.com/c/skia/+/575667 <- We suspect that this may fix a race in command buffer submission when going into the background.\nhttps://skia-review.googlesource.com/c/skia/+/566883 <- If that change does not fix the flickering issue, then this change will give more verbose logs when command buffers fail.\n@talarecc Not sure what version of Flutter you were using, but if your repro is reliable on 3.0 or 3.3 on the stable channel, it would be a big help if you could give it a shot on master channel. If you still see flickering on master channel, then if you can share the full device logs starting from slightly before the flickering starts to happen, that would be incredibly useful.\nThanks everyone for your patience on this issue. Hopefully we're getting close.",
                "createdAt": "2022-09-07T17:02:09Z"
            },
            {
                "author": "talarecc",
                "bodyText": "Hello @zanderso\nThe app is currently running on version 3.0.\nI'm sorry, I tried to reproduce the issue on a fresh 3.0 install on an iPhone 12 (15.6.1), but nothing...\nThe \"good\" news is that QA members of my team can reproduce it 100% (see scenario from previous comment) from DEV build (on 3.0) BUT it seems that the bug occurs from our use of the inappwebview package because I can't get it on a new flutter project.\nAlso, sorry but I can't provide the project I am working on. It is a commercial app (in production) of a big european company. \u2639\ufe0f\nI only can show this... but I don't think it could help, and it looks like crashlytics doesn't catch any logs from this issue...\nInAppWebView(\n                key: _key,\n                initialOptions: state.options,\n                onWebViewCreated: onWebViewCreated,\n                onUpdateVisitedHistory: controller.historyChange,\n                onLoadStart: (_, uri) => controller.onLoadStart(uri),\n                onLoadStop: (_, uri) => controller.onLoadStop(uri),\n                onLoadError: (_, uri, code, message) => controller.onLoadError(uri, code, message),\n                androidOnPermissionRequest: (controller, origin, resources) async {\n                  return PermissionRequestResponse(resources: resources, action: PermissionRequestResponseAction.GRANT);\n                },\n                shouldOverrideUrlLoading: (controller, navigationAction) async {\n                  return NavigationActionPolicy.ALLOW;\n                },\n                onConsoleMessage: (_, message) {\n                  if (kDebugMode) {\n                    print(message);\n                  }\n                },\n              )",
                "createdAt": "2022-09-07T17:20:13Z"
            },
            {
                "author": "Hixie",
                "bodyText": "If you can make a flutter project that uses inappwebview that would still be useful, doesn't have to be just the fresh template. Doesn't have to be pretty code, either. Just whatever tickles the bug, so that we can figure out what's going on in the background.",
                "createdAt": "2022-09-07T17:41:22Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Hi all,\nThere are a couple of changes to Skia that are now available on the master channel, and which we expect to be in the 3.4 beta of Flutter.\nhttps://skia-review.googlesource.com/c/skia/+/575667 <- We suspect that this may fix a race in command buffer submission when going into the background.\nhttps://skia-review.googlesource.com/c/skia/+/566883 <- If that change does not fix the flickering issue, then this change will give more verbose logs when command buffers fail.\n@talarecc Not sure what version of Flutter you were using, but if your repro is reliable on 3.0 or 3.3 on the stable channel, it would be a big help if you could give it a shot on master channel. If you still see flickering on master channel, then if you can share the full device logs starting from slightly before the flickering starts to happen, that would be incredibly useful.\nThanks everyone for your patience on this issue. Hopefully we're getting close.\n\nhttps://github.com/flutter/flutter/releases/tag/3.4.0-18.0.pre ? Has it been merged?",
                "createdAt": "2022-09-08T02:57:51Z"
            },
            {
                "author": "Tom3652",
                "bodyText": "I still have this issue in my app, i had made #97910 this year when i thought it was related to the call of several methods when the app becomes in inactive state.\nThe pattern i had from my beta testers was :\n\nUse the app\nOn iOS swipe up to go back to the home screen, on Android use the backstack\nOn iOS the app made the phone frozen few seconds (like i got with the error in the linked issue, with some GPU buffer error)\nThen the app disappeared like during a crash but was not in terminated state\nThe user opens back the app from the phone's home screen\nResuming the app after that was causing the flickering (as shown in the first comment of this issue) \"forever\" in this \"app session\"\nKill the app and launch it again fixes the flickering  until the next GPU error\n\nNote : This was reproductible 1 time over a hundred and my app doesn't have any  webviews inside.\nI will attach a video next time i experience it (because i still do on flutter 3.3)",
                "createdAt": "2022-09-08T19:45:47Z"
            },
            {
                "author": "zanderso",
                "bodyText": "To reiterate, we're interesting in knowing whether this issue reproduces on the master channel, and if it does reproduce, the critical piece of information we need is logs from the device starting from just before the flickering starts.",
                "createdAt": "2022-09-08T19:53:07Z"
            },
            {
                "author": "b055man",
                "bodyText": "@zanderso it reproduces when I rebuilt the app with Flutter 3.4.0-19.0.pre.151 :/\nBtw, not sure if that matters, but this app is not migrated to null-safety yet (only portions of it).\nWhat are the exact logs you're interested with? Console logs, of the 'Runner'? Any particular message to look for?\n[Edit] I checked the commit you referred earlier - I can't find any buffer-related messages in the Console that could be related to this issue.\nAlso, a note: in my case there's no relation with going into background or anything like that. It's likely a matter of poor phone's performance (iPhone 5s) and the issue can be triggered with the app opened, without changing its state.",
                "createdAt": "2022-09-08T23:11:22Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@b055man if the issue you are seeing isn't triggered by going into or coming from the background, then the changes in Skia wouldn't have been exercised. It's possible you are seeing a different issue entirely, one that potentially only affects the older devices. If possible, could you file a new issue with a video and cc me? Thanks! (Apologies if you've already posted something like this upthread. Unfortunately, there are a lot of comments on this issue, and the GitHub interface is not very helpful in this situation.)",
                "createdAt": "2022-09-09T01:49:13Z"
            },
            {
                "author": "wangyan-png",
                "bodyText": "I also encountered this problem. Flutter version 2.10.0 found that it occasionally appeared when using videoplayer to play the m3u8 application and cut the background. Hope to solve it",
                "createdAt": "2022-09-09T07:15:55Z"
            },
            {
                "author": "b055man",
                "bodyText": "@zanderso you're right, it may be a different issue.\nOne extra info though, I mentioned earlier, that in the case of this app the trigger of the problem is toggling video player between portrait and landscape mode (by calling SystemChrome.setEnabledSystemUIMode / SystemChrome.setPreferredOrientations). Any chance that calling these methods is similar in a way to the 'going from background' case?",
                "createdAt": "2022-09-09T07:56:42Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "Is there a way for us to check which releases have the skia fixes? Is it only master right now or does the 3.4.0-18.0.pre release also have it already?\nEdit: followed the trail, it does not, we have to use master for now",
                "createdAt": "2022-09-09T09:16:43Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@knaeckeKami Were you able to test this on the master branch by any chance? Has the issue been resolved, or did you still see it?",
                "createdAt": "2022-09-13T23:11:23Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "We are testing this right now. We did not see it yet with a build on the master branch, but we also don't have a reliable way of triggering it, and it happened only very rarely. So it might take 2-3 weeks until we can say with some confidence that it is really gone.",
                "createdAt": "2022-09-13T23:48:28Z"
            },
            {
                "author": "moffatman",
                "bodyText": "If I ever see this while running in debug mode, are there any buttons I should press or things to do to capture useful data? Seems like console output is not helpful, and I would need to have been running with --trace-skia already?",
                "createdAt": "2022-09-14T00:31:51Z"
            },
            {
                "author": "simonpham",
                "bodyText": "I am able to reproduce it with one of my app by quickly swipe up to go back to the home screen after doing 1 action (not sure, but can reproduce 100 out of 100 times). I will verify it on master branch later and give you guys updates.\nUpdated: mission abort. I cannot reproducce it on my latest code & master branch of Flutter. Using my old code takes time for the migration to make it running on master branch of Flutter.",
                "createdAt": "2022-09-14T09:21:14Z"
            },
            {
                "author": "mohamedsidique94",
                "bodyText": "I also getting the same flickering issue. Intermittently happening.\nWill post video and more details if I can find.\nOnly details with which I can contribute is\niOS version - 15.6.1\nModel - Iphone 13",
                "createdAt": "2022-09-14T13:14:36Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "@simonpham any chance you got to try it out already?",
                "createdAt": "2022-09-18T17:03:27Z"
            },
            {
                "author": "simonpham",
                "bodyText": "@simonpham any chance you got to try it out already?\n\nSorry. I cannot do it.\n\nUpdated: mission abort. I cannot reproducce it on my latest code & master branch of Flutter. Using my old code takes time for the migration to make it running on master branch of Flutter.\n\nHere's what happened when I was able to reproduce the issue:\n\nPush a new Scaffold.\nI quickly swipe up.\nThis Scaffold show a CircularProgressIndicator (loading).\nI quickly go back to the app.\nThe Scaffold finished loading, main UI appear.\nMain UI freeze & flickering.",
                "createdAt": "2022-09-20T15:35:54Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@talarecc You had mentioned you had a QA person who could reproduce this reliably \u2014 any chance you've been able to test this on the latest master build? Does it still happen? If yes, can you post the logs they get now on master (if any)?",
                "createdAt": "2022-09-20T23:09:34Z"
            },
            {
                "author": "boichuk-oleh",
                "bodyText": "Maybe it will be useful.\nCrash on flutter 3.3.2\niOS version - 14.8.1\nModel - Iphone 7\nProfile mode\nRunner(534,0x16bbf7000) malloc: *** error for object 0xa203: pointer being freed was not allocated\nRunner(534,0x16bbf7000) malloc: *** set a breakpoint in malloc_error_break to debug\n* thread #9, name = 'io.flutter.1.raster', stop reason = signal SIGABRT\n    frame #0: 0x00000001d296b7b0 libsystem_kernel.dylib`__pthread_kill + 8\nlibsystem_kernel.dylib`:\n->  0x1d296b7b0 <+8>:  b.lo   0x1d296b7cc               ; <+36>\n    0x1d296b7b4 <+12>: stp    x29, x30, [sp, #-0x10]!\n    0x1d296b7b8 <+16>: mov    x29, sp\n    0x1d296b7bc <+20>: bl     0x1d29481fc               ; cerror_nocancel\nTarget 0: (Runner) stopped.\nLost connection to device.",
                "createdAt": "2022-09-22T13:49:34Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@boichuk-oleh That crash appears to be unrelated to this issue. Could you please file a new issue with full details including a  backtrace for the crash? Thanks!",
                "createdAt": "2022-09-22T15:24:03Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@mohamedsidique94 were you able to make a video? did you figure out steps to reproduce by any chance?",
                "createdAt": "2022-09-27T23:05:36Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@jackTang11 You are seeing a different issue. Please file a new issue with full details. Thanks!",
                "createdAt": "2022-09-28T01:09:14Z"
            },
            {
                "author": "337240552",
                "bodyText": "We have encountered the same issue.  Flutter SDK 3.0.5 on Anddroid platform.\n\nI have experienced the same problem (both IOS and Android) in two of my apps since the upgrade from 2.8 to 2.10. But the issue happens randomly. so far I cannot isolate and replicate the bug. It happens when the screen either has a lot of images or playing video.",
                "createdAt": "2022-09-29T02:31:52Z"
            },
            {
                "author": "mohamedsidique94",
                "bodyText": "@Hixie. It appeared only once on the testing build few days back. Unfortunately I am not able to capture the video of it\n.",
                "createdAt": "2022-09-29T08:11:40Z"
            },
            {
                "author": "serhatuysal",
                "bodyText": "",
                "createdAt": "2022-09-29T12:33:00Z"
            },
            {
                "author": "giovanniguarino",
                "bodyText": "Hello, I have the same issue in iOS. My app is a web view and I use Flutter 3.3.2 and webview_flutter 3.0.4.\n[\u2713] Flutter (Channel stable, 3.3.2, on macOS 12.6 21G115 darwin-arm, locale en-MX)\n\u2022 Flutter version 3.3.2 on channel stable at /Users/giovanni/flutter\n\u2022 Upstream repository https://github.com/flutter/flutter.git\n\u2022 Framework revision e3c29ec (2 weeks ago), 2022-09-14 08:46:55 -0500\n\u2022 Engine revision a4ff2c53d8\n\u2022 Dart version 2.18.1\n\u2022 DevTools version 2.15.0\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 32.1.0-rc1)\n\u2022 Android SDK at /Users/giovanni/Library/Android/sdk\n\u2022 Platform android-32, build-tools 32.1.0-rc1\n\u2022 ANDROID_HOME = /Users/giovanni/Library/Android/sdk\n\u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/Contents/Home/bin/java\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.11+0-b60-7772763)\n\u2022 All Android licenses accepted.\n[\u2713] Xcode - develop for iOS and macOS (Xcode 14.0.1)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 Build 14A400\n\u2022 CocoaPods version 1.11.3\n[\u2713] Chrome - develop for the web\n\u2022 Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome\n[\u2713] Android Studio (version 2021.1)\n\u2022 Android Studio at /Applications/Android Studio.app/Contents\n\u2022 Flutter plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/9212-flutter\n\u2022 Dart plugin can be installed from:\n\ud83d\udd28 https://plugins.jetbrains.com/plugin/6351-dart\n\u2022 Java version OpenJDK Runtime Environment (build 11.0.11+0-b60-7772763)\n[\u2713] VS Code (version 1.71.2)\n\u2022 VS Code at /Applications/Visual Studio Code.app/Contents\n\u2022 Flutter extension version 3.48.0\n[\u2713] Connected device (2 available)\n\u2022 macOS (desktop) \u2022 macos  \u2022 darwin-arm64   \u2022 macOS 12.6 21G115 darwin-arm\n\u2022 Chrome (web)    \u2022 chrome \u2022 web-javascript \u2022 Google Chrome 105.0.5195.125\n[\u2713] HTTP Host Availability\n\u2022 All required HTTP hosts are available\n\u2022 No issues found!",
                "createdAt": "2022-09-29T14:12:45Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I still have this issue in my app, i had made #97910 this year when i thought it was related to the call of several methods when the app becomes in inactive state.\nThe pattern i had from my beta testers was :\n\nUse the app\nOn iOS swipe up to go back to the home screen, on Android use the backstack\nOn iOS the app made the phone frozen few seconds (like i got with the error in the linked issue, with some GPU buffer error)\nThen the app disappeared like during a crash but was not in terminated state\nThe user opens back the app from the phone's home screen\nResuming the app after that was causing the flickering (as shown in the first comment of this issue) \"forever\" in this \"app session\"\nKill the app and launch it again fixes the flickering  until the next GPU error\n\nNote : This was reproductible 1 time over a hundred and my app doesn't have any webviews inside. I will attach a video next time i experience it (because i still do on flutter 3.3)\n\nI think he's right,GPU working error, can you tell me how to capture the log,thanks, My app happens many times a day, but it can't happen in debug mode,  @zanderso",
                "createdAt": "2022-09-29T22:33:01Z"
            },
            {
                "author": "jmagman",
                "bodyText": "If you're only able to reproduce on a release version of your app, the Skia changes added os logging which we should be able to see if you reproduce, note the time it happened, then collect a sysdiagnose from the device and send it to us.\nI haven't been able to reliably collect a sysdiagnose from pressing physical buttons in a few iOS releases.  The \"easiest\" way I've found is to:\n\nSettings > Accessibility > Touch > AssistiveTouch > Toggle on, then Single-Tap > Analytics.  When the white button appears on the screen, tap it.  You should see a notification at the top that analytics are being collected.  At that point you can turn AssistiveTouch back off.\nWait ~5 minutes\nSettings > Privacy & Security > Analytics & Improvements > Analytics Data.  Find the sysdiagnose_2022... with the matching timestamp.  Select it, choose the Share button in the top right corner.  You can Airdrop it to your Mac, or email it to yourself.\nOnce you have the sysdiagnose on your Mac, you can peek in the logs.  Inside the sysdiagnose there is a bundle called system_logs.logarchive.  On the command line, run (this assumes your process is the default \"Runner\":\n\n$ /usr/bin/log show /path/to/sysdiagnose_2022.../system_logs.logarchive --predicate \"process = 'Runner'\" > ~/Desktop/flutter_log.txt\n\n\nOpen ~/Desktop/flutter_log.txt and confirm it contains some logging (columns with timestamps, etc), then attach it to this GitHub issue.  Make sure to also share the time you reproduced the flickering so we can narrow down where in the logs to look.\n\nNote sysdiagnoses contain personally identifiable information.  Be cautious sharing them.  Unless you are reproducing on a test device do not send the link to the full sysdiagnose in GitHub.  You can reach out to us on Discord to coordinate sharing, if needed https://discord.gg/BS8KZyg.\nThank you!",
                "createdAt": "2022-10-04T23:35:04Z"
            },
            {
                "author": "mafanwei",
                "bodyText": "I have the same problem with flutter 3.3.2.",
                "createdAt": "2022-10-11T07:13:41Z"
            },
            {
                "author": "hmbadhon",
                "bodyText": "App screen flickers and freezes, when I restart it, it goes away. This happened on my latest version flutter 3.3.3, it occur very rarely.",
                "createdAt": "2022-10-12T03:18:38Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@mafanwei @hmbadhon are you able to get logs as per #100522 (comment) ? Without logs we cannot make progress here.",
                "createdAt": "2022-10-18T23:24:43Z"
            },
            {
                "author": "trueb2",
                "bodyText": "I\u2019ve experienced this flickering several times this week on 3.3.2. I have an iOS app that stays running the background all the time because it stays connected with CoreBluetooth. It also uses the GPU/Neural Engine periodically to inference on data received over Bluetooth. CoreML will automatically use CPU while in the background and GPU/Neural Engine in the foreground. I don\u2019t have any platform views, but since I have experienced the flickering, I am interested in the race condition fix on master.\nI last experienced the flickering while confirming CPU and energy usage in Xcode while alternating between foreground and background over various periods of time while periodically receiving and inferencing.\nI have reproduced with release builds installed (and actively logging) with Xcode but didn\u2019t see any error logs \u2026 I would like to run with the fix from last month. At this point, is the beta or master build the build to test?",
                "createdAt": "2022-10-21T00:58:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "I recommend testing on master to be sure.",
                "createdAt": "2022-10-25T23:03:30Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi all,\nWe have speculatively cherry-picked the Skia patches mentioned in #100522 (comment) into the stable channel, and they are now available in the 3.3.7 hotfix release. The patches include a potential fix, and additional logging in case the fix does not work. If the issue continues to happen after updating to 3.3.7, please collect and share the logs from the device starting from just before the flickering begins. Thanks for your help and patience on this!",
                "createdAt": "2022-11-02T17:50:05Z"
            },
            {
                "author": "TJRoger",
                "bodyText": "I got the same issue after upgrade to flutter 2.10.3. The issue happens randomly. the device is iOS 15.0.1. This page has a webview which is not flickering, but the appbar is flickering\nnormal.video.mp4\n\n\u8001\u94c1\uff0c\u6211\u4e5f\u9047\u5230\u4e86\u540c\u6837\u7684\u95ee\u9898\uff0c\u60f3\u95ee\u4e0b\u8fd9\u4e2a\u95ee\u9898\u6709\u89e3\u51b3\u5417\uff1f",
                "createdAt": "2022-11-03T03:54:36Z"
            },
            {
                "author": "337240552",
                "bodyText": "https://skia-review.googlesource.com/c/skia/+/575667\n@zanderso\nAndroid also has this problem.",
                "createdAt": "2022-11-03T10:17:56Z"
            },
            {
                "author": "lonyee1989",
                "bodyText": "My app has a lot of animations, so it is easy to switch back and forth to the background many times. The current test 3.3.7 still hasn't fixed it.",
                "createdAt": "2022-11-04T06:13:41Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Can you reproduce this consistently?",
                "createdAt": "2022-11-04T11:54:29Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "https://skia-review.googlesource.com/c/skia/+/575667\n@zanderso\nAndroid also has this problem.\n\n\nI highly doubt that its same issue. Do you have any recordings or more information for Android flickering?",
                "createdAt": "2022-11-04T11:57:34Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@lonyee1989 As mentioned above, 3.3.7 also included additional logging. If it is easy for you to reproduce this issue, then it would be a great help to us if you could collect and share the logs from the device. Thanks!",
                "createdAt": "2022-11-04T15:14:11Z"
            },
            {
                "author": "lonyee1989",
                "bodyText": "@lonyee1989 As mentioned above, 3.3.7 also included additional logging. If it is easy for you to reproduce this issue, then it would be a great help to us if you could collect and share the logs from the device. Thanks!\n\nI didn't see the relevant log. How can I get this log information of my mobile phone.",
                "createdAt": "2022-11-07T02:37:53Z"
            },
            {
                "author": "lonyee1989",
                "bodyText": "We have speculatively cherry-picked the Skia patches mentioned in #100522 (comment) into the stable channel, and they are now available in the 3.3.7 hotfix release. The patches include a potential fix, and additional logging in case the fix does not work. If the issue continues to happen after updating to 3.3.7, please collect and share the logs from the device starting from just before the flickering begins. Thanks for your help and patience on this!\n\n@zanderso It work well in debug mode, but it will flickering  work in release mode.\n2022-11-07 14:36:36.294111+0800 Runner[4777:2920461] Metal GPU Frame Capture Enabled\n2022-11-07 14:36:36.294240+0800 Runner[4777:2920461] Metal API Validation Enabled\n[2022-11-07 14:36:36.439] [0] [debug] /tmp/jenkins/IRIS-SDK/base/internal/log/iris_logger.cc:35 InitLogger /var/mobile/Containers/Data/Application/127F47F5-61A9-4499-AC94-3FFAA77AF131/Library/Caches/\n2022-11-07 14:36:36.481449+0800 Runner[4777:2920461] Unable to upload statistics\uff0cappkey or stats is nil\n2022-11-07 14:36:36.481471+0800 Runner[4777:2920461] device token changed, reconnect\n2022-11-07 14:36:36.954976+0800 Runner[4777:2920461] [RC-Flutter-IM] iOS setReconnectKickEnable, start param:1\n2022-11-07 14:36:36.956640+0800 Runner[4777:2920461] RCFwLog, LogMode = 0, monitorLevel = 5, monitorType = 268434431\n2022-11-07 14:36:37.073836+0800 Runner[4777:2920800] flutter: 2 has been spawned\n2022-11-07 14:36:37.075708+0800 Runner[4777:2920800] flutter: initialized\n2022-11-07 14:36:37.397608+0800 Runner[4777:2920461] [RC-Flutter-IM] iOS onConnectionStatusChanged,status:10\n2022-11-07 14:36:37.410222+0800 Runner[4777:2920461] clientIp:\n[000:000] [83203] (messagequeue.cc:523): Message took 78ms to dispatch. Posted from: Connect@/Users/jenkins/slave/workspace/iOS-SDK-Release/protocol-cpp/rcps/rcps_client_impl.cpp:546\n2022-11-07 14:36:37.488674+0800 Runner[4777:2920793] [RC-Flutter-IM] iOS connect, dbOpened\uff0ccode: 0\n\n2022-11-07 14:36:37.500244+0800 Runner[4777:2920800] [VERBOSE-2:dart_vm_initializer.cc(41)] Unhandled Exception: MissingPluginException(No implementation found for method getRCNotification on channel com.push.msg.method)\n#0      MethodChannel._invokeMethod (package:flutter/src/services/platform_channel.dart:294)\n<asynchronous suspension>\n#1      _IndexState.initNotification (package:xxxx/pages/index.dart:171)\n<asynchronous suspension>\n2022-11-07 14:36:37.515019+0800 Runner[4777:2920785] L-collection-S,host:39.105.152.201,port:443,cost:26,nettype:1,error:0\n2022-11-07 14:36:37.515146+0800 Runner[4777:2920793] L-collection-S,host:39.105.152.201,port:8000,cost:0,nettype:1,error:-1\n2022-11-07 14:36:37.515326+0800 Runner[4777:2920790] L-collection-S,host:t-tcpproxy-cn.ronghub.com,port:443,cost:0,nettype:1,error:-1\n2022-11-07 14:36:37.515342+0800 Runner[4777:2920785] L-collection-S,host:t-tcpproxy-cn.ronghub.com,port:8085,cost:0,nettype:1,error:-1\n2022-11-07 14:36:37.515615+0800 Runner[4777:2920793] [RC:IM-stats_cmp-S]data:{\"hos\":\"http:\\/\\/39.105.152.201:443\",\"fg\":1,\"spr\":0,\"dt\":0,\"pr\":0,\"bid\":\"xxxxxx.music\",\"idx\":0,\"net\":\"wifi\",\"rct\":0,\"dip\":\"\",\"cpd\":\"62BD596F2C9857C993DBCC2F2DDBE47D\",\"ddu\":0,\"dh\":[\"192.168.0.1\"],\"ptc\":2,\"cod\":0,\"cr\":[],\"dur\":26}\n[000:064] [83203] (rcps_pull_message.cpp:55): PullMessageRequest: P-reason-C;;;recv;;;1667561924461, send: 1666864666149, broadcast: 0\n2022-11-07 14:36:37.553327+0800 Runner[4777:2920461] [RC-Flutter-IM] iOS onConnectionStatusChanged,status:0\n2022-11-07 14:36:37.553685+0800 Runner[4777:2920790] [RC-Flutter-IM] iOS connect, success\n[000:173] [83203] (rcps_pull_message.cpp:98): DealWithResponse: P-reason-C;;;sync;;;1667750400000,broadcast: 0,finished: 1,size: 0\n2022-11-07 14:36:38.306210+0800 Runner[4777:2920790] [NSURLSessionTaskMetrics] 0.411221\n2022-11-07 14:36:38.307846+0800 Runner[4777:2920795] [RC:IM-stats_navi-S]data:{\"hos\":\"https:\\/\\/sirb.cn.rongnav.com\\/navi.json\",\"fg\":1,\"spr\":0,\"dt\":1,\"pr\":0,\"bid\":\"xxxxxx.music\",\"net\":\"wifi\",\"dip\":\"1.117.137.95\",\"ddu\":0,\"dh\":[\"192.168.0.1\"],\"ptc\":1,\"cod\":200,\"cr\":[],\"dur\":411}\n\n[180:066] [83203] (rcps_pull_message.cpp:55): PullMessageRequest: P-reason-C;;;recv;;;1667561924461, send: 1666864666149, broadcast: 0\n[180:535] [83203] (rcps_pull_message.cpp:98): DealWithResponse: P-reason-C;;;sync;;;1667750400000,broadcast: 0,finished: 1,size: 0",
                "createdAt": "2022-11-07T07:13:46Z"
            },
            {
                "author": "daniloapr",
                "bodyText": "I also got this, but only in debug mode and it's hard to reproduce. I'm using flutter 3.3.6 right now, but I'm not sure when it has started. I thought it was something in my code, good to know you are working on that!",
                "createdAt": "2022-11-09T13:09:05Z"
            },
            {
                "author": "cj3479",
                "bodyText": "@lonyee1989 As mentioned above, 3.3.7 also included additional logging. If it is easy for you to reproduce this issue, then it would be a great help to us if you could collect and share the logs from the device. Thanks!\n\nAndroid also has this problem\nHow to collect the android log,   do use adb logcat ?",
                "createdAt": "2022-11-10T06:48:30Z"
            },
            {
                "author": "zanderso",
                "bodyText": "@cj3479 If you are seeing something similar on Android, it is very likely a different bug. Please file a new GitHub issue with full details.",
                "createdAt": "2022-11-10T16:20:20Z"
            },
            {
                "author": "daniel-harter",
                "bodyText": "Hey for what it's worth our app has been having a lot of flickering over the past few days.  We were. using a card with a RoundedRectangleBorder and a borderRadious of BorderRadius.circular(4). Once I removed the BorderRadius.circular(4) the iOS app stopped flickering. It would still work with BorderRadius.zero. But anything with circular would caused the flickering to come back.",
                "createdAt": "2022-11-11T20:29:13Z"
            },
            {
                "author": "trueb2",
                "bodyText": "Fwiw, the speculative fix seems to work for me since it used to be so common. I haven't had flickering in a couple weeks on my aforementioned background corebluetooth and coreml use case (release builds). I see that there is a new stable version out with new logs. I will switch to running that and post logs if I catch the issue.",
                "createdAt": "2022-11-11T20:36:22Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Fwiw, the speculative fix seems to work for me since it used to be so common. I haven't had flickering in a couple weeks on my aforementioned background corebluetooth and coreml use case (release builds). I see that there is a new stable version out with new logs. I will switch to running that and post logs if I catch the issue.\n\nwhich branch did you use that fixed it?",
                "createdAt": "2022-11-12T02:42:14Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "I also did not get any reports of flickering recently.\nSo another datapoint to suggest that it might have been fixed :)",
                "createdAt": "2022-11-12T12:06:38Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I also did not get any reports of flickering recently. So another datapoint to suggest that it might have been fixed :)\n\nwhich branch did you use that fixed it?",
                "createdAt": "2022-11-12T12:08:25Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "Currently using stable. Was using master before.",
                "createdAt": "2022-11-12T12:17:36Z"
            },
            {
                "author": "EArminjon",
                "bodyText": "Currently using stable. Was using master before.\n\nSpecify your exact version please, 3.3.8 ?",
                "createdAt": "2022-11-12T13:19:45Z"
            },
            {
                "author": "knaeckeKami",
                "bodyText": "3.3.7, since this is the version that had the speculative fixes. Did not upgrade to 3.3.8 but since this has just a few bugfixes it would have the same behaviour regarding this issue.\nBut please note that I only had very few reports of this happening, and I could not reproduce it reliably. I cannot say for sure if we just got lucky in the last weeks.",
                "createdAt": "2022-11-12T13:28:04Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I still have the flickering issue on 3.3.7 and 3.3.8.",
                "createdAt": "2022-11-13T00:20:50Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Do you have any videos, so we can see it's the same flickering from this issue?",
                "createdAt": "2022-11-13T00:22:13Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Do you have any videos, so we can see it's the same flickering from this issue?",
                "createdAt": "2022-11-13T00:31:05Z"
            },
            {
                "author": "feinstein",
                "bodyText": "Do you have any logs from this? Can you reproduce it?",
                "createdAt": "2022-11-13T00:49:48Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Do you have any logs from this? Can you reproduce it?\n\nI can't reproduce it, it's all accidental, because of privacy, I deleted the above video, this is in the production environment, how to get the log, can firebase capture it?",
                "createdAt": "2022-11-13T01:02:01Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "Hi all,\nWe have speculatively cherry-picked the Skia patches mentioned in #100522 (comment) into the stable channel, and they are now available in the 3.3.7 hotfix release. The patches include a potential fix, and additional logging in case the fix does not work. If the issue continues to happen after updating to 3.3.7, please collect and share the logs from the device starting from just before the flickering begins. Thanks for your help and patience on this!\n\nI still have the flickering issue on 3.3.7 and 3.3.8.",
                "createdAt": "2022-11-13T01:05:04Z"
            },
            {
                "author": "feinstein",
                "bodyText": "@zanderso are the logs being generated with a print?\nThis is important because I think many production apps won't save prints to Crashlytics, unless they capture it in the zone and forward it to Crashlytics.",
                "createdAt": "2022-11-13T01:06:57Z"
            },
            {
                "author": "lcdsmao",
                "bodyText": "Hi\nWe collected some logs via this method #100522 (comment) when flickering occurred.\nAnd would like to share those logs through Discord to see whether it can get help.\nThere are two types of flickering we are facing now and all happened when we switch back the App from the background to the foreground:\n\nApp crashed after flickering for a second\nApp becomes normal after flickering for a second\n\nAnother question is that before using the flutter version that does not contain cherry-picks mentioned in #100522 (comment), flickering can occur during the internal transition of the app. But currently, we cannot produce flickering in this scenario via manually performing some operations or via a Monkey Test that simulates clicking and scrolling. We are curious about whether #100522 (comment) fixes this flickering scenario.",
                "createdAt": "2022-11-14T06:11:05Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@lcdsmao Can you attach the logs here? (Maybe after scrubbing them of anything sensitive.)\nIf you'd prefer to talk on Discord, you can find the link to our server in the contributing guidelines (link just below here).",
                "createdAt": "2022-11-16T00:14:34Z"
            },
            {
                "author": "lcdsmao",
                "bodyText": "Hi @Hixie\nI sent logs to @zanderso however these logs seem not to help too much.\n\nFrom the logs with crashes, it looks like some information is left out due to your local logging settings. The lines \"2022-10-31 11:43:38.027838+0900 0x8e0a14   Error       0x0                  33725  0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. <private>\" don't have the information about the specific error. It's replaced by <private>\".\n\nWe need to adjust the Xcode build settings and collect some new logs.\nIt would be helpful if you could let me know any settings we need to adjust.",
                "createdAt": "2022-11-16T01:10:55Z"
            },
            {
                "author": "delfme",
                "bodyText": "Just experienced this issue this morning with flutter 3.3.7 and iOS 15.2.\nHad to quit and re-launch app.\nApp was already loaded in the emulator from yesterday and there is a simple animation in the screen.\nThis is the only hint I can provide.\nBasically, I logged in my macbook and found my app flashing.",
                "createdAt": "2022-11-16T10:17:15Z"
            },
            {
                "author": "feinstein",
                "bodyText": "@delfme can you collect the logs from your emulator following the steps in #100522 (comment) ?",
                "createdAt": "2022-11-16T11:56:04Z"
            },
            {
                "author": "delfme",
                "bodyText": "@feinstein unfortunately I cant. But I recalled I had same issue while playing with this plugin's example. It was random and couldn't reproduce it. https://github.com/delfme/keyboard_attachable",
                "createdAt": "2022-11-17T08:29:02Z"
            },
            {
                "author": "lcdsmao",
                "bodyText": "Hi @Hixie @zanderso\nI found the crash stack traces in our Sentry log when flickering occurred.\nHere are two stack traces:\n\nStack Traces\nOS Version: iOS 15.6.1 (19G82)\nReport Version: 104\n\nException Type: EXC_BAD_ACCESS (SIGBUS)\nException Codes: BUS_NOOP at 0x0000d4122b72ec50\nCrashed Thread: 3\n\nApplication Specific Information:\nrelease >\nAttempted to dereference garbage pointer 0xd4122b72ec50.\n\nThread 3 Crashed:\n0   libobjc.A.dylib                 0x374cabf40         objc_msgSend\n1   Metal                           0x3786820e8         -[_MTLCommandBuffer dealloc]\n2   IOGPU                           0x404359a04         -[IOGPUMetalCommandBuffer dealloc]\n3   AGXMetalA12                     0x427e0ff80         <redacted>\n4   libobjc.A.dylib                 0x374cb1b10         AutoreleasePoolPage::releaseUntil\n5   libobjc.A.dylib                 0x374cade50         objc_autoreleasePoolPop\n6   CoreFoundation                  0x3431f2674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n7   CoreFoundation                  0x343176650         __CFRunLoopDoTimer\n8   CoreFoundation                  0x343170dfc         __CFRunLoopDoTimers\n9   CoreFoundation                  0x34314f4ac         __CFRunLoopRun\n10  CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n11  Flutter                         0x1074a1094         <redacted>\n12  Flutter                         0x1074a0b84         <redacted>\n13  libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 0\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   GraphicsServices                0x37b457370         GSEventRunModal\n6   UIKitCore                       0x347f54b54         -[UIApplication _run]\n7   UIKitCore                       0x347cd608c         UIApplicationMain\n8   Runner                          0x2046a4f80         <redacted>\n9   <unknown>                       0x104c0dda4         <redacted>\n\nThread 1 name: com.apple.uikit.eventfetch-thread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Foundation                      0x34614d440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x34618ee08         -[NSRunLoop(NSRunLoop) runUntilDate:]\n7   UIKitCore                       0x347ececc0         -[UIEventFetcher threadMain]\n8   Foundation                      0x34619d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 2 name: io.flutter.1.ui\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Flutter                         0x1074a1094         <redacted>\n6   Flutter                         0x1074a0b84         <redacted>\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 3 name: io.flutter.1.raster Crashed:\n0   libobjc.A.dylib                 0x374cabf40         objc_msgSend\n1   Metal                           0x3786820e8         -[_MTLCommandBuffer dealloc]\n2   IOGPU                           0x404359a04         -[IOGPUMetalCommandBuffer dealloc]\n3   AGXMetalA12                     0x427e0ff80         <redacted>\n4   libobjc.A.dylib                 0x374cb1b10         AutoreleasePoolPage::releaseUntil\n5   libobjc.A.dylib                 0x374cade50         objc_autoreleasePoolPop\n6   CoreFoundation                  0x3431f2674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n7   CoreFoundation                  0x343176650         __CFRunLoopDoTimer\n8   CoreFoundation                  0x343170dfc         __CFRunLoopDoTimers\n9   CoreFoundation                  0x34314f4ac         __CFRunLoopRun\n10  CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n11  Flutter                         0x1074a1094         <redacted>\n12  Flutter                         0x1074a0b84         <redacted>\n13  libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 4 name: io.flutter.1.io\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Flutter                         0x1074a1094         <redacted>\n6   Flutter                         0x1074a0b84         <redacted>\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 5 name: io.worker.1\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 6 name: io.worker.2\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 7 name: io.worker.3\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 8 name: io.worker.4\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 9 name: io.worker.5\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 10 name: io.worker.6\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x107211334         <redacted>\n3   Flutter                         0x10749b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 11 name: dart:io EventHandler\n0   libsystem_kernel.dylib          0x3b27b0e18         kevent\n1   Flutter                         0x107680314         <redacted>\n2   Flutter                         0x1076b05c0         <redacted>\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 12 name: AVAudioSession Notify Thread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   AudioSession                    0x355da4f00         CADeprecated::GenericRunLoopThread::Entry\n6   AudioSession                    0x355dae8ec         CADeprecated::CAPThread::Entry\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 13\n0   libsystem_kernel.dylib          0x3b27afa2c         __semwait_signal\n1   libsystem_c.dylib               0x35945f0e0         nanosleep\n2   libsystem_c.dylib               0x359473384         sleep\n3   Sentry                          0x1067a66c4         <unknown> + 676\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 14 name: SentryCrash Exception Handler (Secondary)\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   Sentry                          0x1067b2384         <unknown> + 172\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 16 name: io.sentry.app-hang-tracker\n0   libsystem_kernel.dylib          0x3b27afa2c         __semwait_signal\n1   libsystem_c.dylib               0x35945f0e0         nanosleep\n2   Foundation                      0x3461afce4         +[NSThread sleepForTimeInterval:]\n3   Sentry                          0x1067985d0         <unknown> + 436\n4   Foundation                      0x34619d418         __NSThread__start__\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 17 name: com.apple.NSURLConnectionLoader\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   CFNetwork                       0x3444021d8         _CFURLStorageSessionDisableCache\n6   Foundation                      0x34619d418         __NSThread__start__\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 18 name: GAIThread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Foundation                      0x34614d440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x34614dbfc         -[NSRunLoop(NSRunLoop) run]\n7   Runner                          0x2046aa75c         <redacted>\n8   Foundation                      0x34619d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 19 name: com.apple.CoreMotion.MotionThread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   CoreFoundation                  0x3431e3da4         CFRunLoopRun\n6   CoreMotion                      0x35daaca98         CLMotionActivity::isTypeInVehicle\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 20 name: JavaScriptCore libpas scavenger\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   JavaScriptCore                  0x3596f50b4         scavenger_thread_main\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 21\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 22\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 23\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 24\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 25 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 26\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 27\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 28\n0   libz.1.dylib                    0x424c39b88         inflateInit2_\n1   libz.1.dylib                    0x424c3bb0c         gzdopen\n2   libz.1.dylib                    0x424c37a60         deflate\n3   GoogleDataTransport             0x1056248c8         <unknown> + 300\n4   GoogleDataTransport             0x105627ba4         <unknown> + 100\n5   FBLPromises                     0x104b59508         <unknown> + 40\n6   libdispatch.dylib               0x342b3fe68         _dispatch_call_block_and_release\n7   libdispatch.dylib               0x342b41a2c         _dispatch_client_callout\n8   libdispatch.dylib               0x342b49200         _dispatch_lane_serial_drain\n9   libdispatch.dylib               0x342b49c7c         _dispatch_lane_invoke\n10  libdispatch.dylib               0x342b544fc         _dispatch_workloop_worker_thread\n11  libsystem_pthread.dylib         0x4255f50b8         _pthread_wqthread\n\nThread 29\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 30\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 31\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 32\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 33\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 34\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 35\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 36\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 37\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 38\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107780230         <redacted>\n4   Flutter                         0x107829b60         <redacted>\n5   Flutter                         0x1077ebc68         <redacted>\n6   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 39\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 40\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107780230         <redacted>\n4   Flutter                         0x107829b60         <redacted>\n5   Flutter                         0x1077ebc68         <redacted>\n6   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 41\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107780230         <redacted>\n4   Flutter                         0x107829b60         <redacted>\n5   Flutter                         0x1077ebc68         <redacted>\n6   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 42\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x1077ec29c         <redacted>\n3   Flutter                         0x107829b2c         <redacted>\n4   Flutter                         0x1077ebc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\n\n\nEOF\n\n\nOS Version: iOS 15.6.1 (19G82)\nReport Version: 104\n\nException Type: EXC_BAD_ACCESS (SIGBUS)\nException Codes: BUS_NOOP at 0x00000005a71d6600\nCrashed Thread: 3\n\nApplication Specific Information:\nerror > Error submitting command buffer.\n > status > ZTUM >\nAttempted to dereference garbage pointer 0x5a71d6600.\n\nThread 3 Crashed:\n0   libobjc.A.dylib                 0x374cad9d0         objc_retain\n1   Flutter                         0x103acae04         <redacted>\n2   Flutter                         0x103a2b87c         <redacted>\n3   Flutter                         0x103de10fc         <redacted>\n4   Flutter                         0x103cd7d34         <redacted>\n5   Flutter                         0x103c16c24         <redacted>\n6   Flutter                         0x103c16eec         <redacted>\n7   Flutter                         0x103b3f648         <redacted>\n8   Flutter                         0x103c165fc         <redacted>\n9   Flutter                         0x103c17e3c         <redacted>\n10  Flutter                         0x103c1712c         <redacted>\n11  Flutter                         0x103c2c7f4         <redacted>\n12  Flutter                         0x103b3de90         <redacted>\n13  Flutter                         0x103b40fa8         <redacted>\n14  CoreFoundation                  0x3431f2674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n15  CoreFoundation                  0x343176650         __CFRunLoopDoTimer\n16  CoreFoundation                  0x343170dfc         __CFRunLoopDoTimers\n17  CoreFoundation                  0x34314f4ac         __CFRunLoopRun\n18  CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n19  Flutter                         0x103b41094         <redacted>\n20  Flutter                         0x103b40b84         <redacted>\n21  libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 0\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   GraphicsServices                0x37b457370         GSEventRunModal\n6   UIKitCore                       0x347f54b54         -[UIApplication _run]\n7   UIKitCore                       0x347cd608c         UIApplicationMain\n8   Runner                          0x200d64fa0         <redacted>\n9   <unknown>                       0x100fb9da4         <redacted>\n\nThread 1 name: com.apple.uikit.eventfetch-thread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Foundation                      0x34614d440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x34618ee08         -[NSRunLoop(NSRunLoop) runUntilDate:]\n7   UIKitCore                       0x347ececc0         -[UIEventFetcher threadMain]\n8   Foundation                      0x34619d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 2 name: io.flutter.1.ui\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Flutter                         0x103b41094         <redacted>\n6   Flutter                         0x103b40b84         <redacted>\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 3 name: io.flutter.1.raster Crashed:\n0   libobjc.A.dylib                 0x374cad9d0         objc_retain\n1   Flutter                         0x103acae04         <redacted>\n2   Flutter                         0x103a2b87c         <redacted>\n3   Flutter                         0x103de10fc         <redacted>\n4   Flutter                         0x103cd7d34         <redacted>\n5   Flutter                         0x103c16c24         <redacted>\n6   Flutter                         0x103c16eec         <redacted>\n7   Flutter                         0x103b3f648         <redacted>\n8   Flutter                         0x103c165fc         <redacted>\n9   Flutter                         0x103c17e3c         <redacted>\n10  Flutter                         0x103c1712c         <redacted>\n11  Flutter                         0x103c2c7f4         <redacted>\n12  Flutter                         0x103b3de90         <redacted>\n13  Flutter                         0x103b40fa8         <redacted>\n14  CoreFoundation                  0x3431f2674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n15  CoreFoundation                  0x343176650         __CFRunLoopDoTimer\n16  CoreFoundation                  0x343170dfc         __CFRunLoopDoTimers\n17  CoreFoundation                  0x34314f4ac         __CFRunLoopRun\n18  CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n19  Flutter                         0x103b41094         <redacted>\n20  Flutter                         0x103b40b84         <redacted>\n21  libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 4 name: io.flutter.1.io\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Flutter                         0x103b41094         <redacted>\n6   Flutter                         0x103b40b84         <redacted>\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 5 name: io.worker.1\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 6 name: io.worker.2\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 7 name: io.worker.3\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 8 name: io.worker.4\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 9 name: io.worker.5\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 10 name: io.worker.6\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   Flutter                         0x1038b1334         <redacted>\n3   Flutter                         0x103b3b328         <redacted>\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 11 name: dart:io EventHandler\n0   libsystem_kernel.dylib          0x3b27b0e18         kevent\n1   Flutter                         0x103d20314         <redacted>\n2   Flutter                         0x103d505c0         <redacted>\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 12 name: AVAudioSession Notify Thread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   AudioSession                    0x355da4f00         CADeprecated::GenericRunLoopThread::Entry\n6   AudioSession                    0x355dae8ec         CADeprecated::CAPThread::Entry\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 13 name: JavaScriptCore libpas scavenger\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc294         _pthread_cond_wait\n2   JavaScriptCore                  0x3596f50b4         scavenger_thread_main\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 14 name: com.apple.NSURLConnectionLoader\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   CFNetwork                       0x3444021d8         _CFURLStorageSessionDisableCache\n6   Foundation                      0x34619d418         __NSThread__start__\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 15\n0   libsystem_kernel.dylib          0x3b27afa2c         __semwait_signal\n1   libsystem_c.dylib               0x35945f0e0         nanosleep\n2   libsystem_c.dylib               0x359473384         sleep\n3   Sentry                          0x102e626c4         <unknown> + 676\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 16 name: SentryCrash Exception Handler (Secondary)\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   Sentry                          0x102e6e384         <unknown> + 172\n3   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 18 name: io.sentry.app-hang-tracker\n0   libsystem_kernel.dylib          0x3b27afa2c         __semwait_signal\n1   libsystem_c.dylib               0x35945f0e0         nanosleep\n2   Foundation                      0x3461afce4         +[NSThread sleepForTimeInterval:]\n3   Sentry                          0x102e545d0         <unknown> + 436\n4   Foundation                      0x34619d418         __NSThread__start__\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 19 name: GAIThread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   Foundation                      0x34614d440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x34614dbfc         -[NSRunLoop(NSRunLoop) run]\n7   Runner                          0x200d6a77c         <redacted>\n8   Foundation                      0x34619d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 20 name: com.apple.coremedia.rootQueue.47\n0   libsystem_kernel.dylib          0x3b27af4f4         semaphore_timedwait_trap\n1   libdispatch.dylib               0x342b42044         _dispatch_sema4_timedwait\n2   libdispatch.dylib               0x342b42638         _dispatch_semaphore_wait_slow\n3   libdispatch.dylib               0x342b52f34         _dispatch_worker_thread\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 21 name: com.apple.coremedia.rootQueue.47\n0   libsystem_kernel.dylib          0x3b27af4f4         semaphore_timedwait_trap\n1   libdispatch.dylib               0x342b42044         _dispatch_sema4_timedwait\n2   libdispatch.dylib               0x342b42638         _dispatch_semaphore_wait_slow\n3   libdispatch.dylib               0x342b52f34         _dispatch_worker_thread\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 22\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 23\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 24 name: com.apple.CoreMotion.MotionThread\n0   libsystem_kernel.dylib          0x3b27af4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3b27afae0         mach_msg\n2   CoreFoundation                  0x34314ad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x34314f1b8         __CFRunLoopRun\n4   CoreFoundation                  0x343162bc4         CFRunLoopRunSpecific\n5   CoreFoundation                  0x3431e3da4         CFRunLoopRun\n6   CoreMotion                      0x35daaca98         CLMotionActivity::isTypeInVehicle\n7   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 25\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 26\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 27\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 28\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 29 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 30 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 31 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 32 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 33 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 34 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 35 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 36 name: DartWorker\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 37\n0   libsystem_pthread.dylib         0x4255f4e54         start_wqthread\n\nThread 38\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 39\n0   libsystem_kernel.dylib          0x3b27af4f4         semaphore_timedwait_trap\n1   libdispatch.dylib               0x342b42044         _dispatch_sema4_timedwait\n2   libdispatch.dylib               0x342b42638         _dispatch_semaphore_wait_slow\n3   libdispatch.dylib               0x342b52f34         _dispatch_worker_thread\n4   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\nThread 40\n0   libsystem_kernel.dylib          0x3b27afa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x4255f5104         _pthread_wqthread\n\nThread 41\n0   libsystem_kernel.dylib          0x3b27aff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x4255fc2c0         _pthread_cond_wait\n2   Flutter                         0x103e8c29c         <redacted>\n3   Flutter                         0x103ec9b2c         <redacted>\n4   Flutter                         0x103e8bc68         <redacted>\n5   libsystem_pthread.dylib         0x4255f59a8         _pthread_start\n\n\n\nEOF\n\n\nText file version:\n2022.10.26-3d94b8fd1db50fe25bc780b7465c32e99f7f2372-symbolicated.txt\n2022.10.31-3d94b8fd1db50fe25bc780b7465c32e99f7f2372-symbolicated.txt\nAll occurred when using the master branch (3d94b8f).",
                "createdAt": "2022-11-18T09:02:13Z"
            },
            {
                "author": "lcdsmao",
                "bodyText": "I updated comment with stack traces.\nCan any flutter member use @flutter-symbolizer-bot to symbolize the log?",
                "createdAt": "2022-11-24T08:58:44Z"
            },
            {
                "author": "lcdsmao",
                "bodyText": "We get new crash stack traces with flutter 3.3.8.\nThis occurred when we were doing the following steps:\n\nClick send email button on our app's email login page\niPhone seems to freeze\nGo to the background and then enter the foreground of our app again\nFlickering occurred for about 1~2 second\nThen crash\n\n\nStack traces\nOS Version: iOS 15.6.1 (19G82)\nReport Version: 104\n\nException Type: EXC_BAD_ACCESS (SIGBUS)\nException Codes: BUS_NOOP at 0x0000000a2395d9d0\nCrashed Thread: 6\n\nApplication Specific Information:\nerror > Error submitting command buffer.\n > status > ZTUM >\nAttempted to dereference garbage pointer 0xa2395d9d0.\n\nThread 6 Crashed:\n0   libobjc.A.dylib                 0x36543d9d0         objc_retain\n1   Flutter                         0x106095530         <redacted>\n2   Flutter                         0x106099bbc         <redacted>\n3   Flutter                         0x105fbee9c         <redacted>\n4   Flutter                         0x105e7f5c4         <redacted>\n5   Flutter                         0x1063a18e8         <redacted>\n6   Flutter                         0x1062b8884         <redacted>\n7   Flutter                         0x1061f3584         <redacted>\n8   Flutter                         0x1061f3b80         <redacted>\n9   Flutter                         0x1061176b0         <redacted>\n10  Flutter                         0x1061f2f90         <redacted>\n11  Flutter                         0x1061f4ba4         <redacted>\n12  Flutter                         0x1061f3e8c         <redacted>\n13  Flutter                         0x1061fdc34         <redacted>\n14  Flutter                         0x106115ec4         <redacted>\n15  Flutter                         0x1061191fc         <redacted>\n16  CoreFoundation                  0x333982674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n17  CoreFoundation                  0x333906650         __CFRunLoopDoTimer\n18  CoreFoundation                  0x333900dfc         __CFRunLoopDoTimers\n19  CoreFoundation                  0x3338df4ac         __CFRunLoopRun\n20  CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n21  Flutter                         0x1061190cc         <redacted>\n22  Flutter                         0x106118acc         <redacted>\n23  libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 0\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   GraphicsServices                0x36bbe7370         GSEventRunModal\n6   UIKitCore                       0x3386e4b54         -[UIApplication _run]\n7   UIKitCore                       0x33846608c         UIApplicationMain\n8   Runner                          0x202444c50         <redacted>\n9   <unknown>                       0x102a05da4         <redacted>\n\nThread 1\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 2\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 3 name: com.apple.uikit.eventfetch-thread\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   Foundation                      0x3368dd440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x33691ee08         -[NSRunLoop(NSRunLoop) runUntilDate:]\n7   UIKitCore                       0x33865ecc0         -[UIEventFetcher threadMain]\n8   Foundation                      0x33692d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 4\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 5 name: io.flutter.1.ui\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   Flutter                         0x1061190cc         <redacted>\n6   Flutter                         0x106118acc         <redacted>\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 6 name: io.flutter.1.raster Crashed:\n0   libobjc.A.dylib                 0x36543d9d0         objc_retain\n1   Flutter                         0x106095530         <redacted>\n2   Flutter                         0x106099bbc         <redacted>\n3   Flutter                         0x105fbee9c         <redacted>\n4   Flutter                         0x105e7f5c4         <redacted>\n5   Flutter                         0x1063a18e8         <redacted>\n6   Flutter                         0x1062b8884         <redacted>\n7   Flutter                         0x1061f3584         <redacted>\n8   Flutter                         0x1061f3b80         <redacted>\n9   Flutter                         0x1061176b0         <redacted>\n10  Flutter                         0x1061f2f90         <redacted>\n11  Flutter                         0x1061f4ba4         <redacted>\n12  Flutter                         0x1061f3e8c         <redacted>\n13  Flutter                         0x1061fdc34         <redacted>\n14  Flutter                         0x106115ec4         <redacted>\n15  Flutter                         0x1061191fc         <redacted>\n16  CoreFoundation                  0x333982674         __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__\n17  CoreFoundation                  0x333906650         __CFRunLoopDoTimer\n18  CoreFoundation                  0x333900dfc         __CFRunLoopDoTimers\n19  CoreFoundation                  0x3338df4ac         __CFRunLoopRun\n20  CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n21  Flutter                         0x1061190cc         <redacted>\n22  Flutter                         0x106118acc         <redacted>\n23  libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 7 name: io.flutter.1.io\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   Flutter                         0x1061190cc         <redacted>\n6   Flutter                         0x106118acc         <redacted>\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 8 name: io.worker.1\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 9 name: io.worker.2\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 10 name: io.worker.3\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 11 name: io.worker.4\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 12 name: io.worker.5\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 13 name: io.worker.6\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   libc++.1.dylib                  0x365599288         std::__1::condition_variable::wait\n3   Flutter                         0x106113840         <redacted>\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 14 name: dart:io EventHandler\n0   libsystem_kernel.dylib          0x3a2f40e18         kevent\n1   Flutter                         0x10630432c         <redacted>\n2   Flutter                         0x106333414         <redacted>\n3   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 15 name: AVAudioSession Notify Thread\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   AudioSession                    0x346534f00         CADeprecated::GenericRunLoopThread::Entry\n6   AudioSession                    0x34653e8ec         CADeprecated::CAPThread::Entry\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 16 name: JavaScriptCore libpas scavenger\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349e850b4         scavenger_thread_main\n3   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 17\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 18 name: com.apple.NSURLConnectionLoader\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   CFNetwork                       0x334b921d8         _CFURLStorageSessionDisableCache\n6   Foundation                      0x33692d418         __NSThread__start__\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 19\n0   libsystem_kernel.dylib          0x3a2f3fa2c         __semwait_signal\n1   libsystem_c.dylib               0x349bef0e0         nanosleep\n2   libsystem_c.dylib               0x349c03384         sleep\n3   Sentry                          0x103fb1720         <unknown> + 676\n4   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 20 name: SentryCrash Exception Handler (Secondary)\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   Sentry                          0x103fbd56c         <unknown> + 172\n3   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 22 name: io.sentry.app-hang-tracker\n0   libsystem_kernel.dylib          0x3a2f3fa2c         __semwait_signal\n1   libsystem_c.dylib               0x349bef0e0         nanosleep\n2   Foundation                      0x33693fce4         +[NSThread sleepForTimeInterval:]\n3   Sentry                          0x103fa2570         <unknown> + 448\n4   Foundation                      0x33692d418         __NSThread__start__\n5   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 23\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 24\n0   libsystem_pthread.dylib         0x415d84e54         start_wqthread\n\nThread 25 name: Heap Helper Thread\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349de3c1c         WTF::ParkingLot::parkConditionallyImpl\n3   JavaScriptCore                  0x349da8c14         WTF::Condition::waitUntilUnchecked<T>\n4   JavaScriptCore                  0x349da909c         WTF::Detail::CallableWrapper<T>::call\n5   JavaScriptCore                  0x349e04dc0         WTF::Thread::entryPoint\n6   JavaScriptCore                  0x349e070cc         WTF::wtfThreadEntryPoint\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 26 name: Heap Helper Thread\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349de3c1c         WTF::ParkingLot::parkConditionallyImpl\n3   JavaScriptCore                  0x349da8c14         WTF::Condition::waitUntilUnchecked<T>\n4   JavaScriptCore                  0x349da909c         WTF::Detail::CallableWrapper<T>::call\n5   JavaScriptCore                  0x349e04dc0         WTF::Thread::entryPoint\n6   JavaScriptCore                  0x349e070cc         WTF::wtfThreadEntryPoint\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 27 name: Heap Helper Thread\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349de3c1c         WTF::ParkingLot::parkConditionallyImpl\n3   JavaScriptCore                  0x349da8c14         WTF::Condition::waitUntilUnchecked<T>\n4   JavaScriptCore                  0x349da909c         WTF::Detail::CallableWrapper<T>::call\n5   JavaScriptCore                  0x349e04dc0         WTF::Thread::entryPoint\n6   JavaScriptCore                  0x349e070cc         WTF::wtfThreadEntryPoint\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 28 name: Heap Helper Thread\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349de3c1c         WTF::ParkingLot::parkConditionallyImpl\n3   JavaScriptCore                  0x349da8c14         WTF::Condition::waitUntilUnchecked<T>\n4   JavaScriptCore                  0x349da909c         WTF::Detail::CallableWrapper<T>::call\n5   JavaScriptCore                  0x349e04dc0         WTF::Thread::entryPoint\n6   JavaScriptCore                  0x349e070cc         WTF::wtfThreadEntryPoint\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 29 name: Heap Helper Thread\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c294         _pthread_cond_wait\n2   JavaScriptCore                  0x349de3c1c         WTF::ParkingLot::parkConditionallyImpl\n3   JavaScriptCore                  0x349da8c14         WTF::Condition::waitUntilUnchecked<T>\n4   JavaScriptCore                  0x349da909c         WTF::Detail::CallableWrapper<T>::call\n5   JavaScriptCore                  0x349e04dc0         WTF::Thread::entryPoint\n6   JavaScriptCore                  0x349e070cc         WTF::wtfThreadEntryPoint\n7   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 30 name: GAIThread\n0   libsystem_kernel.dylib          0x3a2f3f4a0         mach_msg_trap\n1   libsystem_kernel.dylib          0x3a2f3fae0         mach_msg\n2   CoreFoundation                  0x3338dad2c         __CFRunLoopServiceMachPort\n3   CoreFoundation                  0x3338df1b8         __CFRunLoopRun\n4   CoreFoundation                  0x3338f2bc4         CFRunLoopRunSpecific\n5   Foundation                      0x3368dd440         -[NSRunLoop(NSRunLoop) runMode:beforeDate:]\n6   Foundation                      0x3368ddbfc         -[NSRunLoop(NSRunLoop) run]\n7   Runner                          0x20244a42c         <redacted>\n8   Foundation                      0x33692d418         __NSThread__start__\n9   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 31\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 32\n0   libsystem_kernel.dylib          0x3a2f3fa74         __workq_kernreturn\n1   libsystem_pthread.dylib         0x415d85104         _pthread_wqthread\n\nThread 34\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c2c0         _pthread_cond_wait\n2   Flutter                         0x10644a8fc         <redacted>\n3   Flutter                         0x10648b9a0         <redacted>\n4   Flutter                         0x10644a224         <redacted>\n5   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 35\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c2c0         _pthread_cond_wait\n2   Flutter                         0x10644a8fc         <redacted>\n3   Flutter                         0x10648b9a0         <redacted>\n4   Flutter                         0x10644a224         <redacted>\n5   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 36\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c2c0         _pthread_cond_wait\n2   Flutter                         0x10644a8fc         <redacted>\n3   Flutter                         0x10648b9a0         <redacted>\n4   Flutter                         0x10644a224         <redacted>\n5   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\nThread 37\n0   libsystem_kernel.dylib          0x3a2f3ff24         __psynch_cvwait\n1   libsystem_pthread.dylib         0x415d8c2c0         _pthread_cond_wait\n2   Flutter                         0x10644a8fc         <redacted>\n3   Flutter                         0x10648b9a0         <redacted>\n4   Flutter                         0x10644a224         <redacted>\n5   libsystem_pthread.dylib         0x415d859a8         _pthread_start\n\n\n\nEOF\n\n\n2022.11.25-3.3.8-symbolicated.txt",
                "createdAt": "2022-11-25T01:50:41Z"
            },
            {
                "author": "ostk0069",
                "bodyText": "Hi @Hixie , @zanderso\n@lcdsmao attacked stack trace above.\nIs anyone looking for this? or are there any schedules to look into?\nSorry to bother you, but please let us know.",
                "createdAt": "2022-12-05T04:30:52Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@lcdsmao @ostk0069 This issue is about screen flickering, if you are seeing a crash please file a separate bug, thanks!",
                "createdAt": "2022-12-07T00:07:00Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@zanderso do the logs from @lcdsmao above help?",
                "createdAt": "2022-12-07T00:08:52Z"
            },
            {
                "author": "zanderso",
                "bodyText": "From Engine triage: @chinmaygarde will be taking a closer look at the crash backtraces since they may indicate that there is a race or object lifetime issue that has the same underlying cause as the GPU errors.",
                "createdAt": "2022-12-07T16:10:05Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "When will this problem be fixed? Is the fix abandoned?",
                "createdAt": "2022-12-19T11:42:18Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "So any news? It's been 2 weeks. After months of asking for logs, you get them and now what? If this issue is not one of your highest priorities then I don't know what is...",
                "createdAt": "2022-12-20T12:06:28Z"
            },
            {
                "author": "Hixie",
                "bodyText": "Folks, this is December, a lot of our contributor are on vacation right now. Also, this bug is important, but it is not the only important bug. In general, demanding updates is a violation of our code of conduct because it doesn't feel welcoming. Rest assured that if there's an update, it will be posted here promptly. If you need it to be addressed sooner, then consider that Flutter is an open source project and that we accept contributions. There are hundreds of people contributing to Flutter in various capacities, you could be one of them.",
                "createdAt": "2022-12-20T22:11:14Z"
            },
            {
                "author": "delfme",
                "bodyText": "Just faced this on master with Impeller, ios 16.1.1.\nApp started to flash after resuming it from background.\nContinuous flashing till entire screen gets a red-ish/pink-ish color and app crashed.\nUnfortunately, code is closed and I cannot share, nor I can reproduce it on a sample repo.\nDo I have to raise a different issue for that?\nI see issue's title still refers only to flutter 2.10.0",
                "createdAt": "2022-12-28T15:38:08Z"
            },
            {
                "author": "WilliamCunhaCardoso",
                "bodyText": "Do I have to raise a different issue for that? I see issue's title still refers only to flutter 2.10.0\n\nIt is not only for such version, but since such version.",
                "createdAt": "2022-12-28T15:55:18Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I repeated the problem again and captured the feedback information. The user's operation process:\n\nThe user slides up and exits, causing a stuck state\nAfter the screen is locked, it flashes when it is opened again.\nIt crashes after a period of time\n\ncrashlog.txt\nfeedback.txt\nI found in the log that it was caused by pictures. There are indeed a large number of pictures in my app. Please tell me how to solve it\nextended_image: ^6.3.4\nflutter_svg: ^1.1.6\n[\u2713] Flutter (Channel stable, 3.3.8, on macOS 13.1 22C65 darwin-arm, locale zh-Hans-CN)\n\u2022 Flutter version 3.3.8 on channel stable\n\u2022 Upstream repository https://github.com/flutter/flutter.git\n\u2022 Framework revision 52b3dc2 (7 weeks ago), 2022-11-09 12:09:26 +0800\n\u2022 Engine revision 857bd6b74c\n\u2022 Dart version 2.18.4\n\u2022 DevTools version 2.15.0\n\u2022 Pub download mirror https://pub.flutter-io.cn\n\u2022 Flutter download mirror https://storage.flutter-io.cn",
                "createdAt": "2022-12-30T08:04:51Z"
            },
            {
                "author": "DjordjeMancic97",
                "bodyText": "Just experienced this myself for the first time ever. It happened when I opened a deeplink which triggers a webview inside the app. However this is just one of the ways it was triggered in our app, other cases were not deeplink nor webview related. Of course it happened only once and can't reproduce it again.\niPhone 13 Pro Max\niOS 16.1.1\nFlutter 3.3.7\nHere are logs:\n022-12-30 10:29:41.546158+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.546220+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)}\n2022-12-30 10:29:41.546302+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.546342+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.546481+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.555722+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.555780+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.567496+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.567651+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.575821+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.575924+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.584281+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.584417+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.592477+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.592548+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.600692+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.600745+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.608991+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.609068+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.617360+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.617400+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.625678+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.625739+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.634637+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.634671+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.634714+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored), MTLCommandBufferEncoderInfoErrorKey=(\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\"\n)}\n2022-12-30 10:29:41.634811+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.634836+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.642785+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.642815+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.642842+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored), MTLCommandBufferEncoderInfoErrorKey=(\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\"\n)}\n2022-12-30 10:29:41.642906+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.642929+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.651200+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.651231+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.651264+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored), MTLCommandBufferEncoderInfoErrorKey=(\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\"\n)}\n2022-12-30 10:29:41.651327+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.651350+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.659688+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.659720+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.659753+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored), MTLCommandBufferEncoderInfoErrorKey=(\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\"\n)}\n2022-12-30 10:29:41.659814+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.659840+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.667843+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.667885+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)}\n2022-12-30 10:29:41.667925+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.667957+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.667982+0100 0x6e50ce   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.676737+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.676774+0100 0x6e53c9   Error       0x0                  1269   0    Runner: (Metal) Execution of the command buffer was aborted due to an error during execution. Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\n2022-12-30 10:29:41.676813+0100 0x6e4c89   Default     0x0                  1269   0    Runner: (Flutter) Error Domain=MTLCommandBufferErrorDomain Code=4 \"Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored)\" UserInfo={NSLocalizedDescription=Ignored (for causing prior/excessive GPU errors) (00000004:kIOGPUCommandBufferCallbackErrorSubmissionsIgnored), MTLCommandBufferEncoderInfoErrorKey=(\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\",\n    \"<errorState: MTLCommandEncoderErrorStateCompleted, label: (null), debugSignposts: (null)>\"\n)}",
                "createdAt": "2022-12-30T09:56:53Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "From Triage: We know from @lcdsmao and @jackTang11 s backtraces that this is an over-release of a Metal command buffer. I am instrumenting our behavior now but the surface area is large. What is peculiar is that @lcdsmao backtrace points to an overrelease on the render thread while @jackTang11 s issue is on the platform thread. We now suspect that this could happen during thread merging and unmerging. This narrows down where we can look for issues. More updates incoming.",
                "createdAt": "2023-01-09T18:46:26Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "From Triage: We know from @lcdsmao and @jackTang11 s backtraces that this is an over-release of a Metal command buffer. I am instrumenting our behavior now but the surface area is large. What is peculiar is that @lcdsmao backtrace points to an overrelease on the render thread while @jackTang11 s issue is on the platform thread. We now suspect that this could happen during thread merging and unmerging. This narrows down where we can look for issues. More updates incoming.\n\nLooking forward to your fix",
                "createdAt": "2023-01-10T10:26:49Z"
            },
            {
                "author": "briankariuki",
                "bodyText": "I got this flickering issue on my app on ios 16.1, iphone XS Max.\nI'm using flutter 3.3.10",
                "createdAt": "2023-01-13T06:48:16Z"
            },
            {
                "author": "Yukinosuke-Takada",
                "bodyText": "We also experience this in our project.\nThis only happens on iPhone 8, and SE 2nd, 3rd generation (as we know of. ) We don't experience this on other modern iPhones. We use device_preview package for debugging. Very interesting point is that when we view other iPhone screens (such as iPhone 13 screen) through device_preview on (iPhone 8 the one that flickers) the flickering does not happen.\nWe couldn't create a minimal code to simulate this as it seems to be a very random behavior. For security reasons, I can't share the whole code...",
                "createdAt": "2023-01-13T08:58:59Z"
            },
            {
                "author": "delfme",
                "bodyText": "I saw it a couple of times with my app on iphone pro 13 ios16",
                "createdAt": "2023-01-13T14:39:42Z"
            },
            {
                "author": "tal412",
                "bodyText": "I saw it a couple of times with my app on iphone pro 13 ios16\n\nHaving the same issue.\nAny news about this one?",
                "createdAt": "2023-01-26T16:29:55Z"
            },
            {
                "author": "briankariuki",
                "bodyText": "I saw it a couple of times with my app on iphone pro 13 ios16\n\nHaving the same issue. Any news about this one?\n\nI think we should try impeller. I'll use it for my next release on ios\n]",
                "createdAt": "2023-01-26T19:45:17Z"
            },
            {
                "author": "delfme",
                "bodyText": "I saw it a couple of times with my app on iphone pro 13 ios16\n\nHaving the same issue. Any news about this one?\n\nI think we should try impeller. I'll use it for my next release on ios ]\n\nThis occurs also with Impeller. We are in test mode pre-launch and we see this issue every day on our iphones. Waiting for the fix before shipping app is mandatory. Hoping you guys get to fix it soon\ud83e\udd1e",
                "createdAt": "2023-02-01T14:32:20Z"
            },
            {
                "author": "delfme",
                "bodyText": "We also experience this in our project.\nThis only happens on iPhone 8, and SE 2nd, 3rd generation (as we know of. ) We don't experience this on other modern iPhones. We use device_preview package for debugging. Very interesting point is that when we view other iPhone screens (such as iPhone 13 screen) through device_preview on (iPhone 8 the one that flickers) the flickering does not happen.\nWe couldn't create a minimal code to simulate this as it seems to be a very random behavior. For security reasons, I can't share the whole code...\n\nAre you sure? Lately we see it regularly on iphone 13 pro",
                "createdAt": "2023-02-01T14:35:11Z"
            },
            {
                "author": "Hixie",
                "bodyText": "@delfme If you can create a test case that reproduces it reliably that would be massively helpful!",
                "createdAt": "2023-02-01T22:56:00Z"
            },
            {
                "author": "delfme",
                "bodyText": "@delfme If you can create a test case that reproduces it reliably that would be massively helpful!\n\n@Hixie I\u2019ve already tried with no luck. Will try again and let you know.",
                "createdAt": "2023-02-02T17:08:08Z"
            },
            {
                "author": "briankariuki",
                "bodyText": "I saw it a couple of times with my app on iphone pro 13 ios16\n\nHaving the same issue. Any news about this one?\n\nI think we should try impeller. I'll use it for my next release on ios ]\n\nThis occurs also with Impeller. We are in test mode pre-launch and we see this issue every day on our iphones. Waiting for the fix before shipping app is mandatory. Hoping you guys get to fix it soon\ud83e\udd1e\n\nI havent experienced this with impeller yet. I'll try to do more testing. This issue is very hard to recreate and does not happen all the time. I attached a video in this thread as I experienced it while using the app in release mode",
                "createdAt": "2023-02-02T19:12:00Z"
            },
            {
                "author": "Brazol",
                "bodyText": "I also experienced it with Impeller once and couldn't reproduce it. I think it was different than on Skia tho because it started blinking with pink tint and at the end just shown pink screen. I did experience this once (pink blinking screen) on Apple's Photos native app on my phone so it's definitely something on native side (but maybe enhanced by Flutter?).",
                "createdAt": "2023-02-03T09:02:23Z"
            },
            {
                "author": "delfme",
                "bodyText": "We use Impeller and blinking is not pink in our case.\nFor us a fix to this issue and #105093 is key. Without them users would rate app 1-star and uninstall it.",
                "createdAt": "2023-02-05T07:26:09Z"
            },
            {
                "author": "themartorana",
                "bodyText": "We're experiencing this in our main app with Impeller. Our flashing is pink, for whatever that's worth. We're working to figure out a pattern/trigger and make something reproducible. We're seeing it on a broad range of iPhones, almost all iOS 16.x.\nAs above, if I jump on Console, we're seeing this log with each flash. Flashing is made worse with touch. Touch makes flashing happen, but touch is broken once we get into this state - that is, scrolling is broken, etc.\n0\t23852\t13:47:41.077922-0500\tExecution of the command buffer was aborted due to an error during execution. <private>\tRunner",
                "createdAt": "2023-02-08T19:37:03Z"
            },
            {
                "author": "chinmaygarde",
                "bodyText": "If you are experiencing this with the Impeller backend enabled, we have additional logging instrumentation to log the root cause of the error as well as print the debug description of the faulting render pass. You should see the following log line in the console: \"Impeller command buffer could not be committed\" followed by a bunch of information. Can you paste that information in the logs please.",
                "createdAt": "2023-02-08T22:23:37Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "From Triage: We know from @lcdsmao and @jackTang11 s backtraces that this is an over-release of a Metal command buffer. I am instrumenting our behavior now but the surface area is large. What is peculiar is that @lcdsmao backtrace points to an overrelease on the render thread while @jackTang11 s issue is on the platform thread. We now suspect that this could happen during thread merging and unmerging. This narrows down where we can look for issues. More updates incoming.\n\nIs there any result? Is it being repaired?",
                "createdAt": "2023-02-10T05:07:48Z"
            },
            {
                "author": "NikosTsesmelis",
                "bodyText": "I found out that this happens if I put an CircularProgressIndicator with opacity 0.\nSometimes you don't need to put it in background at all.\nHope this is related to this issue\nEdit: this only happens with skia consistently, I don't know if this can happen with impeller. I have personally not encountered it.\nclass TestScreen extends StatefulWidget {\n  const TestScreen({Key? key}) : super(key: key);\n\n  @override\n  _TestScreenState createState() => _TestScreenState();\n}\n\nclass _TestScreenState extends State<TestScreen> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Container(\n        color: Colors.black,\n        child: Stack(\n          children: [\n            Padding(\n              padding: const EdgeInsets.only(top: 200),\n              child: Stack(\n                children: [_grid()],\n              ),\n            ),\n            const Opacity(\n              opacity: 0,\n              child: CircularProgressIndicator(strokeWidth: 5, color: Colors.blue),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _grid() {\n    return Align(\n      alignment: Alignment.topCenter,\n      child: Container(\n        color: Colors.grey[200],\n        child: GridView.count(\n          crossAxisCount: 3,\n          padding: const EdgeInsets.all(8),\n          childAspectRatio: 1.2,\n          shrinkWrap: true,\n          physics: const NeverScrollableScrollPhysics(),\n          children: _gridChildren(),\n        ),\n      ),\n    );\n  }\n\n  List<Widget> _gridChildren() {\n    List<Widget> list = [];\n    for (int i = 1; i <= 12; i++) {\n      list.add(\n        Opacity(\n          opacity: 0.3,\n          child: Container(\n            decoration: BoxDecoration(\n              color: Colors.white,\n              boxShadow: [\n                BoxShadow(\n                  color: const Color(0xff002255).withOpacity(0.20),\n                  blurRadius: 12,\n                  spreadRadius: -1,\n                  offset: const Offset(0, 3),\n                )\n              ],\n            ),\n            child: Center(\n              child: Text(i.toString()),\n            ),\n          ),\n        ),\n      );\n    }\n    return list;\n  }\n}",
                "createdAt": "2023-02-10T12:25:32Z"
            },
            {
                "author": "dnfield",
                "bodyText": "@NikosTsesmelis - thank you for the reproduction, I'm able to see it. I you've actually found a different (although slightly similar) bug unfortunately. I've filed #120455 to track that.",
                "createdAt": "2023-02-10T17:44:20Z"
            },
            {
                "author": "themartorana",
                "bodyText": "If you are experiencing this with the Impeller backend enabled, we have additional logging instrumentation to log the root cause of the error as well as print the debug description of the faulting render pass. You should see the following log line in the console: \"Impeller command buffer could not be committed\" followed by a bunch of information. Can you paste that information in the logs please.\n\nWe will try to do this. Unfortunately we're having issues seeing it at all when attached to a debugger, and it seems to show up mostly on release builds. But we'll keep trying.",
                "createdAt": "2023-02-10T19:00:34Z"
            },
            {
                "author": "flar",
                "bodyText": "Also, try testing your apps with the following fix (which is now in the engine repo, but hasn't rolled into the Flutter repo yet):\nflutter/engine#39690",
                "createdAt": "2023-02-17T05:19:54Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Note that the fix mentioned by @flar (flutter/engine#39690) is for #120455, and won't help when the flickering is caused by GPU faults.",
                "createdAt": "2023-02-17T16:19:53Z"
            },
            {
                "author": "jackTang11",
                "bodyText": "I repeated the problem again and captured the feedback information. The user's operation process:\n\nThe user slides up and exits, causing a stuck state\nAfter the screen is locked, it flashes when it is opened again.\nIt crashes after a period of time\n\ncrashlog.txt\nfeedback.txt\nI found in the log that it was caused by pictures. There are indeed a large number of pictures in my app. Please tell me how to solve it\nextended_image: ^6.3.4 flutter_svg: ^1.1.6\n[\u2713] Flutter (Channel stable, 3.3.8, on macOS 13.1 22C65 darwin-arm, locale zh-Hans-CN) \u2022 Flutter version 3.3.8 on channel stable \u2022 Upstream repository https://github.com/flutter/flutter.git \u2022 Framework revision 52b3dc2 (7 weeks ago), 2022-11-09 12:09:26 +0800 \u2022 Engine revision 857bd6b74c \u2022 Dart version 2.18.4 \u2022 DevTools version 2.15.0 \u2022 Pub download mirror https://pub.flutter-io.cn \u2022 Flutter download mirror https://storage.flutter-io.cn\n\n@zanderso    My log seems to be caused by threads. Is this related to CPU?",
                "createdAt": "2023-02-18T02:23:50Z"
            },
            {
                "author": "delfme",
                "bodyText": "I confirm we also experienced same flow: app first gets stuck and then flashes when it is opened again.\nWe also use extented_image and images are almost everywhere inside our app.",
                "createdAt": "2023-02-20T09:40:48Z"
            },
            {
                "author": "mazhengshui",
                "bodyText": "Is there any new progress on this issue? This problem has been bothering me. When can I solve it?",
                "createdAt": "2023-03-02T05:16:58Z"
            },
            {
                "author": "remakerich",
                "bodyText": "I experienced flickering both on iOS Simulator (iOS 16.2) and Android physical device (Galaxy s20 FE).\nFlutter 3.3.10\nWe also use quite a number of svg images around the app.\nBtw, svg images drop performance quite a bit. It's very noticeable on 120 hz screen.",
                "createdAt": "2023-03-03T16:52:19Z"
            },
            {
                "author": "aa1dar",
                "bodyText": "I experienced appbar flickering after migrating the Flutter version from 2.0.4 to 3.3.10. This happens on physical Pixel 6(Android 13) and Samsung A52s(Android 12, 120 Hz).\nWe also use multiple WebViews on the same screen.\nWith flutter 3.7 the same behavior",
                "createdAt": "2023-03-06T12:57:31Z"
            },
            {
                "author": "chikang",
                "bodyText": "I repeated the problem again and captured the feedback information. The user's operation process:\n\nThe user slides up and exits, causing a stuck state\nAfter the screen is locked, it flashes when it is opened again.\nIt crashes after a period of time\n\ncrashlog.txt\nfeedback.txt\nI found in the log that it was caused by pictures. There are indeed a large number of pictures in my app. Please tell me how to solve it\nextended_image: ^6.3.4 flutter_svg: ^1.1.6\n[\u2713] Flutter (Channel stable, 3.3.8, on macOS 13.1 22C65 darwin-arm, locale zh-Hans-CN) \u2022 Flutter version 3.3.8 on channel stable \u2022 Upstream repository https://github.com/flutter/flutter.git \u2022 Framework revision 52b3dc2 (7 weeks ago), 2022-11-09 12:09:26 +0800 \u2022 Engine revision 857bd6b74c \u2022 Dart version 2.18.4 \u2022 DevTools version 2.15.0 \u2022 Pub download mirror https://pub.flutter-io.cn \u2022 Flutter download mirror https://storage.flutter-io.cn\n\n@zanderso My log seems to be caused by threads. Is this related to CPU?\n\nDid you finally find out what the problem was and how it was solved?",
                "createdAt": "2023-03-14T03:14:44Z"
            },
            {
                "author": "dingjianjaja",
                "bodyText": "I summarize some recurrence rules\uff1a\n\nhigh refresh rate phone\uff0c120hz\nused animation\uff0cSingleTickerProviderStateMixin\nstatelessWidget\uff0cstatefulWidget did not flickering\n\nmaybe is TickerProvider problem",
                "createdAt": "2023-03-20T01:30:47Z"
            },
            {
                "author": "zanderso",
                "bodyText": "Hi everyone,\nThanks for your patience on this very difficult issue. As you've likely noticed, this thread has become quite long. It has become so long that GitHub's UI has made it essentially impossible for the team to use it. Additionally, we on the Flutter team have also not done a great job of enforcing Flutter's issue hygiene policies on this issue. This has led to a somewhat low signal to noise ratio. The combination of these factors with our inability to reproduce this issue locally requires a change in tactics. Along those lines, I'm going to close and lock this issue, and replace it with multiple issues that attempt to tease out the different situations discussed in this thread, and focus the conversations on details that will help the team fix the problems. Here they are:\n\n#123120\n#123121\n#123122\n#123123\n\nPlease note that these issues are focused on recent versions of Flutter as the team will not be able to back-port any fixes to older versions. Please also note that on iOS, any reproduction should be with Impeller enabled.\nThanks again for your help and continued patience!",
                "createdAt": "2023-03-21T15:50:42Z"
            }
        ],
        "commentCount": 320
    },
    {
        "number": 18494,
        "title": "Support APKs with 32-bit and 64-bit binaries within them",
        "author": "zilong",
        "state": "CLOSED",
        "createdAt": "2018-06-15T08:35:27Z",
        "closedAt": "2019-06-25T22:03:36Z",
        "comments": [
            {
                "author": "swavkulinski",
                "bodyText": "AFAIK, currently, Flutter will only add libflutter.so to one selected platform folder in the release APK. The workaround which worked for me was to force build.gradle to do 32bit only (excluding all 64bit libraries + Intel)\nrelease {\n        \n    ...\n            ndk{\n                abiFilters \"armeabi-v7a\"\n            }\n}",
                "createdAt": "2018-06-21T15:59:39Z"
            },
            {
                "author": "zoechi",
                "bodyText": "cc @Hixie",
                "createdAt": "2018-06-22T08:35:48Z"
            },
            {
                "author": "jeanpaulcozzatti",
                "bodyText": "@swavkulinski how would you release the to apks to the playstore?",
                "createdAt": "2018-07-01T18:49:58Z"
            },
            {
                "author": "kevinvandenbreemen",
                "bodyText": "Similar to #18939",
                "createdAt": "2018-07-24T22:57:17Z"
            },
            {
                "author": "qbsho",
                "bodyText": "Have the same problem - but flutter.so not included in \"armeabi-v7a folder.\nHas only third party libraries for x86 and armeabi-v7a - but no arm64.\nWould like to build flutter only for \"armeabi-v7a with\nndk{\nabiFilters \"armeabi-v7a\" // also not work\"armeabi\", \"x86\",\n}\nand set as target-platform as @mravn-google suggest to android-arm.\nAPK without specify arch and not include libraries\n\nAPK with libraries and no arm spec\n\nAPK with specify arch and include libraries\n\nAny suggestion how to debug further steps?",
                "createdAt": "2018-07-26T19:42:23Z"
            },
            {
                "author": "peasfarmer",
                "bodyText": "@xxseabxx  i have the same problem",
                "createdAt": "2018-08-09T15:01:55Z"
            },
            {
                "author": "gurleensethi",
                "bodyText": "I have the same problem, building for 32-bit will exclude 64-bit devices, it runs on them though. Building for 64 by specifying --target-platform android-arm64 works on 64-bit devices, but crashes on 32-bit devices. Also Google will be restricting upload of apks to be 64-bit in 2019.\nFlutter Team, please resolve this basic issue!",
                "createdAt": "2018-08-13T05:37:35Z"
            },
            {
                "author": "dieegov",
                "bodyText": "Flutter Team, please resolve this basic issue!",
                "createdAt": "2018-08-14T18:43:02Z"
            },
            {
                "author": "bdytx5",
                "bodyText": "So am I wrong by saying that flutter can only support release apk\u2019s for either 32 or 64 bit, but not both?",
                "createdAt": "2018-08-30T18:55:15Z"
            },
            {
                "author": "jeanpaulcozzatti",
                "bodyText": "any luck here?",
                "createdAt": "2018-09-13T23:34:00Z"
            },
            {
                "author": "bdytx5",
                "bodyText": "I think xxseabxx's comment might work but I haven't tried it...",
                "createdAt": "2018-09-14T17:42:41Z"
            },
            {
                "author": "lance-blo",
                "bodyText": "I am also having the same issue.\nIn all of my dependencies, I isolated at least one package causing the issue, I filled a bug report accordingly: azihsoyn/flutter_mlkit#36\nTo isolate the problem, for each of my dependency / plugin:\n\n\nCreate an empty flutter project\n\n\nReplace main.dart with\n\n\nthe package example code (ex: https://pub.dartlang.org/packages/flutter_html_view#-example-tab-)\n\n\nUpdate pubspec.yaml accordingly\n\n\nrun\n\n\n$ flutter build apk\nIt turned out that the one creating was flutter_mlkit.\nI want to be able to target both 32 & 64 architectures.",
                "createdAt": "2018-09-15T08:44:07Z"
            },
            {
                "author": "cortexuvula",
                "bodyText": "Have the same issue. --target-platform=android-arm64 works for me but I would like to support 32 bit until Google pulls the plug on 32 bit",
                "createdAt": "2018-09-27T13:01:17Z"
            },
            {
                "author": "OnlyMyRailgun",
                "bodyText": "Flutter Team, please resolve this basic issue!",
                "createdAt": "2018-10-09T05:34:38Z"
            },
            {
                "author": "lianjianjie",
                "bodyText": "lots of third SDK not working, i think it's urgent",
                "createdAt": "2018-10-10T01:12:26Z"
            },
            {
                "author": "philipgiuliani",
                "bodyText": "I can reproduce this when adding Mapbox to the android application.",
                "createdAt": "2018-10-12T07:01:17Z"
            },
            {
                "author": "John-jin",
                "bodyText": "I have the same problem too.I use baiduMap in my Project,bebug model is ok,release crash.\nuser flutter build apk --release --target-platform=android-arm64 in my phone is ok,but 32 bit phone will crash.Flutter Team,please resolve this issue as soon as possible.",
                "createdAt": "2018-10-31T09:31:04Z"
            },
            {
                "author": "JackJonson",
                "bodyText": "Similar to https://github.com/azihsoyn/flutter_mlkit/issues/36 , it works for me , the apk can run in both 32bit and 64bit phone. @peace2knowledge",
                "createdAt": "2018-11-01T09:29:45Z"
            },
            {
                "author": "krmao",
                "bodyText": "this should be very important problem for release apk",
                "createdAt": "2018-11-02T04:52:02Z"
            },
            {
                "author": "jeffreyyoung",
                "bodyText": "is there a work around for this issue?",
                "createdAt": "2018-11-02T06:13:41Z"
            },
            {
                "author": "zephyrluo",
                "bodyText": "extract lib/armeabi-v7a/libflutter.so from $<FLUTTER>/bin/cache/artifacts/engine/android-arm-release/flutter.jar\ncopy file armeabi-v7a/libflutter.so into $<project>/android/jniLibs/armeabi-v7a/\nmodify $<project>/android/app/build.gradle as below:\n\nandroid {\n...\n    buildTypes {\n        release {\n            // TODO: Add your own signing config for the release build.\n            // Signing with the debug keys for now, so `flutter run --release` works.\n            signingConfig signingConfigs.debug\n            ndk {\n                abiFilters \"arm\"\n            }\n        }\n        debug {\n            ndk {\n                abiFilters \"arm\"\n            }\n        }\n}\n    }",
                "createdAt": "2018-11-05T06:16:24Z"
            },
            {
                "author": "INRIX-joel-winarske",
                "bodyText": "For NDK, the 64-bit toolchain requires minSdkVersion >= 21.\nThis unblocked me (with proper minSdkVersion set):\nminSdkVersion=16\nflutter build apk --release --target-platform=android-arm\nflutter run --release --target-platform=android-arm\n\nminSdkVersion=21\nflutter build apk --release --target-platform=android-arm64\nflutter run --release --target-platform=android-arm64",
                "createdAt": "2018-11-28T02:10:37Z"
            },
            {
                "author": "RockCoder7",
                "bodyText": "Delete all abiFilters, it works for me.",
                "createdAt": "2018-11-28T03:46:33Z"
            },
            {
                "author": "neiljaywarner",
                "bodyText": "@zoechi  @Hixie   gentle bump. I also am running into this when trying to integrate with existing app, which is our most important use case at the moment.\nmindsdk=21, but haven't updated target platform yet",
                "createdAt": "2018-12-13T00:16:39Z"
            },
            {
                "author": "zoechi",
                "bodyText": "@neiljaywarner a thumbs-up on the initial comment would be more effective to raise priority",
                "createdAt": "2018-12-13T06:41:08Z"
            },
            {
                "author": "gerryhigh",
                "bodyText": "extract lib/armeabi-v7a/libflutter.so from $<FLUTTER>/bin/cache/artifacts/engine/android-arm-release/flutter.jar\ncopy file armeabi-v7a/libflutter.so into $<project>/android/jniLibs/armeabi-v7a/\nmodify $<project>/android/app/build.gradle as below:\n\nandroid {\n...\n    buildTypes {\n        release {\n            // TODO: Add your own signing config for the release build.\n            // Signing with the debug keys for now, so `flutter run --release` works.\n            signingConfig signingConfigs.debug\n            ndk {\n                abiFilters \"arm\"\n            }\n        }\n        debug {\n            ndk {\n                abiFilters \"arm\"\n            }\n        }\n}\n    }\n\n\nThis didn't work for me--it generated an APK that was missing the lib folder (and thus was half the size of my previous apk).\nWe've also found that if we implement the 32-bit only solution that some have posted  (e.g. https://medium.com/flutterpub/flutter-app-couldnt-find-libflutter-so-c95ad81cbccd) it results in a non-performant app. In particular in one test on a Samsung S6 & S9 we are seeing very slow scrolling on a big list.",
                "createdAt": "2018-12-18T18:22:57Z"
            },
            {
                "author": "jbg",
                "bodyText": "I don't think the problem is only the missing arm64 libflutter.so.\nI tried adding the missing library to the APK by building for arm64, copying out libflutter.so and then re-building and manually adding the arm64 library to the APK, re-aligning and re-signing:\nflutter build apk --target-platform=android-arm64\nmkdir -p tmp/lib/arm64-v8a\ncp build/app/intermediates/transforms/mergeJniLibs/release/0/lib/arm64-v8a/libflutter.so tmp/lib/arm64-v8a/\nflutter build apk\ncp build/app/outputs/apk/release/app-release.apk tmp/\ncd tmp\naapt add app-release.apk lib/arm64-v8a/libflutter.so\nzipalign 4 app-release.apk app-release-aligned.apk\napksigner sign --ks keystore.jks app-release-aligned.apk\n\nThe resulting APK has libflutter.so for both armeabi-v7a and arm64-v8a, but crashes on launch with the following error:\n12-22 09:53:29.274  7457  7457 F flutter : [FATAL:flutter/runtime/dart_vm.cc(403)] Error while initializing the Dart VM: Snapshot not compatible with the current VM configuration: the snapshot requires 'product no-type_checks no-asserts no-error_on_bad_type sync_async reify_generic_functions arm-eabi softfp' but the VM has 'product no-type_checks no-asserts no-error_on_bad_type sync_async reify_generic_functions arm64-sysv'\nI suppose that separate snapshot assets need to be shipped for each arch too. For now building two separate APKs is the only solution that works for me.",
                "createdAt": "2018-12-22T09:16:44Z"
            },
            {
                "author": "james-lawrence",
                "bodyText": "this is a pretty shitty issue to run into after spending time actually writing a frontend in flutter only to find the release doesn't properly build the apk.\nam I going to run into the same issue once I get around to doing iOS?",
                "createdAt": "2018-12-23T01:45:28Z"
            },
            {
                "author": "John-jin",
                "bodyText": "What time can solve this problem?",
                "createdAt": "2019-01-02T07:31:05Z"
            },
            {
                "author": "eseidelGoogle",
                "bodyText": "Is this just that our gradle files don't know how to bundle all the right bits for both?  @jason-simmons @cbracken might know?\nOr @FaisalAbid might?",
                "createdAt": "2019-01-09T21:43:03Z"
            },
            {
                "author": "gerryhigh",
                "bodyText": "Is this just that our gradle files don't know how to bundle all the right bits for both? @jason-simmons @cbracken might know?\nOr @FaisalAbid might?\n\nBy right bits I assume you mean more than the libflutter.so, per this comment: #18494 (comment)\nRight now I think the only solution is to build 32-bit APKs until there is a fix. Note however that we've seen performance issues with 32-bit (albeit non-optimal code with large lists).",
                "createdAt": "2019-01-09T23:27:05Z"
            },
            {
                "author": "jbg",
                "bodyText": "It's working fine for me to build separate 64-bit and 32-bit APKs and upload both to Google (they handle providing the correct APK to the correct devices automatically).\nYou do one build with abiFilters set to armeabi-v7a and --target-platform=android-arm, upload that APK, then do another build with abiFilters set to arm64-v8a and --target-platform=android-arm64 and upload that one too.\nNote that you also need to use a different version code for each APK, so include something in the version code to indicate that it's 64 or 32 bit, same as you would for DPI or API level.",
                "createdAt": "2019-01-10T03:58:06Z"
            },
            {
                "author": "marnberg",
                "bodyText": "Currently the best option is to set abiFilters conditionally from target-platform\n        ndk {\n            if (project.hasProperty('target-platform') &&\n               project.property('target-platform') == 'android-arm64') {\n                abiFilters 'arm64-v8a'\n            } else {\n                abiFilters 'armeabi-v7a'\n            }\n        }\nThe problem I have is that now I need to upload two apks with different version codes\nThe real fix for this is being able to build android bundles with multiple target platforms. App bundles is in flutter master currently but I couldn't get it to work for this",
                "createdAt": "2019-01-15T21:56:40Z"
            },
            {
                "author": "MarcelEdward",
                "bodyText": "The play store will require 64 bit starting on the 1 August.\nAssuming there will still be 32bit devices wanting to run our apps after 1 august, how to make sure 32bit AND 64bit is included in release builds ?\nhttps://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html",
                "createdAt": "2019-02-06T14:12:26Z"
            },
            {
                "author": "jbg",
                "bodyText": "All new apps and app updates that include native code are required to provide 64-bit versions in addition to 32-bit versions when publishing to Google Play.\nThis requirement is easily met right now with Flutter apps by simply building two APKs \u2013 one for 32-bit devices and one for 64-bit devices \u2013 and uploading both as part of the same release. Google Play will automatically provide the appropriate APK to the appropriate device. I'm doing this and it works well. I agree with other commenters that it's not ideal, but IMO it's really not much of a problem to make this part of your workflow.",
                "createdAt": "2019-02-06T14:30:27Z"
            },
            {
                "author": "ened",
                "bodyText": "It would be great if this can be fixed in the near future. The multi-APK approach is only a temporary solution until Flutter builds APKs with multiple .so architecture versions, just like other Android projects do.\nIt requires a lot of manual handling (version codes, build system, automation) plus Android App Bundles were supposed to relieve developers of the manual build steps.\nCurrently this issue only mentions 32 & 64 bit versions, but there is also x86, x64 plus some developers in China still talk about supporting mips.",
                "createdAt": "2019-02-11T02:59:33Z"
            },
            {
                "author": "MarcelEdward",
                "bodyText": "Shouldn't flutter support as much of the 7 android architectures with the smallest apk size as possible out of the box ?\nhttps://proandroiddev.com/reducing-apk-size-by-using-abi-filters-and-apk-split-74a68a885f4e",
                "createdAt": "2019-02-11T08:29:11Z"
            },
            {
                "author": "ened",
                "bodyText": "@MarcelEdward It should - however IMHO the APK size is not the most important aspect, given that Android now fully supports App Bundles (aab) and end-users will download an optimized build for their phone anyway.\nFor the size of a platform-specific APK that should be as optimized/small as possible.\nDuring development it may be painful to reinstall a full-size APK every time you change native code. A trick is to use abifilters to limit the debug build to your test phones' architecture. I'm not sure if this is as relevant now though, given that Flutter supports the hot reload.",
                "createdAt": "2019-02-14T04:15:33Z"
            },
            {
                "author": "MarcelEdward",
                "bodyText": "#17829 Is about the aap app bundels, but i can only find 32bit when compile With flutter build apk\nSo when i understanding richt then we have to build two serperate versions with at least 32 and 64 upload them both and then the app stroe Will miraculously build an aap so that the consumer Gets the optimized Version for their specific archtecture",
                "createdAt": "2019-02-14T08:21:39Z"
            },
            {
                "author": "jbg",
                "bodyText": "@MarcelEdward The play store doesn't build an app bundle. It just serves the appropriate APK to the device based on the device architecture. This has been supported since long before app bundles came along, not only for architecture but also for screen size/resolution, API level, and other differentiators. You can read more about this here.\nYou can see a good example of this by having a look at the 13 variants of Google Maps here (note that APKMirror has nothing to do with this functionality other than being an easy way to get a listing of the variants for a given app). The Play Store serves up the appropriate APK from these variants for your device based on its characteristics.\nIf you used an app bundle, then you would only have to upload the bundle once instead of uploading multiple APKs, but my understanding is that the Play Store then generates the various APK variants for you, so the end result is similar but there's less work for you to automate yourself. (App bundles also support the new dynamically-loaded modules, but that's another story.)",
                "createdAt": "2019-02-14T08:55:01Z"
            },
            {
                "author": "Hixie",
                "bodyText": "So it seems like the desired feature here is to be able to run flutter build with two --target-platform arguments and have flutter automatically put both architectures into the APK, is that right?",
                "createdAt": "2019-02-27T00:45:40Z"
            },
            {
                "author": "ened",
                "bodyText": "@Hixie isn\u2019t libflutter.so only generated once per flutter version and release type? In which case you\u2019d have 8 variants (32,64,x86,x86_64). I think those should simply be selected when a flutter app is built and filtered out depending on what the target phone or use case is. Gradle can do the filtering pretty well.",
                "createdAt": "2019-02-27T01:03:41Z"
            },
            {
                "author": "MarcelEdward2",
                "bodyText": "What atchitecture an phone has got is something pretty low level, I haven\"t got a clue wich architecture the people have got who use our apps. Flutter compiles 32bit when no architecture is specified so I would assume 32bit fits all. But now the play store will require 64bit in august, so when 32bits fits all and 64bit is required then those two should go into a release build ?\nI haven\"t got an android phone myself, so I will assume it will work when it does on a simulator. Until our app users state otherwise.",
                "createdAt": "2019-02-27T08:39:40Z"
            },
            {
                "author": "jbg",
                "bodyText": "@MarcelEdward2 It's not just 32-bit vs. 64-bit. There are four architectures supported by modern Android NDK:\n\narmeabi-v7a\narm64-v8a\nx86\nx86_64\n\nAt the moment Flutter defaults to building an APK containing native code compiled for armeabi-v7a only. This will run fine on arm64-v8a, though with a performance penalty compared to something compiled for arm64-v8a natively. However, it will run under an ARM emulator on x86 or x86_64, assuming the device bundles one. If the x86/x86_64 device doesn't have an ARM emulator, it won't run at all.\nOnce again, the August requirement doesn't require you to produce one universal APK or AAB containing both architectures. It simply requires that each release you make contains (at least) one APK suitable for 64-bit devices. Modifications in Flutter to make it possible to build one universal APK/AAB with support for several architectures would be nice in terms of developer workflow, but you can meet this requirement with or without such improvements.\nEdited to add: personally I think first-class support for app bundles is the best way to improve the multi-arch situation.",
                "createdAt": "2019-02-27T13:57:30Z"
            },
            {
                "author": "luigi-agosti",
                "bodyText": "appbundle looks like the solution going forward ... I guess next step is this: #29303",
                "createdAt": "2019-03-16T19:20:36Z"
            },
            {
                "author": "eseidelGoogle",
                "bodyText": "As I understand this bug, it's very tied with moving to .aab as the default output format for flutter build and making that .aab include then both 32 and 64-bit builds:\nhttps://developer.android.com/studio/projects/dynamic-delivery\nMy understanding was some of this work may already be in progress. @dnfield might know.",
                "createdAt": "2019-03-18T17:08:47Z"
            },
            {
                "author": "dnfield",
                "bodyText": "/cc @mklim\nIt seems like .aab would help, but may not really be necessary.  Is the problem as simple as just adding both the 32 and 64 bit arm binaries to the APK?",
                "createdAt": "2019-03-18T19:16:25Z"
            },
            {
                "author": "dnfield",
                "bodyText": "Ahh I see.  It's because we'd need to potentially include the AOT snapshot for the target arch as well.  And right now we just put that under assets, we don't put a per-architecture version under libs.  If we could put the AOT snapshot into the architecture specific libs folder that might work, otherwise we'd want to use the .aab format for that reason.\nWe want to do this anyway to support building .AARs for add2app use cases.  I'll poke at it.",
                "createdAt": "2019-03-18T19:22:18Z"
            },
            {
                "author": "rodydavis",
                "bodyText": "ndk {\n            if (project.hasProperty('target-platform') &&\n               project.property('target-platform') == 'android-arm64') {\n                abiFilters 'arm64-v8a'\n            } else {\n                abiFilters 'armeabi-v7a'\n            }\n        }\n\n\nThis worked for me after days of troubleshooting",
                "createdAt": "2019-03-22T18:30:53Z"
            },
            {
                "author": "robsonmeemo",
                "bodyText": "The solution posted by @AppleEducate does not work when I try to run the app on the emulator.",
                "createdAt": "2019-03-25T23:12:59Z"
            },
            {
                "author": "Ricket",
                "bodyText": "Put it in the release section",
                "createdAt": "2019-03-26T01:56:02Z"
            },
            {
                "author": "edTheGuy00",
                "bodyText": "This was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\n\n\nupload app-armeabi-v7a-release.apk to the play store\n\n\nincrement versionCode\n\n\nrun flutter build apk --release --target-platform=android-arm64 \n\n\nupload app-arm64-v8a-release.apk to the play store\n\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be  10MB+",
                "createdAt": "2019-03-28T08:44:41Z"
            },
            {
                "author": "MarcelEdward2",
                "bodyText": "@edTheGuy00  I doubt it is interesting how big the upload to the play store is. The android phones will ask for a 125+ temporay free space anyhow and wil refuse to use external storage for unpacking. That is all users will know about the app size, It does not really matter how much an app uses after installing. It will ask for the 125mb+ free space for installing.\nPlease make it possible to include all possible architectures. I don\"t care if the upload to the play store will be 250mb.\nIt would be nice if flutter would use the gigabites space on the external storage for installling on an android phone. That is if flutter can influence the installation on an android phone",
                "createdAt": "2019-03-28T09:02:03Z"
            },
            {
                "author": "slightfoot",
                "bodyText": "I think the flutter.gradle script should include all ABIs into the final APK (Universal APK) and then default turn split APKs on. The android tools will select the right APK to upload to the connected device and all is well. The final universal APK can then be uploaded to the play-store, or either the split APKs for each ABI.\nIn the meantime as a solution you can add this to the bottom of your build.gradle in your android\\app directory.\n// Include both 32bit and 64bit arm libflutter.so files into your APK\nproject.afterEvaluate {\n\tassembleRelease.doLast {\n\t\tString src\n\t\tif(project.hasProperty('target-platform') &&\n\t\t\tproject.property('target-platform') == 'android-arm64') {\n\t\t\t// If we are building the 64bit then we also want to add the 32bit libflutter.so\n\t\t\tsrc = \"$flutterRoot/bin/cache/artifacts/engine/android-arm-release/flutter.jar\"\n\t\t}else{\n\t\t\t// If we are building the opposite (32bit), we include the 64bit libflutter.so\n\t\t\tsrc = \"$flutterRoot/bin/cache/artifacts/engine/android-arm64-release/flutter.jar\"\n\t\t}\n\t\tcopy {\n\t\t\tfrom zipTree(src)\n\t\t\tinclude 'lib/*/libflutter.so'\n\t\t\tinto \"$buildDir/intermediates/jniLibs/release/0/\"\n\t\t}\n\t}\n}\nI also recommend adding this to your buildTypes > release section. This will ensure your release APK contains both ABIs.\nndk {\n    abiFilters 'armeabi-v7a', 'arm64-v8a'\n}",
                "createdAt": "2019-03-28T11:09:44Z"
            },
            {
                "author": "gerryhigh",
                "bodyText": "After a collab with @slightfoot we came up with this but it's still not quite right as you have to build twice initially to pick up the libs that get inserted into your src directory.\nproject.afterEvaluate {\n    assembleRelease.doFirst {\n\n        String src\n        if(project.hasProperty('target-platform') &&\n                project.property('target-platform') == 'android-arm64') {\n            // If we are building the 64bit then we also want to add the 32bit libflutter.so\n            src = \"$flutterRoot/bin/cache/artifacts/engine/android-arm-release/flutter.jar\"\n        }else{\n            // If we are building the opposite (32bit), we include the 64bit libflutter.so\n            src = \"$flutterRoot/bin/cache/artifacts/engine/android-arm64-release/flutter.jar\"\n        }\n        copy {\n            from zipTree(src)\n            include 'lib/*/libflutter.so'\n            into \"src/main/jniLibs/\"\n            eachFile {\n                it.path = it.path.replaceFirst(\"lib/\", \"\")\n            }\n        }\n    }\n}\n\n\nUpdate: After trying to run this APK on the device it fails and thus is not a viable solution. The error is \"Error while initializing the Dart VM: Snapshot not compatible with the current VM configuration:\nthe snapshot requires 'product use_bare_instructions no-\"asserts\" causal_async_stacks arm-eabi softfp'\nbut the VM has 'product use_bare_instructions no-\"asserts\" causal_async_stacks arm64-sysv'\"",
                "createdAt": "2019-03-30T20:42:07Z"
            },
            {
                "author": "ened",
                "bodyText": "Ahh I see. It's because we'd need to potentially include the AOT snapshot for the target arch as well. And right now we just put that under assets, we don't put a per-architecture version under libs. If we could put the AOT snapshot into the architecture specific libs folder that might work, otherwise we'd want to use the .aab format for that reason.\nWe want to do this anyway to support building .AARs for add2app use cases. I'll poke at it.\n\n@dnfield did you have some success at this, yet?",
                "createdAt": "2019-03-31T15:07:02Z"
            },
            {
                "author": "dnfield",
                "bodyText": "Working through the plug-in piece at the moment.  We've been trying to get parts of it prioritized to fix the Android X issues but should see some more come out of that.",
                "createdAt": "2019-03-31T15:27:50Z"
            },
            {
                "author": "slightfoot",
                "bodyText": "@gerryhigh and myself were looking into this. Please ignore my last replies. The problem is just the fact that libflutter.so is not included for 64bit but for AOT you have to run the build process twice, once for 32bit and again for 64bit. You then get two sets of compiled Dart code in your application assets as well as two versions of libflutter.so. I think the eventual goal would be to setup compilation tasks for Flutter so that it runs the two separate build steps and have split APKs setup automatically.\nBut for the moment, the only solution is to run the build twice and uploading multiple-APKs to the Play Store.\nflutter build apk --release --target-platform=android-arm\nflutter build apk --release --target-platform=android-arm64\n\nThis can be better be achieved with enabling split-APKs. More details can be found here: https://developer.android.com/studio/build/configure-apk-splits",
                "createdAt": "2019-04-01T16:22:21Z"
            },
            {
                "author": "edTheGuy00",
                "bodyText": "@slightfoot yes this is the best solution I have found so far as mentioned in my comment up there #18494 (comment)",
                "createdAt": "2019-04-01T16:30:03Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@slightfoot if I understand correctly, it would not be possible to build an universal APK as some code are located in the assets folder which does not allow to split files according to targeted archtecture as the lib folder ?",
                "createdAt": "2019-04-02T08:14:48Z"
            },
            {
                "author": "ctrysbita",
                "bodyText": "The snapshot built for each architecture is different. Simply copy the engine libflutter.so will cause the snapshot cannot be loaded if the architecture of snapshot doesn't match the architecture of flutter engine.\nSo currently there is no way for us to build a universal apk that contains all architectures unless separate the snapshot files and include the snapshot file for every architecture.",
                "createdAt": "2019-04-02T08:27:22Z"
            },
            {
                "author": "josh-burton",
                "bodyText": "I'm a bit confused as to why this is even a problem.\nDebug builds create libflutter.so in x86_64, x86, armeabi-v7a, and arm64-v8a.\nRelease builds should do exactly the same.\nAGP (Android Gradle Plugin) already includes the functionality to filter out architectures, so if a user wishes to do that for a release build they can modify their build.gradle.\n@eseidel @dnfield I don't really think this is solved by Android App Bundles - they are not the default Android output yet and when running from the IDE apks will be used for quite a while yet I'm sure.\nAABs are another reason why Flutter should include all architectures of libflutter.so as the Play Store can filter out which architecture it delivers to devices.",
                "createdAt": "2019-04-13T09:18:43Z"
            },
            {
                "author": "edTheGuy00",
                "bodyText": "@athornz the problem is  not with libflutter.so but with your dart code compiling down to a AOT snapshot  debug builds include the Dart VM so all your dart code just runs JIT on the VM, but release builds compile your dart code into a snapshot and place that snapshot into an assets folder. Ideally the snapshot should be compiled for each architecture and placed alongside libflutter.so but that is not the case at the moment. So while you can include libflutter.so for all the architectures, the snapshot will only work for whatever architecture it was compiled for.",
                "createdAt": "2019-04-13T10:01:21Z"
            },
            {
                "author": "trevorwang",
                "bodyText": "Any plan to fix this issue?\nGoogle Play store ask developer to provide 64-bit support after  August 1, 2019.\nhttps://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html\n\nThe 64-bit requirement: what it means for developers\nStarting August 1, 2019:\nAll new apps and app updates that include native code are required to provide 64-bit versions in addition to 32-bit versions when publishing to Google Play.\nExtension: Google Play will continue to accept 32-bit only updates to existing games that use Unity 5.6.6 or older until August 2021.\nStarting August 1, 2021:\nGoogle Play will stop serving apps without 64-bit versions on 64-bit capable devices, meaning they will no longer be available in the Play Store on those devices.\nThis will include games built with Unity 5.6.6 or older.",
                "createdAt": "2019-04-18T06:55:00Z"
            },
            {
                "author": "slightfoot",
                "bodyText": "@trevorwang we can already build 64bit and upload them along with 32bit to the Play Store. So that isn't a problem.",
                "createdAt": "2019-04-18T07:27:06Z"
            },
            {
                "author": "trevorwang",
                "bodyText": "@slightfoot Do you mean I have to build another 64-bit APK and upload it to Google Play?\nAs you know, Google Play is not available in China mainland. We prefer a universal APK to support all platforms.",
                "createdAt": "2019-04-18T07:34:19Z"
            },
            {
                "author": "edTheGuy00",
                "bodyText": "@trevorwang pretty much. This is how I do it  #18494 (comment)",
                "createdAt": "2019-04-18T07:36:40Z"
            },
            {
                "author": "MarcelEdward2",
                "bodyText": "The split thing does not work in the gradfle file.  You have to do something with one of the build.gradle files so flutter knows how to compile different architectures. Or google play will reject the second compile.",
                "createdAt": "2019-04-18T07:42:07Z"
            },
            {
                "author": "trevorwang",
                "bodyText": "Thanks @edTheGuy00\nBut we really need a universal APK including all abis  for China Market.",
                "createdAt": "2019-04-18T07:43:18Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@trevorwang you can build for each targets and explicitely state for which architecture each APK is for. This is how it is done for a lot majority of APK mirror sites.\nThe 64bit limitation is just a limitation of the Google Play Store. You can still deploy the armeabi-v7a only APK and everyone would be able to run your app.",
                "createdAt": "2019-04-18T07:49:52Z"
            },
            {
                "author": "josh-burton",
                "bodyText": "Building separate APKs per architecture is a workaround and definitely not a solution for everyone.\nOnce the Google Play 64bit limitation comes into effect this issue will impact most Flutter developers so we really do need a solution that allows for multiple architectures within one apk/bundle.",
                "createdAt": "2019-04-18T09:32:28Z"
            },
            {
                "author": "edTheGuy00",
                "bodyText": "Just a quick reminder\nThe Flutter team uses the number of \"Thumbs-up\" on a GitHub issue as a guide to its priority.\nI think this issue should be high up in priority.",
                "createdAt": "2019-04-19T03:35:14Z"
            },
            {
                "author": "trevorwang",
                "bodyText": "Thanks for the work of  @gerryhigh  and @slightfoot\nI have added flutter to an existed app and fixed this issue by the following workaround.\nPlease add this to your app module of the host project.\n\nThis is the script for Debug mode, please change accordingly for release.\n\nproject.afterEvaluate {\n    assembleDebug.doLast {\n        def flutterRoot = System.getenv(\"FLUTTER_HOME\")\n        def archTypes = [\"arm\", \"arm64\"]\n        archTypes.forEach { item ->\n            copy {\n                from zipTree(\"$flutterRoot/bin/cache/artifacts/engine/android-$item/flutter.jar\")\n                include 'lib/*/libflutter.so'\n                into \"$buildDir/intermediates/jniLibs/debug/\"\n                eachFile {\n                    it.path = it.path.replaceFirst(\"lib/\", \"\")\n                }\n            }\n        }\n    }\n}",
                "createdAt": "2019-04-28T10:36:37Z"
            },
            {
                "author": "zhancheng",
                "bodyText": "Any recent developments?",
                "createdAt": "2019-04-30T11:27:00Z"
            },
            {
                "author": "andreidiaconu",
                "bodyText": "What I ended up doing, since I wanted\n\nseparate apks for each architecture\nnot to have to modify the versionCode manually\nrun a single command to produce the apks\n\n\nAdded this to gradle. It adds 1 or 2 at the end of the versionCode, so version 1004 becomes 10041 for arm and 10042 for arm64.\n\next.platformCodes = ['android-arm': 1, 'android-arm64' : 2]\nandroid.applicationVariants.all { variant ->\n    variant.outputs.each { output ->\n        int code = 0\n        if (project.hasProperty('target-platform')) {\n            code = project.ext.platformCodes.get(project.property('target-platform'))\n        }\n        output.versionCodeOverride = variant.versionCode * 10 + code\n    }\n}\n\n\nTo produce the apks I use a longer terminal command (which you can put in a script). It runs the build twice and creates copies of the apks at the end:\n\nflutter clean; flutter build apk --release --target-platform=android-arm; mv build/app/outputs/apk/release/app-release.apk build/app/outputs/apk/release/app-release-arm32.apk; flutter build apk --release --target-platform=android-arm64; mv build/app/outputs/apk/release/app-release.apk build/app/outputs/apk/release/app-release-arm64.apk;\n\nHope this helps.",
                "createdAt": "2019-05-02T09:17:21Z"
            },
            {
                "author": "BND10706",
                "bodyText": "So this is an issue that I am having as well.. I have building an app bundle instead of an apk and when i have been uploading it to google it gives me the warning and wont let me alpha test it.\nIve been using codemagic to do it, is there a way to sign it and put it in a bundle? or use codemagic to dot it?",
                "createdAt": "2019-05-02T10:56:43Z"
            },
            {
                "author": "PandaGeek1024",
                "bodyText": "Im facing the same issue which I thought shouldn't exist at all.",
                "createdAt": "2019-05-02T11:22:02Z"
            },
            {
                "author": "lifenautjoe",
                "bodyText": "How come this is on the Milestone \"Goals\".\n\nP2: These are tasks we think are worth fixing in the coming years. It includes issues we've identified that might block fully shipping broad consumer-facing apps, correctness issues, and bugs relating to polish and quality. The date on this milestone is utterly arbitrary and just intended to sort the milestone appropriately.\n\nIt's a critical issue already and will become a full blown show-stopper later this year once Google enforces the 64bit limitation.",
                "createdAt": "2019-05-02T21:12:26Z"
            },
            {
                "author": "dnfield",
                "bodyText": "I've bumped the milestone on this.  No solid date yet.\nTo be clear: it is possible, but difficult, to comply with the new guidelines today.  We want to make that easier.",
                "createdAt": "2019-05-02T22:12:54Z"
            },
            {
                "author": "BND10706",
                "bodyText": "So @andreidiaconu method worked for me as long as I manually build the app.\nBut I have been using codemagic to build and deploy.\nSo this is a waste, Flutter needs to get this built it.",
                "createdAt": "2019-05-03T01:55:25Z"
            },
            {
                "author": "masewo",
                "bodyText": "At the moment I personally do not really care if it is complicated. If it is complicated it will get automated by a script. The question is if it is possible and how because Google Play Console warns me:\n\nThis release is not compliant with the Google Play 64-bit requirement\nThe following APKs or App Bundles are available to 64-bit devices, but they only have 32-bit native code: 6.\nFrom 1. August 2019 all releases must be compliant with the Google Play 64-bit requirement.\nInclude 64-bit and 32-bit native code in your app. Use the Android App Bundle publishing format to automatically ensure that each device architecture receives only the native code it needs. This avoids increasing the overall size of your app.\n\nI do not want a solution that needs different version codes and I want a solution that works with Android App Bundles (AAB).",
                "createdAt": "2019-05-04T10:55:49Z"
            },
            {
                "author": "mcjons",
                "bodyText": "Warning\nThis release is not compliant with the Google Play 64-bit requirement\nThe following APKs or App Bundles are available to 64-bit devices, but they only have 32-bit native code: 3.",
                "createdAt": "2019-05-05T09:20:50Z"
            },
            {
                "author": "mcjons",
                "bodyText": "Any solution?",
                "createdAt": "2019-05-05T09:21:08Z"
            },
            {
                "author": "pablote",
                "bodyText": "I've bumped the milestone on this. No solid date yet.\nTo be clear: it is possible, but difficult, to comply with the new guidelines today. We want to make that easier.\n\nShould the docs be updated with instructions on how to do this for both apk and app bundles? All I\u2019ve seen so far are bunchs of code and config which I\u2019m not exactly sure where to put. I could probably figure it out with some trial and error, but it\u2019s less than ideal.",
                "createdAt": "2019-05-05T22:20:51Z"
            },
            {
                "author": "Nastya-Scherbakova",
                "bodyText": "same issue",
                "createdAt": "2019-05-06T07:56:46Z"
            },
            {
                "author": "noinskit",
                "bodyText": "Thanks for the work of @gerryhigh and @slightfoot\nI have added flutter to an existed app and fixed this issue by the following workaround.\nPlease add this to your app module of the host project.\n\nThis is the script for Debug mode, please change accordingly for release.\n\nproject.afterEvaluate {\n    assembleDebug.doLast {\n        def flutterRoot = System.getenv(\"FLUTTER_HOME\")\n        def archTypes = [\"arm\", \"arm64\"]\n        archTypes.forEach { item ->\n            copy {\n                from zipTree(\"$flutterRoot/bin/cache/artifacts/engine/android-$item/flutter.jar\")\n                include 'lib/*/libflutter.so'\n                into \"$buildDir/intermediates/jniLibs/debug/\"\n                eachFile {\n                    it.path = it.path.replaceFirst(\"lib/\", \"\")\n                }\n            }\n        }\n    }\n}\n\n\nThis solution/workaround looks most promising, thanks @trevorwang ! I do have problems implementing this in an existing flutter project, though. Do you have an example build.gradle file or something equivalent that would demo this?",
                "createdAt": "2019-05-06T14:34:52Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "PLEASE NOTE THAT THIS PROBABLY WON'T SOLVE YOUR PROBLEM - SEE BELOW\nThanks to @trevorwang answer & @noinskit suggestion I've managed to include 64bit native libs in release builds with a small addition to ./android/app/build.gradle shown below.\nYou can also view the whole file here.\nafterEvaluate {\n    mergeReleaseJniLibFolders.doLast {\n        def archTypes = [\"arm-release\", \"arm64-release\"]\n        archTypes.forEach { item ->\n            copy {\n                from zipTree(\"$flutterRoot/bin/cache/artifacts/engine/android-$item/flutter.jar\")\n                include 'lib/*/libflutter.so'\n                into \"$buildDir/intermediates/jniLibs/release/\"\n                eachFile {\n                    it.path = it.path.replaceFirst(\"lib/\", \"\")\n                }\n            }\n        }\n    }\n}",
                "createdAt": "2019-05-06T22:29:50Z"
            },
            {
                "author": "noinskit",
                "bodyText": "@SPodjasek thanks! I arrived at something similar. In my case, I need to change assembleRelease in your snippet to mergeReleaseJniLibFolders, otherwise the extra *.so file ends up under \"intermediates/...\", but not in the final apk.",
                "createdAt": "2019-05-06T23:11:09Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "@noinskit It seems that my previous solution was error prone. After running flutter clean it generated aab's with just 32bit libs. Replacing assembleRelease with mergeReleaseJniLibFolders seems to work also after cleaning of the build true.",
                "createdAt": "2019-05-07T10:15:11Z"
            },
            {
                "author": "function1983",
                "bodyText": "@SPodjasek do you have to tweak any other options?\nHere is my app.gradle\ndef flutterRoot = localProperties.getProperty('flutter.sdk')\nif (flutterRoot == null) {\n    throw new GradleException(\"Flutter SDK not found. Define location with flutter.sdk in the local.properties file.\")\n}\n\nafterEvaluate {\n    mergeReleaseJniLibFolders.doLast {\n        def archTypes = [\"arm-release\", \"arm64-release\"]\n        archTypes.forEach { item ->\n            copy {\n                from zipTree(\"$flutterRoot/bin/cache/artifacts/engine/android-$item/flutter.jar\")\n                include 'lib/*/libflutter.so'\n                into \"$buildDir/intermediates/jniLibs/release/\"\n                eachFile {\n                    it.path = it.path.replaceFirst(\"lib/\", \"\")\n                }\n            }\n        }\n    }\n}\n\nBoth of my intermediates/jniLibs/release/arm64-v8a and armeabi-v7a directories have libflutter.so as expected but the final release APK still missing libflutter.so in arm64-v8a.\nHere is the screenshot",
                "createdAt": "2019-05-07T11:01:32Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "@function1983 You can see my complete build.gradle here.\nAs of my flutter version:\n[\u2713] Flutter (Channel beta, v1.5.4, on Linux, locale pl_PL.UTF-8)\n    \u2022 Flutter version 1.5.4 at .../development/flutter\n    \u2022 Framework revision b593f5167b (2 weeks ago), 2019-04-22 07:51:33 -0700\n    \u2022 Engine revision ca31a7c57b\n    \u2022 Dart version 2.3.0 (build 2.3.0-dev.0.1 cf4444b803)\n\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n    \u2022 Android SDK at .../Android/Sdk\n    \u2022 Android NDK location not configured (optional; useful for native profiling support)\n    \u2022 Platform android-28, build-tools 28.0.3\n    \u2022 Java binary at: .../development/android-studio/jre/bin/java\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b16-5323222)\n    \u2022 All Android licenses accepted.\n\n[\u2713] Android Studio (version 3.4)\n    \u2022 Android Studio at .../development/android-studio\n    \u2022 Flutter plugin version 35.2.1\n    \u2022 Dart plugin version 183.6270\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b16-5323222)",
                "createdAt": "2019-05-07T11:47:25Z"
            },
            {
                "author": "Torrunt",
                "bodyText": "I've been trying to use @SPodjasek's solution to build an appbundle that includes both 64 and 32 bit versions. It successfully builds, I can upload it to Google Play Console and I can install it on both 32 and 64 bit phones. But the app crashes when launched on an android-arm64 device for some reason (seems to work on an old 32bit android phone I was testing with though).\nHere is the error I get on the 64bit device:\n\nAbort message: '[FATAL:flutter/runtime/dart_vm.cc(416)] Error while initializing the Dart VM: Snapshot not compatible with the current VM configuration: the snapshot requires 'product use_bare_instructions no-\"asserts\" causal_async_stacks arm-eabi softfp' but the VM has 'product use_bare_instructions no-\"asserts\" causal_async_stacks arm64-sysv'\n\nNot sure what I can do... Might have to stick with only supporting 64bit devices for now.",
                "createdAt": "2019-05-08T02:37:23Z"
            },
            {
                "author": "dnfield",
                "bodyText": "@Torrunt that error is because the Engine is trying to loat the AOT snapshot for 32bit and finding one for 64.\nWe're working on being able to produce an AAB that has both so that the store can correctly split these out.",
                "createdAt": "2019-05-08T02:53:29Z"
            },
            {
                "author": "dark-chocolate",
                "bodyText": "@SPodjasek Using this increased my app-release.apk file size from 11.1 MB to 15.7 MB",
                "createdAt": "2019-05-09T12:48:23Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "@SPodjasek Using this increased my app-release.apk file size from 11.1 MB to 15.7 MB\n\nYes, as it forcefully includes libflutter.so for 32 & 64bit. If you don't need that, stick with current default to include 32bit only and wait for flutter team to deal with this properly.",
                "createdAt": "2019-05-09T13:07:14Z"
            },
            {
                "author": "MarcelEdward2",
                "bodyText": "looks like there are a few possibilities:\n\nwait till the flutter team resolves the 32 vs 64 architecture thing making google play store accept the flutter builds again\nwe have to limit the android devices used to 32 bit only, so flutter apps will only run on 32 bit devices\nwe have to somehow convice google not to enforce 64 bit on the play store. (I wonder what the difference is between 32 and 64 bit, somthing like bigger numbers ?)\ninstall the 32 apps somehow on 64 bit devices but not in the play store ...",
                "createdAt": "2019-05-09T14:16:12Z"
            },
            {
                "author": "ndusart",
                "bodyText": "Note for people using --target-platform to build for android-arm and android-arm64 separately and upload two APK.\nPay attention that some plugins use native libraries that may target both, and flutter does not filter the libraries folders so your \"32 bits\" APK will actually still target arm64 as well and it will crash as libflutter.so is not present and AOT snapshots are built for armv7.\nSo, you'll need to actually explicitely filter the target abi in your build.gradle file.\nI think the flutter build apk --target-platform ... should logically do this filtering.",
                "createdAt": "2019-05-09T14:30:05Z"
            },
            {
                "author": "CoreyCole",
                "bodyText": "Using @SPodjasek's solution, I got an error about matching arm-eabi versus arm64-sysv. I think the best solution, that worked for me, is just building for 32 bit for the time being until this is all sorted out (@swavkulinski's solution here):\nIn your app level build.gradle:\nandroid {\n    // ...\n    buildTypes {\n        release {\n            // ...\n            ndk {\n                abiFilters \"armeabi-v7a\"\n            }\n        }\n    }\n}",
                "createdAt": "2019-05-14T17:16:35Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "Summarising issue from the subject - it won't be possible to build such APK for both armeabi-v7a and arm64-v8a. Flutter uses AOT snapshots which are ABI dependant, so with APK only possible solution would be to use multiple APK builds.\nThe solution would be to use App Bundles, which, as for now also has some issues (#31922).\nAfter #32787 got merged it's now possible to use App Bundles.",
                "createdAt": "2019-05-14T20:29:11Z"
            },
            {
                "author": "shinayser",
                "bodyText": "How do I set the flavor and my target file (-t lib/another_main.dart, for example) when generating an Android app Bundle via Android Studio? o.o",
                "createdAt": "2019-05-14T21:12:01Z"
            },
            {
                "author": "blasten",
                "bodyText": "This will be supported via flutter build appbundle after #32787 is merged!",
                "createdAt": "2019-05-20T01:17:50Z"
            },
            {
                "author": "swavkulinski",
                "bodyText": "@swavkulinski how would you release the to apks to the playstore?\n\nIt was still possible back then. Now you have to limit to 64bit. We were lockdown by the third party NDK library which was 32bit only.",
                "createdAt": "2019-05-20T14:22:24Z"
            },
            {
                "author": "zimmi",
                "bodyText": "@blasten\nWill this also add support for flutter build apk --release? Or is it planned to phase out support for  APKs in favor of app bundles in the long term? I quite like the relative simplicity of the fat APK.",
                "createdAt": "2019-05-20T18:11:19Z"
            },
            {
                "author": "blasten",
                "bodyText": "@zimmi Correct. App bundles should be the way going forward. You can still use flutter build apk --release when necessary. What is simpler in a fat APK compared to AAB?",
                "createdAt": "2019-05-20T18:22:04Z"
            },
            {
                "author": "audkar",
                "bodyText": "What is simpler in a fat APK compared to AAB?\n\nAAB is not installation file. Android itself can't use it. It's file format for Google Play store only. So need apk when:\n\nInstalling directly to device.\nDirectly distributing app.\nDistributing via any other app market except Google Play store. (amazon & all China).",
                "createdAt": "2019-05-20T18:45:09Z"
            },
            {
                "author": "blasten",
                "bodyText": "I see. Thanks for the background.\nAlso, you can extract the APKs from the AAB using bundletool.",
                "createdAt": "2019-05-20T18:53:30Z"
            },
            {
                "author": "zimmi",
                "bodyText": "@blasten\nThank you for confirming!\nRegarding the simplicity comment: What @audkar said. Also with AABs, the developer has to think about potential failure scenarios caused by missing assets. Testing on all possible device configurations is hard, so if those failures occur, it's likely in production.\nApp size might be a price some are willing to pay for that peace of mind.\nI'm sure there are better places to discuss the merits of each approach than this issue though, I don't want to derail it.",
                "createdAt": "2019-05-20T19:40:21Z"
            },
            {
                "author": "blasten",
                "bodyText": "/cc @jonahwilliams  we may need to support fat APKs in build apk.\nShould we also change the default for build apk?",
                "createdAt": "2019-05-20T20:06:15Z"
            },
            {
                "author": "josh-burton",
                "bodyText": "Fat apk support is definitely needed. There a lots of tools (beta distribution etc) that don't yet work with app bundles.",
                "createdAt": "2019-05-20T20:35:50Z"
            },
            {
                "author": "blasten",
                "bodyText": "flutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this:  flutter build apk --target-platform android-arm,android-arm64",
                "createdAt": "2019-05-20T21:49:58Z"
            },
            {
                "author": "mattetti",
                "bodyText": "@blasten I switched to the master channel, upgraded and build the appbundle, it worked well. Then uploaded it to the play console and all warnings are gone. (macOS 10.14.4)",
                "createdAt": "2019-05-21T00:12:54Z"
            },
            {
                "author": "BND10706",
                "bodyText": "Awesome! I will compile my build tonight after I make my changes.",
                "createdAt": "2019-05-21T00:35:06Z"
            },
            {
                "author": "mattetti",
                "bodyText": "The bundle doesn't to seem to work tho, the app crashes when being downloaded.\nIssue: java.lang.RuntimeException: Unable to instantiate activity ComponentInfo{com.mattetti.sounds/com.mattetti.sounds.MainActivity}: java.lang.ClassNotFoundException: Didn't find class \"com.mattetti.sounds.MainActivity\" on path: DexPathList[[zip file \"/data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/base.apk\", zip file \"/data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/split_config.arm64_v8a.apk\", zip file \"/data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/split_config.xxhdpi.apk\"],nativeLibraryDirectories=[/data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/lib/arm64, /data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/base.apk!/lib/arm64-v8a, /data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/split_config.arm64_v8a.apk!/lib/arm64-v8a, /data/app/com.mattetti.sounds-ewwlQg0QphABpwu8t14HWA==/split_config.xxhdpi.apk!/lib/arm64-v8a, /system/lib64]]",
                "createdAt": "2019-05-21T01:16:47Z"
            },
            {
                "author": "blasten",
                "bodyText": "It seems like com.mattetti.sounds.MainActivity isn't in the bundle?",
                "createdAt": "2019-05-21T01:21:07Z"
            },
            {
                "author": "mattetti",
                "bodyText": "Not sure why, how can I check why it's removed?",
                "createdAt": "2019-05-21T01:29:39Z"
            },
            {
                "author": "blasten",
                "bodyText": "@mattetti Are you using a Flutter module? Is MainActivity extending FlutterActivity?",
                "createdAt": "2019-05-21T04:31:28Z"
            },
            {
                "author": "mattetti",
                "bodyText": "@blasten\nHere are my dependencies\nenvironment:\n  sdk: \">=2.2.2 <3.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n  rxdart: ^0.22.0\n  shared_preferences: ^0.5.2\n  http: ^0.12.0\n  cached_network_image: ^0.8.0\n  url_launcher: ^5.0.2\n\n  # The following adds the Cupertino Icons font to your application.\n  # Use with the CupertinoIcons class for iOS style icons.\n  cupertino_icons: ^0.1.2\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_launcher_icons: \"^0.7.0\"\n\ndependency_overrides:\n  # requried for flutter_icons at this point\n  image: 2.0.7\n\nBut I also just noticed that I renamed the package of my app but didn't change the path to my MainActivity.java file which is still android/app/src/main/java/com/example/old_name/ that might be the issue. Tomorrow, I'll try to change the path and push another bundle.",
                "createdAt": "2019-05-21T04:58:46Z"
            },
            {
                "author": "skybur",
                "bodyText": "hello @blasten , I tried to build the appbundle and got this error\n[  +48 ms] FAILURE: Build failed with an exception.\n[   +3 ms] * What went wrong:\n[        ] Failed to capture snapshot of input files for task ':app::flutter:package:packLibsDevRelease' property\n'rootSpec$2$1' during up-to-date check.\n[        ] > java.io.IOException: The filename, directory name, or volume label syntax is incorrect\n[        ] * Try:\n[        ] Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log\noutput. Run with --scan to get full insights.\n[        ] * Get more help at https://help.gradle.org\n[        ] Deprecated Gradle features were used in this build, making it incompatible with Gradle 5.0.\n[        ] See https://docs.gradle.org/4.6/userguide/command_line_interface.html#sec:command_line_warnings\n[        ] BUILD FAILED in 1m 28s\n\nMy project uses flavor and this is the command I run\nflutter build appbundle --flavor stage -t lib/main-stage.dart -v",
                "createdAt": "2019-05-21T04:59:25Z"
            },
            {
                "author": "nohli",
                "bodyText": "Will the app bundle also include mapping.txt? When uploading app bundles to Google Play Console via Codemagic, there is no mapping.txt included, so no automated testing or pre-launch-reports - which you have when uploading an apk :(",
                "createdAt": "2019-05-21T08:48:25Z"
            },
            {
                "author": "YazeedAlKhalaf",
                "bodyText": "so the question is:\nWill Flutter team make an update for 64-bit release or not before August so we can upload and update our apps that are made with flutter or not?",
                "createdAt": "2019-05-22T00:32:22Z"
            },
            {
                "author": "blasten",
                "bodyText": "@YazeedAlKhalaf Yes. You can use flutter build appbundle today and you will get an app bundle that contains 32 and 64 bits.\n@mattetti is the issue fixed?\n@nohli  mapping.txt sounds like a feature request. Feel free to file a new bug.\n@skybur can you run flutter doctor? Is your Flutter project an app or module?",
                "createdAt": "2019-05-22T01:08:13Z"
            },
            {
                "author": "skybur",
                "bodyText": "@blasten  My project is an app.\nHere is the flutter doctor result\n[\u221a] Flutter (Channel master, v1.6.1-pre.68, on Microsoft Windows [Version 10.0.17763.503], locale en-US)\n    \u2022 Flutter version 1.6.1-pre.68 at D:\\Devs\\Flutter\\testappbundle\\flutter\n    \u2022 Framework revision d5aae54a28 (22 hours ago), 2019-05-20 23:19:18 -0400\n    \u2022 Engine revision 301f560bd8\n    \u2022 Dart version 2.3.1 (build 2.3.1-dev.0.0 b48c8b1d1c)\n\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n    \u2022 Android SDK at D:\\AndroidSDK\n    \u2022 Android NDK location not configured (optional; useful for native profiling support)\n    \u2022 Platform android-28, build-tools 28.0.3\n    \u2022 ANDROID_HOME = D:\\AndroidSDK\n    \u2022 ANDROID_SDK_ROOT = D:\\AndroidSDK\n    \u2022 Java binary at: D:\\AndroidStudio\\jre\\bin\\java\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1136-b06)\n    \u2022 All Android licenses accepted.\n\n[\u221a] Android Studio (version 3.2)\n    \u2022 Android Studio at D:\\AndroidStudio\n    \u2022 Flutter plugin version 31.3.1\n    \u2022 Dart plugin version 181.5656\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1136-b06)\n\n[\u221a] VS Code, 64-bit edition (version 1.33.1)\n    \u2022 VS Code at C:\\Program Files\\Microsoft VS Code\n    \u2022 Flutter extension version 3.0.2\n\n[!] Connected device\n    ! No devices available\n\n! Doctor found issues in 1 category.",
                "createdAt": "2019-05-22T01:47:44Z"
            },
            {
                "author": "zjelo",
                "bodyText": "@blasten: getting the same error as skybur",
                "createdAt": "2019-05-22T07:09:41Z"
            },
            {
                "author": "Kiruel",
                "bodyText": "Trying to use flutter build appbundle then upload to the store, then open from a Android phone:\nInstant crash on opening.\nadb log:\n05-22 09:40:52.404 27305 27305 E flutter : [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.\n05-22 09:40:52.404 27305 27305 E flutter : [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n05-22 09:40:52.404 27305 27305 F flutter : [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n05-22 09:40:52.404 27305 27305 F libc    : Fatal signal 6 (SIGABRT), code -6 in tid 27305 (tform.atomicdex)\n05-22 09:40:52.432 27339 27339 I crash_dump64: obtaining output fd from tombstoned\n05-22 09:40:52.433  1417  1417 I /system/bin/tombstoned: received crash request for pid 27305\n05-22 09:40:52.434 27339 27339 I crash_dump64: performing dump of process 27305 (target tid = 27305)\n05-22 09:40:52.434 27339 27339 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***\n05-22 09:40:52.434 27339 27339 F DEBUG   : Build fingerprint: 'lge/judyln_lao_com/judyln:8.0.0/OPR1.170623.032/190501244a6e5.FGN:user/release-keys'\n05-22 09:40:52.434 27339 27339 F DEBUG   : Revision: '12'\n05-22 09:40:52.434 27339 27339 F DEBUG   : ABI: 'arm64'\n05-22 09:40:52.434 27339 27339 F DEBUG   : pid: 27305, tid: 27305, name: PACKAGE_NAME >>> PACKAGE_NAME <<<\n05-22 09:40:52.434 27339 27339 F DEBUG   : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------\n05-22 09:40:52.435 27339 27339 F DEBUG   : Abort message: '[FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n05-22 09:40:52.435 27339 27339 F DEBUG   : '\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x0   0000000000000000  x1   0000000000006aa9  x2   0000000000000006  x3   0000000000000008\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x4   0000000007d0bf68  x5   0000000007d0bf68  x6   0000000007d0bf68  x7   0000000007d0bfd8\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x8   0000000000000083  x9   8644075c81e36b5a  x10  00000077ccff6a48  x11  8644075c81e36b5a\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x12  8644075c81e36b5a  x13  0000000000000020  x14  ffffffffffffffdf  x15  00000077ca27ec68\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x16  00000077ca2732b8  x17  00000077ca205a44  x18  0000000000000048  x19  0000000000006aa9\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x20  0000000000006aa9  x21  0000007fe4fb81b8  x22  00000077b3dffba0  x23  00000077bd29d7a0\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x24  00000077aa79a150  x25  0000000000000000  x26  0000000000000000  x27  0000000000000002\n05-22 09:40:52.435 27339 27339 F DEBUG   :     x28  0000000000000000  x29  0000007fe4fb81a0  x30  00000077ca1aa8e4\n05-22 09:40:52.435 27339 27339 F DEBUG   :     sp   0000007fe4fb8160  pc   00000077ca205a4c  pstate 0000000060000000\n05-22 09:40:52.436 27339 27339 F DEBUG   :\n05-22 09:40:52.436 27339 27339 F DEBUG   : backtrace:\n05-22 09:40:52.436 27339 27339 F DEBUG   :     #00 pc 0000000000079a4c  /system/lib64/libc.so (tgkill+8)\n05-22 09:40:52.436 27339 27339 F DEBUG   :     #01 pc 000000000001e8e0  /system/lib64/libc.so (abort+88)\n05-22 09:40:52.436 27339 27339 F DEBUG   :     #02 pc 000000000001d61c  /data/app/PACKAGE_NAME-F-z4qH6HT271dk7M7oI8Uw==/split_config.arm64_v8a.apk (offset 0xea7000)```",
                "createdAt": "2019-05-22T09:13:00Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@Kiruel it is very unclear to me why people keep saying that app bundle is solving this issue.\nApp bundle is nothing more than an automated split APK, and there is no split on the assets folder. So the snapshots are still only targeting a single architecture.\nI'm probably missing something but in my opinion, the only solution now is to build APK for each architectures with corresponding ndk filtering in the gradle file. And then upload each of these APK.\nif we cannot solve this issue with APK, there is no chance that app bundle could work either.",
                "createdAt": "2019-05-22T09:25:02Z"
            },
            {
                "author": "andrzejressel",
                "bodyText": "@ndusart I don't think that's true. App bundle docs says:\nres/, lib/, and assets/:\u00a0These directories are identical to those in a typical APK. When you upload your app bundle, Google Play inspects these directories and packages only the files that satisfy the target device configuration, while preserving file paths.\nSo it can somehow split assets.",
                "createdAt": "2019-05-22T09:33:28Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@jereksel this just tell that these directories are working exactly the same way in app bundle than in apk and assets/ folder is not split. It is used to have assets stored in a very specific file structure in the application, it is not meant to be parsed by the OS or anything.\nIf I'm wrong, just tell me how we can split this folder based on target ABI.\nAnd this quote just confirm what I say, if this is not possible right now with APK, this will not be possible using app bundle as these folders work exactly the same in both ways.",
                "createdAt": "2019-05-22T09:43:35Z"
            },
            {
                "author": "andrzejressel",
                "bodyText": "I haven't seen assets split myself, but I found this:\nhttps://medium.com/google-developer-experts/exploring-the-android-app-bundle-ca16846fa3d7\nassets.pb\u200a\u2014\u200aThis is the equivalent of a resource table for application assets and will only be present if you are using assets in your application.\nSo my guess is that Android Studio doesn't split assets, but app bundles themselves have support for that.",
                "createdAt": "2019-05-22T09:55:10Z"
            },
            {
                "author": "ndusart",
                "bodyText": "Have you any official documentation ? All that seems very unreliable.\nThe following article, https://medium.com/mindorks/android-app-bundle-aab-98de6dad8ba8, states that we can append a suffix the name of folders in assets/ to split it but currently this can only be done on language.\nSo still, this does not seems stable yet and should not be based on right now. The VM snapshots should be either deported in the lib/ folder if that's possible or flutter command should come with a complete feature to build an APK for a specific target (there is still work to do on that for being accessible to a lot of people) and delay the production of an app bundle when it is ready to.",
                "createdAt": "2019-05-22T10:40:12Z"
            },
            {
                "author": "MoacirSchmidt",
                "bodyText": "@blasten\nI switched to the master channel, upgraded and build the appbundle. Unfortunately app chashes after downloaded from google play store with following logcat\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n2019-05-22 09:42:14.824 6995-6995/? A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n\n\nflutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this: flutter build apk --target-platform android-arm,android-arm64",
                "createdAt": "2019-05-22T12:47:03Z"
            },
            {
                "author": "CaramelDunes",
                "bodyText": "@blasten\nI switched to the master channel, upgraded and build the appbundle. Unfortunately app chashes after downloaded from google play store with following logcat\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n2019-05-22 09:42:14.824 6995-6995/? A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n\n\nflutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this: flutter build apk --target-platform android-arm,android-arm64 \n\n\nHave the same problem, although I do not have any logs yet.",
                "createdAt": "2019-05-22T14:52:28Z"
            },
            {
                "author": "blasten",
                "bodyText": "@skybur the issue you were having might be related to #33119. If that is case, this patch should fix it.",
                "createdAt": "2019-05-22T15:19:05Z"
            },
            {
                "author": "andrzejressel",
                "bodyText": "@ndusart\nYeah, you're right. I've checked bundletool source code and assets split is only by language indeed:\nhttps://github.com/google/bundletool/blob/master/src/main/java/com/android/tools/build/bundletool/splitters/ModuleSplitter.java#L286",
                "createdAt": "2019-05-22T17:11:54Z"
            },
            {
                "author": "Tokenyet",
                "bodyText": "This was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\nupload app-armeabi-v7a-release.apk to the play store\nincrement versionCode\nrun flutter build apk --release --target-platform=android-arm64 \nupload app-arm64-v8a-release.apk to the play store\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be 10MB+\n\nThere is an important thing to tell you guys. If you use the method I quote. You might need to comment out the setting, when you want to keep debugging your App. I face the error Gradle build failed to produce an Android package, and stuck for few hours, making some gradlew clean...etc, and finally found out this should be commented out!\nHope this helped someone to jump out.",
                "createdAt": "2019-05-22T18:55:22Z"
            },
            {
                "author": "Tokenyet",
                "bodyText": "flutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this: flutter build apk --target-platform android-arm,android-arm64 \n\nflutter build appbundle is working! I don't need to add that setting, and just do the code. However, It takes a bit much time to compile, but It's the only way to pass Google Play now.",
                "createdAt": "2019-05-22T19:51:06Z"
            },
            {
                "author": "blasten",
                "bodyText": "@Tokenyet were you able to download the app from the Play Store and run it after uploading the .aab? If this is the case, would you mind pasting the output of flutter doctor?",
                "createdAt": "2019-05-22T20:05:23Z"
            },
            {
                "author": "robinbonnes",
                "bodyText": "@blasten\nI switched to the master channel, upgraded and build the appbundle. Unfortunately app chashes after downloaded from google play store with following logcat\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n2019-05-22 09:42:14.824 6995-6995/? A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n\n\nflutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this: flutter build apk --target-platform android-arm,android-arm64 \n\n\nExactly the same thing here, when trying to run my app from the Play Store (created as appbundle). What logs do you guys need to resolve this?",
                "createdAt": "2019-05-22T23:47:18Z"
            },
            {
                "author": "blasten",
                "bodyText": "This will be helpful:\n\nDownload bundletool from https://developer.android.com/studio/command-line/bundletool\nRun flutter build appbundle (Please indicate if you pass any flag or if you made custom changes to any Gradle script)\nRun bundletool build-apks --bundle=build/app/outputs/bundle/release/app.aab  --output=out.apks to extract the APK set.\nRun unzip -l out.apks and lastly flutter doctor and paste the output from both commands in your comment.\n\nIf possible:\nTest locally on the device using the bundletool and the APK set. These are the steps, paste the logcat in your comment.\nI'm unable to reproduce the issue although I only tested locally using bundletool.",
                "createdAt": "2019-05-23T03:02:08Z"
            },
            {
                "author": "skybur",
                "bodyText": "@blasten So the previous error is fixed but I ran into another error. I assume this is caused by something in my project. Is there any way I could debug this?\n[+6084 ms] Failed to execute aapt\n[  +17 ms] com.android.ide.common.process.ProcessException: Failed to execute aapt\n[   +1 ms]      at com.android.builder.core.AndroidBuilder.processResources(AndroidBuilder.java:809)\n[   +1 ms]      at com.android.build.gradle.internal.res.LinkAndroidResForBundleTask.taskAction(LinkAndroidResForBundleTask.kt:128)\n[   +1 ms]      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n[   +1 ms]      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n[   +1 ms]      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n[        ]      at java.lang.reflect.Method.invoke(Method.java:498)\n[        ]      at org.gradle.internal.reflect.JavaMethod.invoke(JavaMethod.java:73)\n[   +4 ms]      at org.gradle.api.internal.project.taskfactory.StandardTaskAction.doExecute(StandardTaskAction.java:46)\n[   +1 ms]      at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:39)\n[        ]      at org.gradle.api.internal.project.taskfactory.StandardTaskAction.execute(StandardTaskAction.java:26)\n[   +3 ms]      at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:788)\n[  +29 ms]      at org.gradle.api.internal.AbstractTask$TaskActionWrapper.execute(AbstractTask.java:755)\n[   +1 ms]      at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter$1.run(ExecuteActionsTaskExecuter.java:124)\n[   +1 ms]      at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n[   +2 ms]      at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n[   +1 ms]      at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n[   +9 ms]      at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n[        ]      at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeAction(ExecuteActionsTaskExecuter.java:113)\n[        ]      at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.executeActions(ExecuteActionsTaskExecuter.java:95)\n[   +1 ms]      at org.gradle.api.internal.tasks.execution.ExecuteActionsTaskExecuter.execute(ExecuteActionsTaskExecuter.java:73)\n[        ]      at org.gradle.api.internal.tasks.execution.OutputDirectoryCreatingTaskExecuter.execute(OutputDirectoryCreatingTaskExecuter.java:51)\n[   +1 ms]      at org.gradle.api.internal.tasks.execution.SkipUpToDateTaskExecuter.execute(SkipUpToDateTaskExecuter.java:59)\n[        ]      at org.gradle.api.internal.tasks.execution.ResolveTaskOutputCachingStateExecuter.execute(ResolveTaskOutputCachingStateExecuter.java:54)\n[        ]      at org.gradle.api.internal.tasks.execution.ValidatingTaskExecuter.execute(ValidatingTaskExecuter.java:59)\n[   +5 ms]      at org.gradle.api.internal.tasks.execution.SkipEmptySourceFilesTaskExecuter.execute(SkipEmptySourceFilesTaskExecuter.java:101)\n[        ]      at org.gradle.api.internal.tasks.execution.FinalizeInputFilePropertiesTaskExecuter.execute(FinalizeInputFilePropertiesTaskExecuter.java:44)\n[   +1 ms]      at org.gradle.api.internal.tasks.execution.CleanupStaleOutputsExecuter.execute(CleanupStaleOutputsExecuter.java:91)\n[   +1 ms]      at org.gradle.api.internal.tasks.execution.ResolveTaskArtifactStateTaskExecuter.execute(ResolveTaskArtifactStateTaskExecuter.java:62)\n[  +12 ms]      at org.gradle.api.internal.tasks.execution.SkipTaskWithNoActionsExecuter.execute(SkipTaskWithNoActionsExecuter.java:59)\n[   +4 ms]      at org.gradle.api.internal.tasks.execution.SkipOnlyIfTaskExecuter.execute(SkipOnlyIfTaskExecuter.java:54)\n[        ]      at org.gradle.api.internal.tasks.execution.ExecuteAtMostOnceTaskExecuter.execute(ExecuteAtMostOnceTaskExecuter.java:43)\n[        ]      at org.gradle.api.internal.tasks.execution.CatchExceptionTaskExecuter.execute(CatchExceptionTaskExecuter.java:34)\n[        ]      at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker$1.run(DefaultTaskGraphExecuter.java:256)\n[        ]      at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:336)\n[        ]      at org.gradle.internal.progress.DefaultBuildOperationExecutor$RunnableBuildOperationWorker.execute(DefaultBuildOperationExecutor.java:328)\n[        ]      at org.gradle.internal.progress.DefaultBuildOperationExecutor.execute(DefaultBuildOperationExecutor.java:199)\n[        ]      at org.gradle.internal.progress.DefaultBuildOperationExecutor.run(DefaultBuildOperationExecutor.java:110)\n[   +1 ms]      at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:249)\n[   +6 ms]      at org.gradle.execution.taskgraph.DefaultTaskGraphExecuter$EventFiringTaskWorker.execute(DefaultTaskGraphExecuter.java:238)\n[        ]      at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.processTask(DefaultTaskPlanExecutor.java:123)\n[        ]      at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.access$200(DefaultTaskPlanExecutor.java:79)\n[        ]      at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:104)\n[   +1 ms]      at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker$1.execute(DefaultTaskPlanExecutor.java:98)\n[   +1 ms]      at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.execute(DefaultTaskExecutionPlan.java:663)\n[   +1 ms]      at org.gradle.execution.taskgraph.DefaultTaskExecutionPlan.executeWithTask(DefaultTaskExecutionPlan.java:597)\n[        ]      at org.gradle.execution.taskgraph.DefaultTaskPlanExecutor$TaskExecutorWorker.run(DefaultTaskPlanExecutor.java:98)\n[  +14 ms]      at org.gradle.internal.concurrent.ExecutorPolicy$CatchAndRecordFailures.onExecute(ExecutorPolicy.java:63)\n[   +1 ms]      at org.gradle.internal.concurrent.ManagedExecutorImpl$1.run(ManagedExecutorImpl.java:46)\n[   +4 ms]      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n[   +1 ms]      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n[   +2 ms]      at org.gradle.internal.concurrent.ThreadFactoryImpl$ManagedThreadRunnable.run(ThreadFactoryImpl.java:55)\n[   +1 ms]      at java.lang.Thread.run(Thread.java:745)\n[  +26 ms] Caused by: java.util.concurrent.ExecutionException: java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: AAPT2 error: check logs for details\n[   +4 ms]      at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:503)\n[   +1 ms]      at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:482)\n[        ]      at com.google.common.util.concurrent.AbstractFuture$TrustedFuture.get(AbstractFuture.java:79)\n[        ]      at com.android.builder.internal.aapt.AbstractAapt.link(AbstractAapt.java:34)\n[        ]      at com.android.builder.core.AndroidBuilder.processResources(AndroidBuilder.java:807)\n[        ]      ... 51 more\n[        ] Caused by: java.util.concurrent.ExecutionException: com.android.builder.internal.aapt.v2.Aapt2Exception: AAPT2 error: check logs for details\n[   +1 ms]      at com.google.common.util.concurrent.AbstractFuture.getDoneValue(AbstractFuture.java:503)\n[        ]      at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture.java:462)\n[        ]      at com.google.common.util.concurrent.AbstractFuture$TrustedFuture.get(AbstractFuture.java:79)\n[        ]      at com.android.builder.internal.aapt.v2.QueueableAapt2.lambda$makeValidatedPackage$1(QueueableAapt2.java:166)\n[   +4 ms]      at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n[   +1 ms]      at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n[   +1 ms]      ... 1 more\n[   +1 ms] Caused by: com.android.builder.internal.aapt.v2.Aapt2Exception: AAPT2 error: check logs for details\n[   +1 ms]      at com.android.builder.png.AaptProcess$NotifierProcessOutput.handleOutput(AaptProcess.java:443)\n[   +1 ms]      at com.android.builder.png.AaptProcess$NotifierProcessOutput.err(AaptProcess.java:395)\n[        ]      at com.android.builder.png.AaptProcess$ProcessOutputFacade.err(AaptProcess.java:312)\n[        ]      at com.android.utils.GrabProcessOutput$1.run(GrabProcessOutput.java:104)\n[        ] FAILURE: Build failed with an exception.\n[        ] * What went wrong:\n[        ] Execution failed for task ':app:bundleProdReleaseResources'.\n[        ] > Failed to execute aapt\n[        ] * Try:\n[        ] Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n[   +5 ms] * Get more help at https://help.gradle.org\n[        ] BUILD FAILED in 30s\n[ +324 ms] Running Gradle task 'bundleProdRelease'... (completed in 31.5s)",
                "createdAt": "2019-05-23T04:08:22Z"
            },
            {
                "author": "Kiruel",
                "bodyText": "@blasten I follow all your steps my logs:\n\u279c  PROJECT_NAME git:(master) \u2717 unzip -l out.apks\nArchive:  out.apks\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n 43369811  01-01-1970 01:00   standalones/standalone-armeabi_tvdpi.apk\n 43327197  01-01-1970 01:00   standalones/standalone-armeabi_hdpi.apk\n 43319503  01-01-1970 01:00   standalones/standalone-armeabi_mdpi.apk\n 43320027  01-01-1970 01:00   standalones/standalone-armeabi_ldpi.apk\n 43346424  01-01-1970 01:00   standalones/standalone-armeabi_xxhdpi.apk\n 43350403  01-01-1970 01:00   standalones/standalone-armeabi_xxxhdpi.apk\n 43332970  01-01-1970 01:00   standalones/standalone-armeabi_xhdpi.apk\n 50349155  01-01-1970 01:00   standalones/standalone-armeabi_v7a_ldpi.apk\n 50348629  01-01-1970 01:00   standalones/standalone-armeabi_v7a_mdpi.apk\n 50398968  01-01-1970 01:00   standalones/standalone-armeabi_v7a_tvdpi.apk\n 50356358  01-01-1970 01:00   standalones/standalone-armeabi_v7a_hdpi.apk\n 50362126  01-01-1970 01:00   standalones/standalone-armeabi_v7a_xhdpi.apk\n 50375565  01-01-1970 01:00   standalones/standalone-armeabi_v7a_xxhdpi.apk\n 50379553  01-01-1970 01:00   standalones/standalone-armeabi_v7a_xxxhdpi.apk\n 50660246  01-01-1970 01:00   standalones/standalone-arm64_v8a_ldpi.apk\n 50659718  01-01-1970 01:00   standalones/standalone-arm64_v8a_mdpi.apk\n 50710027  01-01-1970 01:00   standalones/standalone-arm64_v8a_tvdpi.apk\n 50667415  01-01-1970 01:00   standalones/standalone-arm64_v8a_hdpi.apk\n 50673185  01-01-1970 01:00   standalones/standalone-arm64_v8a_xhdpi.apk\n 50686641  01-01-1970 01:00   standalones/standalone-arm64_v8a_xxhdpi.apk\n 43345757  01-01-1970 01:00   standalones/standalone-x86_mdpi.apk\n 43346287  01-01-1970 01:00   standalones/standalone-x86_ldpi.apk\n 43396086  01-01-1970 01:00   standalones/standalone-x86_tvdpi.apk\n 50690619  01-01-1970 01:00   standalones/standalone-arm64_v8a_xxxhdpi.apk\n 43359247  01-01-1970 01:00   standalones/standalone-x86_xhdpi.apk\n 43353470  01-01-1970 01:00   standalones/standalone-x86_hdpi.apk\n 43372688  01-01-1970 01:00   standalones/standalone-x86_xxhdpi.apk\n 43376653  01-01-1970 01:00   standalones/standalone-x86_xxxhdpi.apk\n 43340224  01-01-1970 01:00   standalones/standalone-x86_64_ldpi.apk\n 43339701  01-01-1970 01:00   standalones/standalone-x86_64_mdpi.apk\n 43390033  01-01-1970 01:00   standalones/standalone-x86_64_tvdpi.apk\n 43347418  01-01-1970 01:00   standalones/standalone-x86_64_hdpi.apk\n    57027  01-01-1970 01:00   splits/base-ldpi.apk\n    56501  01-01-1970 01:00   splits/base-mdpi.apk\n    61951  01-01-1970 01:00   splits/base-hdpi.apk\n    67741  01-01-1970 01:00   splits/base-xhdpi.apk\n    81187  01-01-1970 01:00   splits/base-xxhdpi.apk\n    85188  01-01-1970 01:00   splits/base-xxxhdpi.apk\n   105385  01-01-1970 01:00   splits/base-tvdpi.apk\n 43353194  01-01-1970 01:00   standalones/standalone-x86_64_xhdpi.apk\n    11313  01-01-1970 01:00   splits/base-ca.apk\n    11211  01-01-1970 01:00   splits/base-da.apk\n    12040  01-01-1970 01:00   splits/base-fa.apk\n    11659  01-01-1970 01:00   splits/base-ja.apk\n    12486  01-01-1970 01:00   splits/base-ka.apk\n    12511  01-01-1970 01:00   splits/base-pa.apk\n    12856  01-01-1970 01:00   splits/base-ta.apk\n    11195  01-01-1970 01:00   splits/base-nb.apk\n    12001  01-01-1970 01:00   splits/base-be.apk\n    11420  01-01-1970 01:00   splits/base-de.apk\n    13041  01-01-1970 01:00   splits/base-ne.apk\n    12674  01-01-1970 01:00   splits/base-te.apk\n 43366615  01-01-1970 01:00   standalones/standalone-x86_64_xxhdpi.apk\n    11179  01-01-1970 01:00   splits/base-af.apk\n    12151  01-01-1970 01:00   splits/base-bg.apk\n    12353  01-01-1970 01:00   splits/base-th.apk\n    11228  01-01-1970 01:00   splits/base-fi.apk\n    12537  01-01-1970 01:00   splits/base-si.apk\n    12551  01-01-1970 01:00   splits/base-hi.apk\n    11939  01-01-1970 01:00   splits/base-kk.apk\n    11615  01-01-1970 01:00   splits/base-vi.apk\n    12059  01-01-1970 01:00   splits/base-mk.apk\n    11440  01-01-1970 01:00   splits/base-sk.apk\n    11961  01-01-1970 01:00   splits/base-uk.apk\n    12344  01-01-1970 01:00   splits/base-el.apk\n    11342  01-01-1970 01:00   splits/base-gl.apk\n    13334  01-01-1970 01:00   splits/base-ml.apk\n    11350  01-01-1970 01:00   splits/base-nl.apk\n    11371  01-01-1970 01:00   splits/base-pl.apk\n    11311  01-01-1970 01:00   splits/base-sl.apk\n    11428  01-01-1970 01:00   splits/base-tl.apk\n    11825  01-01-1970 01:00   splits/base-am.apk\n    12685  01-01-1970 01:00   splits/base-km.apk\n    12615  01-01-1970 01:00   splits/base-bn.apk\n    11223  01-01-1970 01:00   splits/base-in.apk\n    12832  01-01-1970 01:00   splits/base-kn.apk\n    11958  01-01-1970 01:00   splits/base-mn.apk\n    12621  01-01-1970 01:00   splits/base-lo.apk\n    11425  01-01-1970 01:00   splits/base-ko.apk\n    11395  01-01-1970 01:00   splits/base-ro.apk\n    11438  01-01-1970 01:00   splits/base-sq.apk\n    13612  01-01-1970 01:00   splits/base-fr.apk\n    11647  01-01-1970 01:00   splits/base-ar.apk\n    11278  01-01-1970 01:00   splits/base-hr.apk\n    12447  01-01-1970 01:00   splits/base-mr.apk\n    12943  01-01-1970 01:00   splits/base-or.apk\n    14244  01-01-1970 01:00   splits/base-sr.apk\n    11316  01-01-1970 01:00   splits/base-tr.apk\n    11973  01-01-1970 01:00   splits/base-ur.apk\n    11308  01-01-1970 01:00   splits/base-bs.apk\n    12525  01-01-1970 01:00   splits/base-as.apk\n    13704  01-01-1970 01:00   splits/base-es.apk\n    11367  01-01-1970 01:00   splits/base-cs.apk\n    11222  01-01-1970 01:00   splits/base-is.apk\n    11360  01-01-1970 01:00   splits/base-ms.apk\n    11323  01-01-1970 01:00   splits/base-et.apk\n    11283  01-01-1970 01:00   splits/base-it.apk\n    11550  01-01-1970 01:00   splits/base-lt.apk\n    14605  01-01-1970 01:00   splits/base-pt.apk\n    11377  01-01-1970 01:00   splits/base-eu.apk\n    12409  01-01-1970 01:00   splits/base-gu.apk\n    11651  01-01-1970 01:00   splits/base-hu.apk\n    12048  01-01-1970 01:00   splits/base-ru.apk\n    11616  01-01-1970 01:00   splits/base-lv.apk\n    11314  01-01-1970 01:00   splits/base-zu.apk\n    11260  01-01-1970 01:00   splits/base-sv.apk\n    11539  01-01-1970 01:00   splits/base-iw.apk\n    11283  01-01-1970 01:00   splits/base-sw.apk\n    12110  01-01-1970 01:00   splits/base-hy.apk\n 43370609  01-01-1970 01:00   standalones/standalone-x86_64_xxxhdpi.apk\n    11904  01-01-1970 01:00   splits/base-ky.apk\n    11430  01-01-1970 01:00   splits/base-az.apk\n    13395  01-01-1970 01:00   splits/base-my.apk\n    11296  01-01-1970 01:00   splits/base-uz.apk\n    15398  01-01-1970 01:00   splits/base-zh.apk\n    23877  01-01-1970 01:00   splits/base-en.apk\n   107757  01-01-1970 01:00   splits/base-armeabi.apk\n   134023  01-01-1970 01:00   splits/base-x86.apk\n   127969  01-01-1970 01:00   splits/base-x86_64.apk\n 42926206  01-01-1970 01:00   splits/base-master.apk\n 21480838  01-01-1970 01:00   splits/base-arm64_v8a_2.apk\n 17508309  01-01-1970 01:00   splits/base-armeabi_v7a_2.apk\n   217751  01-01-1970 01:00   splits/base-armeabi_2.apk\n   311771  01-01-1970 01:00   splits/base-x86_2.apk\n   308537  01-01-1970 01:00   splits/base-x86_64_2.apk\n  7136923  01-01-1970 01:00   splits/base-armeabi_v7a.apk\n  7447993  01-01-1970 01:00   splits/base-arm64_v8a.apk\n 42926200  01-01-1970 01:00   splits/base-master_2.apk\n    16537  01-01-1970 01:00   toc.pb\n---------                     -------\n1759809847                     129 files\n\u279c  PROJECT_NAME git:(master) \u2717 flutter doctor\nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel master, v1.6.1-pre.68, on Mac OS X 10.14.5 18F132, locale en-GB)\n\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u2713] iOS toolchain - develop for iOS devices (Xcode 10.2.1)\n[!] Android Studio (version 3.3)\n    \u2717 Flutter plugin not installed; this adds Flutter specific functionality.\n    \u2717 Dart plugin not installed; this adds Dart specific functionality.\n[\u2713] VS Code (version 1.34.0)\n[\u2713] Connected device (1 available)\n\n! Doctor found issues in 1 category.",
                "createdAt": "2019-05-23T09:44:52Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "@jereksel @ndusart\nActually this is called Assets Targeting and it allows you to target/split directories in assets based on Graphics API, Language & Texture Compression.\nAs seen here: .../bundletool/model/targeting/TargetedDirectorySegment.java",
                "createdAt": "2019-05-23T11:50:34Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "Regarding AAB's current flutter@master works for me locally - using bundletool to test and install on real device. I've disabled splitting on density & language in my build.gradle so build-apks gives me this:\n  Length      Date    Time    Name\n---------  ---------- -----   ----\n  6872466  1970-01-01 01:00   splits/base-arm64_v8a.apk\n  6726824  1970-01-01 01:00   splits/base-master.apk\n 13289718  1970-01-01 01:00   standalones/standalone-armeabi_v7a.apk\n 13594392  1970-01-01 01:00   standalones/standalone-arm64_v8a.apk\n  6567785  1970-01-01 01:00   splits/base-armeabi_v7a.apk\n      429  1970-01-01 01:00   toc.pb\n---------                     -------\n 47051614                     6 files\n\nTesting it on Test Lab I also have all green.\nStill waiting for Play Store to process this version to test this channel.",
                "createdAt": "2019-05-23T12:37:29Z"
            },
            {
                "author": "Tokenyet",
                "bodyText": "@Tokenyet were you able to download the app from the Play Store and run it after uploading the .aab? If this is the case, would you mind pasting the output of flutter doctor?\n\nI can download the app from the Play Store, and run It. You could [give It a try] (https://play.google.com/store/apps/details?id=com.bumbystudio.starry_clock). (Edit: Oops, It's not wokring...from PlayStore)\nBelow is my flutter doctor as you need. Hope It helped.\n[\u221a] Flutter (Channel master, v1.6.1-pre.88, on Microsoft Windows [Version 10.0.17134.765], locale zh-TW)\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u221a] Android Studio (version 3.3)\n[\u221a] VS Code, 64-bit edition (version 1.30.2)\n[!] Connected device\n! No devices available",
                "createdAt": "2019-05-23T13:11:30Z"
            },
            {
                "author": "kishan2612",
                "bodyText": "This works fine for me !\nbuildTypes {\nrelease {\n// TODO: Add your own signing config for the release build.\n// Signing with the debug keys for now, so flutter run --release works.\nsigningConfig signingConfigs.debug\n}\ndebug {\nndk {\nabiFilters 'armeabi-v7a'\n}\n}\n}",
                "createdAt": "2019-05-23T13:12:37Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@SPodjasek still, we need to split assets/ based on ABI. How can this be done currently ?",
                "createdAt": "2019-05-23T13:12:42Z"
            },
            {
                "author": "Purus",
                "bodyText": "I installed in my device and it seems it's not working. All I got was a\nblack screen.\n\nThanks,\n\nPurusothaman Ramanujam\n\u2026\nOn Thu, 23 May, 2019, 6:43 PM Tokenyet, ***@***.***> wrote:\n @Tokenyet <https://github.com/Tokenyet> were you able to download the app\n from the Play Store and run it after uploading the .aab? If this is the\n case, would you mind pasting the output of flutter doctor?\n\n I can download the app from the Play Store, and run It. You could give It\n a try\n <https://play.google.com/store/apps/details?id=com.bumbystudio.starry_clock>\n .\n\n Below is my flutter doctor as you need. Hope It helped.\n\n [\u221a] Flutter (Channel master, v1.6.1-pre.88, on Microsoft Windows [Version\n 10.0.17134.765], locale zh-TW)\n\n [\u221a] Android toolchain - develop for Android devices (Android SDK version\n 28.0.3)\n [\u221a] Android Studio (version 3.3)\n [\u221a] VS Code, 64-bit edition (version 1.30.2)\n [!] Connected device\n ! No devices available\n\n \u2014\n You are receiving this because you are subscribed to this thread.\n Reply to this email directly, view it on GitHub\n <#18494?email_source=notifications&email_token=AAIHDZYY47H6PUQQJYEO4J3PW2J7RA5CNFSM4FFE2B7KYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWCFLKY#issuecomment-495211947>,\n or mute the thread\n <https://github.com/notifications/unsubscribe-auth/AAIHDZZXV67JCNVJYLVA3WLPW2J7RANCNFSM4FFE2B7A>\n .",
                "createdAt": "2019-05-23T13:19:15Z"
            },
            {
                "author": "SPodjasek",
                "bodyText": "@ndusart At this point it's impossible - maybe file a feature request on bundletool and Google will consider implementing it.",
                "createdAt": "2019-05-23T13:55:52Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@SPodjasek so that's what I'm saying, all this issue is going the wrong way.\nAll the discussions seems to end to \"ho don't worry, when we could build app bundles, all would be fine\" but it is totally not the case right now and in a close future.\nIt's a bit disappointing to see flutter team let people think it is possible this way.\nflutter should be able to provide a way to easily build split APK either by doing the split itself or manage to move the VM snapshots to the lib/ folder and let the split just work (we could then use app bundles as well)",
                "createdAt": "2019-05-23T15:18:28Z"
            },
            {
                "author": "blasten",
                "bodyText": "Let\u2019s recap:\n\nFlutter will support fat APKs via flutter build apk ....\nIf you want to try this feature right now try flutter build appbundle in the master branch.  If app bundles don\u2019t work for your use case, then (1) should cover the remaining cases.",
                "createdAt": "2019-05-23T15:43:37Z"
            },
            {
                "author": "ndusart",
                "bodyText": "Okay @blasten I did look in the master code and the snapshots are moved to the lib folder:\n\n  \n    \n      flutter/packages/flutter_tools/gradle/flutter.gradle\n    \n    \n        Lines 470 to 481\n      in\n      dc28ba8\n    \n  \n  \n    \n\n        \n          \n           // Add the snapshots and rename them as `lib/{abi}/*.so`. \n        \n\n        \n          \n           flutterTasks.each { flutterTask ->  \n        \n\n        \n          \n               from(flutterTask.intermediateDir) { \n        \n\n        \n          \n                   include 'vm_snapshot_data' \n        \n\n        \n          \n                   include 'vm_snapshot_instr' \n        \n\n        \n          \n                   include 'isolate_snapshot_data' \n        \n\n        \n          \n                   include 'isolate_snapshot_instr' \n        \n\n        \n          \n                   rename {  String filename -> \n        \n\n        \n          \n                       return \"lib/${flutterTask.abi}/lib_${filename}.so\" \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nSo it is not just adding app bundle support. It is more clear now.\nA bit of explanation would have been appreciated though as it was stated that the problem was the assets folder and no information was given work was done in this direction since this problem and app bundle support are pretty independant.\nThanks for your work.",
                "createdAt": "2019-05-23T16:16:44Z"
            },
            {
                "author": "dnfield",
                "bodyText": "@ndusart - @blasten has made changes to the Android embedding so that it will look for the binary blobs in the lib folder now, so that you can bundle in both types if I'm not mistaken...",
                "createdAt": "2019-05-23T16:24:24Z"
            },
            {
                "author": "andrzejressel",
                "bodyText": "If snapshotes are moved into lib, then maybe #30846 will be also fixed?",
                "createdAt": "2019-05-23T16:28:09Z"
            },
            {
                "author": "devhulk",
                "bodyText": "@blasten\nI switched to the master channel, upgraded and build the appbundle. Unfortunately app chashes after downloaded from google play store with following logcat\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm.cc(241)] Could not setup VM data to bootstrap the VM from.\n2019-05-22 09:42:14.824 6995-6995/? E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n2019-05-22 09:42:14.824 6995-6995/? A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n\n\nflutter build appbundle is now in master, does any voluntary person want to give it try?\nWe had some discussion to support a list of platforms in build apk, so you could do something like this: flutter build apk --target-platform android-arm,android-arm64 \n\n\nHave the same problem, although I do not have any logs yet.\n\nSame here. Was having error. Upgraded master and ran flutter build appbundle . Got rid of the error but app crashes when opened.",
                "createdAt": "2019-05-24T12:31:15Z"
            },
            {
                "author": "chitwoob",
                "bodyText": "I tried uploading an appbundle using the latest flutter master version to the app store with the latest changes. The 64 bit error is gone now, but my app immediately crashes.\nWhat's really odd is running the 64 bit version using the commands below works fine.\nflutter build apk --target-platform android-arm64\nflutter install api\nIt's only crashing when the app is installed through the appbundle in the appstore. For now I've reverted the appstore back to the 32 bit apk.\nI don't have anything special in my gradle.build\nminSdkVersion 21\ntargetSdkVersion 28\nversionCode flutterVersionCode.toInteger()\nversionName flutterVersionName\ntestInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\nmultiDexEnabled true\nI'm running Flutter (Channel master, v1.6.4-pre.13, on Mac OS X 10.14.5 18F132, locale en-US)\nIs there anyway to test these bundles before uploading to the appstore? Is this a known issue that google is working on or do I need to make some changes to my gradle file?",
                "createdAt": "2019-05-25T14:08:40Z"
            },
            {
                "author": "blasten",
                "bodyText": "@chitwoob Please follow the steps: #18494 (comment)",
                "createdAt": "2019-05-25T16:08:31Z"
            },
            {
                "author": "chitwoob",
                "bodyText": "@blasten I'm running into an issue with the bundle tool that's unrelated to this issue.\nI get\nError: Failed to start ADB server\nWhen running\nbuild-apks --connected-device --bundle=./app.aab --output=./my_app.apks --adb\nI have adb properly installed. When I try adb logcat it works fine.",
                "createdAt": "2019-05-25T16:39:23Z"
            },
            {
                "author": "KunalT6569",
                "bodyText": "Gonna be a long comment, but this completely fixed the problem\n\nThis was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\nupload app-armeabi-v7a-release.apk to the play store\nincrement versionCode\nrun flutter build apk --release --target-platform=android-arm64 \nupload app-arm64-v8a-release.apk to the play store\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be 10MB+\n\nFollowing these steps was giving \"Gradle build failed to produce an Android package.\" error\nAfter an hour of debugging, found out the fix.\nTo create different apps for x86 and x64, follow these steps:\nStep 1: Include the code snippet in app/build.gradle file. The file will look like:\n....\n    lintOptions {\n        disable 'InvalidPackage'\n    }\n\n    splits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n    defaultConfig {\n....\n\nStep 2: Create a release apk using flutter build apk --release\nThis will create the x86 based apk in folder build/app/outputs/apk/app.apk\nUpload this apk to google play store.\nx86 done till now\nAt this point don't run flutter clean\nI was doing this and getting errors when building x64 apk\nStep 3: Now open pubspec.yaml and change the version from\nversion: 1.0.0+1 to version: 1.0.0+2\n\nThe number next to + is version code\n\nStep 4: Now run the command\nflutter build apk --release --target-platform=android-arm64\nAfter this command completes, go to build/app/outputs/apk/release/. In there you will find an apk with name app-arm64-v8a-release.apk. This is your 64 bit apk file with different version code.\nNow upload this x64 apk to play store....and here you go. You have uploaded both x86 and x64 apps to play store.",
                "createdAt": "2019-05-26T06:09:35Z"
            },
            {
                "author": "aleaforny",
                "bodyText": "Gonna be a long comment, but this completely fixed the problem\n[...]\nTo create different apps for x86 and x64, follow these steps:\nStep 1: Include the code snippet in app/build.gradle file. The file will look like:\n....\n    lintOptions {\n        disable 'InvalidPackage'\n    }\n\n    splits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n    defaultConfig {\n....\n\nStep 2: Create a release apk using flutter build apk --release\n[...]\n\nAgree with your answer. Works for me, even though I didn't have to follow Step 1 (I used a default build.gradle)\nThen, you just need to increment your build number and version so that Google Play accepts it.\nI'm still having troubles with flutter build appbundle on my hand.",
                "createdAt": "2019-05-26T09:32:38Z"
            },
            {
                "author": "mormih",
                "bodyText": "Gonna be a long comment, but this completely fixed the problem\n[...]\nTo create different apps for x86 and x64, follow these steps:\nStep 1: Include the code snippet in app/build.gradle file. The file will look like:\n....\n    lintOptions {\n        disable 'InvalidPackage'\n    }\n\n    splits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n    defaultConfig {\n....\n\nStep 2: Create a release apk using flutter build apk --release\n[...]\n\nAgree with your answer. Works for me, even though I didn't have to follow Step 1 (I used a default build.gradle)\nThen, you just need to increment your build number and version so that Google Play accepts it.\nI'm still having troubles with flutter build appbundle on my hand.\n\nNot working. I am so upset. Application crashed when attempted to deploy on x86 emulator as well as on real arm device. Tried with master/beta/stable channel. No release ready. It is still show stopper for us. Appbundle command generates installable bundle for play but during runtime application shows just  splash screen and then freezes. Flutter team please provide clear solution or WA.",
                "createdAt": "2019-05-26T12:25:59Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@mormih thanks for your patience -- we're working on reproducing.  If you wouldn't mind, could you send me an email (tvolkert@google.com) including the following, it would help:\n\nYour host platform you're using to build.\nThe command you're using to build the app.\nRun your build command with --bug-report (e.g. flutter build appbundle --bug-report) and attach the associated bugreport.zip file\nAttach the generated app bundle so we can try running it on local devices\nAttach the results of adb bugreport after having tried to run the app\n\nThanks!",
                "createdAt": "2019-05-27T02:15:29Z"
            },
            {
                "author": "PerLycke",
                "bodyText": "@tvolkert I also have the issue where it's crashing with the following message:\n\nCheck failed: vm. Must be able to initialize the VM.\n\nMy host platform is a mac and macOS 10.14.5. Were you able to reproduce it, or would you like me to follow the steps you wrote above? Also, maybe this should have a dedicated ticket as it's a separate issue from the OP one.. Cheers",
                "createdAt": "2019-05-27T08:49:01Z"
            },
            {
                "author": "bucketclan",
                "bodyText": "@mormih I am not sure but have you tried including x86 as well in the abi list?\ninclude \"armeabi-v7a\", \"arm64-v8a\", \"x86\"",
                "createdAt": "2019-05-27T12:09:54Z"
            },
            {
                "author": "ezmegy",
                "bodyText": "flutter build appbundle (on master) didn't work for me either, have the splashscreen stuck just like others have noted...\nThe only workaround I found for releasing (in the Play store) for both 32- and 64bit so far is the following. (Partly covered in the thread but might help someone):\n\n\nCreate an apk with the v7 filter on + the default build apk command:\nIn your app/build.gradle file:\ndefaultConfig { ... ndk{ abiFilters \"armeabi-v7a\" } }\nand then run\nflutter build apk\n(defaults to --release)\n\n\nBump your build number in pubspec.yaml.\nE.g. from version: 1.1.0+6 to version: 1.1.0+7\n\n\nCreate an apk with the v8 filter on + build with arm64 as the target platform:\nnow update the build.gradle like:\ndefaultConfig { ... ndk{ abiFilters \"arm64-v8a\" } }\nand then run\nflutter build apk --release --target-platform android-arm64\n\n\nDoes include the overhead of having to upload 2 apks (and thus creating 2 build numbers) but at least it seems to do the job and I can release for both 32 and 64bit devices...\nNote: I let go of x86 as that only involves a very minor group of mobile devices (and potentially none of my users), plus I don't need a release build in the emulator (debug is enough for testing). But this of course might not be the case for others.",
                "createdAt": "2019-05-27T15:21:45Z"
            },
            {
                "author": "marianoarga",
                "bodyText": "@ezmegy method is the only one that worked for me. Thanks",
                "createdAt": "2019-05-27T18:56:59Z"
            },
            {
                "author": "BND10706",
                "bodyText": "Somewhere up in the comments someone left this.\n\nThis has been working for me and its only 1 terminal code.\nIt outputs 2 files which I hate though and it creates 2 versions.",
                "createdAt": "2019-05-27T19:06:09Z"
            },
            {
                "author": "otopba",
                "bodyText": "@ezmegy Thank you! You save my day",
                "createdAt": "2019-05-27T22:52:15Z"
            },
            {
                "author": "felipecarvalho",
                "bodyText": "Thanks @ezmegy, your \"trick\" works!",
                "createdAt": "2019-05-27T23:36:53Z"
            },
            {
                "author": "iqbalmineraltown",
                "bodyText": "Thanks @ezmegy !\nI'd like to share my current workflow which might be helpful:\n\nCreate some build flavors on app/build.gradle per architecture\nflavorDimensions 'arch'\n    productFlavors {\n        arm32 {\n            dimension 'arch'\n            ndk {\n                abiFilters 'armeabi-v7a'\n            }\n        }\n        arm64 {\n            dimension 'arch'\n            ndk {\n                abiFilters 'arm64-v8a'\n            }\n        }\n\nThen I can build both with:\nflutter build apk --flavor arm32\nand\nflutter build apk --flavor arm64 --target-platform android-arm64\nwithout modifying gradle on every build\n\nRegarding version code, I'd prefer set one by default and derived the others from that one\nE.g. set arm32 with 1.0.0+10000 and generate version code for the arm64 which is 1.0.0+10001\nThis should be easy to generate using bash (or within fastfile if you're using fastlane)\nYou could set the build number using --build-number arguments or via fastlane if you're using one\nThis version code scripting helps me in CI/CD \ud83d\ude04\nCMIIW",
                "createdAt": "2019-05-28T01:41:58Z"
            },
            {
                "author": "IvanDreamer",
                "bodyText": "For me this worked out pretty well\n#10728 (comment)",
                "createdAt": "2019-05-28T07:53:44Z"
            },
            {
                "author": "maheshtheknight",
                "bodyText": "Gonna be a long comment, but this completely fixed the problem\n\nThis was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\nupload app-armeabi-v7a-release.apk to the play store\nincrement versionCode\nrun flutter build apk --release --target-platform=android-arm64 \nupload app-arm64-v8a-release.apk to the play store\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be 10MB+\n\nFollowing these steps was giving \"Gradle build failed to produce an Android package.\" error\nAfter an hour of debugging, found out the fix.\nTo create different apps for x86 and x64, follow these steps:\nStep 1: Include the code snippet in app/build.gradle file. The file will look like:\n....\n    lintOptions {\n        disable 'InvalidPackage'\n    }\n\n    splits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n    defaultConfig {\n....\n\nStep 2: Create a release apk using flutter build apk --release\nThis will create the x86 based apk in folder build/app/outputs/apk/app.apk\nUpload this apk to google play store.\nx86 done till now\nAt this point don't run flutter clean\nI was doing this and getting errors when building x64 apk\nStep 3: Now open pubspec.yaml and change the version from\nversion: 1.0.0+1 to version: 1.0.0+2\n\nThe number next to + is version code\n\nStep 4: Now run the command\nflutter build apk --release --target-platform=android-arm64\nAfter this command completes, go to build/app/outputs/apk/release/. In there you will find an apk with name app-arm64-v8a-release.apk. This is your 64 bit apk file with different version code.\nNow upload this x64 apk to play store....and here you go. You have uploaded both x86 and x64 apps to play store.\n\nIt is working to me also without step 1. Thanks to every one. I have used ndk filters  ndk {\nabiFilters \"armeabi-v7a\", \"x86\"\n}\nin build gradle file. I dont know it is required or not. Other than that, i had followed all steps from step 2 and uploaded two apk's, one for 32 bit and other for 64 bit.\nEarlier i had uploaded appbundle, this time uploaded apk files. Working fine. I have to check with appbundle and also trying to fix without uploading two apk's.\nNote :\nBefore doing this process, my app has crashed in following arm-64 bit devices\nRedmi MI,\nRedmi 3S Prime\nHonor 8x\nWorked in in following arm-64 bit devices\nSamsung Galaxy J4\nSamsung On8",
                "createdAt": "2019-05-28T09:41:57Z"
            },
            {
                "author": "lhcdims",
                "bodyText": "Hi Flutter Team,\nPls. also consider other app markets such as those in China.  In China, we are not allowed to use Google Play Store, instead, we have many app markets such as the XiaoMi's, the HuaWei's and the Ali's ...etc.\nIn those app markets, we are NOT allowed to provide apk releases in different architectures, we can only upload ONE AND ONLY ONE apk per release, and that release will override the previous release's apk.   Which means that the current work around is to use \"armeabi-v7a\".\nCorrect me if I'm wrong, by using \"armeabi-v7a\", all 64-bits devices will be running 32-bits libflutter.so, and I guess it will be slower.\nSo I would suggest if the flutter team can provide a method to allow us to build an apk that includes both 32-bit and 64-bit libflutter.so, although the size of the apk will be bigger.  (In China, we usually have very fast internet speed and we pay little to have infinite 4G usage plans, and people don't usually care about the size of the apk)",
                "createdAt": "2019-05-28T09:54:26Z"
            },
            {
                "author": "shinayser",
                "bodyText": "Hi Flutter Team,\nPls. also consider other app markets such as those in China. In China, we are not allowed to use Google Play Store, instead, we have many app markets such as the XiaoMi's, the HuaWei's and the Ali's ...etc.\nIn those app markets, we are NOT allowed to provide apk releases in different architectures, we can only upload ONE AND ONLY ONE apk per release, and that release will override the previous release's apk. Which means that the current work around is to use \"armeabi-v7a\".\nCorrect me if I'm wrong, by using \"armeabi-v7a\", all 64-bits devices will be running 32-bits libflutter.so, and I guess it will be slower.\nSo I would suggest if the flutter team can provide a method to allow us to build an apk that includes both 32-bit and 64-bit libflutter.so, although the size of the apk will be bigger. (In China, we usually have very fast internet speed and we pay little to have infinite 4G usage plans, and people don't usually care about the size of the apk)\n\nIn your case, you can provide the standard 32-bit and everything will be fine, right?\nThe 64 bit warning is only for Google Play. I believe this is not an issue for China.\n(Please, correct me if I am wrong.)",
                "createdAt": "2019-05-28T15:54:51Z"
            },
            {
                "author": "angel1st",
                "bodyText": "@KunalT6569 I guess step 3 as stated by you:\n\nStep 3: Now open pubspec.yaml and change the version from\nversion: 1.0.0+1 to version: 1.0.0+2\n\nis required to allow uploading both apk files to google play console, isn't it?\nI have one more question - once both apk files are ready, you simply upload them via App releases\\New Release\\Browse Files section, don't you?",
                "createdAt": "2019-05-29T15:03:10Z"
            },
            {
                "author": "KunalT6569",
                "bodyText": "@angel1st Yes, Step 3 is required as Google play will not allow uploading two apks with same version codes.\nFor uploading multiple apks to google play, I referred to this video.\nhttps://www.youtube.com/watch?v=rMl_oLlf_g0",
                "createdAt": "2019-05-29T16:49:07Z"
            },
            {
                "author": "Hixie",
                "bodyText": "FYI:\nOur current plan is to release a beta using one of the recent dev releases in the coming 10 or so days. Then, our plan is to wait until we have an updated documented process for how to ship on Android that does not trigger the warnings about 64bit builds from the Play store, to have a way to package an APK that supports 64 bit, and to prove we can release the gallery using that process, and as soon as we have done that, to follow the process to release a new beta which we will then push to stable a week or so later.\nThis means we will likely have a beta in early June, and a beta in late June or early July which will go to stable shortly thereafter.",
                "createdAt": "2019-05-29T18:13:56Z"
            },
            {
                "author": "canewsin",
                "bodyText": "@Hixie There is Another Problem Arose here\napp bundle by latest flutter (master as of now) not generating x86 , x86_64 versions\nFiles produced by master branch\n\nFiles generated by Old Version with android studio\n\nExpected Behaviour is to include  x86 , x86_64 versions as well in file produced by new version",
                "createdAt": "2019-05-29T21:38:51Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@canewsin independent of this issue, we don't provide x86 release binaries (#9253) - is the \"old version\" in #18494 (comment) referring to a debug build?",
                "createdAt": "2019-05-29T22:31:39Z"
            },
            {
                "author": "johnmoscoso911",
                "bodyText": "I have the same problem, building for 32-bit will exclude 64-bit devices, it runs on them though. Building for 64 by specifying --target-platform android-arm64 works on 64-bit devices, but crashes on 32-bit devices. Also Google will be restricting upload of apks to be 64-bit in 2019.\nFlutter Team, please resolve this basic issue!\n\ndefaultConfig {\n....\nversionName flutterVersionName\nndk.abiFilters 'armeabi-v7a','arm64-v8a','x86','x86_64'\n}\n// ready!",
                "createdAt": "2019-05-30T19:14:37Z"
            },
            {
                "author": "canewsin",
                "bodyText": "i compiled my app with latest flutter master branch and uploaded to play store as app bundle but app is crashing on device this log is taken from test lab\n05-31 07:50:28.384: D/AndroidRuntime(11036): --------- beginning of crash\n05-31 07:50:28.384: E/AndroidRuntime(11036): FATAL EXCEPTION: main\n05-31 07:50:28.384: E/AndroidRuntime(11036): Process: in.canews.social, PID: 11036\n05-31 07:50:28.384: E/AndroidRuntime(11036): java.lang.RuntimeException: Unable to create application in.canews.social.App: java.lang.NullPointerException: Attempt to get length of null array\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.ActivityThread.handleBindApplication(ActivityThread.java:5794)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.ActivityThread.-wrap1(Unknown Source:0)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.ActivityThread$H.handleMessage(ActivityThread.java:1661)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.os.Handler.dispatchMessage(Handler.java:105)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.os.Looper.loop(Looper.java:164)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.ActivityThread.main(ActivityThread.java:6541)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat java.lang.reflect.Method.invoke(Native Method)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)\n05-31 07:50:28.384: E/AndroidRuntime(11036): Caused by: java.lang.NullPointerException: Attempt to get length of null array\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat io.flutter.view.FlutterMain.listLibs(FlutterMain.java:381)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat io.flutter.view.FlutterMain.initAot(FlutterMain.java:412)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat io.flutter.view.FlutterMain.startInitialization(FlutterMain.java:164)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat io.flutter.view.FlutterMain.startInitialization(FlutterMain.java:143)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat io.flutter.app.FlutterApplication.onCreate(FlutterApplication.java:22)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1118)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \tat android.app.ActivityThread.handleBindApplication(ActivityThread.java:5791)\n05-31 07:50:28.384: E/AndroidRuntime(11036): \t... 8 more\n05-31 07:50:28.392: W/ActivityManager(897):   Force finishing activity in.canews.social/.MainActivity\n\nFlutter doctor -v\nC:\\flutter\\flutter\\bin>flutter doctor -v\n[\u221a] Flutter (Channel master, v1.6.7-pre.7, on Microsoft Windows [Version 10.0.17763.503], locale en-IN)\n    \u2022 Flutter version 1.6.7-pre.7 at C:\\flutter\\flutter\n    \u2022 Framework revision 6884146925 (2 days ago), 2019-05-29 12:52:05 -0700\n    \u2022 Engine revision 8dc3a4cde2\n    \u2022 Dart version 2.3.2 (build 2.3.2-dev.0.0 e3edfd36b2)\n\n\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n    \u2022 Android SDK at C:\\Users\\PramUkesh\\AppData\\Local\\Android\\sdk\n    \u2022 Android NDK location not configured (optional; useful for native profiling support)\n    \u2022 Platform android-28, build-tools 28.0.3\n    \u2022 Java binary at: C:\\Program Files\\Android\\Android Studio\\jre\\bin\\java\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n    \u2022 All Android licenses accepted.\n\n[\u221a] Android Studio (version 3.4)\n    \u2022 Android Studio at C:\\Program Files\\Android\\Android Studio\n    \u2022 Flutter plugin version 35.3.1\n    \u2022 Dart plugin version 183.6270\n    \u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n\n[\u221a] VS Code (version 1.34.0)\n    \u2022 VS Code at C:\\Users\\PramUkesh\\AppData\\Local\\Programs\\Microsoft VS Code\n    \u2022 Flutter extension version 3.0.2\n\n[\u221a] Connected device (1 available)\n    \u2022 Z2 Plus \u2022 2e9087c2 \u2022 android-arm64 \u2022 Android 9 (API 28)\n\n\u2022 No issues found!",
                "createdAt": "2019-05-31T15:03:36Z"
            },
            {
                "author": "blasten",
                "bodyText": "@canewsin looks like this issue was fixed in flutter/engine#9078. In your Flutter tree, update your local master branch, git fetch upstream && git merge upstream/master",
                "createdAt": "2019-05-31T15:26:35Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "After seeing repeated questions, which have already answered in previous comments, I wrote a short article documenting what options we have now https://medium.com/@truongsinh/flutter-android-64-bit-so-what-the-fuss-15da6f8e3a46. Here's the TLDR:",
                "createdAt": "2019-06-04T01:27:04Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@truongsinh, we're also finalizing support for using flutter build appbundle to build an app bundle containing both 32 and 64 bit binaries for deployment to the Play Store.  See #31922 for more info - please try it out and let us know if you encounter any problems.",
                "createdAt": "2019-06-04T08:09:38Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "@truongsinh, we're also finalizing support for using flutter build appbundle to build an app bundle containing both 32 and 64 bit binaries for deployment to the Play Store. See #31922 for more info - please try it out and let us know if you encounter any problems.\n\nYep I'm still waiting for flutter build appbundle to produce app the does not stuck or crash :D",
                "createdAt": "2019-06-04T11:17:22Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "Yep I'm still waiting for flutter build appbundle to produce app the does not stuck or crash :D\n\nAcknowledged \ud83d\ude42 .  If you have a reproducible case of this happening that we can take a look at, that'd be great.  If you were willing to build an unsigned .aab file from the 1.7.1 release and send it to me via email (tvolkert@google.com), I'd appreciate it!",
                "createdAt": "2019-06-04T23:27:05Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "FYI, the following announcement was sent to flutter-announce@googlegroups.com regarding our 64-bit support.\nhttps://groups.google.com/forum/#!topic/flutter-announce/oIzwT9EDczc",
                "createdAt": "2019-06-04T23:27:43Z"
            },
            {
                "author": "BND10706",
                "bodyText": "I am having this issue too.\nWhen I build app bundle in Android Studios i can load it fine on my simulator, but it crashes the app when I download it from the play store",
                "createdAt": "2019-06-07T14:22:18Z"
            },
            {
                "author": "canewsin",
                "bodyText": "Hi Guys people who are using flutter master branch and building app bundles\nif you are debugging your app your app runs fine\nsome face crashes on downloading from play store if this happens you have check your app bundle whether it is working on your device because debug mode produces JIT binaries and release mode produces AOT binaries currently their placements are also different i think so to test your app correctly\nproduce apk from app bundle for only specific configuration based on your device and completely uninstall debug app from your device and install this new output app from app bundle if it crashes it will crash when downloaded from play store or otherwise, hope this will help others..\nRef for Output to APK from your app bundle from cmd line\nhttps://developer.android.com/studio/command-line/bundletool",
                "createdAt": "2019-06-08T06:30:05Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "FYI, the crashes in the app bundles are better tracked in #31922.  However, cross-posting here:\n\nHi all,\nTLDR:\nWe've identified the problem with the crashes when downloaded from the Play Store and are working on a fix, to be delivered within the same timeframe as outlined above in #31922 (comment)\nHigh-level explanation\nFor those interested, the somewhat long explanation is that with devices running Android Marshmallow or later, the Play Store will detect apps that are packaged as App Bundles containing multiple ABIs -- and it will install those apps on the device in the form of \"split APKs\".  When it does this, the .so files contained therein are not extracted from the APK zip archive, which is different than the behavior of non-split APKs.  Since Flutter engine's current mechanism for finding the .so files assumes they've been extracted from the APK, it fails in the case of split APKs.\nThe solution is just to dlopen the libraries, and Android abstracts away where the libraries are located (i.e. within an archive or not).  However, the necessary .so files were never true libraries to begin with - they were just binary blobs of data that we loaded into the Dart VM.  So as part of this, we're making them ELF libraries (e.g. dart-lang/sdk@6d608fb and #33696).",
                "createdAt": "2019-06-08T06:56:20Z"
            },
            {
                "author": "fritz-playmaker",
                "bodyText": "4. flutter build apk --release --target-platform=android-arm64\n\nI get this error after adding the code snippet to build.gradle\nGradle build failed to produce an Android package.",
                "createdAt": "2019-06-10T16:01:40Z"
            },
            {
                "author": "johnmoscoso911",
                "bodyText": "flutter build apk --release --target-platform=android-arm64\n\n\nI get this error after adding the code snippet to build.gradle\nGradle build failed to produce an Android package.\n\nhttps://developer.android.com/distribute/best-practices/develop/64-bit",
                "createdAt": "2019-06-10T16:07:12Z"
            },
            {
                "author": "christiangarciareyes",
                "bodyText": "Could someone solve the problem? I have an app on flutter that only works its 32-bit apk but the 64's do not work or do not install. I'm testing on a 64-bit cell phone",
                "createdAt": "2019-06-10T16:50:35Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@CgarciaTC please see #18494 (comment) for the most recent update",
                "createdAt": "2019-06-10T18:14:44Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "Hi all,\nWe believe the fixes have all landed on tip-of-tree on the master channel.  If you'd like to try them out, here's how:\n\n\nflutter build appbundle\nBy default, the App Bundle contains your Dart code and the Flutter runtime compiled for armeabi-v7a (32-bit) and arm64-v8a (64-bit)\n\n\nflutter build apk --split-per-abi\nThis command will result in two APKs:\nbuild/app/outputs/apk/release/app-armeabi-v7a-release.apk\nbuild/app/outputs/apk/release/app-arm64-v8a-release.apk\n\n\nflutter build apk\nThis will result in a fat APK that contains your code compiled for all the target ABIs.  Such APKs will be larger in size than their split counterparts, causing the user to download native binaries that are not applicable to their device\u2019s architecture.",
                "createdAt": "2019-06-13T04:31:36Z"
            },
            {
                "author": "angel1st",
                "bodyText": "flutter build apk --split-per-abi\nThis command will result in two APKs:\nbuild/app/outputs/apk/release/app-armeabi-v7a-release.apk\nbuild/app/outputs/apk/release/app-arm64-v8a-release.apk\n\n@tvolkert - in this particular scenario, what about each release version number? As long as I am aware, they have to differ, so we can upload both into Google Play. Is that part somehow managed, when the apks are built? If not, how is it supposed to be handled?",
                "createdAt": "2019-06-13T07:08:31Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@angel1st it's managed automatically when the APKs are built, per the guidance in https://developer.android.com/studio/build/configure-apk-splits#configure-APK-versions",
                "createdAt": "2019-06-13T07:50:43Z"
            },
            {
                "author": "ndusart",
                "bodyText": "@tvolkert is there any information about when this will land in stable channel ?",
                "createdAt": "2019-06-13T08:14:20Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@ndusart, yep - see #18494 (comment)",
                "createdAt": "2019-06-13T08:25:36Z"
            },
            {
                "author": "deletedUser",
                "bodyText": "Can confirm this is working (After switching to master) on multiple android devices. What a lifesaver, thank you.",
                "createdAt": "2019-06-13T14:30:13Z"
            },
            {
                "author": "harsha973",
                "bodyText": "@tvolkert Thanks heaps. Any timeline for getting this into Flutter stable?",
                "createdAt": "2019-06-13T21:38:43Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@harsha973 see #18494 (comment)",
                "createdAt": "2019-06-13T21:43:53Z"
            },
            {
                "author": "PerLycke",
                "bodyText": "@harsha973 you are seriously tagging and asking the exact same question that he answered 2 posts above yours. Not only ignorant but on the verge of disrespectful.",
                "createdAt": "2019-06-13T21:57:44Z"
            },
            {
                "author": "harsha973",
                "bodyText": "@PerLycke sorry about that.",
                "createdAt": "2019-06-14T05:40:43Z"
            },
            {
                "author": "michalsuryntequiqo",
                "bodyText": "I have checked out the master channel, upgraded flutter and now I can't really build the app, using the command:\nflutter build apk --release --flavor production -t lib/main.dart \nthe result is:\n* What went wrong:                                                                                                 \nExecution failed for task ':app:transformNativeLibsWithMergeJniLibsForProductionRelease'.                          \n> More than one file was found with OS independent path 'lib/armeabi-v7a/libapp.so' \n\nSimilar StackOverflow issues' answers do not really help.",
                "createdAt": "2019-06-14T10:31:12Z"
            },
            {
                "author": "deletedUser",
                "bodyText": "@MichaelRFairhurst flutter build apk --release worked well for me, so maybe the new updates on master also requires an update to your flavor settings.\nI know it's not an answer, sorry, but at least a point in the right direction.",
                "createdAt": "2019-06-14T10:55:34Z"
            },
            {
                "author": "derolf",
                "bodyText": "When will the fix go beta?",
                "createdAt": "2019-06-14T14:22:38Z"
            },
            {
                "author": "MisterJimson",
                "bodyText": "@derolf please see #18494 (comment) as the most recent update with target timelines.",
                "createdAt": "2019-06-14T14:31:56Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "Hi all,\nThese fixes are now live in the dev channel, at the v1.7.4 release or later.",
                "createdAt": "2019-06-14T22:56:03Z"
            },
            {
                "author": "nate-eisner",
                "bodyText": "While trying to figure out this 64 bit stuff, I am having the same issue as @michalsuryntequiqo and I cannot build anything now via CLI. It builds and runs fine through Android Studio....\nrun flutter build apk --flavor=dev -t lib/main-dev.dart\n[   +3 ms] FAILURE: Build failed with an exception.\n[   +1 ms] * What went wrong:\n[        ] Execution failed for task ':app:transformNativeLibsWithMergeJniLibsForDevRelease'.\n[        ] > More than one file was found with OS independent path 'lib/armeabi-v7a/libapp.so'\n[        ] * Try:\n[        ] Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n[        ] * Get more help at https://help.gradle.org\n[        ] BUILD FAILED in 1m 3s\n[ +370 ms] Running Gradle task 'assembleDevRelease'... (completed in 64.0s)\n[   +4 ms] \"flutter apk\" took 69,789ms.\n[        ] \"flutter apk\" took 69,789ms.\n\ndoctor\nEdit:\njust tried with the commit right before 8627ff4 and it produces the apk with the usual error Gradle build failed to produce an Android package. because of #24106\n@blasten Any idea how to get this working again with your changes?\nEdit 2:\nOpened new issue for this: #34598",
                "createdAt": "2019-06-17T16:32:06Z"
            },
            {
                "author": "eugenio-tesio",
                "bodyText": "I read flutter documentation today and i found:\n\nFrom the command line:\nEnter cd \n(Replace  with your application\u2019s directory.)\nRun flutter build apk --split-per-abi\n(The flutter build command defaults to --release.)\nThis command results in two APK files:\n/build/app/outputs/apk/release/app-armeabi-v7a-release.apk\n/build/app/outputs/apk/release/app-arm64-v8a-release.apk\n\nhttps://flutter.dev/docs/deployment/android#build-an-apk",
                "createdAt": "2019-06-18T20:21:26Z"
            },
            {
                "author": "andretietz",
                "bodyText": "@eugenio-tesio which versioncodes are used, when using --split-per-abi?",
                "createdAt": "2019-06-19T09:20:24Z"
            },
            {
                "author": "eugenio-tesio",
                "bodyText": "I saw it in the documentation and i thought to publish it here. I didn't test it.\nI'd run the command and didn't work. It says:\n\nCould not find an option named \"split-per-abi\".\nRun 'flutter -h' (or 'flutter  -h') for available flutter commands and options.\n\nflutter doctor:\n\nFlutter 1.6.3 \u2022 channel beta \u2022 https://github.com/flutter/flutter.git\nFramework \u2022 revision bc7bc94 (4 weeks ago) \u2022 2019-05-23 10:29:07 -0700\nEngine \u2022 revision 8dc3a4c\nTools \u2022 Dart 2.3.2 (build 2.3.2-dev.0.0 e3edfd36b2)\nRunning \"flutter pub upgrade\" in consumos_app...                   19,8s\nRunning flutter doctor...\nDoctor summary (to see all details, run flutter doctor -v):\n[\u221a] Flutter (Channel beta, v1.6.3, on Microsoft Windows [Versi\u00c3\u00b3n 10.0.17134.829], locale es-AR)\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u221a] Android Studio (version 3.4)\n[\u221a] IntelliJ IDEA Ultimate Edition (version 2019.1)\n[\u221a] VS Code (version 1.26.1)\n[\u221a] VS Code, 64-bit edition (version 1.33.1)\n[!] Connected device\n! No devices available\n\nI think this function will be available soon.",
                "createdAt": "2019-06-19T10:41:32Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "I saw it in the documentation and i thought to publish it here. I didn't test it.\nI'd run the command and didn't work. It says:\n\nCould not find an option named \"split-per-abi\".\nRun 'flutter -h' (or 'flutter  -h') for available flutter commands and options.\n\nflutter doctor:\n\nFlutter 1.6.3 \u2022 channel beta \u2022 https://github.com/flutter/flutter.git\nFramework \u2022 revision bc7bc94 (4 weeks ago) \u2022 2019-05-23 10:29:07 -0700\nEngine \u2022 revision 8dc3a4c\nTools \u2022 Dart 2.3.2 (build 2.3.2-dev.0.0 e3edfd36b2)\nRunning \"flutter pub upgrade\" in consumos_app...                   19,8s\nRunning flutter doctor...\nDoctor summary (to see all details, run flutter doctor -v):\n[\u221a] Flutter (Channel beta, v1.6.3, on Microsoft Windows [Versi\u00c3\u00b3n 10.0.17134.829], locale es-AR)\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u221a] Android Studio (version 3.4)\n[\u221a] IntelliJ IDEA Ultimate Edition (version 2019.1)\n[\u221a] VS Code (version 1.26.1)\n[\u221a] VS Code, 64-bit edition (version 1.33.1)\n[!] Connected device\n! No devices available\n\nI think this function will be available soon.\n\nPlease be reminded that this is on dev channel / version 1.7.4 onward only. You are running beta channel / version 1.6.3",
                "createdAt": "2019-06-19T10:51:18Z"
            },
            {
                "author": "nohli",
                "bodyText": "I just tried it (building and publishing using Codemagic) and it worked really well. Thanks!\nGoogle still complains that I\u2019m not using appbundle though. Given this warning, publishing apks maybe doesn\u2019t make too much sense?\nI would use appbundle - but this stops Google\u2019s automated testing (generating the pre-launch-report) from working. Should I open a new issue for this?",
                "createdAt": "2019-06-19T18:08:55Z"
            },
            {
                "author": "blasten",
                "bodyText": "@nohli We updated the docs to reflect the latest about app bundles/APKs: https://flutter.dev/docs/deployment/android#building-the-app-for-release.\nFeel free to file the issue about Google\u2019s automated testing.",
                "createdAt": "2019-06-19T18:29:39Z"
            },
            {
                "author": "nimesh1997",
                "bodyText": "I build my the  app from bundle but after running on 64bit devices says libflutter.so is missing by building app for both 32bit device and 64bit device. How to add libflutter.so for both architecture in single bundle file?",
                "createdAt": "2019-06-21T16:43:37Z"
            },
            {
                "author": "wal33d006",
                "bodyText": "@nohli We updated the docs to reflect the latest about app bundles/APKs: https://flutter.dev/docs/deployment/android#building-the-app-for-release.\nFeel free to file the issue about Google\u2019s automated testing.\n\n@blasten The procedure given on in the link didn't produce 64-bit APK in the bundle. When I uploaded the bundle, the Google Play store had the same error intact saying your APK is not 64-bit compliant.",
                "createdAt": "2019-06-21T21:21:19Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@wal33d006 see the disclaimer at the top of the page - it only applies to v1.7.4 or later (currently dev or master channels).",
                "createdAt": "2019-06-21T21:24:23Z"
            },
            {
                "author": "wal33d006",
                "bodyText": "@wal33d006 see the disclaimer at the top of the page - it only applies to v1.7.4 or later (currently dev or master channels).\n\n@tvolkert  I am unable to even build my application through dev or master channels.",
                "createdAt": "2019-06-21T21:33:47Z"
            },
            {
                "author": "wal33d006",
                "bodyText": "This is my output when I build it on dev or master channels:\nCompiler message:\nfile:///Users/waleed/.pub-cache/hosted/pub.dartlang.org/cached_network_image-0.5.1/lib/cached_network_image.dart:199:38: Error: The argument type 'void Function(ImageInfo, bool)' can't be assigned to the parameter type 'ImageStreamListener'.\n\n'ImageInfo' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\n'ImageStreamListener' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\nTry changing the type of the parameter, or casting the argument to 'ImageStreamListener'.\noldImageStream?.removeListener(_handleImageChanged);\n^\nfile:///Users/waleed/.pub-cache/hosted/pub.dartlang.org/cached_network_image-0.5.1/lib/cached_network_image.dart:200:32: Error: The argument type 'void Function(ImageInfo, bool)' can't be assigned to the parameter type 'ImageStreamListener'.\n'ImageInfo' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\n'ImageStreamListener' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\nTry changing the type of the parameter, or casting the argument to 'ImageStreamListener'.\n_imageStream.addListener(_handleImageChanged);\n^\nfile:///Users/waleed/.pub-cache/hosted/pub.dartlang.org/cached_network_image-0.5.1/lib/cached_network_image.dart:210:34: Error: The argument type 'void Function(ImageInfo, bool)' can't be assigned to the parameter type 'ImageStreamListener'.\n'ImageInfo' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\n'ImageStreamListener' is from 'package:flutter/src/painting/image_stream.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/painting/image_stream.dart').\nTry changing the type of the parameter, or casting the argument to 'ImageStreamListener'.\n_imageStream?.removeListener(_handleImageChanged);\n^\nfile:///Users/waleed/.pub-cache/hosted/pub.dartlang.org/cached_network_image-0.5.1/lib/cached_network_image.dart:465:31: Error: The argument type 'Null Function(StringBuffer)' can't be assigned to the parameter type 'Iterable Function()'.\n'StringBuffer' is from 'dart:core'.\n'Iterable' is from 'dart:core'.\n'DiagnosticsNode' is from 'package:flutter/src/foundation/diagnostics.dart' ('file:///Users/waleed/Developer/flutter-sdk/flutter/packages/flutter/lib/src/foundation/diagnostics.dart').\nTry changing the type of the parameter, or casting the argument to 'Iterable Function()'.\ninformationCollector: (StringBuffer information) {\n^\nCompiler terminated unexpectedly.\n\nFAILURE: Build failed with an exception.\n\n\nWhere:\nScript '/Users/waleed/Developer/flutter-sdk/flutter/packages/flutter_tools/gradle/flutter.gradle' line: 638\n\n\nWhat went wrong:\nExecution failed for task ':app:compileflutterBuildReleaseArm'.\n\n\n\nProcess 'command '/Users/waleed/Developer/flutter-sdk/flutter/bin/flutter'' finished with non-zero exit value 1\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n\nGet more help at https://help.gradle.org\n\n\nBUILD FAILED in 14s\nRunning Gradle task 'bundleRelease'...\nRunning Gradle task 'bundleRelease'... Done                        15.0s\nGradle task bundleRelease failed with exit code 1",
                "createdAt": "2019-06-21T21:52:24Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@wal33d006 package:cached_network_image is now version 0.8.0and you're using 0.5.1 -- it looks like when running against the newer version of Flutter, you need to update your version constraint in your pubspec.yaml and flutter packages upgrade",
                "createdAt": "2019-06-21T22:21:00Z"
            },
            {
                "author": "nimesh1997",
                "bodyText": "@tvolkert you are saying that in v1.7.4 the file libflutter.so is automatically added for 64bit device when we build the bundle using command flutter build appbundle?",
                "createdAt": "2019-06-22T04:22:14Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@nimesh1997 yep, although the build that makes it to stable will likely be a newer version.",
                "createdAt": "2019-06-22T04:33:28Z"
            },
            {
                "author": "nimesh1997",
                "bodyText": "@tvolkert I changed my channel to ### master channel and also upgraded the ### package:cached_network_image version to 0.8.0 by changing inside the pubspec.yaml. But when running flutter packages upgrade. Error shows below like this:\n**Because cached_network_image >=0.7.0 depends on flutter_cache_manager ^0.3.2 which depends on path_provider ^0.5.0+1, cached_network_image >=0.7.0 requires path_provider ^0.5.0+1.",
                "createdAt": "2019-06-22T04:41:46Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@nimesh1997 can you file a separate issue and cc me?  There are hundreds of people subscribed to this bug.",
                "createdAt": "2019-06-22T05:27:54Z"
            },
            {
                "author": "nimesh1997",
                "bodyText": "@tvolkert When will be flutter version 1.7.4 be available in stable channel and when the error mentioned below be resolved in flutter version 1.7.4 because of that error it does not run on 64bit devices (libflutter.so is missing)?\nThis is the output I am getting when I run on flutter v1.7.4 or later:-\nCompiler message:\nfile:///home/zunroof-dev-4/package_flutter/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_image-1.0.0/lib/network.dart:75:31:\nError: The argument type 'Null Function(StringBuffer)' can't be assigned to the parameter type 'Iterable Function()'.\n\n'StringBuffer' is from 'dart:core'.\n'Iterable' is from 'dart:core'.\n'DiagnosticsNode' is from 'package:flutter/src/foundation/diagnostics.dart' ('file:///home/zunroof-dev-4/package_flutter/flutter/packages/flutter/lib/src/foundation/diagnostics.dart').\nTry changing the type of the parameter, or casting the argument to 'Iterable Function()'.\ninformationCollector: (StringBuffer information) {\n^\nfile:///home/zunroof-dev-4/package_flutter/flutter/.pub-cache/hosted/pub.dartlang.org/flutter_image-1.0.0/lib/network.dart:168:65: Error: The argument type 'String' can't be assigned to the parameter type 'DiagnosticsNode'.\n'DiagnosticsNode' is from 'package:flutter/src/foundation/diagnostics.dart' ('file:///home/zunroof-dev-4/package_flutter/flutter/packages/flutter/lib/src/foundation/diagnostics.dart').\nTry changing the type of the parameter, or casting the argument to 'DiagnosticsNode'.\ncontext: '$runtimeType failed to load ${instructions.uri}',\n^\nCompiler terminated unexpectedly.",
                "createdAt": "2019-06-24T12:07:48Z"
            },
            {
                "author": "leonardop21",
                "bodyText": "Error compiling, does not generate logs and flutter doctor -v does not point to errors. what should I do?\nIf you are deploying the app to the Play Store, it's recommended to use app\nbundles or split the APK to reduce the APK size.\nTo generate an app bundle, run:\nflutter build appbundle --target-platform android-arm,android-arm64\nLearn more on: https://developer.android.com/guide/app-bundle\nTo split the APKs per ABI, run:\nflutter build apk --target-platform android-arm,android-arm64\n--split-per-abi\nLearn more on:\nhttps://developer.android.com/studio/build/configure-apk-splits#configur\ne-abi-split\nInitializing gradle...                                              7,4s\nResolving dependencies...                                           4,3s\nregisterResGeneratingTask is deprecated, use registerGeneratedResFolders(FileCollection)\nregisterResGeneratingTask is deprecated, use registerGeneratedResFolders(FileCollection)\nregisterResGeneratingTask is deprecated, use registerGeneratedResFolders(FileCollection)\nRunning Gradle task 'assembleRelease'...\nRunning Gradle task 'assembleRelease'... Done                       9,0s\nGradle build failed to produce an Android package.",
                "createdAt": "2019-06-24T13:25:10Z"
            },
            {
                "author": "canewsin",
                "bodyText": "@leonardop21 try with\n\nflutter run -v",
                "createdAt": "2019-06-24T14:46:30Z"
            },
            {
                "author": "leonardop21",
                "bodyText": "@canewsin\nOMG. I have no idea what to do now\nGradle build failed to produce an Android package.\n#0      throwToolExit (package:flutter_tools/src/base/common.dart:28:3)\n#1      _buildGradleProjectV2\n(package:flutter_tools/src/android/gradle.dart:514:7)\n#2      _asyncThenWrapperHelper.\n(dart:async-patch/async_patch.dart:77:64)\n#3      _rootRunUnary (dart:async/zone.dart:1132:38)\n#4      _CustomZone.runUnary (dart:async/zone.dart:1029:19)\n#5      _FutureListener.handleValue (dart:async/future_impl.dart:126:18)\n#6      Future._propagateToListeners.handleValueCallback\n(dart:async/future_impl.dart:639:45)\n#7      Future._propagateToListeners (dart:async/future_impl.dart:668:32)\n#8      Future._complete (dart:async/future_impl.dart:473:7)\n#9      _SyncCompleter.complete (dart:async/future_impl.dart:51:12)\n#10     _AsyncAwaitCompleter.complete (dart:async-patch/async_patch.dart:28:18)\n#11     _completeOnAsyncReturn (dart:async-patch/async_patch.dart:294:13)\n#12     runCommandAndStreamOutput (package:flutter_tools/src/base/process.dart)\n#13     _asyncThenWrapperHelper.\n(dart:async-patch/async_patch.dart:77:64)\n#14     _rootRunUnary (dart:async/zone.dart:1132:38)\n#15     _CustomZone.runUnary (dart:async/zone.dart:1029:19)\n#16     _FutureListener.handleValue (dart:async/future_impl.dart:126:18)\n#17     Future._propagateToListeners.handleValueCallback\n(dart:async/future_impl.dart:639:45)\n#18     Future._propagateToListeners (dart:async/future_impl.dart:668:32)\n#19     Future._completeWithValue (dart:async/future_impl.dart:483:5)\n#20     Future._asyncComplete.\n(dart:async/future_impl.dart:513:7)\n#21     _rootRun (dart:async/zone.dart:1124:13)\n#22     _CustomZone.run (dart:async/zone.dart:1021:19)\n#23     _CustomZone.runGuarded (dart:async/zone.dart:923:7)\n#24     _CustomZone.bindCallbackGuarded.\n(dart:async/zone.dart:963:23)\n#25     _microtaskLoop (dart:async/schedule_microtask.dart:41:21)\n#26     _startMicrotaskLoop (dart:async/schedule_microtask.dart:50:5)\n#27     _runPendingImmediateCallback\n(dart:isolate-patch/isolate_patch.dart:116:13)\n#28     _RawReceivePortImpl._handleMessage\n(dart:isolate-patch/isolate_patch.dart:173:5)",
                "createdAt": "2019-06-24T16:51:29Z"
            },
            {
                "author": "blasten",
                "bodyText": "We have updated our docs to indicate how you can build APKs with 32-bit and 64-bit binaries. https://flutter.dev/docs/deployment/android#building-the-app-for-release .\nPlease use the dev channel: v1.7.9 or above.  The team is working to promote the latest changes to beta by this Friday (06/28/2019).",
                "createdAt": "2019-06-25T22:03:36Z"
            },
            {
                "author": "JaeyoungChu",
                "bodyText": "Compiler message:\nfile:///Users/systemgnk/Desktop/flutter/.pub-cache/hosted/pub.dartlang.org/flare_flutter-1.5.2/lib/flare.dart:1033:18: Error: The argument type 'Int32List' can't be assigned to the parameter type 'Uint16List'.\n\n'Int32List' is from 'dart:typed_data'.\n'Uint16List' is from 'dart:typed_data'.\nTry changing the type of the parameter, or casting the argument to 'Uint16List'.\nindices: _indices, textureCoordinates: _uvBuffer);\n^\nCompiler terminated unexpectedly.\n\nFAILURE: Build failed with an exception.\n\n\nWhere:\nScript '/Users/systemgnk/Desktop/flutter/packages/flutter_tools/gradle/flutter.gradle' line: 631\n\n\nWhat went wrong:\nExecution failed for task ':app:compileflutterBuildReleaseArm'.\n\n\n\nProcess 'command '/Users/systemgnk/Desktop/flutter/bin/flutter'' finished with non-zero exit value 1\n\n\n\nTry:\nRun with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output. Run with --scan to get full insights.\n\n\nGet more help at https://help.gradle.org\n\n\nBUILD FAILED in 22s\nRunning Gradle task 'assembleRelease'...\nRunning Gradle task 'assembleRelease'... Done                      23.3s\nGradle task assembleRelease failed with exit code 1\n[\u2713] Flutter (Channel dev, v1.7.10, on Mac OS X 10.13.6 17G65, locale en-US)\n\u2022 Flutter version 1.7.10 at /Users/systemgnk/Desktop/flutter\n\u2022 Framework revision 9a3a749 (2 days ago), 2019-06-25 15:59:15 +0200\n\u2022 Engine revision ae8e6d9\n\u2022 Dart version 2.4.0\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n\u2022 Android SDK at /Users/systemgnk/Library/Android/sdk\n\u2022 Android NDK location not configured (optional; useful for native profiling support)\n\u2022 Platform android-28, build-tools 28.0.3\n\u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1248-b01)\n\u2022 All Android licenses accepted.\n[\u2713] Xcode - develop for iOS and macOS (Xcode 10.1)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 Xcode 10.1, Build version 10B61\n\u2022 CocoaPods version 1.6.0\n[\u2713] iOS tools - develop for iOS devices\n\u2022 ios-deploy 1.9.4\n[\u2713] Chrome - develop for the web\n\u2022 Chrome at /Applications/Google Chrome.app/Contents/MacOS/Google Chrome\n[\u2713] Android Studio (version 3.3)\n\u2022 Android Studio at /Applications/Android Studio.app/Contents\n\u2022 Flutter plugin version 33.3.1\n\u2022 Dart plugin version 182.5215\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1248-b01)\n[\u2713] Connected device (4 available)\n\u2022 Android SDK built for x86 \u2022 emulator-5554                            \u2022 android-x86    \u2022 Android 7.0 (API 24) (emulator)\n\u2022 System\u2019s iPhone           \u2022 73145c33ee6d180a2db3d4a96b908ceb4c49065b \u2022 ios            \u2022 iOS 12.3.1\n\u2022 macOS                     \u2022 macOS                                    \u2022 darwin-x64     \u2022 Mac OS X 10.13.6 17G65\n\u2022 Chrome                    \u2022 chrome                                   \u2022 web-javascript \u2022 Google Chrome 75.0.3770.100\n\u2022 No issues found!\nI am still having issue with building apk.\nI was only available to build 32bit apk in stable channel.\nI think I need to wait until flutter team fix this bug rather than use dev or master channel sdk.\nThank you.",
                "createdAt": "2019-06-27T13:51:05Z"
            },
            {
                "author": "ctrysbita",
                "bodyText": "@JaeyoungChu Refer to 2d-inc/Flare-Flutter#79",
                "createdAt": "2019-06-27T15:30:02Z"
            },
            {
                "author": "JaeyoungChu",
                "bodyText": "@ctrysbita Thanks for the link. I changed the channel to master and change type of _indices from Int32List to Uint16List.\napk which is uploaded on play store does not have warning for 64bit and it is running after installing from play store test page.",
                "createdAt": "2019-06-27T18:38:23Z"
            },
            {
                "author": "JaeyoungChu",
                "bodyText": "I have other issues with dev channel flutter sdk such as not pop up permission dialog for location and google map does not show in ios and could not show big image file by http(cached network image). Those issues are not sure due to dev channel but when I got back to stable and build again all the issues are gone. I do not have much time for digging in this issues so it is not 100% sure. Sorry about that but perhaps someone get hint from this issues.",
                "createdAt": "2019-06-28T15:10:52Z"
            },
            {
                "author": "ArtfulDodgerB92",
                "bodyText": "This was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\nupload app-armeabi-v7a-release.apk to the play store\nincrement versionCode\nrun flutter build apk --release --target-platform=android-arm64 \nupload app-arm64-v8a-release.apk to the play store\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be 10MB+\n\nWHERE?  WHERE do we add the splits section to the gradle file??   I added it between flutter {} and dependencies {} and it will not build the first APK as it says:\nPlease review your Gradle project setup in the android/ folder.\nSo clearly this is not right, as this is the only change I have made to the project since my last build.",
                "createdAt": "2019-06-29T06:28:02Z"
            },
            {
                "author": "JaeyoungChu",
                "bodyText": "@ArtfulDodgerB92 Thanks for the solution. which channel did you user for building apk and version?",
                "createdAt": "2019-06-29T15:09:38Z"
            },
            {
                "author": "iqbalmineraltown",
                "bodyText": "WHERE? WHERE do we add the splits section to the gradle file?? I added it between flutter {} and dependencies {} and it will not build the first APK as it says:\nPlease review your Gradle project setup in the android/ folder.\nSo clearly this is not right, as this is the only change I have made to the project since my last build.\n\n@ArtfulDodgerB92 it should be inside android{} section, as written here: https://developer.android.com/studio/build/configure-apk-splits.html",
                "createdAt": "2019-07-01T01:55:43Z"
            },
            {
                "author": "nohli",
                "bodyText": "FYI, the following announcement was sent to flutter-announce@googlegroups.com regarding our 64-bit support.\nhttps://groups.google.com/forum/#!topic/flutter-announce/oIzwT9EDczc\n\nany news about an upcoming beta release?",
                "createdAt": "2019-07-01T10:16:08Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@nohli we delayed the beta release by a few days to pick up a fix (revert commit) to #35291.  We're working to get a release out to beta ASAP.",
                "createdAt": "2019-07-01T17:15:01Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "This is now live on the beta channel, in release v1.7.8+hotfix.2",
                "createdAt": "2019-07-02T17:57:12Z"
            },
            {
                "author": "ssghazaryan",
                "bodyText": "This is now live on the beta channel, in release v1.7.8+hotfix.2\n\n\u0421ool how to generate release apk ?",
                "createdAt": "2019-07-05T08:51:01Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "This is now live on the beta channel, in release v1.7.8+hotfix.2\n\n\u0421ool how to generate release apk ?\n\nHere's the instruction https://flutter.dev/docs/deployment/android",
                "createdAt": "2019-07-05T09:52:44Z"
            },
            {
                "author": "ssghazaryan",
                "bodyText": "This is now live on the beta channel, in release v1.7.8+hotfix.2\n\n\u0421ool how to generate release apk ?\n\nHere's the instruction https://flutter.dev/docs/deployment/android\n\ni tried but not working at 32",
                "createdAt": "2019-07-05T11:34:51Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "i tried but not working at 32\n\nWhat do you mean by 32? Like \"I can generate a fat apk, and that apk is working on a 64-bit device, but crashing on 32-bit device\"?\nCan you post the result of flutter doctor, your step-by-step (e.g. this is the step 2 of progard https://flutter.dev/docs/deployment/android#step-2---enable-obfuscation-andor-minification), are you generating APK or AAB, and which device are you testing?",
                "createdAt": "2019-07-05T12:38:06Z"
            },
            {
                "author": "KsAmJ",
                "bodyText": "do we still need to put\nndk { abiFilters 'armeabi-v7a' , 'x86', 'armeabi' } in the gradle ot no longer needed after the fix on beta??",
                "createdAt": "2019-07-07T15:10:12Z"
            },
            {
                "author": "blasten",
                "bodyText": "@KsAmJ that isn\u2019t needed.",
                "createdAt": "2019-07-07T18:26:50Z"
            },
            {
                "author": "ssghazaryan",
                "bodyText": "i tried but not working at 32\n\nWhat do you mean by 32? Like \"I can generate a fat apk, and that apk is working on a 64-bit device, but crashing on 32-bit device\"?\nCan you post the result of flutter doctor, your step-by-step (e.g. this is the step 2 of progard https://flutter.dev/docs/deployment/android#step-2---enable-obfuscation-andor-minification), are you generating APK or AAB, and which device are you testing?\n\nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel beta, v1.7.8+hotfix.2, on Mac OS X 10.14.5 18F132, locale ru-RU)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 10.2.1)\n[\u2713] iOS tools - develop for iOS devices\n[\u2713] Android Studio (version 3.4)\n[\u2713] Connected device (1 available)\n\u2022 No issues found!\nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel beta, v1.7.8+hotfix.2, on Mac OS X 10.14.5 18F132, locale ru-RU)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 10.2.1)\n[\u2713] iOS tools - develop for iOS devices\n[\u2713] Android Studio (version 3.4)\n[\u2713] Connected device (1 available)\n\u2022 No issues found!\nDoctor summary (to see all details, run flutter doctor -v):\n[\u2713] Flutter (Channel beta, v1.7.8+hotfix.2, on Mac OS X 10.14.5 18F132, locale ru-RU)\n[\u2713] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n[\u2713] Xcode - develop for iOS and macOS (Xcode 10.2.1)\n[\u2713] iOS tools - develop for iOS devices\n[\u2713] Android Studio (version 3.4)\n[\u2713] Connected device (1 available)\n\u2022 No issues found!\nbuild apk\nI did everything as in the instructions but it does not install on 32 bit",
                "createdAt": "2019-07-08T08:43:09Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "I did everything as in the instructions but it does not install on 32 bit\n\nAny screenshot/log showing that the installation of 32-bit apk on the 32-bit device was not successful, and what device model is that?",
                "createdAt": "2019-07-08T10:38:08Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "Hi all,\nv1.7.8+hotfix.2 has been released to the stable channel, so this fix is now available in all channels.  Thanks everyone for your patience and help along the way!",
                "createdAt": "2019-07-08T17:50:01Z"
            },
            {
                "author": "ssghazaryan",
                "bodyText": "I did everything as in the instructions but it does not install on 32 bit\n\nAny screenshot/log showing that the installation of 32-bit apk on the 32-bit device was not successful, and what device model is that?\n\nthanks for help, i tried to build appbundle and its worked.",
                "createdAt": "2019-07-09T05:54:30Z"
            },
            {
                "author": "nimesh1997",
                "bodyText": "@tvolkert Same issue please check it. #31962 (comment)",
                "createdAt": "2019-07-09T06:09:20Z"
            },
            {
                "author": "dnfield",
                "bodyText": "@nimesh1997 that issue has nothing to do with this one.  If you didn't find the answers provides in the linked issue helpful, perhaps you could look at posting a Stackoverflow question with your problem.",
                "createdAt": "2019-07-09T06:21:07Z"
            },
            {
                "author": "angel1st",
                "bodyText": "@tvolkert - just to clarify - the above hotfix can be used to build separate apks according to flutter docs instructions, correct?\nTherefore, it won't be required to make any other changes in gradle file as described in earlier partial solutions\nThanks for you and the rest of the team excellent work and on time delivery!",
                "createdAt": "2019-07-09T13:50:23Z"
            },
            {
                "author": "angel1st",
                "bodyText": "I have just compiled one of my app with the most recent hot fix. As a result the compiled app-production-armeabi-v7a-release.apk is not able to run on Galaxy S3 mini (Android OS 4.1.2) - after the splash screen, the app closes without any notification.\nI am able however to successfully run the very same apk on 64 phone e.g. Galaxy S8.\nhere is how I run the flutter from the command line:\n\nflutter build apk --target=\"lib/config/main_production.dart\" --flavor=production --split-per-abi\n\nand here is my flutter doctor -v\n\n[\u221a] Flutter (Channel stable, v1.7.8+hotfix.2, on Microsoft Windows [Version 10.0.17763.557], locale en-US)\n\u2022 Flutter version 1.7.8+hotfix.2 at E:\\DevTools\\flutter\n\u2022 Framework revision 2e54093 (7 days ago), 2019-07-02 09:31:07 -0700\n\u2022 Engine revision b1cb0d9e9b\n\u2022 Dart version 2.4.0\n\n\n[\u221a] Android toolchain - develop for Android devices (Android SDK version 28.0.3)\n\u2022 Android SDK at E:\\DevTools\\Android\\Sdk\n\u2022 Android NDK location not configured (optional; useful for native profiling support)\n\u2022 Platform android-28, build-tools 28.0.3\n\u2022 ANDROID_SDK_ROOT = E:\\DevTools\\Android\\Sdk\n\u2022 Java binary at: E:\\DevTools\\android-studio\\jre\\bin\\java\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n\u2022 All Android licenses accepted.\n\n\n[\u221a] Android Studio (version 3.4)\n\u2022 Android Studio at E:\\DevTools\\android-studio\n\u2022 Flutter plugin version 37.0.1\n\u2022 Dart plugin version 183.6270\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n\n\n[\u221a] Connected device (1 available)\n\u2022 Android SDK built for x86 \u2022 emulator-5554 \u2022 android-x86 \u2022 Android 8.1.0 (API 27) (emulator)\n\n\n\u2022 No issues found!\n\nAdditionally - the fat apk also is not able to run - after the install (on the same arm-32 device) & run it just closes.\nPlease let me know how to proceed and resolve the issue, thanks!",
                "createdAt": "2019-07-09T14:28:30Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "@angel1st is it possible that you can share your AAB and/or APK file here so that we can help you troubleshooting?",
                "createdAt": "2019-07-09T14:56:52Z"
            },
            {
                "author": "angel1st",
                "bodyText": "@truongsinh - sure, here they are:\napp-production-releases.zip\nI have uploaded both APKs, although, the alleged issue is with arm-32 version as stated above.",
                "createdAt": "2019-07-09T15:05:55Z"
            },
            {
                "author": "angel1st",
                "bodyText": "Guys, in the meantime, would someone be so kind and tell (if they know), what would happen after August 1st in Google Play Store, in case you do not have arm-64 version of your app - would the apk will stop to be served to arm64 devices or you will not be able to upload arm32 only version or both?",
                "createdAt": "2019-07-09T16:28:57Z"
            },
            {
                "author": "blasten",
                "bodyText": "@angel1st I was able to run the app (app-production-armeabi-v7a-release.apk) on Android 4.4.2 Galaxy S4. Nice app!\nI suspect this is very specific to Galaxy S3 mini / Android OS 4.1.2. In the meanwhile, I requested this configuration to see if I can repro the issue.",
                "createdAt": "2019-07-09T18:03:43Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "@angel1st here's the most informative source: https://android-developers.googleblog.com/2019/01/get-your-apps-ready-for-64-bit.html\n\nThe requirement [64-bit stuff] does not apply to:\n\nAPKs or app bundles explicitly targeting Wear OS or Android TV, which are form factors that do not currently support 64-bit code.\nAPKs or app bundles that are not distributed to devices running Android 9 Pie or later.\n\n\n\nStarting August 1, 2019:\n\nAll new apps and app updates that include native code are required to provide 64-bit versions in addition to 32-bit versions when publishing to Google Play.\n\n\nIn other words, apps continue to be distributed, though you cannot upload a new version of exisiting app, or publish new app without compliance.",
                "createdAt": "2019-07-10T00:22:04Z"
            },
            {
                "author": "blasten",
                "bodyText": "@angel1st I was able to repro this issue on a Galaxy S3 mini running Android OS 4.1.2.\nThe logcat is:\n[ERROR:flutter/fml/platform/posix/native_library_posix.cc(16)] Could not open library 'libapp.so' due to error 'Cannot load library: load_library[1093]: Library 'libapp.so' not found'.\n07-10 00:16:50.298 8739-8739/? E/flutter: [ERROR:flutter/fml/platform/posix/native_library_posix.cc(16)] Could not open library 'libapp.so' due to error 'Cannot load library: load_library[1093]: Library 'libapp.so' not found'.\n07-10 00:16:50.298 8739-8739/? E/flutter: [ERROR:flutter/runtime/dart_vm_data.cc(19)] VM snapshot invalid and could not be inferred from settings.\n07-10 00:16:50.298 8739-8739/? E/flutter: [ERROR:flutter/runtime/dart_vm.cc(238)] Could not setup VM data to bootstrap the VM from.\n07-10 00:16:50.298 8739-8739/? E/flutter: [ERROR:flutter/runtime/dart_vm_lifecycle.cc(89)] Could not create Dart VM instance.\n07-10 00:16:50.298 8739-8739/? A/flutter: [FATAL:flutter/shell/common/shell.cc(218)] Check failed: vm. Must be able to initialize the VM.\n\nI filed #35838 in the meanwhile.\ncc @jason-simmons",
                "createdAt": "2019-07-10T00:25:37Z"
            },
            {
                "author": "angel1st",
                "bodyText": "@truongsinh - thanks for the overview.\n@blasten - thanks for the prompt feedback. As far as I understand, there is nothing I can do ATM but monitor #35838 with fingers crossed it will be resolved at some point this month? I believe the same issue will appear to any other apk for Android 4.1.2 compiled with the most recent hot fix?\nFYI - the app apk compiled with previous flutter stable version does not have this issue (S3 mini with Android 4.1.2 is one of my test devices).",
                "createdAt": "2019-07-10T05:16:59Z"
            },
            {
                "author": "nohli",
                "bodyText": "Anyone else got a mail from Google today, saying\n\n\"Action required: Update your apps to be 64-bit compliant by August 1, 2019\"\n\nalthough already publishing both 32bit and 64bit versions?\nIt says\n\nBy August 1, 2019, all apps that use native code must provide a 64-bit version in order to publish an update. As of the sending of this email, at least one of your apps* does not yet meet the requirement\n\n\n*Note: This list of apps reflects Google\u2019s best estimate as of the sending of this email. (...)\n\nI guess, Google's \"best estimate\" is not correct?",
                "createdAt": "2019-07-10T07:05:07Z"
            },
            {
                "author": "JaeyoungChu",
                "bodyText": "Thanks for Flutter team. I upgrade Flutter and build on stable channel and the warning is gone.\nhope to not have a bug with testers but so far I did not find any bugs yet with real device!",
                "createdAt": "2019-07-10T14:46:16Z"
            },
            {
                "author": "rsin46",
                "bodyText": "Thanks Team Flutter, upgrading Flutter with the hotfix fixes this issue when building .aab",
                "createdAt": "2019-07-11T07:28:16Z"
            },
            {
                "author": "christiangarciareyes",
                "bodyText": "Thanks to the flutter team for this achievement. Now to continue programmed!",
                "createdAt": "2019-07-12T20:18:24Z"
            },
            {
                "author": "abdullayev007",
                "bodyText": "@angel1st I am also having issues on some Samsung devices.\n#36128",
                "createdAt": "2019-07-14T04:35:21Z"
            },
            {
                "author": "angel1st",
                "bodyText": "@abdullayev007 - thanks! I would suggest you to take a look at #35838, it might be somehow related.",
                "createdAt": "2019-07-14T05:09:18Z"
            },
            {
                "author": "surveshoeb",
                "bodyText": "I did everything as in the instructions but it does not install on 32 bit\n\nAny screenshot/log showing that the installation of 32-bit apk on the 32-bit device was not successful, and what device model is that?\n\n\nThe device is Samsung M10",
                "createdAt": "2019-07-14T14:18:31Z"
            },
            {
                "author": "deletedUser",
                "bodyText": "@tvolkert Please give me any solution for fixing following issue:\n#36063\nThanks",
                "createdAt": "2019-07-15T06:21:54Z"
            },
            {
                "author": "muthufmass",
                "bodyText": "I tried the latest version of flutter from dev channel - v1.8.4. I created a fresh project too - vanilla flutter project and tried building a release signed version out of it. It builds and app size is just 10.4 mb. But tried all above steps in this trail, nothing helping out. Can some one give a clear set of sequence of steps to take a build that we can push to playstore with aab or apk with emulator and local device from flutter. Its been more than a week, we have project built on flutter not moving to prod on android, but we are able to publish to appstore on ios. Some help will be great.\n`[\u2713] Flutter (Channel dev, v1.8.4, on Mac OS X 10.14.5, locale en-US)\n\u2022 Flutter version 1.8.4 at /Users/muthu/muthu/devapps/flutter\n\u2022 Framework revision 954714c (7 days ago), 2019-08-02 10:10:39 -0700\n\u2022 Engine revision 2636822\n\u2022 Dart version 2.5.0 (build 2.5.0-dev.1.0 bd049f5b53)\n[!] Android toolchain - develop for Android devices (Android SDK version 29.0.1)\n\u2022 Android SDK at ../Library/Android/sdk\n\u2022 Android NDK location not configured (optional; useful for native profiling support)\n\u2022 Platform android-29, build-tools 29.0.1\n\u2022 Java binary at: /Applications/Android Studio.app/Contents/jre/jdk/Contents/Home/bin/java\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n\u2717 Android license status unknown.\nTry re-installing or updating your Android SDK Manager.\nSee https://developer.android.com/studio/#downloads or visit https://flutter.dev/setup/#android-setup\nfor detailed instructions.\n[\u2713] Xcode - develop for iOS and macOS (Xcode 10.3)\n\u2022 Xcode at /Applications/Xcode.app/Contents/Developer\n\u2022 Xcode 10.3, Build version 10G8\n\u2022 CocoaPods version 1.7.3\n[\u2713] Android Studio (version 3.4)\n\u2022 Android Studio at /Applications/Android Studio.app/Contents\n\u2022 Flutter plugin version 38.2.1\n\u2022 Dart plugin version 183.6270\n\u2022 Java version OpenJDK Runtime Environment (build 1.8.0_152-release-1343-b01)\n[\u2713] VS Code (version 1.36.1)\n\u2022 VS Code at /Applications/Visual Studio Code.app/Contents\n\u2022 Flutter extension version 3.3.0\n[\u2713] Connected device (3 available)\n\u2022 Android SDK built for x86 \u2022 emulator-5554                        \u2022 android-x86 \u2022 Android 9 (API 28)\n(emulator)`",
                "createdAt": "2019-08-09T12:56:33Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@muthufmass, please file a new issue with details of what's not working and how to reproduce the failure.  Thanks!",
                "createdAt": "2019-08-09T14:32:46Z"
            },
            {
                "author": "truongsinh",
                "bodyText": "Can some one give a clear set of sequence of steps to take a build that we can push to playstore\n\nhttps://flutter.dev/docs/deployment/android",
                "createdAt": "2019-08-09T14:39:59Z"
            },
            {
                "author": "muthufmass",
                "bodyText": "Can some one give a clear set of sequence of steps to take a build that we can push to playstore\n\nhttps://flutter.dev/docs/deployment/android\n\nThese steps are already followed, its not working on the prod release build. debug build works! I clearly find a difference, in debug build, the .so files of flutter are present, but not with the release version. Those are ones, creating problem to install the apk to emulator or to devices with signed apk.",
                "createdAt": "2019-08-09T14:55:04Z"
            },
            {
                "author": "muthufmass",
                "bodyText": "@muthufmass, please file a new issue with details of what's not working and how to reproduce the failure. Thanks!\n\nI hope I have shared cleared steps above. Fresh app creation using flutter create - vanilla code with latest flutter sdk. Unable to build a release version, while debug versions runs smooth. Significant difference between prod and dev version of apk on size. Tried all the above steps, unable to build a release version that runs. Build happens super fast and file comes less than 11 mb with release, while with debug apk it comes around 40mb+. Debug apk works, while prod release signed apk doesnt install even.",
                "createdAt": "2019-08-09T15:00:00Z"
            },
            {
                "author": "blasten",
                "bodyText": "@muthufmass when you file the new issue, please include the Android SDK version, device model, the doctor output, and steps starting from flutter create.",
                "createdAt": "2019-08-09T15:06:30Z"
            },
            {
                "author": "tvolkert",
                "bodyText": "@muthufmass as well as adb logcat output.\nThis issue is closed - please file a new issue so we can track it properly.",
                "createdAt": "2019-08-09T15:08:05Z"
            },
            {
                "author": "muthufmass",
                "bodyText": "raised a separate ticket now #37935",
                "createdAt": "2019-08-09T17:34:53Z"
            },
            {
                "author": "solid-dimakoniaiev",
                "bodyText": "If u had flavors in your project, and want to support both x64 and x32, just add jniLibs folder to your   flavor folder and it's work great, like this",
                "createdAt": "2019-08-20T12:21:45Z"
            },
            {
                "author": "jeuxdaily",
                "bodyText": "how can I do this in adobe animate cc\nneed more info",
                "createdAt": "2019-08-23T06:46:37Z"
            },
            {
                "author": "newapproach",
                "bodyText": "Google play console recently has started disabling the rollout button because of various warnings. And one of those warnings is using apk instead of .aab file. There are solutions to make .aab file if the project has been created in Android Studio or Unity. But what if apk has been created by Animate CC or Haxe/Flash Develop? Is there any way to convert?",
                "createdAt": "2019-09-14T06:06:15Z"
            },
            {
                "author": "eseidelGoogle",
                "bodyText": "@newapproach it's not clear to me if your comment has anything to do with Flutter?  Would you be willing to file a new issue with more details?  Thanks!",
                "createdAt": "2019-09-16T15:14:41Z"
            },
            {
                "author": "kecson",
                "bodyText": "Have the same problem - but flutter.so not included in \"armeabi-v7a folder.\nHas only third party libraries for x86 and armeabi-v7a - but no arm64.\nWould like to build flutter only for \"armeabi-v7a with\nndk{\nabiFilters \"armeabi-v7a\" // also not work\"armeabi\", \"x86\",\n}\nand set as target-platform as @mravn-google suggest to android-arm.\nAPK without specify arch and not include libraries\n\nAPK with libraries and no arm spec\n\nAPK with specify arch and include libraries\n\nAny suggestion how to debug further steps?\n\nI has find this error too, it is fixed?? Could help me?",
                "createdAt": "2019-11-22T09:08:34Z"
            },
            {
                "author": "eseidelGoogle",
                "bodyText": "I recommend asking on Stack Overflow, or opening a new bug.  I doubt this closed bug will be the right place for folks to help you resolve the above issue.  Thanks!",
                "createdAt": "2019-11-22T15:17:10Z"
            },
            {
                "author": "aldwnesx",
                "bodyText": "This was my solution:\n\nin app gradle\n\nsplits {\n        // Configures multiple APKs based on ABI.\n        abi {\n            // Enables building multiple APKs per ABI.\n            enable true\n            // By default all ABIs are included, so use reset() and include to specify that we only\n            // want APKs for armeabi-v7a and arm64-v8a.\n\n            // Resets the list of ABIs that Gradle should create APKs for to none.\n            reset()\n\n            // Specifies a list of ABIs that Gradle should create APKs for.\n            include \"armeabi-v7a\", \"arm64-v8a\"\n\n            // Specifies that we do not want to also generate a universal APK that includes all ABIs.\n            universalApk false\n        }\n    }\n\n\nrun flutter build apk --release --target-platform=android-arm\nupload app-armeabi-v7a-release.apk to the play store\nincrement versionCode\nrun flutter build apk --release --target-platform=android-arm64 \nupload app-arm64-v8a-release.apk to the play store\n\nGoogle play store will serve App according to device architecture. 32bit devices are happy, 64bit devices are happy and I'm happy knowing that my APK size remains relatively small while still serving both architectures.\nIf we include support for both architectures in the same APK, expect the size of your app to be 10MB+\n\ndoesn't work.. when I view it on playstore on pixel 2 it says not supported for this device",
                "createdAt": "2020-03-28T06:08:19Z"
            },
            {
                "author": "jbg",
                "bodyText": "It does work, many well-known apps have been deploying multiple APKs this way and letting the Play Store serve the appropriate one to the appropriate device for a long time.\nApp bundles are the modern way to do this, though.",
                "createdAt": "2020-03-28T06:38:41Z"
            },
            {
                "author": "aldwnesx",
                "bodyText": "It does work, many well-known apps have been deploying multiple APKs this way and letting the Play Store serve the appropriate one to the appropriate device for a long time.\nApp bundles are the modern way to do this, though.\n\nI don\u2019t know why it\u2019s not showing up on pixel 2 playstore for me then... I folllowr exactly , twice, just incase..\nI used app bundle and my app is crashing hence I\u2019m looking for alternatives",
                "createdAt": "2020-03-28T06:46:21Z"
            }
        ],
        "commentCount": 285
    }
]